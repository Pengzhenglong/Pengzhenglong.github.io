<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2025</title>
    <link href="/2025/05/04/ReactHook-useContext%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8%E5%88%B0%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(3)/"/>
    <url>/2025/05/04/ReactHook-useContext%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8%E5%88%B0%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(3)/</url>
    
    <content type="html"><![CDATA[<p>2025 todo list</p><hr><h3 id="todo-list"><a href="#todo-list" class="headerlink" title="todo list"></a>todo list</h3><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
      <category>React hooks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>React hooks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React hooks（四）：useContext从基础应用到性能优化</title>
    <link href="/2024/07/04/test/"/>
    <url>/2024/07/04/test/</url>
    
    <content type="html"><![CDATA[<p>学习react Hooks的笔记</p><p>上一篇文章（全面掌握useReducer）我们用useReducer和useContext实现了一个切换主题的功能，useReducer我们已经掌握了，那么useContext又有哪些知识需要学习呢？</p><p>我们知道，每一个hook的诞生都有它独特的使命，比如useState是解决组件内状态更新的问题，useReducer是解决组件复杂状态更新的问题。</p><p>而useContext要解决的是：让开发者在某些场景下，从多层嵌套传值的组件树中解脱出来；useContext实现的是：让开发者通过context实现跨层级共享状态。</p><p>现在我们已经了解了useContext的主要作用，让我们开始今天的学习吧。</p><hr><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><ol><li>创建 Context<br>首先，我们需要使用React.createContext创建一个context对象：</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const MyContext = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">React</span>.</span></span>create<span class="hljs-constructor">Context(<span class="hljs-params">defaultValue</span>)</span>;<br></code></pre></td></tr></table></figure><p>这里的defaultValue是当组件不在任何 Context Provider 内部时的默认值，defaultValue可以用 null，但 React 官方建议提供一个有意义的默认值，这样可以让调用usecontext组件更安全。</p><ol start="2"><li>使用 Context Provider<br>为了在组件树中使用这个context，我们需要使用&lt;MyContext.Provider&gt;组件，它接受一个valueprop，这就是你想在它的子组件中共享的值。</li></ol><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyContext.Provider</span> <span class="hljs-attr">value</span>=</span></span><span class="hljs-template-variable">&#123;someValue&#125;</span><span class="xml"><span class="hljs-tag">&gt;</span></span><br><span class="xml">  </span><span class="hljs-template-tag">&#123;/* 子组件 */&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">MyContext.Provider</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>在组件中访问 Context<br>在函数组件中，可以使用useContexthook 来访问这个 context 的值。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> contextValue = useContext(MyContext);<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;contextValue&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的contextValue就是第二步传入的someValue，而且contextValue获取到的永远是最新的值。</p><h4 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h4><p>我们来看一个更直观的示例：</p><h4 id="使用reducer函数的注意事项"><a href="#使用reducer函数的注意事项" class="headerlink" title="使用reducer函数的注意事项"></a>使用reducer函数的注意事项</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-comment">// 1. 创建 Context</span><br><span class="hljs-keyword">const</span> ThemeContext = React.createContext(<span class="hljs-string">&#x27;light&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="hljs-comment">// 2. 使用 Context Provider</span><br>    &lt;ThemeContext.Provider value=<span class="hljs-string">&quot;dark&quot;</span>&gt;<br>      &lt;Toolbar /&gt;<br>    &lt;/ThemeContext.Provider&gt;<br>  );<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Toolbar</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div&gt;<br>      &lt;ThemeButton /&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ThemeButton</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 3. 在组件中访问 Context</span><br>  <span class="hljs-keyword">const</span> theme = useContext(ThemeContext);<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>&#123;theme&#125; theme<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;<br></code></pre></td></tr></table></figure><p>这个示例中，App 中引用了ThemeContext并传了值，ThemeButton 是 App 的孙组件，这二者之间没有通过 Toolbar 进行嵌套传值，但是 ThemeButton 依然通过useContext拿到了 App 里的值。</p><p>从这个示例中我们可以总结出，React.createContext和useContext共同组成了一个管道，通过这个管道，开发者可以进行跨组件共享状态。</p><h3 id="进阶技巧"><a href="#进阶技巧" class="headerlink" title="进阶技巧"></a>进阶技巧</h3><p>动态Context值<br>有的时候 Context 传的值需要动态变化，我们可以基于useState去更新状态，更新后的值会实时反应到调用 Context 的组件上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ThemeProvider</span>(<span class="hljs-params">&#123; children &#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [theme, setTheme] = useState(<span class="hljs-string">&quot;light&quot;</span>);<br><br>  <span class="hljs-keyword">return</span> (<br>    &lt;ThemeContext.Provider value=&#123;theme&#125;&gt;<br>      &lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> setTheme(theme === <span class="hljs-string">&quot;light&quot;</span> ? <span class="hljs-string">&quot;dark&quot;</span> : <span class="hljs-string">&quot;light&quot;</span>)&#125;&gt;<br>        Toggle Theme<br>      &lt;/button&gt;<br>      &#123;children&#125;<br>    &lt;/ThemeContext.Provider&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要更新对象也是可以的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-comment">// 1. 创建 Context</span><br><span class="hljs-keyword">const</span> CurrentUserContext = React.createContext(<span class="hljs-string">&#x27;light&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">const</span> [currentUser, setCurrentUser] = useState(<span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="hljs-comment">// 2. 使用 Context Provider</span><br>    &lt;CurrentUserContext.Provider <br>      value=&#123;&#123;<br>        currentUser,<br>        setCurrentUser<br>      &#125;&#125;<br>    &gt;<br>      &lt;Toolbar /&gt;<br>    &lt;/CurrentUserContext.Provider&gt;<br>  );<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Toolbar</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div&gt;<br>      &lt;LoginButton /&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LoginButton</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;<br>    currentUser,<br>    setCurrentUser<br>  &#125; = useContext(CurrentUserContext);<br><br>  <span class="hljs-keyword">if</span> (currentUser !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You logged in as &#123;currentUser.name&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    &lt;Button onClick=&#123;<span class="hljs-function">() =&gt;</span> &#123;<br>      setCurrentUser(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Advika&#x27;</span> &#125;)<br>    &#125;&#125;&gt;Log <span class="hljs-keyword">in</span> <span class="hljs-keyword">as</span> Weijunext&lt;/Button&gt;<br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;<br></code></pre></td></tr></table></figure><h4 id="和useReducer共用"><a href="#和useReducer共用" class="headerlink" title="和useReducer共用"></a>和useReducer共用</h4><p>在大型应用中，通常会将useContext与useReducer结合起来使用，以便从组件中提取与某些状态相关的逻辑。上一篇文章即是用这种思路实现了主题切换，源码可查看Github：useReducer-useContext实现主题切换，本文不再重复。</p><h4 id="覆盖Provider-value"><a href="#覆盖Provider-value" class="headerlink" title="覆盖Provider value"></a>覆盖Provider value</h4><p>当我们调用多个相同 Context，会实现value的覆盖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;dark&quot;</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;light&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Footer</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="高级应用——性能优化"><a href="#高级应用——性能优化" class="headerlink" title="高级应用——性能优化"></a>高级应用——性能优化</h4><p>当我们在使用useContext时，一个经常被提到的问题是性能优化。如果不正确地使用，Context 可能导致不必要的组件渲染，从而影响应用性能。</p><h5 id="为什么会出现性能问题？"><a href="#为什么会出现性能问题？" class="headerlink" title="为什么会出现性能问题？"></a>为什么会出现性能问题？</h5><p>当Provider的value属性值发生变化时，所有使用了useContext的组件都将重新渲染。如果value经常变化，或者消费者组件很多，那么这会引起大量的不必要的渲染。</p><ol><li>怎样解决？</li></ol><ul><li>粒度化 Context</li></ul><p>如果你的 context 包含许多不同的状态值，尝试将它们分解成更小的 context。例如，而不是只有一个大的 AppContext，你可以有 UserContext、ThemeContext 等。这样，当某一部分的数据发生变化时，只有依赖于那部分数据的组件会重新渲染。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createContext, useContext, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">const</span> ThemeContext = createContext(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">const</span> CurrentUserContext = createContext(<span class="hljs-literal">null</span>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyApp</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [theme, setTheme] = useState(<span class="hljs-string">&#x27;light&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [currentUser, setCurrentUser] = useState(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">return</span> (<br>    &lt;ThemeContext.Provider value=&#123;theme&#125;&gt;<br>      &lt;CurrentUserContext.Provider<br>        value=&#123;&#123;<br>          currentUser,<br>          setCurrentUser<br>        &#125;&#125;<br>      &gt;<br>      &lt;Toolbar /&gt;<br>         &lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> setTheme(theme === <span class="hljs-string">&quot;light&quot;</span> ? <span class="hljs-string">&quot;dark&quot;</span> : <span class="hljs-string">&quot;light&quot;</span>)&#125;&gt;<br>        Toggle Theme<br>      &lt;/button&gt;<br>      &lt;/CurrentUserContext.Provider&gt;<br>    &lt;/ThemeContext.Provider&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用多个 Context 提供者</li></ul><p>这与上一点相似。你可以为应用中的不同部分使用不同的 context 提供者，确保仅当真正需要的数据更改时才重新渲染组件。</p><ul><li>使用useMemo和useCallback优化value</li></ul><p>为了避免value变化造成子孙组件频繁的重新渲染，可以使用useMemo和useCallback对参数和方法进行缓存，减少value的无意义更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useCallback, useMemo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyApp</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [currentUser, setCurrentUser] = useState(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-keyword">const</span> login = useCallback(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>    storeCredentials(response.credentials);<br>    setCurrentUser(response.user);<br>  &#125;, []);<br><br>  <span class="hljs-keyword">const</span> contextValue = useMemo(<span class="hljs-function">() =&gt;</span> (&#123;<br>    currentUser,<br>    login<br>  &#125;), [currentUser, login]);<br><br>  <span class="hljs-keyword">return</span> (<br>    &lt;AuthContext.Provider value=&#123;contextValue&#125;&gt;<br>      &lt;Page /&gt;<br>    &lt;/AuthContext.Provider&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>注：如果你的应用状态经常发生变化，并触发大量组件的更新，那么这种情况不适合用useContext，请立即考虑其它状态更新方案。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>希望本文所讲的useContext应用和技巧能帮助你掌握useContexthook。</p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://juejin.cn/post/7274789845754445859">掘金</a><br><a href="https://juejin.cn/post/7275214254096728116">精读React hooks</a></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
      <category>React hooks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>React hooks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React hooks（二）：全面掌握useReducer</title>
    <link href="/2024/06/27/ReactHook-%E5%85%A8%E9%9D%A2%E6%8E%8C%E6%8F%A1useReducer(2)/"/>
    <url>/2024/06/27/ReactHook-%E5%85%A8%E9%9D%A2%E6%8E%8C%E6%8F%A1useReducer(2)/</url>
    
    <content type="html"><![CDATA[<p>学习react Hooks的笔记</p><p>上一篇文章中，我们学习了useState的一些基础用法和进阶技巧，useState是React的一个基础Hook，允许我们在函数组件中存储状态。</p><p>随着应用逐渐复杂，我们经常发现useState在管理复杂的状态逻辑时显得有些力不从心。这时，React为我们提供的另一个更为强大的hook——useReducer——可以帮助我们优雅地处理复杂状态。</p><p>useReducer允许我们使用 action 和 reducer 的方式来组织复杂的状态逻辑，使其变得更加清晰和模块化，弥补了useState的局限性。</p><hr><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><p>与useState相似，useReducer也是 React 的 Hook，而且也只能放在组件最顶层使用。与前者不同的地方在于，它是通过 action 来更新状态的，使状态更新逻辑更具可读性。</p><p>useReducer接收三个参数：</p><p>reducer 函数：指定如何更新状态的还原函数，它必须是纯函数，以 state 和 dispatch 为参数，并返回下一个状态。<br>初始状态：初始状态的计算值。<br>（可选的）初始化参数：用于返回初始状态。如果未指定，初始状态将设置为 initialArg；如果有指定，初始状态将被设置为调用init(initialArg)的结果。</p><p>useReducer返回两个参数：</p><p>当前的状态：当前状态。在第一次渲染时，它会被设置为init(initialArg)或 initialArg（如果没有 init 的情况下）。<br>dispatch：调度函数，用于调用 reducer 函数，以更新状态并触发重新渲染。<br>基本形式如下：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, dispatch] = useReducer(reducer, initialArg, init?)<br></code></pre></td></tr></table></figure><p>通常情况下，我们只会用到useReducer的前两个参数，如这个计数器组件：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> initialState = &#123; count: <span class="hljs-number">0</span> &#125;;<br><br>function reducer(<span class="hljs-keyword">state</span>, action) &#123;<br>  switch (action.type) &#123;<br>    case &#x27;increment&#x27;:<br>      return &#123; count: <span class="hljs-keyword">state</span>.count + <span class="hljs-number">1</span> &#125;;<br>    case &#x27;decrement&#x27;:<br>      return &#123; count: <span class="hljs-keyword">state</span>.count - <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">default</span>:<br>      throw new Error();<br>  &#125;<br>&#125;<br><br>function Counter() &#123;<br>  <span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, dispatch] = useReducer(reducer, initialState);<br><br>  return (<br>    <span class="hljs-variable">&lt;&gt;</span><br>      Count: &#123;<span class="hljs-keyword">state</span>.count&#125;<br>      <span class="hljs-variable">&lt;button onClick=&#123;() =&gt;</span> dispatch(&#123; type: &#x27;decrement&#x27; &#125;)&#125;&gt;-&lt;/button&gt;<br>      <span class="hljs-variable">&lt;button onClick=&#123;() =&gt;</span> dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;&gt;+&lt;/button&gt;<br>    &lt;/&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>使用dispatch的注意事项</p><ul><li>dispatch调用后，状态更新是异步的，因此立刻读取状态可能仍是旧的。</li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pf">function addCount() &#123;<br>dispatch(&#123; type: &#x27;increment&#x27; &#125;)<br>console.<span class="hljs-keyword">log</span>(<span class="hljs-keyword">state</span>.count) // 打印出来的不是新值<br>&#125;<br><br><span class="hljs-variable">&lt;button onClick=&#123;addCount&#125;&gt;</span>+&lt;/button&gt;<br></code></pre></td></tr></table></figure><ul><li>React 对dispatch有一个优化机制：如果dispatch触发更新前后的值相等（使用Object.is判断），实际上 React 不会进行重新渲染，这是出于性能考虑。</li></ul><h4 id="使用reducer函数的注意事项"><a href="#使用reducer函数的注意事项" class="headerlink" title="使用reducer函数的注意事项"></a>使用reducer函数的注意事项</h4><p>你在reducer里面更新对象和数组的状态，需要创建一个新的对象或数组，而不是在原对象和数组上修改，这一点和useState是一样的。</p><h3 id="初始化状态：使用init函数"><a href="#初始化状态：使用init函数" class="headerlink" title="初始化状态：使用init函数"></a>初始化状态：使用init函数</h3><p>上一节我们提到了useReducer还有第三个参数init，那么它的作用是什么？它也是为了性能优化而来。</p><p>我们先假设一个场景，计数器的值保存在localStorage里面，进入页面的时候，我们希望从localStorage中读取值来作为useReducer初值，如果没有init，我们可以这样做：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pf">function getInitialCount() &#123;<br>  <span class="hljs-keyword">const</span> savedCount = localStorage.getItem(<span class="hljs-string">&quot;count&quot;</span>);<br>  return savedCount ? Number(savedCount) : <span class="hljs-number">0</span>;<br>&#125;<br><br>function counterReducer(<span class="hljs-keyword">state</span>, action) &#123;<br>  switch (action.type) &#123;<br>    case <span class="hljs-string">&quot;INCREMENT&quot;</span>:<br>      return &#123; count: <span class="hljs-keyword">state</span>.count + <span class="hljs-number">1</span> &#125;;<br>    case <span class="hljs-string">&quot;DECREMENT&quot;</span>:<br>      return &#123; count: <span class="hljs-keyword">state</span>.count - <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">default</span>:<br>      return <span class="hljs-keyword">state</span>;<br>  &#125;<br>&#125;<br><br>function Counter() &#123;<br>  <span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, dispatch] = useReducer(counterReducer, getInitialCount());<br><br>  // 使用useEffect来监听状态的变化，并将其保存到localStorage<br>  useEffect(() =&gt; &#123;<br>    localStorage.<span class="hljs-built_in">set</span>Item(<span class="hljs-string">&quot;count&quot;</span>, <span class="hljs-keyword">state</span>.count);<br>  &#125;, [<span class="hljs-keyword">state</span>.count]);<br><br>  return (<br>    <span class="hljs-variable">&lt;&gt;</span><br>      Count: &#123;<span class="hljs-keyword">state</span>.count&#125;<br>      <span class="hljs-variable">&lt;button onClick=&#123;() =&gt;</span> dispatch(&#123; type: <span class="hljs-string">&quot;INCREMENT&quot;</span> &#125;)&#125;&gt;+<span class="hljs-number">1</span>&lt;/button&gt;<br>      <span class="hljs-variable">&lt;button onClick=&#123;() =&gt;</span> dispatch(&#123; type: <span class="hljs-string">&quot;DECREMENT&quot;</span> &#125;)&#125;&gt;-<span class="hljs-number">1</span>&lt;/button&gt;<br>    &lt;/&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们直接调用getInitialCount函数作为useReducer的第二个参数，从而得到初始状态。当React初始化这个组件时，它会执行这个函数并使用其返回值作为初始状态。</p><p>如果在第三个参数里进行初始化，代码是这样写：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs pf">function init(initialValue) &#123;<br>  // 尝试从localStorage中读取值<br>  <span class="hljs-keyword">const</span> savedCount = localStorage.getItem(<span class="hljs-string">&quot;count&quot;</span>);<br><br>  // 如果有值并且可以被解析为数字，则返回它，否则返回initialValue<br>  return &#123; count: savedCount ? Number(savedCount) : initialValue &#125;;<br>&#125;<br><br>function counterReducer(<span class="hljs-keyword">state</span>, action) &#123;<br>  switch (action.type) &#123;<br>    case <span class="hljs-string">&quot;INCREMENT&quot;</span>:<br>      return &#123; count: <span class="hljs-keyword">state</span>.count + <span class="hljs-number">1</span> &#125;;<br>    case <span class="hljs-string">&quot;DECREMENT&quot;</span>:<br>      return &#123; count: <span class="hljs-keyword">state</span>.count - <span class="hljs-number">1</span> &#125;;<br>    <span class="hljs-keyword">default</span>:<br>      return <span class="hljs-keyword">state</span>;<br>  &#125;<br>&#125;<br><br>function Counter() &#123;<br>  <span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, dispatch] = useReducer(counterReducer, <span class="hljs-number">0</span>, init);<br><br>  // 使用useEffect来监听状态的变化，并将其保存到localStorage<br>  useEffect(() =&gt; &#123;<br>    localStorage.<span class="hljs-built_in">set</span>Item(<span class="hljs-string">&quot;count&quot;</span>, <span class="hljs-keyword">state</span>.count);<br>  &#125;, [<span class="hljs-keyword">state</span>.count]);<br><br>  return (<br>    <span class="hljs-variable">&lt;&gt;</span><br>      Count: &#123;<span class="hljs-keyword">state</span>.count&#125;<br>      <span class="hljs-variable">&lt;button onClick=&#123;() =&gt;</span> dispatch(&#123; type: <span class="hljs-string">&quot;INCREMENT&quot;</span> &#125;)&#125;&gt;+<span class="hljs-number">1</span>&lt;/button&gt;<br>      <span class="hljs-variable">&lt;button onClick=&#123;() =&gt;</span> dispatch(&#123; type: <span class="hljs-string">&quot;DECREMENT&quot;</span> &#125;)&#125;&gt;-<span class="hljs-number">1</span>&lt;/button&gt;<br>    &lt;/&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>这两种方式看似差不多，但它们区别很大：</p><ol><li>执行时机：</li></ol><ul><li>直接调用函数作为第二个参数：这个函数会在每次组件渲染时执行。</li><li>使用init函数：init函数只在组件初次渲染时执行一次。</li></ul><ol start="2"><li>访问到的数据：</li></ol><ul><li>直接调用函数作为第二个参数：这个函数只能访问到定义它时的作用域内的数据。</li><li>使用init函数：由于init函数接受initialArg作为参数，这使得init函数具有更大的灵活性，能够基于传入的参数进行计算。</li></ul><ol start="3"><li>代码组织：</li></ol><ul><li>直接调用函数作为第二个参数：这通常更简洁，适合那些简单的初始化逻辑。</li><li>使用init函数：它提供了更清晰的代码组织结构，特别是当初始化逻辑相对复杂或需要根据传入的参数变化时。</li></ul><ol start="4"><li>性能：</li></ol><ul><li>直接调用函数作为第二个参数：如果这个函数执行了一些计算密集或副作用的操作，那么在每次组件渲染时都会执行，可能会导致性能问题。</li><li>使用init函数：由于它只在组件的初始化阶段执行一次，所以对于那些计算密集的初始化操作，使用init函数可能会更为高效。<h4 id="总结一下，两者都可以用于初始化状态，如果你的初始化逻辑简单并且没有性能顾虑，可以直接使用一个函数作为useReducer的第二个参数，但如果你需要基于传入的参数来决定初始化逻辑或者想确保性能最优的做法，那么应该使用init函数。"><a href="#总结一下，两者都可以用于初始化状态，如果你的初始化逻辑简单并且没有性能顾虑，可以直接使用一个函数作为useReducer的第二个参数，但如果你需要基于传入的参数来决定初始化逻辑或者想确保性能最优的做法，那么应该使用init函数。" class="headerlink" title="总结一下，两者都可以用于初始化状态，如果你的初始化逻辑简单并且没有性能顾虑，可以直接使用一个函数作为useReducer的第二个参数，但如果你需要基于传入的参数来决定初始化逻辑或者想确保性能最优的做法，那么应该使用init函数。"></a>总结一下，两者都可以用于初始化状态，如果你的初始化逻辑简单并且没有性能顾虑，可以直接使用一个函数作为useReducer的第二个参数，但如果你需要基于传入的参数来决定初始化逻辑或者想确保性能最优的做法，那么应该使用init函数。</h4><h3 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h3><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4>就像Redux中的中间件，我们可以利用dispatch创建一个中间件方法，支持调用dispatch之前或之后执行代码。<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">thunkMiddleware</span>(<span class="hljs-params">dispatch</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">action</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (typeof action === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>            action(dispatch);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dispatch(action);<br>        &#125;<br> <span class="hljs-comment">// 代码在dispatch之后执行</span><br>        console.log(<span class="hljs-string">&quot;Action dispatched at: &quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString());<br>    &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchData</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">dispatch</span> =&gt;</span> &#123;<br>        fetch(<span class="hljs-string">&quot;/api/data&quot;</span>)<br>            .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())<br>            .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SET_DATA&#x27;</span>, <span class="hljs-attr">payload</span>: data &#125;));<br>    &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>    const [state, unenhancedDispatch] = useReducer(reducer, initialState);<br>    const dispatch = thunkMiddleware(unenhancedDispatch);<br>    <br>    useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        dispatch(fetchData());<br>    &#125;, [dispatch]);<br>&#125;<br></code></pre></td></tr></table></figure>在这个示例中，通过将原始的dispatch包裹在另一个函数内部，中间件为我们提供了一个在真正的状态更新前后注入自定义逻辑的机会。</li></ul><p>示例中，我们在调用原始的dispatch之前首先检查了action的类型。实际上，你可以在这里添加任何你想要的逻辑，例如日志记录、错误处理、请求API等。在dispatch调用之后，依然可以添加额外的逻辑。</p><h3 id="与useContext一起使用"><a href="#与useContext一起使用" class="headerlink" title="与useContext一起使用"></a>与useContext一起使用</h3><p>结合useContext和useReducer可以创建简单的全局状态管理系统。</p><p>我们就以此来尝试创建一个完整的主题切换系统：</p><p>首先，定义状态、reducer 和 context:</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> ThemeContext = React.createContext();<br><br><span class="hljs-keyword">const</span> initialState = &#123; theme: &#x27;light&#x27; &#125;;<br><br>function themeReducer(<span class="hljs-keyword">state</span>, action) &#123;<br>    switch (action.type) &#123;<br>        case &#x27;TOGGLE_THEME&#x27;:<br>            return &#123; theme: <span class="hljs-keyword">state</span>.theme === &#x27;light&#x27; ? &#x27;dark&#x27; : &#x27;light&#x27; &#125;;<br>        <span class="hljs-keyword">default</span>:<br>            return <span class="hljs-keyword">state</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，创建一个Provider组件：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">function ThemeProvider(&#123; children &#125;) &#123;</span><br><span class="xml">    const [state, dispatch] = useReducer(themeReducer, initialState);</span><br><br><span class="xml">    return (</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">theme:</span> state.theme, toggleTheme: () =&gt; dispatch(&#123; <span class="hljs-name">type:</span> <span class="hljs-string">&#x27;TOGGLE_THEME&#x27;</span> &#125;) &#125;&#125;</span><span class="xml"><span class="hljs-tag">&gt;</span></span><br><span class="xml">            &#123;children&#125;</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span><br><span class="xml">    );</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><p>在子组件中，你可以轻松切换和读取主题：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">function ThemedButton() &#123;</span><br><span class="xml">    const &#123; theme, toggleTheme &#125; = useContext(ThemeContext);</span><br><br><span class="xml">    return (</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">style</span>=</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">backgroundColor:</span> theme === <span class="hljs-string">&#x27;light&#x27;</span> ? <span class="hljs-string">&#x27;#fff&#x27;</span> : <span class="hljs-string">&#x27;#000&#x27;</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag"> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;toggleTheme&#125;</span>&gt;</span></span><br><span class="xml">            Toggle Theme</span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    );</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><p>这部分代码只是示例说明，完整的使用逻辑和 TypeScript 实现的源码已经发布到我的Github：useReducer-useContext实现主题切换</p><h3 id="useReducer与-Redux-的差异"><a href="#useReducer与-Redux-的差异" class="headerlink" title="useReducer与 Redux 的差异"></a>useReducer与 Redux 的差异</h3><p>虽然useReducer和 Redux 都采用了 action 和 reducer 的模式来处理状态，但它们在实现和使用上有几个主要的区别：</p><ul><li>范围：useReducer通常在组件或小型应用中使用，而Redux被设计为大型应用的全局状态管理工具。</li><li>中间件和扩展：Redux支持中间件，这允许开发者插入自定义逻辑，例如日志、异步操作等。而useReducer本身不直接支持，但我们可以模拟中间件的效果。</li><li>复杂性：对于简单的状态管理，useReducer通常更简单和直接。但当涉及到复杂的状态逻辑和中间件时，Redux可能更具优势。</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>useReducer作为 React 的一部分，它比useState强大，又比 Redux 轻量，尤其适合中小型应用或组件级状态管理。本文把useReducer的用法和注意项完整的讲解了一遍，吃透其中的知识点就能保证你对useReducer有足够的了解了。</p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://juejin.cn/post/7274789845754445859">掘金</a><br><a href="https://juejin.cn/column/7274211579691319311">精读React hooks</a></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
      <category>React hooks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>React hooks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React hooks（一）：useState 的几个基础用法和进阶技巧</title>
    <link href="/2024/06/27/ReactHook-useState(1)/"/>
    <url>/2024/06/27/ReactHook-useState(1)/</url>
    
    <content type="html"><![CDATA[<p>学习react Hooks的笔记</p><p>自从 React v16.8 版本以来，React Hooks 为我们提供了全新的编写和思考 React 组件的方式。不仅管理状态和生命周期变得更简洁、更强大，Hooks 还引入了并发渲染和其他高级功能。本系列文章将详细探讨每一个 Hook，从基础到高级。首篇，我们将探讨最常用的 hook——useState。</p><hr><h3 id="useState-的基本用法"><a href="#useState-的基本用法" class="headerlink" title="useState 的基本用法"></a>useState 的基本用法</h3><p>useState主要用于给组件添加状态变量。注意，我们只能在组件的顶层或自定义的 Hooks 中调用useState。</p><h4 id="初始化状态"><a href="#初始化状态" class="headerlink" title="初始化状态"></a>初始化状态</h4><ol><li>基础定义</li></ol><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> [age, <span class="hljs-built_in">set</span>Age] = useState(<span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li>懒初始化</li></ol><p>对于需要计算得到的初始状态，可以使用函数传递给useState。这样，函数只在初次渲染时执行，而非每次渲染。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const <span class="hljs-literal">[<span class="hljs-identifier">todos</span>, <span class="hljs-identifier">setTodos</span>]</span> = use<span class="hljs-constructor">State(<span class="hljs-params">createInitialTodos</span>)</span>; <span class="hljs-comment">// 注意：传递函数本身，非执行结果</span><br></code></pre></td></tr></table></figure><h4 id="更新状态"><a href="#更新状态" class="headerlink" title="更新状态"></a>更新状态</h4><p><strong>直接更新vs函数式更新</strong><br>大部分情况，直接更新状态即可：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">setAge(<span class="hljs-keyword">new</span><span class="hljs-type">State</span>);<br></code></pre></td></tr></table></figure><p>但当新状态依赖于前一个状态时，推荐使用函数式更新。这确保了更新准确性，特别是在并发模式下。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">set<span class="hljs-constructor">State(<span class="hljs-params">prevState</span> =&gt; <span class="hljs-params">prevState</span> + 1)</span>;<br></code></pre></td></tr></table></figure><ol start="2"><li>以下两个例子展示函数式更新的重要性：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 示例1: 使用函数式更新</span><br><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [age, setAge] = useState(<span class="hljs-number">42</span>);<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span>(<span class="hljs-params"></span>) </span>&#123;<br>    setAge(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> a + <span class="hljs-number">1</span>); <span class="hljs-comment">// 函数式更新</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    &lt;&gt;<br>      &lt;h1&gt;Your age: &#123;age&#125;&lt;/h1&gt;<br>      &lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> &#123;<br>        increment();<br>        increment();<br>        increment();<br>      &#125;&#125;&gt;+<span class="hljs-number">3</span>&lt;/button&gt;<br>    &lt;/&gt;<br>  );<br>&#125;<br><span class="hljs-comment">// 结果：点击 +3 时，age 更新为 45。</span><br><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 示例2: 使用直接更新</span><br><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [age, setAge] = useState(<span class="hljs-number">42</span>);<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span>(<span class="hljs-params"></span>) </span>&#123;<br>    setAge(age + <span class="hljs-number">1</span>); <span class="hljs-comment">// 直接更新</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;&gt;<br>      &lt;h1&gt;Your age: &#123;age&#125;&lt;/h1&gt;<br>      &lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> &#123;<br>        increment();<br>        increment();<br>        increment();<br>      &#125;&#125;&gt;+<span class="hljs-number">3</span>&lt;/button&gt;<br>    &lt;/&gt;<br>  );<br>&#125;<br><span class="hljs-comment">// 结果：点击 +3 时，可能只更新为 43。</span><br></code></pre></td></tr></table></figure><h5 id="在-React-中，当你直接更新状态，每次调用-setAge-age-1-时，如果这些调用在同一个渲染周期中执行，它们可能都会使用相同的初始状态（即在函数组件体的开始时捕获的状态值）。这是因为-React-的状态更新可能是异步的，特别是在批量处理或并发模式下，状态的更新可能还没有被应用，就已经触发了下一个更新。"><a href="#在-React-中，当你直接更新状态，每次调用-setAge-age-1-时，如果这些调用在同一个渲染周期中执行，它们可能都会使用相同的初始状态（即在函数组件体的开始时捕获的状态值）。这是因为-React-的状态更新可能是异步的，特别是在批量处理或并发模式下，状态的更新可能还没有被应用，就已经触发了下一个更新。" class="headerlink" title="在 React 中，当你直接更新状态，每次调用 setAge(age + 1) 时，如果这些调用在同一个渲染周期中执行，它们可能都会使用相同的初始状态（即在函数组件体的开始时捕获的状态值）。这是因为 React 的状态更新可能是异步的，特别是在批量处理或并发模式下，状态的更新可能还没有被应用，就已经触发了下一个更新。"></a>在 React 中，当你直接更新状态，每次调用 <code>setAge(age + 1)</code> 时，如果这些调用在同一个渲染周期中执行，它们可能都会使用相同的初始状态（即在函数组件体的开始时捕获的状态值）。这是因为 React 的状态更新可能是异步的，特别是在批量处理或并发模式下，状态的更新可能还没有被应用，就已经触发了下一个更新。</h5><p>在你的第二个示例中，每次调用 <code>increment()</code> 都直接使用了组件当前渲染周期中的 <code>age</code> 值，而这个值在连续调用 <code>increment</code> 时不会改变（始终为 42）。因此，尽管 <code>increment()</code> 被调用了三次，每次都是基于 42 的状态值来计算的，只有一次有效更新将被执行，使得 <code>age</code> 最终只增加 1，变为 43。<br>相反，使用函数式更新（如 <code>setAge(a =&gt; a + 1)</code>），每次更新都会接收到最新的状态作为参数，即使这些更新是在同一个渲染周期内触发的。这种方式确保了每次调用都基于前一次更新后的最新状态进行，从而正确地将 <code>age</code> 增加三次，达到预期的 45。</p><p>在并发模式下，因为状态更新可能是异步的，直接使用状态值进行更新时可能会遇到竞态条件，这时函数式更新显得尤为重要。函数式更新通过使用最新的状态值来保证状态更新的连贯性和正确性，尤其是在多次状态更新需要被顺序应用时。</p><h4 id="对象与数组的更新"><a href="#对象与数组的更新" class="headerlink" title="对象与数组的更新"></a>对象与数组的更新</h4><p>对象和数组的更新需要创建新的引用，而不是直接修改原状态。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">setForm(&#123;<br>  ...form,<br>  name: e.target.value <span class="hljs-regexp">//</span> 更新这个属性<br>&#125;);<br><br><span class="hljs-regexp">//</span> 错误示例：<br><span class="hljs-regexp">//</span> form.name = e.target.value<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk">setTodos([<br>  ...todos,<br>  &#123;<br>    id: nextId++,<br>    title: title,<br>    done: false<br>  &#125;<br>]);<br><br><span class="hljs-regexp">//</span> 错误示例<br><span class="hljs-regexp">//</span> todos.push(&#123;<br><span class="hljs-regexp">//</span>   id: nextId++,<br><span class="hljs-regexp">//</span>   title: title,<br><span class="hljs-regexp">//</span>   done: false<br><span class="hljs-regexp">//</span> &#125;);<br><span class="hljs-regexp">//</span> setTodos(todos);<br></code></pre></td></tr></table></figure><h4 id="函数的更新"><a href="#函数的更新" class="headerlink" title="函数的更新"></a>函数的更新</h4><p>把函数存储到state里是很少见的做法，但某些情况下，我们有可能需要这么做。</p><p>先看一个错误的示例：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const <span class="hljs-literal">[<span class="hljs-identifier">fn</span>, <span class="hljs-identifier">setFn</span>]</span> = use<span class="hljs-constructor">State(<span class="hljs-params">someFunction</span>)</span>;<br><br><span class="hljs-keyword">function</span> handle<span class="hljs-constructor">Click()</span> &#123;<br>  set<span class="hljs-constructor">Fn(<span class="hljs-params">someOtherFunction</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上文，我们知道这样的用法是把函数的返回值存储或更新到状态中，并不是把函数存储到状态中。</p><p>如果你想在状态中存储一个函数，你需要使用一个箭头函数来“包裹”它。这是正确的做法：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">const</span> [<span class="hljs-function"><span class="hljs-keyword">fn</span>, <span class="hljs-title">setFn</span>] = <span class="hljs-title">useState</span><span class="hljs-params">(<span class="hljs-params">()</span> =&gt; someFunction)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleClick</span><span class="hljs-params">()</span> </span>&#123;<br>  setFn(() =&gt; someOtherFunction);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们什么时候会需要这样使用？这里介绍一些可能的场景：</p><ol><li>可配置的行为: 你可能有一个组件，它的行为可以由父组件进行配置。在这种情况下，你可以将函数作为状态存储，以便在组件的生命周期中更改或更新它。</li><li>动态创建的函数: 在某些情况下，你可能需要基于组件的某些属性或状态动态创建函数。将这些函数存储为状态可以确保你只在必要时重新创建它们。</li><li>回调和外部交互: 如果你的组件与外部系统交互，并且需要提供回调函数，你可能希望在状态中存储这些回调函数，以便在适当的时候更改或更新它们。</li><li>延迟执行的函数: 在某些情况下，你可能想要在将来的某个时间点执行函数（例如，使用setTimeout）。将函数存储为状态可以确保即使组件的其他部分发生变化，你也可以访问到最初的函数引用。</li><li>与第三方库的集成: 有些第三方库可能要求你提供并在后续更改函数。在这种情况下，将函数作为状态存储可能会更加方便。</li></ol><h5 id="在-React-开发中，通常我们不会把函数直接存储在状态（state）中，因为函数通常作为固定的逻辑存在而不需要存储为变化的状态。然而，有一些特定场景下，存储函数到状态中可能是有益的或必要的。这些场景通常涉及到动态行为的配置、动态函数的创建、对外部交互的处理、计划执行任务，或者是与某些需要动态改变函数的第三方库集成。下面我会详细解释每一个场景："><a href="#在-React-开发中，通常我们不会把函数直接存储在状态（state）中，因为函数通常作为固定的逻辑存在而不需要存储为变化的状态。然而，有一些特定场景下，存储函数到状态中可能是有益的或必要的。这些场景通常涉及到动态行为的配置、动态函数的创建、对外部交互的处理、计划执行任务，或者是与某些需要动态改变函数的第三方库集成。下面我会详细解释每一个场景：" class="headerlink" title="在 React 开发中，通常我们不会把函数直接存储在状态（state）中，因为函数通常作为固定的逻辑存在而不需要存储为变化的状态。然而，有一些特定场景下，存储函数到状态中可能是有益的或必要的。这些场景通常涉及到动态行为的配置、动态函数的创建、对外部交互的处理、计划执行任务，或者是与某些需要动态改变函数的第三方库集成。下面我会详细解释每一个场景："></a>在 React 开发中，通常我们不会把函数直接存储在状态（state）中，因为函数通常作为固定的逻辑存在而不需要存储为变化的状态。然而，有一些特定场景下，存储函数到状态中可能是有益的或必要的。这些场景通常涉及到动态行为的配置、动态函数的创建、对外部交互的处理、计划执行任务，或者是与某些需要动态改变函数的第三方库集成。下面我会详细解释每一个场景：</h5><ol><li><p><strong>可配置的行为</strong>:</p><ul><li>在某些情况下，组件的行为可能需要根据父组件的配置来动态改变。例如，如果你有一个通用的按钮组件，其点击行为（如打开模态框、提交表单等）可以通过父组件传入的函数来定义。这时，你可以在状态中存储这个行为函数，并在需要时更新它，以改变按钮的功能。</li></ul></li><li><p><strong>动态创建的函数</strong>:</p><ul><li>如果函数的行为需要基于组件的某些属性或状态动态生成，例如一个根据用户角色动态生成的权限验证函数，那么将这些函数存储为状态可以避免在每次渲染时都重新创建它们，优化性能。</li></ul></li><li><p><strong>回调和外部交互</strong>:</p><ul><li>当组件需要与外部系统（如 Web API、浏览器API等）交互时，这些外部系统可能需要回调函数来处理异步事件或数据。将这些回调函数存储在状态中可以在它们需要更新时，方便地进行替换。</li></ul></li><li><p><strong>延迟执行的函数</strong>:</p><ul><li>在使用 <code>setTimeout</code> 或 <code>setInterval</code> 等时，你可能想在未来某个时间点执行某些特定的逻辑。将这个逻辑封装在一个函数中并将其保存在状态里，可以确保即使在组件更新后，你依然可以访问到最初的函数引用，保证执行的一致性。</li></ul></li><li><p><strong>与第三方库的集成</strong>:</p><ul><li>有些第三方库可能要求提供函数并在之后的操作中可能需要更改这些函数。例如，一个事件监听库可能允许你在初始化时提供一个回调函数，并在需要时通过某种方法更新它。在这种情况下，将函数作为状态存储，可以使这一过程更加灵活和可控。</li></ul></li></ol><p>总之，虽然通常不推荐将函数存储在状态中，但在需要高度动态和可配置的行为时，这种方法可以提供额外的灵活性和控制能力。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在这篇文章中，我们深入探讨了 React 的useStateHook，从它的基础用法到一些进阶技巧。掌握好useState是走向 React 高手之路的关键一步。在未来的文章中，我们还将继续探讨其他的 Hooks。</p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://juejin.cn/post/7274211579691335695">掘金</a><br><a href="https://juejin.cn/column/7274211579691319311">精读React hooks</a></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
      <category>React hooks</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>React hooks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>源码学习---为什么 Vue2 this 能够直接获取到 data 和 methods ?</title>
    <link href="/2023/04/01/%5B%E6%BA%90%E7%A0%81%5D%E4%B8%BA%E4%BB%80%E4%B9%88Vue2this%E8%83%BD%E5%A4%9F%E7%9B%B4%E6%8E%A5%E8%8E%B7%E5%8F%96%E5%88%B0data%E5%92%8Cmethods/"/>
    <url>/2023/04/01/%5B%E6%BA%90%E7%A0%81%5D%E4%B8%BA%E4%BB%80%E4%B9%88Vue2this%E8%83%BD%E5%A4%9F%E7%9B%B4%E6%8E%A5%E8%8E%B7%E5%8F%96%E5%88%B0data%E5%92%8Cmethods/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="为什么-Vue2-this-能够直接获取到-data-和-methods"><a href="#为什么-Vue2-this-能够直接获取到-data-和-methods" class="headerlink" title="为什么 Vue2 this 能够直接获取到 data 和 methods ?"></a>为什么 Vue2 this 能够直接获取到 data 和 methods ?</h2><blockquote><p>当我们使用Vue.js开发应用时，经常会使用一些状态，例如props、methods、data、computed和watch。在Vue.js内部，这些状态在使用之前需要进行初始化。这里将介绍methods和data的内部原理，理解为什么data和methods的数据可以通过this访问。</p></blockquote><h3 id="new-Vue被调用时发生了什么"><a href="#new-Vue被调用时发生了什么" class="headerlink" title="new Vue被调用时发生了什么"></a>new Vue被调用时发生了什么</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Vue</span><span class="hljs-params">(options)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;development&quot;</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; !(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Vue)<br>        ) &#123;<br>            warn(<span class="hljs-string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">this</span>._init(options);<br>    &#125;<br></code></pre></td></tr></table></figure><p>首先来看Vue构造函数，在Vue构造函数中，首先进行安全检查，在非生产环境下，如果没有使用new来调用Vue，则会在控制台抛出错误警告我们：<strong>Vue是构造函数，应该使用new关键字来调用。 然后调用this._init(options)来执行初始化流程。下面再来看_init初始化函数</strong></p><h3 id="init初始化函数"><a href="#init初始化函数" class="headerlink" title="_init初始化函数"></a>_init初始化函数</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> initMixin (Vue) &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Vue</span>.</span></span>prototype._init = <span class="hljs-keyword">function</span> (options) &#123;<br>      var vm = this;<br>      <span class="hljs-comment">// 省略其他代码</span><br>      vm._self = vm;<br>      init<span class="hljs-constructor">Lifecycle(<span class="hljs-params">vm</span>)</span>;<br>      init<span class="hljs-constructor">Events(<span class="hljs-params">vm</span>)</span>;<br>      init<span class="hljs-constructor">Render(<span class="hljs-params">vm</span>)</span>;<br>      call<span class="hljs-constructor">Hook(<span class="hljs-params">vm</span>, &#x27;<span class="hljs-params">beforeCreate</span>&#x27;)</span>;<br>      init<span class="hljs-constructor">Injections(<span class="hljs-params">vm</span>)</span>;<br>      init<span class="hljs-constructor">State(<span class="hljs-params">vm</span>)</span>;<br>      init<span class="hljs-constructor">Provide(<span class="hljs-params">vm</span>)</span>;<br>      call<span class="hljs-constructor">Hook(<span class="hljs-params">vm</span>, &#x27;<span class="hljs-params">created</span>&#x27;)</span>;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，Vue.js会在初始化流程的不同时期通过callHook函数触发生命周期钩子。在生命周期钩子beforeCreate被触发之前执行了initLifecycle、initEvents和initRender.在初始化的过程中，首先初始化事件与属性，然后触发生命周期钩子beforeCreate。随后初始化provide/inject和状态，这里的状态指的是props、methods、data、computed以及watch。接着触发生命周期钩子created。<strong>而我们需要了解的data和methods就在initState这个函数中。</strong></p><h3 id="初始化状态"><a href="#初始化状态" class="headerlink" title="初始化状态"></a>初始化状态</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> initState (vm) &#123;<br>    var opts = vm.$options;<br>    <span class="hljs-keyword">if</span> (opts.props) &#123; init<span class="hljs-constructor">Props(<span class="hljs-params">vm</span>, <span class="hljs-params">opts</span>.<span class="hljs-params">props</span>)</span>; &#125;<br>    <span class="hljs-keyword">if</span> (opts.methods) &#123; init<span class="hljs-constructor">Methods(<span class="hljs-params">vm</span>, <span class="hljs-params">opts</span>.<span class="hljs-params">methods</span>)</span>; &#125;<br>    <span class="hljs-keyword">if</span> (opts.data) &#123;<br>      init<span class="hljs-constructor">Data(<span class="hljs-params">vm</span>)</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      observe(vm._data = &#123;&#125;, <span class="hljs-literal">true</span> <span class="hljs-comment">/* asRootData */</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (opts.computed) &#123; init<span class="hljs-constructor">Computed(<span class="hljs-params">vm</span>, <span class="hljs-params">opts</span>.<span class="hljs-params">computed</span>)</span>; &#125;<br>    <span class="hljs-keyword">if</span> (opts.watch<span class="hljs-operator"> &amp;&amp; </span>opts.watch !== nativeWatch) &#123;<br>      init<span class="hljs-constructor">Watch(<span class="hljs-params">vm</span>, <span class="hljs-params">opts</span>.<span class="hljs-params">watch</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在initState函数中，我们看到了initMethods和initData函数，在接着往下看这两个函数</p><h3 id="初始化methods"><a href="#初始化methods" class="headerlink" title="初始化methods"></a>初始化methods</h3><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sas">function initMethods (vm, methods) &#123;<br>    var props = vm.$<span class="hljs-meta">options</span>.props;<br>    for (var <span class="hljs-meta">key</span> <span class="hljs-meta">in</span> methods) &#123;<br>      &#123;<br>        <span class="hljs-meta">if</span> (typeof methods[<span class="hljs-meta">key</span>] !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>          wa<span class="hljs-meta">rn(</span><br>            <span class="hljs-string">&quot;Method \&quot;&quot;</span> + <span class="hljs-meta">key</span> + <span class="hljs-string">&quot;\&quot; has type \&quot;&quot;</span> + (typeof methods[<span class="hljs-meta">key</span>]) + <span class="hljs-string">&quot;\&quot; in the component definition. &quot;</span> +<br>            <span class="hljs-string">&quot;Did you reference the function correctly?&quot;</span>,<br>            vm<br>          );<br>        &#125;<br>        <span class="hljs-meta">if</span> (props <span class="hljs-variable">&amp;&amp;</span> hasO<span class="hljs-meta">wn(</span>props, <span class="hljs-meta">key</span>)) &#123;<br>          wa<span class="hljs-meta">rn(</span><br>            (<span class="hljs-string">&quot;Method \&quot;&quot;</span> + <span class="hljs-meta">key</span> + <span class="hljs-string">&quot;\&quot; has already been defined as a prop.&quot;</span>),<br>            vm<br>          );<br>        &#125;<br>        <span class="hljs-meta">if</span> ((<span class="hljs-meta">key</span> <span class="hljs-meta">in</span> vm) <span class="hljs-variable">&amp;&amp;</span> isReserved(<span class="hljs-meta">key</span>)) &#123;<br>          wa<span class="hljs-meta">rn(</span><br>            <span class="hljs-string">&quot;Method \&quot;&quot;</span> + <span class="hljs-meta">key</span> + <span class="hljs-string">&quot;\&quot; conflicts with an existing Vue instance method. &quot;</span> +<br>            <span class="hljs-string">&quot;Avoid defining component methods that start with _ or $.&quot;</span><br>          );<br>        &#125;<br>      &#125;<br>      vm[<span class="hljs-meta">key</span>] = typeof methods[<span class="hljs-meta">key</span>] !== <span class="hljs-string">&#x27;function&#x27;</span> ? noop : bind(methods[<span class="hljs-meta">key</span>], vm);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化methods时，只需要循环选项中的methods对象，并将每个属性依次挂载到vm上即可，在循环中会校验方法是否合法，<strong>合法后最终是通过bind显示绑定this指向为vm</strong>，所以这里也就是为什么我们能通过this访问到methods里面函数的原因</p><h3 id="初始化data"><a href="#初始化data" class="headerlink" title="初始化data"></a>初始化data</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">function</span> initData (vm) &#123;<br>    var <span class="hljs-class"><span class="hljs-keyword">data</span> = vm.$options.<span class="hljs-keyword">data</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">data</span> = vm._data = typeof <span class="hljs-keyword">data</span> === &#x27;function&#x27;</span><br>      ? getData(<span class="hljs-class"><span class="hljs-keyword">data</span>, vm)</span><br>      : <span class="hljs-class"><span class="hljs-keyword">data</span> || &#123;&#125;;</span><br>    <span class="hljs-keyword">if</span> (!isPlainObject(<span class="hljs-class"><span class="hljs-keyword">data</span>)) &#123;</span><br><span class="hljs-class">      <span class="hljs-title">data</span> = &#123;&#125;;</span><br>      warn(<br>        &#x27;<span class="hljs-class"><span class="hljs-keyword">data</span> functions should return an object:\n&#x27; +</span><br>        &#x27;https://vuejs.org/v2/guide/components.html#<span class="hljs-class"><span class="hljs-keyword">data</span>-<span class="hljs-type">Must</span>-<span class="hljs-type">Be</span>-a-<span class="hljs-type">Function&#x27;</span>,</span><br>        vm<br>      );<br>    &#125;<br>    // 将<span class="hljs-class"><span class="hljs-keyword">data</span>代理到<span class="hljs-type">Vue</span>.js实例上</span><br>    var keys = <span class="hljs-type">Object</span>.keys(<span class="hljs-class"><span class="hljs-keyword">data</span>);</span><br>    var props = vm.$options.props;<br>    var methods = vm.$options.methods;<br>    var i = keys.length;<br>    while (i<span class="hljs-comment">--) &#123;</span><br>      var key = keys[i];<br>      &#123;<br>        <span class="hljs-keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;<br>          warn(<br>            (<span class="hljs-string">&quot;Method \&quot;&quot;</span> + key + <span class="hljs-string">&quot;\&quot; has already been defined as a data property.&quot;</span>),<br>            vm<br>          );<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;<br>        warn(<br>          <span class="hljs-string">&quot;The data property \&quot;&quot;</span> + key + <span class="hljs-string">&quot;\&quot; is already declared as a prop. &quot;</span> +<br>          <span class="hljs-string">&quot;Use prop default value instead.&quot;</span>,<br>          vm<br>        );<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isReserved(key)) &#123;<br>        proxy(vm, <span class="hljs-string">&quot;_data&quot;</span>, key);<br>      &#125;<br>    &#125;<br>    // 观察数据<br>    observe(<span class="hljs-class"><span class="hljs-keyword">data</span>, true /* asRootData */);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>简单来说，<strong>data中的数据最终会保存到vm._data中</strong>。然后在vm上设置一个代理，使得通过vm.x可以访问到vm._data中的x属性。最后由于这些数据并不是响应式数据，所以需要调用observe函数将data转换成响应式数据。于是，data就完成了初始化。</p><p><strong>在上述代码中，还有对data类型的判断，如果是函数，则需要执行函数并将返回值赋值给变量data和vm._data。</strong></p><p>代码中调用了proxy函数实现代理功能。该函数的作用是在第一个参数上设置一个属性名为第三个参数的属性。这个属性的修改和获取操作实际上针对的是与第二个参数相同属性名的属性。proxy的代码如下：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noop</span> <span class="hljs-params">(a, b, c)</span> </span>&#123;&#125;<br><span class="hljs-keyword">var</span> sharedPropertyDefinition = &#123;<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>    <span class="hljs-keyword">get</span>: noop,<br>    <span class="hljs-keyword">set</span>: noop<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxy</span> <span class="hljs-params">(target, sourceKey, key)</span> </span>&#123;<br>    sharedPropertyDefinition.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxyGetter</span> <span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[sourceKey][key]<br>    &#125;;<br>    sharedPropertyDefinition.set = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxySetter</span> <span class="hljs-params">(val)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>[sourceKey][key] = val;<br>    &#125;;<br>    Object.defineProperty(target, key, sharedPropertyDefinition);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里先声明了一个变量sharedPropertyDefinition作为默认属性描述符。接下来声明了proxy函数，此函数接收3个参数：<strong>target、sourceKey和key</strong>。随后在代码中设置了get和set属性，相当于给属性提供了getter和setter方法。在getter方法中读取了<code>this[sourceKey][key]</code>，在setter方法中设置了<code>this[sourceKey][key]</code> 属性。最后，使用Object.defineProperty方法为target定义一个属性，属性名为key，属性描述符为sharedPropertyDefinition。通过这样的方式将vm._data中的方法代理到vm上。所有属性都代理后，执行observe函数将数据转换成响应式的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后其实总的来说在data里<strong>通过Object.defineProperty代理方式将vm._data代理到vm上，在methods里通过bind绑定this指向为vm</strong></p><p>Vue的这种设计，好处在于便于获取。<strong>也有不方便的地方，就是props、methods 和 data三者容易产生冲突。</strong></p><p>文章整体难度不大，但非常建议读者朋友们自己动手调试下。调试后，你可能会发现：原来 Vue 源码，也没有想象中的那么难，也能看懂一部分。</p><p>启发：我们工作使用常用的技术和框架或库时，保持好奇心，多思考内部原理。能够做到知其然，知其所以然。就能远超很多人。</p><p>你可能会思考，为什么模板语法中，可以省略this关键词写法呢，内部模板编译时其实是用了with。有余力的读者可以探究这一原理。</p><h4 id="摘抄两个工具方法"><a href="#摘抄两个工具方法" class="headerlink" title="摘抄两个工具方法"></a>摘抄两个工具方法</h4><ol><li>hasOwn 是否是对象本身拥有的属性</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Check whether an object has the property.</span><br><span class="hljs-comment">* 是自己的本身拥有的属性，不是通过原型链向上查找的。</span><br><span class="hljs-comment">*/</span><br>var hasOwnProperty = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>prototype.hasOwnProperty;<br><span class="hljs-keyword">function</span> hasOwn (obj, key) &#123;<br>  return hasOwnProperty.call(obj, key)<br>&#125;<br><br>has<span class="hljs-constructor">Own(&#123; <span class="hljs-params">a</span>: <span class="hljs-params">undefined</span> &#125;, &#x27;<span class="hljs-params">a</span>&#x27;)</span> <span class="hljs-comment">// true</span><br>has<span class="hljs-constructor">Own(&#123;&#125;, &#x27;<span class="hljs-params">a</span>&#x27;)</span> <span class="hljs-comment">// false</span><br>has<span class="hljs-constructor">Own(&#123;&#125;, &#x27;<span class="hljs-params">hasOwnProperty</span>&#x27;)</span> <span class="hljs-comment">// false</span><br>has<span class="hljs-constructor">Own(&#123;&#125;, &#x27;<span class="hljs-params">toString</span>&#x27;)</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><ol start="2"><li>isReserved 是否是内部私有保留的字符串$ 和 _ 开头</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Check if a string starts with $ or _</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">function</span> isReserved (str) &#123;<br>  var c = (str + &#x27;&#x27;).<span class="hljs-built_in">char</span><span class="hljs-constructor">CodeAt(0)</span>;<br>  return c<span class="hljs-operator"> === </span><span class="hljs-number">0x24</span><span class="hljs-operator"> || </span>c<span class="hljs-operator"> === </span><span class="hljs-number">0x5F</span><br>&#125;<br>is<span class="hljs-constructor">Reserved(&#x27;<span class="hljs-params">_data</span>&#x27;)</span>; <span class="hljs-comment">// true</span><br>is<span class="hljs-constructor">Reserved(&#x27;$<span class="hljs-params">options</span>&#x27;)</span>; <span class="hljs-comment">// true</span><br>is<span class="hljs-constructor">Reserved(&#x27;<span class="hljs-params">data</span>&#x27;)</span>; <span class="hljs-comment">// false</span><br>is<span class="hljs-constructor">Reserved(&#x27;<span class="hljs-params">options</span>&#x27;)</span>; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="最后用60余行代码实现简化版"><a href="#最后用60余行代码实现简化版" class="headerlink" title="最后用60余行代码实现简化版"></a>最后用60余行代码实现简化版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noop</span> (<span class="hljs-params">a, b, c</span>) </span>&#123;&#125;<br><span class="hljs-keyword">var</span> sharedPropertyDefinition = &#123;<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>    get: noop,<br>    set: noop<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxy</span> (<span class="hljs-params">target, sourceKey, key</span>) </span>&#123;<br>    sharedPropertyDefinition.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxyGetter</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>[sourceKey][key]<br>    &#125;;<br>    sharedPropertyDefinition.set = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">proxySetter</span> (<span class="hljs-params">val</span>) </span>&#123;<br>      <span class="hljs-built_in">this</span>[sourceKey][key] = val;<br>    &#125;;<br>    <span class="hljs-built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initData</span>(<span class="hljs-params">vm</span>)</span>&#123;<br>  <span class="hljs-keyword">const</span> data = vm._data = vm.$options.data;<br>  <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(data);<br>  <span class="hljs-keyword">var</span> i = keys.length;<br>  <span class="hljs-keyword">while</span> (i--) &#123;<br>    <span class="hljs-keyword">var</span> key = keys[i];<br>    proxy(vm, <span class="hljs-string">&#x27;_data&#x27;</span>, key);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initMethods</span>(<span class="hljs-params">vm, methods</span>)</span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> methods) &#123;<br>    vm[key] = <span class="hljs-keyword">typeof</span> methods[key] !== <span class="hljs-string">&#x27;function&#x27;</span> ? noop : methods[key].bind(vm);<br>  &#125; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">options</span>)</span>&#123;<br>  <span class="hljs-keyword">let</span> vm = <span class="hljs-built_in">this</span>;<br>  vm.$options = options;<br>  <span class="hljs-keyword">var</span> opts = vm.$options;<br>  <span class="hljs-keyword">if</span>(opts.data)&#123;<br>    initData(vm);<br>  &#125;<br>  <span class="hljs-keyword">if</span>(opts.methods)&#123;<br>    initMethods(vm, opts.methods)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> Person(&#123;<br>    data: &#123;<br>        name: <span class="hljs-string">&#x27;ZL&#x27;</span><br>    &#125;,<br>    methods: &#123;<br>        <span class="hljs-function"><span class="hljs-title">sayName</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>        &#125;<br>    &#125;<br>&#125;);<br><br><span class="hljs-built_in">console</span>.log(p.name);<br><span class="hljs-comment">// 未实现前： undefined</span><br><span class="hljs-comment">// &#x27;ZL&#x27;</span><br><span class="hljs-built_in">console</span>.log(p.sayName());<br><span class="hljs-comment">// 未实现前：Uncaught TypeError: p.sayName is not a function</span><br><span class="hljs-comment">// &#x27;ZL&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/7010920884789575711">为什么 Vue2 this 能够直接获取到 data 和 methods ? 源码揭秘！</a><br><a href="https://juejin.cn/search?query=%E4%B8%BA%E4%BB%80%E4%B9%88%20Vue2%20this%20%E8%83%BD%E5%A4%9F%E7%9B%B4%E6%8E%A5%E8%8E%B7%E4%B8%BA%E4%BB%80%E4%B9%88%20Vue2%20this%20%E8%83%BD%E5%A4%9F%E7%9B%B4%E6%8E%A5%E8%8E%B7%E5%8F%96%E5%8F%96%E5%88%B0%20data%20%E5%92%8C%20methods%20?%20%E6%BA%90%E7%A0%81%E6%8F%AD%E7%A7%98%EF%BC%81&type=0">掘金</a></p>]]></content>
    
    
    <categories>
      
      <category>源码学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端进阶</tag>
      
      <tag>源码学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在DOM编程中，innerHTML和createElement都可以往页面中去追加元素，那么它们之间有什么区别？</title>
    <link href="/2023/03/31/%E5%9C%A8DOM%E7%BC%96%E7%A8%8B%E4%B8%AD%EF%BC%8CinnerHTML%E5%92%8CcreateElement%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%BE%80%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%8E%BB%E8%BF%BD%E5%8A%A0%E5%85%83%E7%B4%A0%EF%BC%8C%E9%82%A3%E4%B9%88%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <url>/2023/03/31/%E5%9C%A8DOM%E7%BC%96%E7%A8%8B%E4%B8%AD%EF%BC%8CinnerHTML%E5%92%8CcreateElement%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%BE%80%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%8E%BB%E8%BF%BD%E5%8A%A0%E5%85%83%E7%B4%A0%EF%BC%8C%E9%82%A3%E4%B9%88%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="在DOM编程中，innerHTML和createElement都可以往页面中去追加元素，那么它们之间有什么区别？"><a href="#在DOM编程中，innerHTML和createElement都可以往页面中去追加元素，那么它们之间有什么区别？" class="headerlink" title="在DOM编程中，innerHTML和createElement都可以往页面中去追加元素，那么它们之间有什么区别？"></a>在DOM编程中，innerHTML和createElement都可以往页面中去追加元素，那么它们之间有什么区别？</h3><p>下面让我们来一步一步看</p><h4 id="1-createElement-性能更好"><a href="#1-createElement-性能更好" class="headerlink" title="#1) createElement 性能更好"></a>#1) createElement 性能更好</h4><p>假如我们有一个div，然后需要往里插入元素</p><h5 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h5><p>使用<strong>createElement</strong>来创建元素，然后使用<strong>appendChild</strong>来插入到页面中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.container&#x27;</span>);</span><br><br><span class="javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;p&#x27;</span>);</span><br><span class="javascript">p.textContent = <span class="hljs-string">&#x27;JS DOM&#x27;</span>;</span><br>div.appendChild(p);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h4><p>使用innerHTML来在div内追加元素</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta">let <span class="hljs-keyword">div</span> = document.querySelector(<span class="hljs-string">&#x27;.container&#x27;</span>);<br><span class="hljs-keyword">div</span>.innerHTML += <span class="hljs-string">&#x27;&lt;p&gt;JS DOM&lt;/p&gt;&#x27;</span>;<br></code></pre></td></tr></table></figure><p>使用innerHTML来去创建元素，更简单、更简洁、更直观。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">let <span class="hljs-keyword">div</span> = document.querySelector(&#x27;.container&#x27;);<br><span class="hljs-keyword">div</span>.innerHTML += &#x27;&lt;p <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;note&quot;</span>&gt;JS DOM&lt;/p&gt;&#x27;;<br></code></pre></td></tr></table></figure><p>但是，使用 innerHTML 会导致浏览器重新解析并重新创建 div 元素内的所有 DOM 节点。 因此，它比创建一个新元素并追加到 div 中效率低。 换句话说，创建一个新元素并将其追加到 DOM 树中比 innerHTML有着更好的性能。</p><h4 id="2-createElement-更安全"><a href="#2-createElement-更安全" class="headerlink" title="#2) createElement 更安全"></a>#2) createElement 更安全</h4><p>如果innerHTML的数据来自我们自己，那可以认为是安全的。</p><p>如果innerHTML的数据来自于用户，我们无法控制其是否安全，以及是否被注入了恶意代码。</p><h4 id="3-使用-DocumentFragment-DOM片段"><a href="#3-使用-DocumentFragment-DOM片段" class="headerlink" title="#3) 使用 DocumentFragment DOM片段"></a>#3) 使用 DocumentFragment DOM片段</h4><p>假如我们有一个1000个列表的子元素需要插入到页面中，我们需要像下面一样去循环</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.container&#x27;</span>);</span><br><br><span class="javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;</span><br><span class="javascript">  <span class="hljs-keyword">let</span> p = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;p&#x27;</span>);</span><br><span class="javascript">  p.textContent = <span class="hljs-string">`段落 <span class="hljs-subst">$&#123;i&#125;</span>`</span>;</span><br>  div.appendChild(p);<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>但这会有个问题，每个元素被插入到div中都会重新计算样式、绘制和布局，损失性能。</strong></p><p>为了解决这个问题，我们通常去使用DocumentFragment来收集所有DOM节点并一次插入到DOM中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.container&#x27;</span>);</span><br><br><span class="javascript"><span class="hljs-comment">// 使用DocumentFragment</span></span><br><span class="javascript"><span class="hljs-keyword">let</span> fragment = <span class="hljs-built_in">document</span>.createDocumentFragment();</span><br><span class="javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;</span><br><span class="javascript">   <span class="hljs-keyword">let</span> p = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;p&#x27;</span>);</span><br><span class="javascript">   p.textContent = <span class="hljs-string">`段落 <span class="hljs-subst">$&#123;i&#125;</span>`</span>;</span><br>   fragment.appendChild(p);<br>&#125;<br><br><span class="javascript"><span class="hljs-comment">// 将fragment插入到div</span></span><br>div.appendChild(fragment);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上面代码中，我们先把生成的DOM先插入到<strong>DocumentFragment</strong>对象中，最后经DocumentFragment一次的插入到页面中。所以比每次插入更加高效。</p><p>使用innerHTML的话，语法会更简洁直观</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.container&#x27;</span>);</span><br><br><span class="javascript"><span class="hljs-comment">// 使用DocumentFragment</span></span><br><span class="javascript"><span class="hljs-keyword">let</span> html = <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;</span><br><span class="javascript">  html += <span class="hljs-string">`&lt;p&gt;段落 <span class="hljs-subst">$&#123;i&#125;</span>&lt;/p&gt;`</span>;</span><br>&#125;<br><br>div.innerHTML = html;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>createElement性能更好，更安全，插入多个元素需要使DocumentFragment</strong><br><strong>innerHTML使用更简单、更简洁、更直观，但安全性需要注意</strong></p><p>面试中问到的innerHTML与createElement创建方式的区别：可以从innerHTML是采用字符串拼接还是数组形式拼接和其结构来说</p>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Performance使用指南前端性能排查</title>
    <link href="/2023/03/31/Performance%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E6%8E%92%E6%9F%A5/"/>
    <url>/2023/03/31/Performance%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E6%8E%92%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="Performance使用指南前端性能排查"><a href="#Performance使用指南前端性能排查" class="headerlink" title="Performance使用指南前端性能排查"></a>Performance使用指南前端性能排查</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在前端领域, <strong>性能优化</strong>都是一个非常重要的组成部分，如何通过合理的手段尽可能地提高页面性能，是需要我们不断地努力要做到的，但在那之前, <strong>性能排查</strong>又是让你能够“对症下药”的重要手段, 通过性能排查, 咱们才能清楚的知道页面中具体是什么原因影响了性能，<strong>Chrome DevTools</strong>给我们提供了2种常用方式 Audits和Performance，<strong>Audits</strong>可以对页面进行性能评分，同时，还会给我们提供一些优化建议。而<strong>Performance</strong>则提供了非常多的运行时数据，能让我们看到更多细节数据。下面主要介绍一下如何利用DevTools中的Performance面板来进行性能分析, 并排查性能问题。</p><h4 id="Performance-面板介绍"><a href="#Performance-面板介绍" class="headerlink" title="Performance 面板介绍"></a>Performance 面板介绍</h4><p>首先在新的无痕窗口打开网页(使用无痕的目的是尽可能减少浏览器插件和缓存对页面的影响)，打开Chrome DevTools 切换到 Performance 下可以看到以下界面：<br><img src="/img/performance1.png" alt="Performance 面板介绍"><br>上图1、3区域按钮可以用来控制性能数据记录，黑色按钮可以记录交互阶段的性能数据，圆形箭头按钮用来记录加载阶段的性能数据。<br>上图2区域 可以设置当前页面的网络加载速度与CPU运算速度, 通过这2项可以去尽可能的模拟移动端设备的加载环境。<br>通过点击3区域内的<strong>刷新</strong>按钮,会刷新页面并记录性能数据, 并得到以下性能报告。</p><p><img src="/img/performance2.png" alt="Performance 面板介绍"></p><h4 id="整个页面性能数据分析报告从上至下可简单分为三个部分"><a href="#整个页面性能数据分析报告从上至下可简单分为三个部分" class="headerlink" title="整个页面性能数据分析报告从上至下可简单分为三个部分."></a>整个页面性能数据分析报告从上至下可简单分为三个部分.</h4><h5 id="第一部分：网页性能总览图"><a href="#第一部分：网页性能总览图" class="headerlink" title="第一部分：网页性能总览图"></a>第一部分：网页性能总览图</h5><p>这里最主要是整体的界面渲染的时候，每个时间段执行的事件顺序，通过上图我们就能知道我们每个时间段（精确到毫秒）都做了什么，当鼠标放上去的时候，我们还可以大图的形式去查看我们每个时间段界面的渲染情况，Performance 就会将几个关键指标，诸如FPS（每秒帧数情况）、CPU（CPU占用情况）、NET（网络资源情况）、HEAP（JS堆内存占用情况） 等，按照时间顺序做成图表的形式展现出来。</p><h6 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h6><p>全称Frames Per Second，表示每秒传输帧数，是速度单位，用来分析动画的一个主要性能指标。 如下图所示，绿色竖线越高，FPS 越高。 红色表示长时间帧，可能出现卡顿。</p><p>不同帧的体验：<br>帧率能够达到 50 ～ 60 FPS 的动画将会相当流畅，让人倍感舒适；<br>帧率在 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异；<br>帧率在 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感；<br>帧率波动很大的动画，亦会使人感觉到卡顿。<br><img src="/img/performance3.png" alt="Performance 面板介绍"></p><h6 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h6><p>CPU 资源占用情况。此面积图指示消耗 CPU 资源的事件类型。<br>下图中颜色分别为（与数据统计中的颜色数据表示一致）：<br>蓝色(Loading)：表示网络通信和 HTML 解析时间。<br>黄色(Scripting)：表示 JavaScript 执行时间。<br>紫色(Rendering)：表示样式计算和布局（重排）时间。<br>绿色(Painting)：表示重绘时间。<br>灰色(other)：表示其它事件花费的时间。<br>白色(Idle)：表示空闲时间。<br><img src="/img/performance4.png" alt="Performance 面板介绍"></p><h6 id="NET"><a href="#NET" class="headerlink" title="NET"></a>NET</h6><p>Network 概览。深蓝色表示存在高优先级的资源请求的时间段，浅蓝色表示存在低优先级的资源请求的时间段。<br><img src="/img/performance5.png" alt="Performance 面板介绍"></p><h6 id="HEAP"><a href="#HEAP" class="headerlink" title="HEAP"></a>HEAP</h6><p>JavaScript代码执行时堆内存的占用情况<br><img src="/img/performance6.png" alt="Performance 面板介绍"></p><h5 id="第二部分：各项指标的区块图"><a href="#第二部分：各项指标的区块图" class="headerlink" title="第二部分：各项指标的区块图"></a>第二部分：各项指标的区块图</h5><p>详情展开<br><img src="/img/performance7.png" alt="Performance 面板介绍"></p><ol><li>Network(网络)：这里可以直观的看到页面的网络资源加载的顺序与时长。</li><li>Frames(帧)：表示每帧的运行情况。</li><li>Timings(时间)：用来记录<strong>一些关键的时间节点</strong>在何时产生的数据信息，诸如 FP、FCP、LCP 等</li><li>Main(主线程)：是Performance工具中比较重要的部分，记录了渲染进程中主线程的执行记录，点击main可以看到某个任务执行的具体情况</li><li>Raster(光栅)：光栅化线程池，用来让 GPU 执行光栅化的任务</li><li>GPU：对GPU进程主线程的执行过程记录</li><li>Chrome_childIOThread: 子线程</li><li>Compositor(合成线程) 合成线程的执行记录，用来记录html绘制阶段 (Paint)结束后的图层合成操作<br>下面针对几个比较重要的指标进行介绍：</li></ol><h6 id="Timing"><a href="#Timing" class="headerlink" title="Timing"></a>Timing</h6><p><img src="/img/performance8.png" alt="Performance 面板介绍"></p><ul><li>DCL（DOMContentLoaded）表示 HTML 文档加载完成事件。当初始 HTML 文档完全加载并解析之后触发，无需等待样式、图片、子 frame 结束。作为明显的对比，load 事件是当个页面完全被加载时才触发。</li><li>FP（First Paint）首屏绘制，页面第一个像素渲染到屏幕上所用的时间。</li><li>FCP（First Contentful Paint）首屏内容绘制，首次绘制任何文本，图像，非空白canvas 或 SVG 的时间点。</li><li>L（Onload）页面所有资源加载完成事件。</li><li>LCP（Largest Contentful Paint ）最大内容绘制，页面上尺寸最大的元素绘制时间。</li></ul><h6 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h6><p>主线程活动。通过倒置的火焰图展示主线程上发生的活动，x 轴表示随时间的记录。y 轴代表调用堆栈。上层的事件调用（触发）了下层的事件（anonymous代表匿名函数），火焰图<strong>顶层宽度越大就表示该活动可能存在性能问题</strong>。<br><img src="/img/performance9.png" alt="Performance 面板介绍"></p><p>查看长任务<br>火焰图顶部（根部）由很多任务（Task）组成，使用灰色背景色区分。鼠标悬浮上去可以看到任务的总耗时。<br><img src="/img/performance10.png" alt="Performance 面板介绍"></p><p><strong>查看代码位置和执行时间</strong><br>通过某个Task下的代码块会对应显示该代码对应位置以及执行时间<br><img src="/img/performance11.png" alt="Performance 面板介绍"></p><h4 id="第三部分：数据统计与汇总"><a href="#第三部分：数据统计与汇总" class="headerlink" title="第三部分：数据统计与汇总"></a>第三部分：数据统计与汇总</h4><ul><li>背景</li><li>Performance 面板介绍<ul><li>第一部分：网页性能总览图<ul><li>FPS</li><li>CPU</li><li>NET</li><li>HEAP</li></ul></li><li>第二部分：各项指标的区块图<ul><li>Timing</li><li>Main<ul><li>查看长任务</li><li>查看代码位置和执行时间</li></ul></li></ul></li><li>第三部分：数据统计与汇总<ul><li> Summary</li><li>Bottom-Up</li><li> Call Tree</li><li> Event log</li></ul></li></ul></li><li>Performance面板实践<pre><code> * 网络资源和白屏 *  timings(时间线)和内存情况 *  火焰图</code></pre></li></ul><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p>在前端领域, <strong>性能优化</strong>都是一个非常重要的组成部分，如何通过合理的手段尽可能地提高页面性能，是需要我们不断地努力要做到的，但在那之前, 性能排查又是让你能够“对症下药”的重要手段, 通过性能排查, 咱们才能清楚的知道页面中具体是什么原因影响了性能，Chrome DevTools给我们提供了2种常用方式 Audits和Performance，Audits可以对页面进行性能评分，同时，还会给我们提供一些优化建议。而Performance则提供了非常多的运行时数据，能让我们看到更多细节数据。下面主要介绍一下如何利用DevTools中的Performance面板来进行性能分析, 并排查性能问题。</p><h4 id="Performance-面板介绍-1"><a href="#Performance-面板介绍-1" class="headerlink" title="Performance 面板介绍"></a>Performance 面板介绍</h4><p>首先在新的无痕窗口打开网页(使用无痕的目的是尽可能减少浏览器插件和缓存对页面的影响)，打开Chrome DevTools 切换到 Performance 下可以看到以下界面：</p><p>上图1、3区域按钮可以用来控制性能数据记录，黑色按钮可以记录交互阶段的性能数据，圆形箭头按钮用来记录加载阶段的性能数据。<br>上图2区域 可以设置当前页面的网络加载速度与CPU运算速度, 通过这2项可以去尽可能的模拟移动端设备的加载环境。<br>通过点击3区域内的按钮,会刷新页面并记录性能数据, 并得到以下性能报告。</p><p>整个页面性能数据分析报告从上至下可简单分为三个部分.</p><h4 id="第一部分：网页性能总览图-1"><a href="#第一部分：网页性能总览图-1" class="headerlink" title="第一部分：网页性能总览图"></a>第一部分：网页性能总览图</h4><p>详情展开<br>这里最主要是整体的界面渲染的时候，每个时间段执行的事件顺序，通过上图我们就能知道我们每个时间段（精确到毫秒）都做了什么，当鼠标放上去的时候，我们还可以大图的形式去查看我们每个时间段界面的渲染情况，Performance 就会将几个关键指标，诸如FPS（每秒帧数情况）、CPU（CPU占用情况）、NET（网络资源情况）、HEAP（JS堆内存占用情况） 等，按照时间顺序做成图表的形式展现出来。</p><h5 id="FPS-1"><a href="#FPS-1" class="headerlink" title="FPS"></a>FPS</h5><p>全称Frames Per Second，表示每秒传输帧数，是速度单位，用来分析动画的一个主要性能指标。 如下图所示，绿色竖线越高，FPS 越高。 红色表示长时间帧，可能出现卡顿。</p><blockquote><p>不同帧的体验：<br>帧率能够达到 50 ～ 60 FPS 的动画将会相当流畅，让人倍感舒适；<br>帧率在 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异；<br>帧率在 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感；<br>帧率波动很大的动画，亦会使人感觉到卡顿。</p></blockquote><h5 id="CPU-1"><a href="#CPU-1" class="headerlink" title="CPU"></a>CPU</h5><p>CPU 资源占用情况。此面积图指示消耗 CPU 资源的事件类型。<br>下图中颜色分别为（与数据统计中的颜色数据表示一致）：<br>蓝色(Loading)：表示网络通信和 HTML 解析时间。<br>黄色(Scripting)：表示 JavaScript 执行时间。<br>紫色(Rendering)：表示样式计算和布局（重排）时间。<br>绿色(Painting)：表示重绘时间。<br>灰色(other)：表示其它事件花费的时间。<br>白色(Idle)：表示空闲时间。</p><h5 id="NET-1"><a href="#NET-1" class="headerlink" title="NET"></a>NET</h5><p>Network 概览。深蓝色表示存在高优先级的资源请求的时间段，浅蓝色表示存在低优先级的资源请求的时间段。</p><h5 id="HEAP-1"><a href="#HEAP-1" class="headerlink" title="HEAP"></a>HEAP</h5><p>JavaScript代码执行时堆内存的占用情况</p><h4 id="第二部分：各项指标的区块图-1"><a href="#第二部分：各项指标的区块图-1" class="headerlink" title="第二部分：各项指标的区块图"></a>第二部分：各项指标的区块图</h4><p>详情展开</p><ol><li>Network(网络)：这里可以直观的看到页面的网络资源加载的顺序与时长。</li><li>Frames(帧)：表示每帧的运行情况。</li><li>Timings(时间)：用来记录一些关键的时间节点在何时产生的数据信息，诸如<br>FP、<br>FCP、<br>LCP 等</li><li>Main(主线程)：是<br>Performance工具中比较重要的部分，记录了渲染进程中主线程的执行记录，点击<br>main可以看到某个任务执行的具体情况</li><li>Raster(光栅)：光栅化线程池，用来让 GPU 执行光栅化的任务</li><li>GPU：对GPU进程主线程的执行过程记录</li><li>Chrome_childIOThread: 子线程</li><li>Compositor(合成线程) 合成线程的执行记录，用来记录<br>html绘制阶段 (Paint)结束后的图层合成操作,下面针对几个比较重要的指标进行介绍：</li></ol><h5 id="Timing-1"><a href="#Timing-1" class="headerlink" title="Timing"></a>Timing</h5><ul><li>DCL<br>（DOMContentLoaded）表示 HTML 文档加载完成事件。当初始 HTML 文档完全加载并解析之后触发，无需等待样式、图片、子 frame 结束。作为明显的对比，load 事件是当个页面完全被加载时才触发。</li><li>FP<br>（First Paint）首屏绘制，页面第一个像素渲染到屏幕上所用的时间。</li><li>FCP<br>（First Contentful Paint）首屏内容绘制，首次绘制任何文本，图像，非空白canvas 或 SVG 的时间点。</li><li>L<br>（Onload）页面所有资源加载完成事件。</li><li>LCP<br>（Largest Contentful Paint ）最大内容绘制，页面上尺寸最大的元素绘制时间。</li></ul><h5 id="Main-1"><a href="#Main-1" class="headerlink" title="Main"></a>Main</h5><p>主线程活动。通过倒置的火焰图展示主线程上发生的活动，x 轴表示随时间的记录。y 轴代表调用堆栈。上层的事件调用（触发）了下层的事件（anonymous代表匿名函数），<strong>火焰图顶层宽度越大就表示该活动可能存在性能问题。</strong></p><p>查看长任务<br>火焰图顶部（根部）由很多任务（Task）组成，使用灰色背景色区分。鼠标悬浮上去可以看到任务的总耗时。</p><p>查看代码位置和执行时间<br>通过某个Task下的代码块会对应显示该代码对应位置以及执行时间</p><h4 id="第三部分：数据统计与汇总-1"><a href="#第三部分：数据统计与汇总-1" class="headerlink" title="第三部分：数据统计与汇总"></a>第三部分：数据统计与汇总</h4><h5 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h5><p><img src="/img/performance12.png" alt="Performance 面板介绍"><br>表示各指标时间占用统计报表, 它是一个用来统计在我们检测性能的时间范围内，都做了哪些事情：</p><ul><li>Loading：网络请求与解析。</li><li>Scripting: JS 执行时间。</li><li>Rendering: 重排，主要包含样式计算、更新布局树、布局、分层等。</li><li>Painting：重绘。更新分层、光栅化分层、合成等。</li><li>System: 系统占用时间。</li><li>Idle: 空闲时间。</li><li>Total: 总计时间<br>分类中的详细事件可点击这里<h5 id="Bottom-Up"><a href="#Bottom-Up" class="headerlink" title="Bottom-Up"></a>Bottom-Up</h5>自下而上，通常用于查看选择的时间段中直接花费时间最多的活动。<br>使用 <strong>Bottom-Up</strong> 可以查看哪些活动在总体上占用了最多的时间。<strong>Bottom-Up</strong> 只显示选中部分的记录。<br><img src="/img/performance13.png" alt="Performance 面板介绍"></li></ul><p>在上图的火焰图中可以看出几乎所有的时间都花在三个对wait的调用上，所以 Bottom-Up 中，最顶部的是wait；wait调用下面的黄色部分其实是数以千计的 GC（垃圾回收） 调用，所以下一个开销最大的是Minor GC。<br>Self Time 表示直接花费在该事件上的时间，Total Time 表示花费在该事件及其所有后代（子孙）事件的总时间。</p><h5 id="Call-Tree"><a href="#Call-Tree" class="headerlink" title="Call Tree"></a>Call Tree</h5><p>调用树，通常用于查看选择的时间段中导致最多耗时的根活动。<br>下图中 Event 是一个根活动，嵌套结构表示表示调用栈，表示 Event 导致了 button.addEventListener，button.addEventListener 中执行了 b…<br><img src="/img/performance14.png" alt="Performance 面板介绍"></p><ul><li><p>Self Time：该活动直接花费的时间。</p></li><li><p>Total Time：该活动和其所有子活动花费的时间。</p><h5 id="Event-log"><a href="#Event-log" class="headerlink" title="Event log"></a>Event log</h5><p>事件日志，用于按照活动的发生顺序查看活动。<br><img src="/img/performance15.png" alt="Performance 面板介绍"></p></li><li><p>Start Time: 该活动的启动时间，它相对于录制的开始时间。</p></li><li><p>Self Time：直接在该活动上花费的时间。</p></li><li><p>Total Time：直接在该活动及其所有子活动上花费的时间。</p><h4 id="Performance面板实践"><a href="#Performance面板实践" class="headerlink" title="Performance面板实践"></a>Performance面板实践</h4><p>下面举例来说明一下<strong>Performance</strong>面板的使用，在无痕窗口下点击自动重启页面，并记录整个页面加载的过程，然后来分析结果～</p><h5 id="网络资源和白屏"><a href="#网络资源和白屏" class="headerlink" title="网络资源和白屏"></a>网络资源和白屏</h5><p>咱们首先从白屏时间和网络资源加载两方面来查看, 如下图：<br><img src="/img/performance16.png" alt="Performance 面板介绍"><br>那么从上图, 我们可以看到几点信息：<br>本次页面的白屏时间约为150ms, 并且从网络资源加载情况来看, 图片资源没有启用HTTP2协议, 同一时间请求的图片有限, 导致资源出现排队等待的情况。<br>此外, 从网络资源的加载时长咱们也能分析出几个问题：</p></li><li><p>白屏时间是否过长</p></li><li><p>单个资源文件过大导致加载时间过长, 可以采用压缩代码、拆包等方式优化</p></li><li><p>资源加载是否有空白期, 有的话说明没有充分利用资源加载的空闲时间</p></li><li><p>服务器性能较差, 导致各资源加载时间过长</p><h5 id="timings-时间线-和内存情况"><a href="#timings-时间线-和内存情况" class="headerlink" title="timings(时间线)和内存情况"></a>timings(时间线)和内存情况</h5><p>上述在讲timings的时候我们有提到几个关键指标: FCP、FP、L、LCP、DCL，那么通过这几个指标咱们也可以判断出页面加载性能的情况<br><img src="/img/performance17.png" alt="Performance 面板介绍"></p></li></ul><p>另外，我们可以看到页面中的内存使用的情况，比如 JS Heap(堆)，如果曲线一直在增长，则说明存在内存泄露。如果Nodes和Listeners不断增加说明可能存在重复添加节点或者事件的情况。<br>最下方就是页面的一个整体耗时概况，如果 Scripting 时间过长，则说明JS执行的逻辑太多，可以考虑优化JS，如果渲染时间过长，则考虑优化渲染过程，如果空闲时间过多，则可以考虑充分利用起来，比如把一些上报操作放到页面空闲时间再上报等。</p><h5 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h5><p>火焰图，主要在 Main 面板中，是我们分析具体函数耗时最常看的面板，我们来看一下，如图：<br><img src="/img/performance18.png" alt="Performance 面板介绍"></p><p>首先，面板中会有很多的 Task，如果是耗时长的 Task，其右上角会<strong>标红色三角形</strong>，这个时候，我们可以选中标红的 <strong>Task</strong>，然后放大，看其具体的耗时点。<br>放大后，这里可以看到都在做哪些操作，哪些函数耗时了多少。然后我们点击一下某个函数，在面板最下面，就会出现代码的信息，是哪个函数，耗时多少，在哪个文件上的第几行等。这样我们就很方便地定位到耗时函数了。<br><img src="/img/performance19.png" alt="Performance 面板介绍"></p><p>从图里的例子可以看出 <strong>prototypeClone</strong>函数占比较大, 可以查看下这个函数的作用是什么? 看是否有优化空间, 通过点击下方Summary里的代码位置, 可以得到这样的一张图<br><img src="/img/performance20.png" alt="Performance 面板介绍"></p><p>从图中可以看到这个函数的详细代码, 分析出这是一个<strong>深拷贝对象</strong>的工具函数, 那么就可以分析出这里耗时长的原因是由于需要深拷贝的对象体积过大, 导致深拷贝对象需要的时间较长, 知道原因后, 咱们可以找到调用这个函数的代码位置，改为使用浅拷贝或者移除深拷贝的方式去解决。</p><p>同时也可以查看 Main 指标分析代码里面是否存在强制同步布局等操作，分析出来这些原因之后，我们可以有针对性地去优化我们的程序。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本篇文章, 主要讲解Chrome DevTools Performance面板的一些常用的功能, 并简单地实践了一下如何利用该工具分析页面性能的优化点，总的来说, Chrome DevTools Performance面板功能是十分的强大的，通过这个工具, 方便咱们开发人员可以更快更容易的找到性能优化的点, “对症下药”, 达到性能优化的目的，同时Performance 不仅是性能分析工具，在分析的过程中, 也能加深咱们对浏览器工作原理的理解。</p><h5 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h5><p><a href="https://segmentfault.com/a/1190000023272526">Chrome Performance 页面性能分析指南</a></p><p><a href="https://segmentfault.com/a/1190000038442806">使用 Performance 看看浏览器在做什么</a></p><p><a href="https://segmentfault.com/a/1190000037699517">https://segmentfault.com/a/1190000037699517</a></p><p><a href="https://stackoverflow.com/questions/61922993/chrome-devtools-performance-tab-summary">Chrome DevTools - Performance Tab Summary</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>前端进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>querySelector和getElementsBy系列的区别</title>
    <link href="/2023/03/31/querySelector%E5%92%8CgetElementsBy%E7%B3%BB%E5%88%97%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/03/31/querySelector%E5%92%8CgetElementsBy%E7%B3%BB%E5%88%97%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="querySelector和getElementsBy系列的区别"><a href="#querySelector和getElementsBy系列的区别" class="headerlink" title="querySelector和getElementsBy系列的区别"></a>querySelector和getElementsBy系列的区别</h2><h3 id="querySelector系列和getElementsBy系列"><a href="#querySelector系列和getElementsBy系列" class="headerlink" title="querySelector系列和getElementsBy系列"></a>querySelector系列和getElementsBy系列</h3><p>之前在使用的时候，比较经常用getElementsById，这两个似乎可以混用，但是在有一些地方这两个的差别还是很大的，现在来整理一下。</p><p>querySelector 属于 <code>W3C</code> 中的 <code>Selectors API</code> 规范，接收的参数是一个css选择符。而 <code>getElementsBy</code> 系列则属于 <code>W3C</code> 的 DOM 规范 。</p><ul><li>querySelector返回的都是NodeList对象（即文档节点的集合）</li><li>getElementsBy系列返回的是HTMLCollection（HTML元素的集合）</li><li>注意这两者返回的都是一个集合，如果要使用其中的元素，都要通过索引值取出；</li></ul><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p><strong>getElement获取的是动态集合</strong>，<strong>而querySelector获取的是静态集合</strong>；说到底这两个特性有什么区别呢；其实就是动态选出的元素会随着文档的改变而改变，而静态的不会，我们以获取一个无序列表为例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Lisa<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Jennie<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Rose<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Jisoo<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接下来获取<code>dom</code>元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ul1 = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;ul&#x27;</span>);<br><span class="hljs-keyword">const</span> ul2 = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;ul&#x27;</span>)<br>ul1[<span class="hljs-number">0</span>].appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>));<br>ul2[<span class="hljs-number">0</span>].appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>));<br><span class="hljs-built_in">console</span>.log(li1.length);  <span class="hljs-comment">// 6</span><br><span class="hljs-built_in">console</span>.log(li2.length);  <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>上面这段代码，运行可以看到，不管是对ul1或者ul2进行添加节点都是可以成功被渲染到页面中的，但是，当我们打印出ul1和ul2会发现，通过getElement获取的元素集合发生了改变(length值增加了2)，而querySelector获取的元素的length值是不变的；</p><p>也就是说，<strong>如果要动态获取新创建的dom元素，就只能通过getElementsByClassName去实现</strong>；</p><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>这里通过对比两者获取元素的运行时间来判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.time(<span class="hljs-string">&#x27;querySelectorAll&#x27;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>    <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;li&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&#x27;querySelectorAll&#x27;</span>);<br><span class="hljs-built_in">console</span>.time(<span class="hljs-string">&#x27;getElementsByTagName&#x27;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>    <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;li&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&#x27;getElementsByTagName&#x27;</span>);<br></code></pre></td></tr></table></figure><p>输出结果如下：<br><img src="/img/%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="get和query.png"></p><p>可以看到，<strong>getElement方法的运行速度比querySelector快了好几倍</strong>；也就是说getElement的性能确实是比较好滴~</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><strong>getElement</strong>返回动态集合，是<strong>document</strong>的方法；性能较好，一般情况下优先使用；接收的参数只能是简单的<strong>className、tagName和name</strong>；</li><li><strong>querySelector</strong>返回静态集合，是<strong>element</strong>的方法，css Selector的API，接收的参数是一个CSS选择符；</li><li><strong>getElement比querySelector的性能好，一般对于选择器比较复杂(多层嵌套的)再考虑使用querySelector；</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cookie-JS 如何创建、读取和删除cookie</title>
    <link href="/2023/03/28/Cookie-JS%20%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E3%80%81%E8%AF%BB%E5%8F%96%E5%92%8C%E5%88%A0%E9%99%A4cookie/"/>
    <url>/2023/03/28/Cookie-JS%20%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E3%80%81%E8%AF%BB%E5%8F%96%E5%92%8C%E5%88%A0%E9%99%A4cookie/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="Cookie-JS-如何创建、读取和删除cookie"><a href="#Cookie-JS-如何创建、读取和删除cookie" class="headerlink" title="Cookie-JS 如何创建、读取和删除cookie"></a>Cookie-JS 如何创建、读取和删除cookie</h3><p>Cookie 为 Web 应用程序保存用户相关信息提供了一种有用的方法。例如，当用户访问咱们的站点时，可以利用 Cookie 保存用户首选项或其他信息，这样，当用户下次再访问咱们的站点时，应用程序就可以检索以前保存的信息。</p><h4 id="Cookie-是什么鬼"><a href="#Cookie-是什么鬼" class="headerlink" title="Cookie 是什么鬼"></a>Cookie 是什么鬼</h4><p><strong>Cookie</strong> 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递。用户每次访问站点时，Web 应用程序都可以读取 Cookie 包含的信息。</p><p>Cookie的出现是为了解决保存用户信息的问题。例如</p><ol><li>当用户访问网页时，用户的名字可以存储在cookie中。</li><li>下次用户访问页面时，cookie会记住用户名。<br>Cookie 能在所有网页中记住用户的信息。它<strong>以字符串的形式包含信息，并键值对的形式保存的，即key=value的格式</strong>。各个cookie之间一般是以“;”分隔。</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">username</span> = Daisy Green<br></code></pre></td></tr></table></figure><h4 id="Cookie-缺点"><a href="#Cookie-缺点" class="headerlink" title="Cookie 缺点"></a>Cookie 缺点</h4><ol><li>cookie<strong>可能被禁用</strong>。当用户非常注重个人隐私保护时，他很可能禁用浏览器的cookie功能；</li><li>cookie是与浏览器相关的。这意味着即使访问的是同一个页面，<strong>不同浏览器之间所保存的cookie也是不能互相访问的</strong>；</li><li>cookie<strong>可能被删除</strong>。因为每个cookie都是硬盘上的一个文件，因此很有可能被用户删除；</li><li>cookie<strong>安全性不够高</strong>。所有的cookie都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理。<h4 id="Cooke-工作方式"><a href="#Cooke-工作方式" class="headerlink" title="Cooke 工作方式"></a>Cooke 工作方式</h4>服务器以cookie的形式向访问者的浏览器发送一些数据。如果浏览器允许接受 cookie。 则将其作为纯文本记录存储在访问者的硬盘上。</li></ol><p>当访问者跳转到另一个页面时，浏览器会将相同的cookie发送到服务器进行检索。一旦检索到它，您的服务器就知道或记得以前存储了什么。</p><h4 id="Cookie-的组成"><a href="#Cookie-的组成" class="headerlink" title="Cookie 的组成"></a>Cookie 的组成</h4><p>Cookie 在HTTP的头部Header信息中，HTTP Set-Cookie的<strong>Header</strong>格式如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Set-Cookie: <span class="hljs-attribute">name</span>=value; [<span class="hljs-attribute">expires</span>=date]; [<span class="hljs-attribute">path</span>=path];<br>[<span class="hljs-attribute">domain</span>=domainname]; [secure];<br></code></pre></td></tr></table></figure><p>在HTTP代码中一个具体的例子：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">&lt;meta <span class="hljs-attr">http-equiv=&quot;set-cookie&quot;</span> <span class="hljs-attr">content=&quot;</span> <span class="hljs-attr">cookieName</span> = cookieValue;<br><span class="hljs-attr">expires=01-Dec-2006</span> <span class="hljs-number">01</span>:<span class="hljs-number">14</span>:<span class="hljs-number">26</span> GMT; <span class="hljs-attr">path=/&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>从上面的格式可以看出，Cookie由下面几部分组成。</p><h5 id="Name-Value对"><a href="#Name-Value对" class="headerlink" title="Name/Value对"></a>Name/Value对</h5><p>Name/Value由分号分隔，一个Cookie最多有20对，每个网页最多有一个Cookie，Value的长度不超过4K。对于Value值，最好用encodeURIComponent对其编码。</p><h4 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h4><p>Domain域名也是Cookie的一部分，默认情况下，用户访问网页的域名会存放在Cookie中。如果设置了这个Cookie的域名值，那么意味着域名上的所有服务器，而不仅是你正在访问的服务器，都能访问这个Cookie，通常不要这样做。设置域名的格式如下：domain=<a href="http://xyz.com/">http://xyz.com</a></p><h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><p>设置对于特定的服务器来说哪个目录中的网页可访问Cookie，设置path的格式是：path = /movies</p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>设置Cookie存活的时间，默认情况下，用户关闭浏览器则Cookie自动删除，如果没有设置Cookie失效的时间，那么用户关闭浏览器时Cookie也消失。如果设置该项，就能延长Cookie的生命期。设置时间在JS 中用Date对象的GMT形式，格式如下： expires = date.toGMTString()</p><h4 id="Secure"><a href="#Secure" class="headerlink" title="Secure"></a>Secure</h4><p>取true或者false值。如果为true，那么必须通过https发送Cookie。</p><h3 id="JS-Cookie"><a href="#JS-Cookie" class="headerlink" title="JS Cookie"></a>JS Cookie</h3><p>在JS中，可以使用<strong>Document对象的cookie属性操作cookie</strong>。 JS 可以读取，创建，修改和删除当前网页的cookie,，来看看具体的骚操作。</p><h5 id="创建-Cookie"><a href="#创建-Cookie" class="headerlink" title="创建 Cookie"></a>创建 Cookie</h5><p>JS可以使用<strong>document.cookie属性创建cookie</strong>，可以通过以下方式创建cookie：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">document.cookie</span> = <span class="hljs-string">&quot;username=Daisy Green&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>还可以添加有效日期（UTC 时间）。默认情况下，在浏览器关闭时会删除 cookie：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">document.cookie</span> = <span class="hljs-string">&quot;username=Daisy Green; expires=Mon, 26 Aug 2019 12:00:00 UTC&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>通过 path 参数，可以告诉浏览器 cookie 属于什么路径。默认情况下，cookie 属于当前页。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">document.cookie</span> = <span class="hljs-string">&quot;username=Daisy Green; expires=Mon, 26 Aug 2019 12:00:00 UTC&quot;</span><span class="hljs-comment">; path=/&quot;;</span><br></code></pre></td></tr></table></figure><p>读取 Cookie<br>通过 JS，可以这样读取 cookie：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> x = <span class="hljs-built_in">document</span>.cookie;<br></code></pre></td></tr></table></figure><p>document.cookie 会在一条字符串中返回所有 cookie，比如：cookie1=value; cookie2</p><p>事例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>   <br>      <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br>         &lt;!--<br><span class="javascript">            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ReadCookie</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">               <span class="hljs-keyword">var</span> allcookies = <span class="hljs-built_in">document</span>.cookie;</span><br><span class="javascript">               <span class="hljs-built_in">document</span>.write (<span class="hljs-string">&quot;All Cookies : &quot;</span> + allcookies );</span><br>                <br><span class="javascript">               <span class="hljs-comment">// Get all the cookies pairs in an array</span></span><br><span class="javascript">               cookiearray = allcookies.split(<span class="hljs-string">&#x27;;&#x27;</span>);</span><br>                <br><span class="javascript">               <span class="hljs-comment">// Now take key value pair out of this array</span></span><br><span class="javascript">               <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;cookiearray.length; i++) &#123;</span><br><span class="javascript">                  name = cookiearray[i].split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">0</span>];</span><br><span class="javascript">                  value = cookiearray[i].split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">1</span>];</span><br><span class="javascript">                  <span class="hljs-built_in">document</span>.write (<span class="hljs-string">&quot;Key is : &quot;</span> + name + <span class="hljs-string">&quot; and Value is : &quot;</span> + value);</span><br>               &#125;<br>            &#125;<br><span class="javascript">         <span class="hljs-comment">//--&gt;</span></span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>      <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <br>   <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>     <br>      <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;myform&quot;</span> <span class="hljs-attr">action</span> = <span class="hljs-string">&quot;&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> click the Button to View Result:<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;Get Cookie&quot;</span> <span class="hljs-attr">onclick</span> = <span class="hljs-string">&quot;ReadCookie()&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>      <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>运行：</p><h5 id="改变-cookie"><a href="#改变-cookie" class="headerlink" title="改变 cookie"></a>改变 cookie</h5><p>通过使用 JS，咱们可以像创建 cookie 一样改变它：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">document.cookie</span> = <span class="hljs-string">&quot;username=Steve Jobs; expires=Sun, 31 Dec 2017 12:00:00 UTC; path=/&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这样旧 cookie 会被覆盖。</p><p>事例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>   <br>      <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br>         &lt;!--<br><span class="javascript">            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WriteCookie</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">               <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</span><br>               now.setMonth( now.getMonth() + 1 );<br><span class="javascript">               cookievalue = <span class="hljs-built_in">escape</span>(<span class="hljs-built_in">document</span>.myform.customer.value) + <span class="hljs-string">&quot;;&quot;</span></span><br>                <br><span class="javascript">               <span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&quot;name=&quot;</span> + cookievalue;</span><br><span class="javascript">               <span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&quot;expires=&quot;</span> + now.toUTCString() + <span class="hljs-string">&quot;;&quot;</span></span><br><span class="javascript">               <span class="hljs-built_in">document</span>.write (<span class="hljs-string">&quot;Setting Cookies : &quot;</span> + <span class="hljs-string">&quot;name=&quot;</span> + cookievalue );</span><br>            &#125;<br><span class="javascript">         <span class="hljs-comment">//--&gt;</span></span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>      <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <br>   <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;myform&quot;</span> <span class="hljs-attr">action</span> = <span class="hljs-string">&quot;&quot;</span>&gt;</span><br>         Enter name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;customer&quot;</span>/&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;Set Cookie&quot;</span> <span class="hljs-attr">onclick</span> = <span class="hljs-string">&quot;WriteCookie()&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>      <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>运行：</p><h5 id="删除-cookie"><a href="#删除-cookie" class="headerlink" title="删除 cookie"></a>删除 cookie</h5><p>删除 cookie 非常简单，不必指定 cookie 值：直接把 <strong>expires 参数设置为过去的日期</strong>即可：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">document.cookie</span> = <span class="hljs-string">&quot;username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>应该定义 cookie 路径以确保删除正确的 cookie。如果不指定路径，有些浏览器不会让咱们删除 cookie。</p><p>事例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>   <br>      <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br>         &lt;!--<br><span class="javascript">            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WriteCookie</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">               <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</span><br>               now.setMonth( now.getMonth() - 1 );<br><span class="javascript">               cookievalue = <span class="hljs-built_in">escape</span>(<span class="hljs-built_in">document</span>.myform.customer.value) + <span class="hljs-string">&quot;;&quot;</span></span><br>                <br><span class="javascript">               <span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&quot;name=&quot;</span> + cookievalue;</span><br><span class="javascript">               <span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&quot;expires=&quot;</span> + now.toUTCString() + <span class="hljs-string">&quot;;&quot;</span></span><br><span class="javascript">               <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;Setting Cookies : &quot;</span> + <span class="hljs-string">&quot;name=&quot;</span> + cookievalue );</span><br>            &#125;<br><span class="javascript">          <span class="hljs-comment">//--&gt;</span></span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>      <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <br>   <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;myform&quot;</span> <span class="hljs-attr">action</span> = <span class="hljs-string">&quot;&quot;</span>&gt;</span><br>         Enter name: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;customer&quot;</span>/&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span> = <span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span> = <span class="hljs-string">&quot;Set Cookie&quot;</span> <span class="hljs-attr">onclick</span> = <span class="hljs-string">&quot;WriteCookie()&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>      <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6844903933320790024">JS 如何创建、读取和删除cookie</a></p>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拆解追溯 GPT-3.5 各项能力的起源</title>
    <link href="/2023/03/26/%E6%8B%86%E8%A7%A3%E8%BF%BD%E6%BA%AF%20GPT-3.5%20%E5%90%84%E9%A1%B9%E8%83%BD%E5%8A%9B%E7%9A%84%E8%B5%B7%E6%BA%90/"/>
    <url>/2023/03/26/%E6%8B%86%E8%A7%A3%E8%BF%BD%E6%BA%AF%20GPT-3.5%20%E5%90%84%E9%A1%B9%E8%83%BD%E5%8A%9B%E7%9A%84%E8%B5%B7%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="拆解追溯-GPT-3-5-各项能力的起源"><a href="#拆解追溯-GPT-3-5-各项能力的起源" class="headerlink" title="拆解追溯 GPT-3.5 各项能力的起源"></a>拆解追溯 GPT-3.5 各项能力的起源</h3><h4 id="一、2020-版初代-GPT-3-与大规模预训练"><a href="#一、2020-版初代-GPT-3-与大规模预训练" class="headerlink" title="# 一、2020 版初代 GPT-3 与大规模预训练"></a># 一、2020 版初代 GPT-3 与大规模预训练</h4><p>初代GPT-3展示了三个重要能力：</p><ul><li><strong>语言生成</strong>：遵循提示词（prompt），然后生成补全提示词的句子 (completion)。这也是今天人类与语言模型最普遍的交互方式。</li><li><strong>上下文学习 (in-context learning)</strong>:  遵循给定任务的几个示例，然后为新的测试用例生成解决方案。很重要的一点是，GPT-3虽然是个语言模型，但它的论文几乎没有谈到“语言建模” (language modeling) —— 作者将他们全部的写作精力都投入到了对上下文学习的愿景上，这才是 GPT-3的真正重点。</li><li>**世界知识 (world knowledge)**：包括事实性知识 (factual knowledge) 和常识 (commonsense)。</li></ul><p>那么这些能力从何而来呢？</p><p>基本上，以上三种能力都来自于大规模预训练：在有3000亿单词的语料上预训练拥有1750亿参数的模型（ 训练语料的60%来自于 2016 - 2019 的 C4 + 22% 来自于 WebText2 + 16% 来自于Books + 3%来自于Wikipedia）。其中：</p><ul><li><strong>语言生成</strong>的能力来自于语言建模的<strong>训练目标</strong> (language modeling)。</li><li><strong>世界知识</strong>来自 3000 亿单词的<strong>训练语料库</strong>（不然还能是哪儿呢）。</li><li><strong>模型的 1750 亿参数</strong>是为了<strong>存储知识</strong>，Liang et al. (2022) 的文章进一步证明了这一点。 他们的结论是，知识密集型任务的性能与模型大小息息相关。</li><li>上下文学习的能力来源及为什么上下文学习可以泛化，<strong>仍然难以溯源。</strong>直觉上，这种能力可能来自于同一个任务的数据点在训练时按顺序排列在同一个 batch 中。然而，很少有人研究为什么语言模型预训练会促使上下文学习，以及为什么上下文学习的行为与微调 (fine-tuning) 如此不同。</li></ul><p>令人好奇的是，初代<strong>的GPT-3有多强。</strong><br>其实比较难确定初代 GPT-3（在 OpenAI API 中被称为<code>davinci</code>）到底是“强”还是“弱”。一方面，它合理地回应了某些特定的查询，并在许多数据集中达到了还不错的性能；另一方面，它在许多任务上的<strong>表现还不如 T5 这样的小模型</strong>（参见其原始论文）。在今天（2022 年 12 月）ChatGPT 的标准下，很难说初代的 GPT-3 是“智能的”。Meta 开源的 OPT 模型试图复现初代 GPT-3，但它的能力与当今的标准也形成了尖锐的对比。许多测试过 OPT 的人也认为与现在的<code>text-davinci-002</code>相比，该模型确实 “不咋地”。尽管如此，OPT 可能是初代 GPT-3 的一个足够好的开源的近似模型了（根据 OPT 论文和斯坦福大学的 HELM 评估）。</p><p>虽然初代的 GPT-3 可能表面上看起来很弱，但后来的实验证明，初代 GPT-3 有着非常强的潜力。这些潜力后来被代码训练、指令微调 (instruction tuning) 和基于人类反馈的强化学习 (reinforcement learning with human feedback, RLHF) 解锁，最终体展示出极为强大的突现能力。</p><h4 id="二、从-2020-版-GPT-3-到-2022-版-ChatGPT"><a href="#二、从-2020-版-GPT-3-到-2022-版-ChatGPT" class="headerlink" title="# 二、从 2020 版 GPT-3 到 2022 版 ChatGPT"></a># 二、从 2020 版 GPT-3 到 2022 版 ChatGPT</h4><p>从最初的 GPT-3 开始，为了展示 OpenAI 是如何发展到ChatGPT的，我们看一下 GPT-3.5 的进化树：</p><p><img src="/img/chatGPT.png" alt="chatGPT"></p><p>在 <strong>2020 年 7 月</strong>，OpenAI 发布了模型索引为的 <code>davinci</code> 的初代 GPT-3 论文，从此它就开始不断进化。在 <strong>2021 年 7 月</strong>，Codex 的论文发布，其中初始的 Codex 是根据（可能是内部的）120 亿参数的 GPT-3 变体进行微调的。后来这个 120 亿参数的模型演变成 OpenAI API 中的<code>code-cushman-001</code>。在 <strong>2022 年 3 月</strong>，OpenAI 发布了指令微调 (instruction tuning) 的论文，其监督微调 (supervised instruction tuning) 的部分对应了<code>davinci-instruct-beta</code>和<code>text-davinci-001</code>。在 <strong>2022 年 4 月至 7 月的</strong>，OpenAI 开始对<code>code-davinci-002</code>模型进行 Beta 测试，也称其为 Codex。然后<code>code-davinci-002</code>、<code>text-davinci-003</code>和<code>ChatGPT</code> 都是从<code>code-davinci-002</code>进行指令微调得到的。详细信息请参阅 OpenAI的模型索引文档。</p><p>尽管 Codex 听着像是一个只管代码的模型，但<code>code-davinci-002</code>可能是最强大的针对<strong>自然语言</strong>的GPT-3.5 变体（优于 <code>text-davinci-002</code>和 <code>-003</code>）。<code>code-davinci-002</code>很可能在文本和代码上都经过训练，然后根据指令进行调整（将在下面解释）。然后<strong>2022 年 5-6 月</strong>发布的<code>text-davinci-002</code>是一个基于<code>code-davinci-002</code>的有监督指令微调 (supervised instruction tuned) 模型。在<code>text-davinci-002</code>上面进行<strong>指令微调</strong>很可能<strong>降低</strong>了模型的<strong>上下文学习</strong>能力<strong>，</strong>但是<strong>增强了</strong>模型的<strong>零样本能力</strong>（将在下面解释）。然后是<code>text-davinci-003</code>和 <code>ChatGPT</code>，它们都在 <strong>2022 年 11 月</strong>发布，是使用的基于人类反馈的强化学习的版本指令微调 (instruction tuning with reinforcement learning from human feedback) 模型的两种不同变体。<code>text-davinci-003</code> 恢复了（但仍然比<code>code-davinci-002</code>差）一些在<code>text-davinci-002</code> 中丢失的部分<strong>上下文学习能</strong>力（大概是因为它在微调的时候混入了语言建模） 并进一步改进了零样本能力（得益于RLHF）。另一方面，ChatGPT 似乎<strong>牺牲了几乎所有的上下文学习的能力</strong>来<strong>换取</strong>建模对话历史的能力。</p><p>总的来说，在 2020 - 2021 年期间，在<code>code-davinci-002</code>之前，OpenAI 已经投入了大量的精力通过代码训练和指令微调来增强GPT-3。当他们完成<code>code-davinci-002</code>时，所有的能力都已经存在了。很可能后续的指令微调，无论是通过有监督的版本还是强化学习的版本，都会做以下事情（稍后会详细说明）：</p><ul><li>指令微调<strong>不会为模型注入新的能力</strong> —— 所有的能力都已经存在了。指令微调的作用是<strong>解锁 / 激发这些能力</strong>。这主要是因为指令微调的数据量比预训练数据量少几个数量级（基础的能力是通过预训练注入的）。</li><li>指令微调<strong>将 GPT-3.5 的分化到不同的技能树。</strong>有些更擅长上下文学习，如<code>text-davinci-003</code>，有些更擅长对话，如<code>ChatGPT</code>。</li><li>指令微调<strong>通过牺牲性能换取与人类的对齐（alignment）</strong>。 OpenAI 的作者在他们的指令微调论文中称其为 “对齐税” (alignment tax)。许多论文都报道了<code>code-davinci-002</code>在基准测试中实现了最佳性能（但模型不一定符合人类期望）。 在<code>code-davinci-002</code>上进行指令微调后，模型可以生成更加符合人类期待的反馈（或者说模型与人类对齐），例如：零样本问答、生成安全和公正的对话回复、拒绝超出模型它知识范围的问题。</li></ul><h4 id="三、Code-Davinci-002和-Text-Davinci-002，在代码上训练，在指令上微调"><a href="#三、Code-Davinci-002和-Text-Davinci-002，在代码上训练，在指令上微调" class="headerlink" title="# 三、Code-Davinci-002和 Text-Davinci-002，在代码上训练，在指令上微调"></a># 三、Code-Davinci-002和 Text-Davinci-002，在代码上训练，在指令上微调</h4><p>在<code>code-davinci-002</code>和<code>text-davinci-002</code>之前，有两个中间模型，分别是 davinci-instruct-beta 和 text-davinci-001。两者在很多方面都比上述的两个-002模型差（例如，text-davinci-001 链式思维推理能力不强）。所以我们在本节中重点介绍 -002 型号。</p><h5 id="3-1-复杂推理能力的来源和泛化到新任务的能力"><a href="#3-1-复杂推理能力的来源和泛化到新任务的能力" class="headerlink" title="3.1 复杂推理能力的来源和泛化到新任务的能力"></a><strong>3.1 复杂推理能力的来源和泛化到新任务的能力</strong></h5><p>我们关注<code>code-davinci-002</code>和<code>text-davinci-002</code>，这两兄弟是第一版的 GPT3.5 模型，一个用于代码，另一个用于文本。它们表现出了四种与初代 GPT-3 不同的重要能力：</p><ul><li><strong>响应人类指令</strong>：以前，GPT-3 的输出主要训练集中常见的句子。现在的模型会针对指令 / 提示词生成更合理的答案（而不是相关但无用的句子）。</li><li><strong>泛化到没有见过的任务</strong>：当用于调整模型的指令数量超过一定的规模时，模型就可以自动在从没见过的新指令上也能生成有效的回答。 <strong>这种能力对于上线部署至关重要</strong>，因为用户总会提新的问题，模型得答得出来才行。</li><li><strong>代码生成和代码理解</strong>：这个能力很显然，因为模型用代码训练过。</li><li><strong>利用思维链 (chain-of-thought) 进行复杂推理</strong>：初代 GPT3 的模型思维链推理的能力很弱甚至没有。 <strong>code-davinci-002 和 text-davinci-002 是两个拥有足够强的思维链推理能力的模型。</strong><ul><li>思维链推理之所以重要，是因为思维链可能是解锁突现能力和超越缩放法则 (scaling laws) 的关键。请参阅上一篇博文。</li></ul></li></ul><p>这些能力从何而来？</p><p>与之前的模型相比，两个主要区别是<strong>指令微调</strong>和<strong>代码训练</strong>。具体来说</p><ul><li>能够<strong>响应人类指令</strong>的能力是<strong>指令微调</strong>的直接产物。</li><li><strong>对没有见过的指令做出反馈</strong>的泛化能力是在指令数量超过一定程度之后<strong>自动出现的</strong>，T0、Flan 和 FlanPaLM 论文进一步证明了这一点</li><li>使用<strong>思维链</strong>进行<strong>复杂推理</strong>的能力很可能是<strong>代码训练</strong>的<strong>一个神奇的副产物</strong>。对此，我们有以下的事实作为一些支持：<ul><li>最初的 GPT-3 没有接受过代码训练，它不能做<strong>思维链</strong>。</li><li>text-davinci-001 模型，虽然经过了指令微调，但第一版思维链论文报告说，它的它思维链推理的能力非常弱 —— <strong>所以指令微调可能不是思维链存在的原因，代码训练才是模型能做思维链推理的最可能原因。</strong></li><li>PaLM 有 5% 的代码训练数据，可以做思维链。</li><li>Codex论文中的代码数据量为 159G ，大约是初代 GPT-3 5700 亿训练数据的28%。code-davinci-002 及其后续变体可以做思维链推理。</li><li>在 HELM 测试中，Liang et al. (2022) 对不同模型进行了大规模评估。 他们发现了针对代码训练的模型具有很强的语言推理能力，包括 120亿参数的code-cushman-001.。</li><li>我们在 AI2 的工作也表明，当配备复杂的思维链时，code-davinci-002 在 GSM8K 等重要数学基准上是目前表现最好的模型</li><li>直觉来说，<strong>面向过程的编程 (procedure-oriented programming)</strong> 跟人类<strong>逐步解决任务</strong>的过程很类似，<strong>面向对象编程 (object-oriented programming)</strong> 跟人类<strong>将复杂任务分解为多个简单任务</strong>的过程很类似。</li><li>以上所有观察结果都是代码与推理能力 / 思维链 之间的相关性，但不一定是因果性。这种相关性很有趣，但现在还是一个待研究的开放性问题。目前看来，我们<strong>没有非常确凿的证据证明代码就是思维链和复杂推理的原因</strong>。</li></ul></li><li>此外， <strong>代码训练</strong>另一个可能的副产品是<strong>长距离依赖，</strong>正如Peter Liu所指出：“语言中的下个词语预测通常是非常局部的，而代码通常需要更长的依赖关系来做一些事情，比如前后括号的匹配或引用远处的函数定义”。这里我想进一步补充的是：由于面向对象编程中的类继承，代码也可能有助于模型建立编码层次结构的能力。我们将对这一假设的检验留给未来的工作。</li></ul><p>另外还要注意一些细节差异：</p><ul><li><strong>text-davinci-002 与 code-davinci-002</strong><ul><li>Code-davinci-002 是基础模型，text-davinci-002 是指令微调 code-davinci-002 的产物（见 OpenAI 的文档）。它在以下数据上作了微调：（一）人工标注的指令和期待的输出；（二）由人工标注者选择的模型输出。</li><li>当有上下文示例 (in-context example) 的时候， Code-davinci-002 更擅长上下文学习；当没有上下文示例 / 零样本的时候， text-davinci-002 在零样本任务完成方面表现更好。从这个意义上说，text-davinci-002 更符合人类的期待（因为对一个任务写上下文示例可能会比较麻烦）。</li><li>OpenAI 不太可能故意牺牲了上下文学习的能力换取零样本能力 —— 上下文学习能力的降低更多是指令学习的一个副作用，OpenAI 管这叫对齐税。</li></ul></li><li><strong>001 模型（code-cushman-001 和 text-davinci-001）v.s. 002 模型（code-davinci-002 和 text-davinci-002）</strong><ul><li>001 模型主要是为了做纯代码 / 纯文本任务； 002 模型则深度融合了代码训练和指令微调，代码和文本都行。</li><li>Code-davinci-002 可能是第一个深度融合了代码训练和指令微调的模型。证据有：code-cushman-001 可以进行推理但在纯文本上表现不佳，text-davinci-001 在纯文本上表现不错但在推理上不大行。 code-davinci-002 则可以同时做到这两点。</li></ul></li></ul><h5 id="3-2-这些能力是在预训练之后已经存在还是在之后通过微调注入？"><a href="#3-2-这些能力是在预训练之后已经存在还是在之后通过微调注入？" class="headerlink" title="3.2 这些能力是在预训练之后已经存在还是在之后通过微调注入？"></a>3.2 <strong>这些能力是在预训练之后已经存在还是在之后通过微调注入？</strong></h5><p>在这个阶段，我们已经确定了指令微调和代码训练的关键作用。一个重要的问题是如何进一步分析代码训练和指令微调的影响？具体来说：<br>上述三种能力是否<strong>已经存在于初代的GPT-3</strong>中，只是<strong>通过指令和代码训练触发 / 解锁</strong>？ 或者这些能力在初代的 GPT-3 中<strong>并不存在</strong>，是通过指令和代码训练<strong>注入？</strong><br>如果答案已经在初代的 GPT-3 中，<strong>那么这些能力也应该在 OPT 中。 因此，要复现这些能力，或许可以直接通过指令和代码调整 OPT。</strong> 但是，code-davinci-002 也可能不是基于最初的 GPT-3 davinci，而是基于比初代 GPT-3 更大的模型。如果是这种情况，可能就没办法通过调整 OPT 来复现了。研究社区需要进一步弄清楚 OpenAI 训练了什么样的模型作为 code-davinci-002 的基础模型。</p><p>我们有以下的假设和证据：</p><ul><li>code-davinci-002的<strong>基础模型可能不是初代GPT-3 davinci 模型</strong>。以下是证据：<ul><li>初代的GPT-3在数据集 C4 2016 - 2019 上训练，而 code-davinci-002 训练集则在延长到2021年才结束。因此 code-davinci-002 有可能在 C4 的 2019-2021 版本上训练。</li><li>初代的 GPT-3 有一个大小为 <strong>2048</strong> 个词的上下文窗口。code-davinci-002 的上下文窗口则为 <strong>8192</strong>。GPT 系列使用绝对位置嵌入 (absolute positional embedding)，直接对绝对位置嵌入进行外推而不经过训练是比较难的，并且会严重损害模型的性能（参考 Press et al., 2022）。如果 code-davinci-002 是基于初代GPT-3，那OpenAI 是如何扩展上下文窗口的？</li></ul></li><li>另一方面，无论基础模型是初代的 GPT-3 还是后来训练的模型， <strong>遵循指令和零样本泛化的能力都可能已经存在于基础模型</strong>中，后来才通过指令微调来<strong>解锁</strong> （<strong>而不是注入）</strong><ul><li>这主要是因为 OpenAI 的论文报告的指令数据量大小只有 77K，比预训练数据少了几个数量级。</li><li>其他指令微调论文进一步证明了数据集大小对模型性能的对比，例如 Chung et al. (2022) 的工作中， Flan-PaLM 的指令微调仅为预训练计算的 0.4%。一般来说，指令数据会显著少于预训练数据。</li></ul></li><li>然而 <strong>，模型的复杂推理能力可能是在预训练阶段通过代码数据注入</strong><ul><li>代码数据集的规模与上述指令微调的情况不同。这里的代码数据量足够大，可以占据训练数据的重要部分（例如，PaLM 有 8% 的代码训练数据）</li><li>如上所述，在 code-davinci-002 之前的模型 text-davinci-001 大概没有在代码数据上面微调过，所以它的推理 / 思维链能力是非常差的，正如第一版思维链论文中所报告的那样，有时甚至比参数量更小的 code-cushman-001 还差。</li></ul></li><li><strong>区分代码训练和指令微调效果的最好方法</strong>可能是<strong>比较 code-cushman-001、T5 和 FlanT5</strong><ul><li>因为它们具有相似的模型大小（110亿 和 120亿），相似的训练数据集 (C4)，它们最大的区别就是有没有在代码上训练过 / 有没有做过指令微调。</li><li>目前还没有这样的比较。我们把这个留给未来的研究。</li></ul></li></ul><h4 id="四、text-davinci-003-和-ChatGPT，基于人类反馈的强化学习-Reinforcement-Learning-from-Human-Feedback-RLHF-的威力"><a href="#四、text-davinci-003-和-ChatGPT，基于人类反馈的强化学习-Reinforcement-Learning-from-Human-Feedback-RLHF-的威力" class="headerlink" title="四、text-davinci-003 和 ChatGPT，基于人类反馈的强化学习(Reinforcement Learning from Human Feedback, RLHF) 的威力"></a>四、text-davinci-003 和 ChatGPT，基于人类反馈的强化学习(Reinforcement Learning from Human Feedback, RLHF) 的威力</h4><p>在当前阶段（2022 年 12 月）， text-davinci-002、text-davinci-003 和 ChatGPT之间<strong>几乎没有严格的统计上的比较</strong> ，主要是因为</p><ul><li>text-davinci-003 和 ChatGPT 在撰写本文时才发布不到一个月。</li><li>ChatGPT 不能通过 OpenAI API 被调用，所以想要在标准基准上测试它很麻烦。</li></ul><p>所以在这些模型之间的比较更多是<strong>基于研究社区的集体经验</strong> （统计上不是很严格）。不过，我们相信初步的描述性比较仍然可以揭示模型的机制。</p><p>我们首先注意到以下 text-davinci-002，text-davinci-003 和 ChatGPT 之间的比较：</p><ul><li>所有三个模型都经过<strong>指令微调</strong>。</li><li><strong>text-davinci-002</strong> 是一个经过<strong>监督学习指令微调</strong> (supervised instruction tuning) ****的模型</li><li><strong>text-davinci-003 和 ChatGPT</strong> 是<strong>基于人类反馈的强化学习的指令微调</strong> (Instruction tuning with Reinforcement Learning from Human Feedback, RLHF)。这是它们之间最显着的区别。</li></ul><p><strong>这意味着大多数新模型的行为都是 RLHF 的产物</strong>。</p><p>那么让我们看看 RLHF 触发的能力：</p><ul><li><strong>翔实的回应：</strong> text-davinci-003 的生成通常比 text-davinci-002长。 ChatGPT 的回应则更加冗长，以至于用户必须明确要求“用一句话回答我”，才能得到更加简洁的回答。这是 RLHF 的直接产物。</li><li><strong>公正的回应：</strong>ChatGPT 通常对涉及多个实体利益的事件（例如政治事件）给出非常平衡的回答。这也是RLHF的产物。</li><li><strong>拒绝不当问题：</strong>这是内容过滤器和由 RLHF 触发的模型自身能力的结合，过滤器过滤掉一部分，然后模型再拒绝一部分。</li><li><strong>拒绝其知识范围之外的问题：</strong>例如，拒绝在2021 年 6 月之后发生的新事件（因为它没在这之后的数据上训练过）。这是 RLHF 最神奇的部分，因为它使模型能够隐式地区分哪些问题在其知识范围内，哪些问题不在其知识范围内。</li></ul><p>有两件事情值得注意：</p><ul><li>所有的能力都是模型本来就有的， <strong>而不是通过RLHF 注入的</strong>。 RLHF 的作用是<strong>触发 / 解锁突现能力</strong>。这个论点主要来自于数据量大小的比较：因为与预训练的数据量相比，RLHF 占用的计算量 / 数据量要少得多。</li><li>模型<strong>知道它不知道什么不是通过编写规则来实现的，</strong> 而是通过RLHF解锁的。这是一个非常令人惊讶的发现，因为 RLHF 的最初目标是让模型生成符合人类期望的回答，这更多是让模型生成安全的句子，而不是让模型知道它不知道的内容。</li></ul><p>幕后发生的事情可能是：</p><ul><li>ChatGPT: 通过<strong>牺牲上下文学习</strong>的能力<strong>换取建模对话历史</strong>的能力。这是一个基于经验的观测结果，因为 ChatGPT 似乎不像 text-davinci-003 那样受到上下文演示的强烈影响。</li><li>text-davinci-003：<strong>恢复了</strong> text-davinci-002 所牺牲的<strong>上下文学习能力</strong>， <strong>提高零样本的能力</strong>。 <del>我们不确定这是否也是 RLHF 或其他东西的副产品。</del> 根据instructGPT的论文，这是来自于强化学习调整阶段混入了语言建模的目标（而不是 RLHF 本身）。</li></ul><h4 id="五、总结当前阶段-GPT-3-5-的进化历程"><a href="#五、总结当前阶段-GPT-3-5-的进化历程" class="headerlink" title="# 五、总结当前阶段 GPT-3.5 的进化历程"></a># 五、总结<strong>当前阶段 GPT-3.5 的进化历程</strong></h4><p>到目前为止，我们已经仔细检查了沿着进化树出现的所有能力，下表总结了演化路径：<br><img src="/img/chatGPT1.png" alt="chatGPT1"></p><p>我们可以得出结论：</p><ul><li>语言生成能力 + 基础世界知识 + 上下文学习都是来自于预训练（<code>davinci</code>）</li><li>存储大量知识的能力来自 1750 亿的参数量。</li><li>遵循指令和泛化到新任务的能力来自于扩大指令学习中指令的数量（<code>Davinci-instruct-beta</code>)</li><li>执行复杂推理的能力很可能来自于代码训练（<code>code-davinci-002</code>）</li><li>生成中立、客观的能力、安全和翔实的答案来自与人类的对齐。具体来说：<ul><li>如果是监督学习版，得到的模型是<code>text-davinci-002</code></li><li>如果是强化学习版 (RLHF) ，得到的模型是<code>text-davinci-003</code></li><li>无论是有监督还是 RLHF ，模型在很多任务的性能都无法超过 code-davinci-002 ，这种因为对齐而造成性能衰退的现象叫做对齐税。</li></ul></li><li>对话能力也来自于 RLHF（<code>ChatGPT</code>），具体来说它牺牲了上下文学习的能力，来换取：<ul><li>建模对话历史</li><li>增加对话信息量</li><li>拒绝模型知识范围之外的问题</li></ul></li></ul><h4 id="六、GPT-3-5-目前不能做什么"><a href="#六、GPT-3-5-目前不能做什么" class="headerlink" title="# 六、GPT-3.5 目前不能做什么"></a># 六、<strong><strong>GPT-3.5 目前不能做什么</strong></strong></h4><p>虽然GPT-3.5是自然语言处理研究中的重要一步，但它并没有完全包含许多研究人员（包括 AI2）设想的所有理想属性。以下是GPT-3.5不具备的某些重要属性：</p><ul><li><strong>实时改写模型的信念</strong>：当模型表达对某事的信念时，如果该信念是错误的，我们可能很难纠正它：<ul><li>我最近遇到的一个例子是：ChatGPT 坚持认为 3599 是一个质数，尽管它承认 3599 = 59 * 61。另外，请参阅Reddit上关于游得最快的海洋哺乳动物的例子。</li><li>然而，模型信念的强度似乎存在不同的层次。一个例子是即使我告诉它达斯·维达（星球大战电影中的人物）赢得了2020年大选，模型依旧会认为美国现任总统是拜登。但是如果我将选举年份改为 2024 年，它就会认为总统是达斯·维达是 2026 年的总统。</li></ul></li><li><strong>形式推理</strong>：GPT-3.5系列不能在数学或一阶逻辑等形式严格的系统中进行推理：<ul><li>在自然语言处理的文献中， “推理” 一词的定义很多时候不太明确。但如果我们从模糊性的角度来看，例如一些问题 (a) 非常模棱两可，没有推理；(b) 有点儿逻辑在里面，但有些地方也可以模糊；(c) 非常严谨，不能有任何歧义。那么，</li><li>模型可以很好地进行 (b) 类的带模糊性的推理，例子有：<ul><li>生成如何做豆腐脑的方法。做豆腐脑的时候，中间很多步骤模糊一点是可以接受的，比如到底是做咸的还是做甜的。只要整体步骤大致正确，做出来的豆腐脑儿就能吃。</li><li>数学定理的证明思路。证明思路是用语言表达的非正式的逐步解法，其中每一步的严格推导可以不用太具体。证明思路经常被用到数学教学：只要老师给一个大致正确的整体步骤，学生就可以大概明白。然后老师把具体的证明细节作为作业布置给学生，答案略。</li></ul></li><li>GPT-3.5 不能进行类型 (c) 的推理（推理不能容忍歧义）。<ul><li>一个例子是严格的数学证明，要求中间步骤中不能跳，不能模糊，不能错。</li><li>但这种严格推理到底是应该让语言模型做还是让符号系统做还有待讨论。一个例子是，与其努力让 GPT 做三位数加法，不如直接调 Python。</li></ul></li></ul></li><li><strong>从互联网进行检索</strong>：GPT-3.5 系列（暂时）不能直接搜索互联网<ul><li>但是有一篇 WebGPT 论文发表于2021年12月，里面就让 GPT 调用了搜索引擎。所以检索的能力已经在 OpenAI 内部进行了测试。</li><li>这里需要区分的一点是，GPT-3.5 的两个重要但不同的能力是 <strong>知识</strong> 和 <strong>推理</strong>。一般来说，如果我们能够 <strong>将知识部分卸载到外部的检索系统，让语言模型只专注于推理，这就很不错了。</strong> 因为：<ul><li>模型的内部知识总是在某个时间被切断。模型始终需要最新的知识来回答最新的问题。</li><li>回想一下，我们已经讨论过 1750 亿的参数大量用于存储知识。如果我们可以将知识卸载到模型之外，那么模型参数可能会大大减少，最终它甚至可以在手机上运行（疯狂的想法，但 ChatGPT 已经足够科幻了，谁知道未来会怎样呢).</li></ul></li></ul></li></ul><h4 id="七、结论"><a href="#七、结论" class="headerlink" title="# 七、结论"></a># 七、结论</h4><p>在这篇博文中，我们仔细检查了GPT-3.5系列的能力范围，并追溯了它们所有突现能力的来源。初代GPT-3模型通过预训练获得生成能力、世界知识和in-context learning。然后通过instruction tuning的模型分支获得了遵循指令和能泛化到没有见过的任务的能力。经过代码训练的分支模型则获得了代码理解的能力，作为代码训练的副产品，模型同时潜在地获得了复杂推理的能力。结合这两个分支，code-davinci-002似乎是具有所有强大能力的最强GPT-3.5模型。接下来通过有监督的instruction tuning和 RLHF通过牺牲模型能力换取与人类对齐，即对齐税。 RLHF 使模型能够生成更翔实和公正的答案，同时拒绝其知识范围之外的问题。</p><p>我们希望这篇文章能够帮助提供一个清晰的GPT评估图，并引发一些关于语言模型、instruction tuning和code tuning的讨论。最重要的是， <strong>我们希望这篇文章可以作为在开源社区内复现GPT-3.5的路线图。</strong></p><blockquote><p>“因为山就在那里。”——乔治·马洛里，珠穆朗玛峰探险先驱</p></blockquote><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://yaofu.notion.site/GPT-3-5-360081d91ec245f29029d37b54573756#cef4ffed7ee54302981ae7acb0fbc9f3">拆解追溯 GPT-3.5 各项能力的起源</a></p>]]></content>
    
    
    <categories>
      
      <category>GPT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPT</tag>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>框架+设计思想学习笔记</title>
    <link href="/2023/03/05/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0--%EF%BC%88%E6%80%9D%E6%83%B3%EF%BC%89/"/>
    <url>/2023/03/05/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0--%EF%BC%88%E6%80%9D%E6%83%B3%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="高内聚低耦合"><a href="#高内聚低耦合" class="headerlink" title="高内聚低耦合"></a>高内聚低耦合</h3><h4 id="高内聚"><a href="#高内聚" class="headerlink" title="高内聚"></a>高内聚</h4><p>内聚性：又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高—-（你中有我 我中有你）</p><h4 id="低耦合"><a href="#低耦合" class="headerlink" title="低耦合"></a>低耦合</h4><p>一个完整的系统，模块与模块之间，尽可能的使其独立存在—-（最好0耦合）</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6992023978466344997">如何理解“高内聚低耦合”</a></p><h5 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://refactoring.guru/">设计思想参考网站</a></p>]]></content>
    
    
    <categories>
      
      <category>编程思想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端进阶</tag>
      
      <tag>编程思想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章  权衡的艺术</title>
    <link href="/2023/03/04/Vuejs%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%B8%8E%E5%91%BD%E4%BB%A4%E5%BC%8F/"/>
    <url>/2023/03/04/Vuejs%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%B8%8E%E5%91%BD%E4%BB%A4%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="第一章-权衡的艺术"><a href="#第一章-权衡的艺术" class="headerlink" title="第一章  权衡的艺术"></a>第一章  权衡的艺术</h2><h3 id="1-1-命令式与声明式"><a href="#1-1-命令式与声明式" class="headerlink" title="1.1 命令式与声明式"></a>1.1 命令式与声明式</h3><p>从范式上来看，视图层框架通常分为命令式和声明式，它们各有优缺点。 </p><h4 id="JQuery是命令式框架-命令式一大特点就是关注过程。"><a href="#JQuery是命令式框架-命令式一大特点就是关注过程。" class="headerlink" title="JQuery是命令式框架,命令式一大特点就是关注过程。"></a>JQuery是命令式框架,命令式一大特点就是关注过程。</h4><p>例如，我们把下面这段话翻译成对应的代码：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">01 </span>- 获取 id 为 app 的 div 标签<br><span class="hljs-symbol">02 </span>- 它的文本内容为 hello world<br><span class="hljs-symbol">03 </span>- 为其绑定点击事件<br><span class="hljs-symbol">04 </span>- 当点击时弹出提示：ok<br></code></pre></td></tr></table></figure><h4 id="Vue-js的内部一定是命令式的，而暴露给用户的确实更加声明式的。（Vue-js帮我们封装了过程）"><a href="#Vue-js的内部一定是命令式的，而暴露给用户的确实更加声明式的。（Vue-js帮我们封装了过程）" class="headerlink" title="Vue.js的内部一定是命令式的，而暴露给用户的确实更加声明式的。（Vue.js帮我们封装了过程）"></a>Vue.js的内部一定是命令式的，而暴露给用户的确实更加声明式的。（Vue.js帮我们封装了过程）</h4><p>这段类 HTML 的模板就是 Vue.js 实现如上功能的方式。可以看到，我们提供的是一个“结果”，至于如何实现这个“结果”，我们并不关心，这就像我们在告诉 Vue.js：“嘿，Vue.js，看到没，我要的就是一个div，文本内容是 hello world，它有个事件绑定，你帮我搞定吧。”至于实现该“结果”的过程，则是由 Vue.js 帮我们完成的。换句话说，Vue.js 帮我们封装了过程。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> @click=<span class="hljs-string">&quot;() =&gt; alert(&#x27;ok&#x27;)&quot;</span>&gt;hello world&lt;/<span class="hljs-keyword">div</span><br></code></pre></td></tr></table></figure><h3 id="1-2-性能与可维护性的权衡"><a href="#1-2-性能与可维护性的权衡" class="headerlink" title="1.2 性能与可维护性的权衡"></a>1.2 性能与可维护性的权衡</h3><p>命令式和声明式<strong>各有优缺点</strong>，在框架设计方面，则体现在性能与可维护性之间的权衡。<br>这里我们先抛出一个结论：<strong>声明式代码的性能不优于命令式代码的性能</strong></p><p>还是拿上面的例子来说，假设现在我们要将 div 标签的文本内容修改为 hello vue3，那么如何用命令式代码实现呢？很简单，因为我们明确知道要修改的是什么，所以直接调用相关命令操作即可：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">01 </span>div.textContent = <span class="hljs-comment">&#x27;hello vue3&#x27; // 直接修改</span><br></code></pre></td></tr></table></figure><p>现在思考一下，还有没有其他办法比上面这句代码的性能更好？<br><strong>答案是“没有”</strong>。可以看到，理论上命令式代码可以做到极致的性能优化，因为我们明确知道哪些发生了变更，只做必要的修改就行了。但是声明式代码不一定能做到这一点，因为它描述的是结果：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">01 </span>&lt;!-- 之前： --&gt;<br><span class="hljs-symbol">02 </span>&lt;div @click=<span class="hljs-string">&quot;() =&gt; alert(&#x27;ok&#x27;)&quot;</span>&gt;hello world&lt;/div&gt;<br><span class="hljs-symbol">03 </span>&lt;!-- 之后： --&gt;<br><span class="hljs-symbol">04 </span>&lt;div @click=<span class="hljs-string">&quot;() =&gt; alert(&#x27;ok&#x27;)&quot;</span>&gt;hello vue3&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>对于框架来说，为了实现最优的更新性能，它需要找到前后的差异并只更新变化的地方，但是最终完成这次更新的代码仍然是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">01 </span>div.textContent = <span class="hljs-comment">&#x27;hello vue3&#x27; // 直接修改</span><br></code></pre></td></tr></table></figure><p>如果我们把直接修改的性能消耗定义为 A，把找出差异的性能消耗定义为 B，那么有：</p><ol><li>命令式代码的更新性能消耗 = A</li><li>声明式代码的更新性能消耗 = B + A<br>可以看到，声明式代码会比命令式代码多出找出差异的性能消耗，因此最理想的情况是，当找出差异的性能消耗为 0 时，声明式代码与命令式代码的性能相同，但是无法做到超越，<strong>毕竟框架本身就是封装了命令式代码才实现了面向用户的声明式</strong>。这符合前文中给出的性能结论：<strong>声明式代码的性能不优于命令式代码的性能</strong>。</li></ol><p>既然在性能层面命令式代码是更好的选择，那么为什么 Vue.js 要选择声明式的设计方案呢？<strong>原因就在于声明式代码的可维护性更强</strong>。</p><p>从上面例子的代码中我们也可以感受到，<strong>在采用命令式代码开发的时候，我们需要维护实现目标的整个过程，包括要手动完成 DOM 元素的创建、更新、删除等工作</strong>。而<strong>声明式代码展示的就是我们要的结果，看上去更加直观，至于做事儿的过程，并不需要我们关心，Vue.js都为我们封装好了。</strong></p><p>这就体现了我们在框架设计上要做出的关于可维护性与性能之间的权衡。<strong>在采用声明式提升可维护性的同时，性能就会有一定的损失，而框架设计者要做的就是：在保持可维护性的同时让性能损失最小化。</strong></p><h3 id="1-3-虚拟-DOM-的性能到底如何"><a href="#1-3-虚拟-DOM-的性能到底如何" class="headerlink" title="1.3 虚拟 DOM 的性能到底如何"></a>1.3 虚拟 DOM 的性能到底如何</h3><p>前文说到，<strong>声明式代码的更新性能消耗 = 找出差异的性能消耗+ 直接修改的性能消耗</strong>，因此，如果我们能够最小化找出差异的性能消耗，就可以让声明式代码的性能无限接近命令式代码的性能。<strong>而所谓的虚拟 DOM，就是为了最小化找出差异这一步的性能消耗而出现的。</strong></p><p>至此，相信你也应该清楚一件事了，<strong>那就是采用虚拟 DOM 的更新技术的性能理论上不可能比原生 JavaScript 操作 DOM 更高</strong>。这里我们强调了理论上三个字，因为这很关键，为什么呢？<strong>因为在大部分情况下，我们很难写出绝对优化的命令式代码，尤其是当应用程序的规模很大的时候，即使你写出了极致优化的代码，也一定耗费了巨大的精力，这时的投入产出比其实并不高。</strong></p><p>那么，<strong>有没有什么办法能够让我们不用付出太多的努力（写声明式代码），还能够保证应用程序的性能下限，让应用程序的性能不于至太差，甚至想办法逼近命令式代码的性能呢？</strong>这其实就是<strong>虚拟 DOM要解决的问题</strong>。</p><p>不过前文中所说的原生 JavaScript 实际上指的是像document.createElement 之类的 DOM 操作方法，并不包含innerHTML，因为它比较特殊，需要单独讨论。<strong>在早年使用 jQuery 或者直接使用 JavaScript 编写页面的时候，使用 innerHTML 来操作页面非常常见</strong>。其实我们可以思考一下：<strong>使用 innerHTML 操作页面和虚拟 DOM 相比性能如何？innerHTML 和document.createElement 等 DOM 操作方法有何差异？</strong></p><p>先来看第一个问题，为了比较 innerHTML 和虚拟 DOM 的性能，我们需要了解它们创建、更新页面的过程。对于 innerHTML 来说，为了创建页面，我们需要构造一段 HTML 字符串：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">01 </span>const html = `<br><span class="hljs-symbol">02 </span>&lt;div&gt;&lt;span&gt;...&lt;/span&gt;&lt;/div&gt;<br><span class="hljs-symbol">03 </span>`<br></code></pre></td></tr></table></figure><p>接着将该字符串赋值给 DOM 元素的 innerHTML 属性：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">01 </span>div.innerHTML = html<br></code></pre></td></tr></table></figure><p>然而这句话远没有看上去那么简单。<strong>为了渲染出页面，首先要把字符串解析成 DOM 树，这是一个 DOM 层面的计算</strong>。我们知道，涉及DOM 的运算要远比 JavaScript 层面的计算性能差，这有一个跑分结果可供参考，如图 1-1 所示。</p><p>在图 1-1 中，上边是纯 JavaScript 层面的计算，循环 10 000 次，每次创建一个 JavaScript 对象并将其添加到数组中；下边是 DOM 操作，每次创建一个 DOM 元素并将其添加到页面中。跑分结果显示，<strong>纯JavaScript 层面的操作要比 DOM 操作快得多</strong>，它们不在一个数量级上。基于这个背景，我们可以用一个公式来表达通过 innerHTML 创建页面的性能：<strong>HTML 字符串拼接的计算量 + innerHTML 的 DOM计算量</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们<strong>分了几个维度：心智负担、可维护性和性能</strong>。其中<strong>原生 DOM操作方法心智负担最大，因为你要手动创建、删除、修改大量的DOM 元素。但它的性能是最高的，不过为了使其性能最佳，我们同样要承受巨大的心智负担。另外，以这种方式编写的代码，可维护性也极差</strong>。而<strong>对于 innerHTML 来说，由于我们编写页面的过程有一部分是通过拼接 HTML 字符串来实现的，这有点儿接近声明式的意思，但是拼接字符串总归也是有一定心智负担的，而且对于事件绑定之类的事情，我们还是要使用原生 JavaScript 来处理。如果 innerHTML 模板很大，则其更新页面的性能最差，尤其是在只有少量更新时</strong>。最后，<strong>我们来看看虚拟 DOM，它是声明式的，因此心智负担小，可维护性强，性能虽然比不上极致优化的原生 JavaScript，但是在保证心智负担和可维护性的前提下相当不错</strong>。</p><h4 id="1-4-运行时和编译时"><a href="#1-4-运行时和编译时" class="headerlink" title="1.4 运行时和编译时"></a>1.4 运行时和编译时</h4><p>首先是<strong>纯运行时的框架</strong>。由于<strong>它没有编译的过程，因此我们没办法分析用户提供的内容</strong>，但是如果加入编译步骤，可能就大不一样了，我们可以分析用户提供的内容，<strong>看看哪些内容未来可能会改变，哪些内容永远不会改变，这样我们就可以在编译的时候提取这些信息，然后将其传递给 Render 函数，Render 函数得到这些信息之后，就可以做进一步的优化了</strong>。然而，假如我们设计的框架是<strong>纯编译时</strong>的，那么它也可以分析用户提供的内容。由于不需要任何运行时，而是直接编译成可执行的 JavaScript 代码，<strong>因此性能可能会更好，但是这种做法有损灵活性，即用户提供的内容必须编译后才能用</strong>。实际上，在这三个方向上业内都有探索，<strong>其中 Svelte 就是纯编译时的框架，但是它的真实性能可能达不到理论高度</strong>。<strong>Vue.js 3 仍然保持了运行时 + 编译时的架构，在保持灵活性的基础上能够尽可能地去优化</strong>。等到后面讲解 Vue.js 3 的编译优化相关内容时，你会看到 Vue.js 3 在保留运行时的情况下，其性能甚至不输纯编译时的框架。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="">Vuejs设计与实现书籍</a></p>]]></content>
    
    
    <categories>
      
      <category>Vuejs设计与实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端进阶</tag>
      
      <tag>Vuejs设计与实现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React初识&amp;&amp;JSX&amp;&amp;函数式组件</title>
    <link href="/2023/03/04/React%E5%88%9D%E8%AF%86&amp;&amp;JSX&amp;&amp;%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6(1)/"/>
    <url>/2023/03/04/React%E5%88%9D%E8%AF%86&amp;&amp;JSX&amp;&amp;%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6(1)/</url>
    
    <content type="html"><![CDATA[<p>学习react的笔记</p><hr><h3 id="react-项目-npm-i-安装依赖报错"><a href="#react-项目-npm-i-安装依赖报错" class="headerlink" title="react 项目 npm i 安装依赖报错"></a>react 项目 npm i 安装依赖报错</h3><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs d">创建react工程，提示错误The engine <span class="hljs-string">&quot;node&quot;</span> <span class="hljs-keyword">is</span> incompatible <span class="hljs-keyword">with</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">module</span>. Expected <span class="hljs-keyword">version</span> <span class="hljs-string">&quot;^8.10.0 || ^10.13.0 || &gt;=11.10.1&quot;</span>. Got <span class="hljs-string">&quot;10.5.0&quot;</span>，导致一直没有创建成功<br></code></pre></td></tr></table></figure><h4 id="node版本不一致"><a href="#node版本不一致" class="headerlink" title="node版本不一致"></a>node版本不一致</h4><ol><li>升级node</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 第一步：使用npm安装n模块,n模块是专门用来管理nodejs版本的，名字就叫n执行命令<br>npm install -g n    <span class="hljs-regexp">//</span> （注意不带sudo，我按照网上带sudo提示错误）<br><span class="hljs-regexp">//</span> 出现此日志表示添加n包成功<br><span class="hljs-regexp">//</span> 第二步：使用n模块升级node<br><span class="hljs-regexp">//</span> 第一种是升级到最新版本<br>sudo n latest<br><span class="hljs-regexp">//</span> 第二种是升级到稳定版本（建议用稳定版本）<br>sudo n stable<br></code></pre></td></tr></table></figure><ol start="2"><li>如果更新了node或许或导致其他工程有问题，不能轻易更新，可以输入命令行,也可以恢复正常</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">yarn<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span> ignore-engines <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="采用了第二种安装，别人的项目拉取node版本不同也能解决"><a href="#采用了第二种安装，别人的项目拉取node版本不同也能解决" class="headerlink" title="采用了第二种安装，别人的项目拉取node版本不同也能解决"></a>采用了第二种安装，别人的项目拉取node版本不同也能解决</h4><p><a href="https://www.jianshu.com/p/a186f65c2586">参考</a></p><h3 id="项目初始–vite配置项目路径别名"><a href="#项目初始–vite配置项目路径别名" class="headerlink" title="项目初始–vite配置项目路径别名"></a>项目初始–vite配置项目路径别名</h3><p><a href="https://segmentfault.com/a/1190000041417219">参考</a></p><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>Vue 早期定位是尽可能的降低前端开发的门槛（这跟 Vue 作者是独立开发者也有关系）。所以 Vue 推崇灵活易用（渐进式开发体验），数据可变，双向数据绑定（依赖收集）。<br>React 早期口号是 Rethinking Best Practices(重新思考最佳实践)。背靠大公司 Facebook 的 React，从开始起就不缺关注和用户，而且 React 想要做的是用更好的方式去颠覆前端开发方式（事实上跟早期 jquery 称霸前端，的确是颠覆了）。所以 React 推崇函数式编程（纯组件），数据不可变以及单向数据流。函数式编程最大的好处是其稳定性（无副作用）和可测试性（输入相同，输出一定相同），所以通常大家说的 React 适合大型应用，根本原因还是在于其函数式编程。<br>由于两者核心思想的不同，所以导致 Vue 和 React 许多外在表现不同（从开发层面看）。</p><p><a href="https://juejin.cn/post/6953482028188860424#comment">掘金</a></p><h4 id="总体感受–一些区别"><a href="#总体感受–一些区别" class="headerlink" title="总体感受–一些区别"></a>总体感受–一些区别</h4><ul><li>vue 更简单，更方便，熟悉了 api 以后，实现某些简单功能更快。react 写法更偏向于原生 JS，Class 的写法不是很舒服，个人更喜欢 hooks。</li><li>熟悉了 hooks 以后，写起来很自由，不用关心 vue 中固定的 options api</li><li>react 做中后台优势更大，有大厂加持，生态更好，组件库功能也更多，解决方案也更多</li><li>vue2.x 对 typescript 不太友好，react + typescript 更加舒适，两者写起来风格差距较大。</li><li>react JSX 写起来还是不够熟练，onClick、style、className 等等，没有 v-if，v-for，All in JS。Vue 则推崇 html、js、css 分离的写法，当然 vue 也可以写 JSX</li><li>vue 的 prop 必须在子组件 props 字段里声明。React 的 prop 不强制声明，直接使用，如果用 TS 的话还是要声明的</li></ul><h3 id="React-是什么？"><a href="#React-是什么？" class="headerlink" title="React 是什么？"></a>React 是什么？</h3><p>React 是一个<strong>声明式</strong>，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作“组件”。</p><h3 id="JSX基础"><a href="#JSX基础" class="headerlink" title="JSX基础"></a>JSX基础</h3><ol><li>JSX介绍<br>概念：JSX是 JavaScript XML（HTML）的缩写，表示在 JS 代码中书写 HTML 结构<br>作用：在React中创建HTML结构（页面UI结构）</li></ol><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>采用类似于HTML的语法，降低学习成本，会HTML就会JSX</li><li>充分利用JS自身的可编程能力创建HTML结构<br>注意：JSX 并不是标准的 JS 语法，是 JS 的语法扩展，浏览器默认是不识别的，脚手架中内置的 @babel/plugin-transform-react-jsx 包，用来解析该语法</li></ol><h4 id="2-JSX中使用js表达式"><a href="#2-JSX中使用js表达式" class="headerlink" title="2. JSX中使用js表达式"></a>2. JSX中使用js表达式</h4><p>语法<br>{ JS 表达式 }</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery">const<span class="hljs-built_in"> name</span> = <span class="hljs-string">&#x27;柴柴&#x27;</span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>你好，我叫</span><span class="xquery"><span class="hljs-built_in">&#123;name</span>&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>   //    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>你好,我叫柴柴<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>可以使用的表达式</p><ol><li>字符串、数值、布尔值、null、undefined、object（ [] / {} ）</li><li>1 + 2、’abc’.split(‘’)、[‘a’, ‘b’].join(‘-‘)</li><li>fn()<br>特别注意</li></ol><blockquote><p>if 语句/ switch-case 语句/ 变量声明语句，这些叫做语句，不是表达式，不能出现在 {} 中！！</p></blockquote><h4 id="3-JSX列表渲染"><a href="#3-JSX列表渲染" class="headerlink" title="3. JSX列表渲染"></a>3. JSX列表渲染</h4><p>页面的构建离不开重复的列表结构，比如歌曲列表，商品列表等，我们知道vue中用的是v-for，react这边如何实现呢？</p><p>实现：使用数组的map 方法</p><p>案例：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xquery">// 来个列表<br>const songs = [<br>  &#123;<span class="hljs-built_in"> id</span>: <span class="hljs-number">1</span>,<span class="hljs-built_in"> name</span>: <span class="hljs-string">&#x27;痴心绝对&#x27;</span> &#125;,<br>  &#123;<span class="hljs-built_in"> id</span>: <span class="hljs-number">2</span>,<span class="hljs-built_in"> name</span>: <span class="hljs-string">&#x27;像我这样的人&#x27;</span> &#125;,<br>  &#123;<span class="hljs-built_in"> id</span>: <span class="hljs-number">3</span>,<span class="hljs-built_in"> name</span>: <span class="hljs-string">&#x27;南山南&#x27;</span> &#125;<br>]<br><span class="hljs-keyword">function</span> App() &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="xml">      </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">        </span><span class="xquery">&#123;</span><br><span class="xquery">          songs.<span class="hljs-keyword">map</span>(<span class="hljs-type">item</span> =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><span class="xquery">&#123;<span class="hljs-type">item</span><span class="hljs-built_in">.name</span>&#125;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="xml">)</span><br><span class="xml">        &#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>    &lt;/div&gt;<br>  )<br>&#125;<br>export <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><p>注意点：需要为遍历项添加 key 属性</p><ol><li>key 在 HTML 结构中是看不到的，是 React 内部用来进行性能优化时使用</li><li>key 在当前列表中要唯一的字符串或者数值（String/Number）</li><li>如果列表中有像 id 这种的唯一值，就用 id 来作为 key 值</li><li>如果列表中没有像 id 这种的唯一值，就可以使用 index（下标）来作为 key 值</li></ol><h4 id="4-JSX条件渲染"><a href="#4-JSX条件渲染" class="headerlink" title="4. JSX条件渲染"></a>4. JSX条件渲染</h4><p>作用：根据是否满足条件生成HTML结构，比如Loading效果</p><p>实现：可以使用 三元运算符 或 逻辑与(&amp;&amp;)运算符</p><p>案例：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 来个布尔值</span><br><span class="hljs-keyword">const</span> flag = <span class="hljs-literal">true</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div className=<span class="hljs-string">&quot;App&quot;</span>&gt;<br>      &#123;<span class="hljs-comment">/*条件渲染字符串*/</span>&#125;<br>      &#123;flag ? <span class="hljs-string">&#x27;react真有趣&#x27;</span> : <span class="hljs-string">&#x27;vue真有趣&#x27;</span>&#125;<br>      &#123;<span class="hljs-comment">/*条件渲染标签/组件*/</span>&#125;<br>      &#123;flag ? &lt;span&gt;<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> span&lt;/span&gt; : <span class="hljs-literal">null</span>&#125;<br>    &lt;/div&gt;<br>  )<br>&#125;<br>export <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><h4 id="5-JSX样式处理"><a href="#5-JSX样式处理" class="headerlink" title="5. JSX样式处理"></a>5. JSX样式处理</h4><p>目标任务: 能够在JSX中实现css样式处理</p><p>行内样式 - style</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs axapta">function App() &#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;<span class="hljs-keyword">div</span> className=<span class="hljs-string">&quot;App&quot;</span>&gt;<br>      &lt;<span class="hljs-keyword">div</span> style=&#123;&#123; color: <span class="hljs-string">&#x27;red&#x27;</span> &#125;&#125;&gt;<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> a <span class="hljs-keyword">div</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;/<span class="hljs-keyword">div</span>&gt;<br>  )<br>&#125;<br><br>export <span class="hljs-literal">default</span> App<br></code></pre></td></tr></table></figure><p>行内样式 - style - 更优写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> styleObj = &#123;<br>    color:red<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div className=<span class="hljs-string">&quot;App&quot;</span>&gt;<br>      &lt;div style=&#123; styleObj &#125;&gt;<span class="hljs-built_in">this</span> is a div&lt;/div&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><p>类名 - className（推荐）</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gradle">app.css<br><br>.title &#123;<br>  font-<span class="hljs-keyword">size</span>: <span class="hljs-number">30</span>px;<br>  color: blue;<br>&#125;<br>app.js<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./app.css&#x27;</span><br><br>function App() &#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;<span class="hljs-keyword">div</span> className=<span class="hljs-string">&quot;App&quot;</span>&gt;<br>      &lt;<span class="hljs-keyword">div</span> className=<span class="hljs-string">&#x27;title&#x27;</span>&gt;<span class="hljs-keyword">this</span> is a <span class="hljs-keyword">div</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;/<span class="hljs-keyword">div</span>&gt;<br>  )<br>&#125;<br>export <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><p>类名 - className - 动态类名控制</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs axapta">import <span class="hljs-string">&#x27;./app.css&#x27;</span><br><span class="hljs-keyword">const</span> showTitle = <span class="hljs-literal">true</span><br>function App() &#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;<span class="hljs-keyword">div</span> className=<span class="hljs-string">&quot;App&quot;</span>&gt;<br>      &lt;<span class="hljs-keyword">div</span> className=&#123; showTitle ? <span class="hljs-string">&#x27;title&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span>&#125;&gt;<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> a <span class="hljs-keyword">div</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;/<span class="hljs-keyword">div</span>&gt;<br>  )<br>&#125;<br>export <span class="hljs-literal">default</span> App<br></code></pre></td></tr></table></figure><p><a href="https://react.docschina.org/docs/introducing-jsx.html">官网</a><br><a href="">参考文档</a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>文件名可以是jsx 或者js，不影响文件中的代码</li><li>组件名称必须大写</li><li>Js中出现 （）代表其中想要写的html</li><li>HTML中出现 {} 代表其中想要写的js</li></ol><h5 id="JSX注意事项"><a href="#JSX注意事项" class="headerlink" title="JSX注意事项"></a>JSX注意事项</h5><p>JSX<strong>必须有一个根节点</strong>，如果没有根节点，可以使用&lt;&gt;&lt;/&gt;（幽灵节点）替代</p><p>所有标签必须形成闭合，成对闭合或者自闭合都可以</p><p>JSX中的语法更加贴近JS语法，<strong>属性名采用驼峰命名法</strong> class -&gt; className for -&gt; htmlFor</p><p>JSX支持多行（换行），如果需要换行，需使用() 包裹，防止bug出现</p><h3 id="React组件基础"><a href="#React组件基础" class="headerlink" title="React组件基础"></a>React组件基础</h3><h4 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h4><p>1.函数式组件没有声明周期<br>2.函数式组件没有this<br>3.函数式组件没有state状态<br>函数组件</p><p>使用 JS 的函数（或箭头函数）创建的组件，就叫做函数组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">组件定义与渲染<br><br><span class="hljs-comment">// 定义函数组件</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HelloFn</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>这是我的第一个函数组件!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-comment">// 定义类组件</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div className=<span class="hljs-string">&quot;App&quot;</span>&gt;<br>      &#123;<span class="hljs-comment">/* 渲染函数组件 */</span>&#125;<br>      &lt;HelloFn /&gt;<br>      &lt;HelloFn&gt;&lt;/HelloFn&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><p>约定说明</p><ol><li>组件的名称<strong>必须首字母大写</strong>，react内部会根据这个来判断是组件还是普通的HTML标签</li><li><strong>函数组件必须有返回值</strong>，表示该组件的 UI 结构；如果不需要渲染任何内容，则返回 null</li><li>组件就像 HTML 标签一样可以被渲染到页面中。组件表示的是一段结构内容，对于函数组件来说，渲染的内容是函数的返回值就是对应的内容</li><li>使用函数名称作为组件标签名称，可以成对出现也可以自闭合</li></ol><h4 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h4><blockquote><p>使用 ES6 的 class 创建的组件，叫做类（class）组件</p></blockquote><p>组件定义与渲染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入React</span><br><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-comment">// 定义类组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  render () &#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>这是我的第一个类组件!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div className=<span class="hljs-string">&quot;App&quot;</span>&gt;<br>      &#123;<span class="hljs-comment">/*渲染类组件*/</span>&#125;<br>      &lt;HelloC /&gt;<br>      &lt;HelloC&gt;&lt;/HelloC&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><p>约定说明</p><ol><li><strong>类名称也必须以大写字母开头</strong></li><li>类组件应该继承 React.Component 父类，从而使用父类中提供的方法或属性</li><li>类组件必须提供 render 方法<strong>render 方法必须有返回值，表示该组件的 UI 结构</strong></li></ol><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><ol><li>如何绑定事件<br>语法</li></ol><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">on + 事件名称 = </span><span class="hljs-template-variable">&#123; 事件处理程序 &#125;</span><span class="xml"> ，比如：<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=</span></span><span class="hljs-template-variable">&#123;()=&gt;&#123;&#125;</span><span class="xml"><span class="hljs-tag">&#125;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>注意点<br>react事件采用<strong>驼峰命名法</strong>，比如：onMouseEnter、onFocus<br>样例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数组件</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HelloFn</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 定义事件回调函数</span><br>  <span class="hljs-keyword">const</span> clickHandler = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;事件被触发了&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="hljs-comment">// 绑定事件</span><br>    &lt;button onClick=&#123;clickHandler&#125;&gt;click me!&lt;/button&gt;<br>  )<br>&#125;<br><span class="hljs-comment">// 类组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-comment">// 定义事件回调函数</span><br>  clickHandler = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;事件被触发了&#x27;</span>)<br>  &#125;<br>  render () &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="hljs-comment">// 绑定事件</span><br>      &lt;button onClick=&#123;<span class="hljs-built_in">this</span>.clickHandler&#125;&gt;click me!&lt;/button&gt;<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>获取事件对象<br>通过事件处理程序的参数获取事件对象e</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数组件</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HelloFn</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 定义事件回调函数</span><br>  <span class="hljs-keyword">const</span> clickHandler = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    e.preventDefault()<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;事件被触发了&#x27;</span>, e)<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="hljs-comment">// 绑定事件</span><br>    &lt;a href=<span class="hljs-string">&quot;http://www.baidu.com/&quot;</span> onClick=&#123;clickHandler&#125;&gt;百度&lt;/a&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="组件状态"><a href="#组件状态" class="headerlink" title="组件状态"></a>组件状态</h4><p>目标任务: 能够为组件添加状态和修改状态的值</p><blockquote><p>一个前提：在react hook出来之前，函数式组件是没有自己的状态的，所以我们统一通过类组件来讲解<br><img src="/imageO/react1.png" alt="组件状态"></p></blockquote><ol><li>初始化状态<br>通过class的实例属性state来初始化</li></ol><p>state的值是一个对象结构，表示一个组件可以有多个数据状态</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-comment">// 初始化状态</span><br>  state = &#123;<br>    count: <span class="hljs-number">0</span><br>  &#125;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> &lt;button&gt;计数器&lt;/button&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>读取状态<br>通过this.state来获取状态</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-comment">// 初始化状态</span><br>  state = &#123;<br>    count: <span class="hljs-number">0</span><br>  &#125;<br>  render() &#123;<br>    <span class="hljs-comment">// 读取状态</span><br>    <span class="hljs-keyword">return</span> &lt;button&gt;计数器&#123;<span class="hljs-keyword">this</span>.state.count&#125;&lt;/button&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>修改状态</li></ol><ul><li>语法</li></ul><p>this.setState({ 要修改的部分数据 })</p><ul><li><p>setState方法作用<br>修改state中的数据状态<br>更新UI</p></li><li><p>思想<br>​ 数据驱动视图，也就是只要修改数据状态，那么页面就会自动刷新，无需手动操作dom</p></li><li><p>注意事项<br>​ <strong>不要直接修改state中的值，必须通过setState方法进行修改</strong></p></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-comment">// 定义数据</span><br>  state = &#123;<br>    count: <span class="hljs-number">0</span><br>  &#125;<br>  <span class="hljs-comment">// 定义修改数据的方法</span><br>  setCount = () =&gt; &#123;<br>    <span class="hljs-keyword">this</span>.setState(&#123;<br>      count: <span class="hljs-keyword">this</span>.state.count + <span class="hljs-number">1</span><br>    &#125;)<br>  &#125;<br>  <span class="hljs-comment">// 使用数据 并绑定事件</span><br>  render () &#123;<br>    <span class="hljs-keyword">return</span> &lt;button onClick=&#123;<span class="hljs-keyword">this</span>.setCount&#125;&gt;&#123;<span class="hljs-keyword">this</span>.state.count&#125;&lt;/button&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/imageO/react2.png" alt="this"></p><h4 id="this问题说明"><a href="#this问题说明" class="headerlink" title="this问题说明"></a>this问题说明</h4><p>这里我们作为了解内容，随着js标准的发展，主流的写法已经变成了class fields，无需考虑太多this问题</p><h4 id="React的状态不可变"><a href="#React的状态不可变" class="headerlink" title="React的状态不可变"></a>React的状态不可变</h4><p>概念：不要直接修改状态的值，而是基于当前状态创建新的状态值</p><ol><li>错误的直接修改</li></ol><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">state</span> = &#123;<br>  count : <span class="hljs-number">0</span>,<br>  list: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<br>  person: &#123;<br>     name:&#x27;jack&#x27;,<br>     age:<span class="hljs-number">18</span><br>  &#125;<br>&#125;<br>// 直接修改简单类型Number<br>this.<span class="hljs-keyword">state</span>.count++<br>++this.<span class="hljs-keyword">state</span>.count<br>this.<span class="hljs-keyword">state</span>.count += <span class="hljs-number">1</span><br>this.<span class="hljs-keyword">state</span>.count = <span class="hljs-number">1</span><br><br>// 直接修改数组<br>this.<span class="hljs-keyword">state</span>.list.push(<span class="hljs-number">123</span>)<br>this.<span class="hljs-keyword">state</span>.list.spice(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br><br>// 直接修改对象<br>this.<span class="hljs-keyword">state</span>.person.name = &#x27;rose&#x27;<br></code></pre></td></tr></table></figure><ol start="2"><li>基于当前状态创建新值</li></ol><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pf">this.<span class="hljs-built_in">set</span>State(&#123;<br>    count: this.<span class="hljs-keyword">state</span>.count + <span class="hljs-number">1</span><br>    list: [...this.<span class="hljs-keyword">state</span>.list, <span class="hljs-number">4</span>],<br>    person: &#123;<br>       ...this.<span class="hljs-keyword">state</span>.person,<br>       // 覆盖原来的属性 就可以达到修改对象中属性的目的<br>       name: &#x27;rose&#x27;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h4><p>使用React处理表单元素，一般有俩种方式：</p><p>受控组件 （推荐使用）<br>非受控组件 （了解）</p><h5 id="1-受控表单组件"><a href="#1-受控表单组件" class="headerlink" title="1. 受控表单组件"></a>1. 受控表单组件</h5><p>什么是受控组件？ input框自己的状态被React组件状态控制</p><blockquote><p>React组件的状态的地方是在state中，input表单元素也有自己的状态是在value中，React将state与表单元素的值（value）绑定到一起，由state的值来控制表单元素的值，从而保证单一数据源特性</p></blockquote><p>实现步骤</p><p>以获取文本框的值为例，受控组件的使用步骤如下：</p><ol><li>在组件的state中声明一个组件的状态数据</li><li>将状态数据设置为input标签元素的value属性的值</li><li>为input添加change事件，在事件处理程序中，通过事件对象e获取到当前文本框的值（即用户当前输入的值）</li><li>调用setState方法，将文本框的值作为state状态的最新值</li></ol><p>代码落地</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-comment">// 声明组件状态</span><br>  state = &#123;<br>    message: <span class="hljs-string">&#x27;this is message&#x27;</span>,<br>  &#125;<br>  <span class="hljs-comment">// 声明事件回调函数</span><br>  changeHandler = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">message</span>: e.target.value &#125;)<br>  &#125;<br>  render () &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        &#123;<span class="hljs-comment">/*绑定value 绑定事件*/</span>&#125;<br>        &lt;input value=&#123;<span class="hljs-built_in">this</span>.state.message&#125; onChange=&#123;<span class="hljs-built_in">this</span>.changeHandler&#125; /&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div className=<span class="hljs-string">&quot;App&quot;</span>&gt;<br>      &lt;InputComponent /&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><h5 id="2-非受控表单组件"><a href="#2-非受控表单组件" class="headerlink" title="2. 非受控表单组件"></a>2. 非受控表单组件</h5><p>什么是非受控组件？</p><blockquote><p>非受控组件就是通过手动操作dom的方式获取文本框的值，文本框的状态不受react组件的state中的状态控制，直接通过原生dom获取输入框的值</p></blockquote><p>实现步骤</p><ol><li>导入createRef 函数</li><li>调用createRef函数，创建一个ref对象，存储到名为msgRef的实例属性中</li><li>为input添加ref属性，值为msgRef</li><li>在按钮的事件处理程序中，通过msgRef.current即可拿到input对应的dom元素，而其中msgRef.current.value拿到的就是文本框的值<br>代码落地</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; createRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-comment">// 使用createRef产生一个存放dom的对象容器</span><br>  msgRef = createRef()<br><br>  changeHandler = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.msgRef.current.value)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        &#123;<span class="hljs-comment">/*ref绑定 获取真实dom*/</span>&#125;<br>        &lt;input ref=&#123;<span class="hljs-built_in">this</span>.msgRef&#125; /&gt;<br>        &lt;button onClick=&#123;<span class="hljs-built_in">this</span>.changeHandler&#125;&gt;click&lt;/button&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div className=<span class="hljs-string">&quot;App&quot;</span>&gt;<br>      &lt;InputComponent /&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://gitee.com/react-cp/react-pc-doc/blob/master/1.%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3/react-%E5%9F%BA%E7%A1%80.md#react%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8D%E5%8F%AF%E5%8F%98">gitee</a><br><a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React初识&amp;&amp;组件通信&amp;&amp;props校验</title>
    <link href="/2023/03/04/React%E5%88%9D%E8%AF%86&amp;&amp;%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1&amp;&amp;props%E6%A0%A1%E9%AA%8C/"/>
    <url>/2023/03/04/React%E5%88%9D%E8%AF%86&amp;&amp;%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1&amp;&amp;props%E6%A0%A1%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p>学习react的笔记</p><hr><h3 id="React组件通信"><a href="#React组件通信" class="headerlink" title="React组件通信"></a>React组件通信</h3><h4 id="组件通信的意义"><a href="#组件通信的意义" class="headerlink" title="组件通信的意义"></a>组件通信的意义</h4><p>组件是独立且封闭的单元，默认情况下组件<strong>只能使用自己的数据（state）</strong></p><p>组件化开发的过程中，完整的功能会拆分多个组件，在这个过程中不可避免的需要互相传递一些数据</p><p>为了能让各组件之间可以进行互相沟通，数据传递，这个过程就是组件通信</p><ol><li>父子关系 - 最重要的</li><li>兄弟关系 - 自定义事件模式产生技术方法 eventBus / 通过共同的父组件通信</li><li>其它关系 - <strong>mobx / redux / 基于hook的方案</strong></li></ol><h4 id="父传子实现"><a href="#父传子实现" class="headerlink" title="父传子实现"></a>父传子实现</h4><p>实现步骤</p><ol><li><p>父组件提供要传递的数据 - state</p></li><li><p>给子组件标签添加属性值为 state中的数据</p></li><li><p>子组件中通过 props 接收父组件中传过来的数据<br>类组件使用this.props获取props对象<br>函数式组件直接通过参数获取props对象</p></li></ol><p>代码实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> <span class="hljs-type">React</span> from <span class="hljs-symbol">&#x27;reac</span>t&#x27;<br><br><span class="hljs-comment">// 函数式子组件</span><br>function <span class="hljs-type">FSon</span>(props) &#123;<br>  console.log(props)<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div&gt;<br>      子组件<span class="hljs-number">1</span><br>      &#123;props.msg&#125;<br>    &lt;/div&gt;<br>  )<br>&#125;<br><br><span class="hljs-comment">// 类子组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CSon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        子组件<span class="hljs-number">2</span><br>        &#123;<span class="hljs-keyword">this</span>.props.msg&#125;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 父组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  state = &#123;<br>    message: <span class="hljs-symbol">&#x27;this</span> is message&#x27;<br>  &#125;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        &lt;div&gt;父组件&lt;/div&gt;<br>        &lt;<span class="hljs-type">FSon</span> msg=&#123;<span class="hljs-keyword">this</span>.state.message&#125; /&gt;<br>        &lt;<span class="hljs-type">CSon</span> msg=&#123;<span class="hljs-keyword">this</span>.state.message&#125; /&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br><br>export <span class="hljs-keyword">default</span> <span class="hljs-type">App</span><br></code></pre></td></tr></table></figure><h4 id="props说明"><a href="#props说明" class="headerlink" title="props说明"></a>props说明</h4><p>目标任务: 知道props传递时的一些注意事项</p><ol><li>props是只读对象（readonly）</li></ol><p>根据单项数据流的要求，子组件只能读取props中的数据，不能进行修改</p><ol start="2"><li>props可以传递任意数据</li></ol><p>数字、字符串、布尔值、数组、对象、函数、JSX</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  state = &#123;<br>    message: <span class="hljs-string">&#x27;this is message&#x27;</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        &lt;div&gt;父组件&lt;/div&gt;<br>        &lt;FSon<br>          msg=&#123;<span class="hljs-built_in">this</span>.state.message&#125;<br>          age=&#123;<span class="hljs-number">20</span>&#125;<br>          isMan=&#123;<span class="hljs-literal">true</span>&#125;<br>          cb=&#123;<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>) &#125;&#125;<br>          child=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>this is child<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>&#125;<br>        /&gt;<br>        &lt;CSon msg=&#123;<span class="hljs-built_in">this</span>.state.message&#125; /&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="子传父实现"><a href="#子传父实现" class="headerlink" title="子传父实现"></a>子传父实现</h4><p>口诀： 父组件给子组件传递回调函数，子组件调用 (<strong>都是父组件在干活</strong>)</p><p>实现步骤</p><ol><li>父组件提供一个回调函数 - 用于接收数据</li><li>将函数作为属性的值，传给子组件</li><li>子组件通过props调用 回调函数</li><li>将子组件中的数据作为参数传递给回调函数</li></ol><p>代码实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-comment">// 子组件</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleClick</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 调用父组件传递过来的回调函数 并注入参数</span><br>    props.changeMsg(<span class="hljs-string">&#x27;this is newMessage&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div&gt;<br>      &#123;props.msg&#125;<br>      &lt;button onClick=&#123;handleClick&#125;&gt;change&lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  state = &#123;<br>    message: <span class="hljs-string">&#x27;this is message&#x27;</span><br>  &#125;<br>  <span class="hljs-comment">// 提供回调函数</span><br>  changeMessage = <span class="hljs-function">(<span class="hljs-params">newMsg</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;子组件传过来的数据:&#x27;</span>,newMsg)<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>      message: newMsg<br>    &#125;)<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        &lt;div&gt;父组件&lt;/div&gt;<br>        &lt;Son<br>          msg=&#123;<span class="hljs-built_in">this</span>.state.message&#125;<br>          <span class="hljs-comment">// 传递给子组件</span><br>          changeMsg=&#123;<span class="hljs-built_in">this</span>.changeMessage&#125;<br>        /&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><h4 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h4><p>核心思路： 通过状态提升机制，利用共同的父组件实现兄弟通信</p><p>实现步骤</p><ol><li>将共享状态提升到最近的公共父组件中，由公共父组件管理这个状态</li></ol><ul><li>提供共享状态</li><li>提供操作共享状态的方法</li></ul><ol start="2"><li>要接收数据状态的子组件通过 props 接收数据</li><li>要传递数据状态的子组件通过props接收方法，调用方法传递数据</li></ol><p>代码实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-comment">// 子组件A</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SonA</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div&gt;<br>      SonA<br>      &#123;props.msg&#125;<br>    &lt;/div&gt;<br>  )<br>&#125;<br><span class="hljs-comment">// 子组件B</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SonB</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div&gt;<br>      SonB<br>      &lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> props.changeMsg(<span class="hljs-string">&#x27;new message&#x27;</span>)&#125;&gt;changeMsg&lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br><br><span class="hljs-comment">// 父组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-comment">// 父组件提供状态数据</span><br>  state = &#123;<br>    message: <span class="hljs-string">&#x27;this is message&#x27;</span><br>  &#125;<br>  <span class="hljs-comment">// 父组件提供修改数据的方法</span><br>  changeMsg = <span class="hljs-function">(<span class="hljs-params">newMsg</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>      message: newMsg<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;&gt;<br>        &#123;<span class="hljs-comment">/*接收数据的组件*/</span>&#125;<br>        &lt;SonA msg=&#123;<span class="hljs-built_in">this</span>.state.message&#125; /&gt;<br>        &#123;<span class="hljs-comment">/*修改数据的组件*/</span>&#125;<br>        &lt;SonB changeMsg=&#123;<span class="hljs-built_in">this</span>.changeMsg&#125; /&gt;<br>      &lt;/&gt;<br>    )<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><h4 id="跨组件通信Context"><a href="#跨组件通信Context" class="headerlink" title="跨组件通信Context"></a>跨组件通信Context</h4><p>问题场景<br><img src="/imageO/react3.png" alt="Context"></p><blockquote><p>上图是一个react形成的嵌套组件树，如果我们想从App组件向任意一个下层组件传递数据，该怎么办呢？目前我们能采取的方式就是一层一层的props往下传，显然很繁琐</p></blockquote><blockquote><p>那么，Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法</p></blockquote><p>实现步骤</p><ol><li>创建Context对象 导出 Provider 和 Consumer对象</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> &#123; Provider, Consumer &#125; = createContext()<br></code></pre></td></tr></table></figure><ol start="2"><li>使用Provider包裹根组件提供数据</li></ol><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span> <span class="hljs-attr">value</span>=</span></span><span class="hljs-template-variable">&#123;this.state.message&#125;</span><span class="xml"><span class="hljs-tag">&gt;</span></span><br><span class="xml">    </span><span class="hljs-template-tag">&#123;/*根组件*/&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>需要用到数据的组件使用Consumer包裹获取数据</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;Consumer &gt;</span><br>    &#123;value =&gt; <span class="hljs-comment">/*基于 context 值进行渲染*/</span>&#125;<br><span class="hljs-params">&lt;/Consumer&gt;</span><br></code></pre></td></tr></table></figure><p>代码实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; createContext &#125;  <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-comment">// 1. 创建Context对象</span><br><span class="hljs-keyword">const</span> &#123; Provider, Consumer &#125; = createContext()<br><br><span class="hljs-comment">// 3. 消费数据</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ComC</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;Consumer &gt;<br>      &#123;<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;<br>    &lt;/Consumer&gt;<br>  )<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ComA</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;ComC/&gt;<br>  )<br>&#125;<br><br><span class="hljs-comment">// 2. 提供数据</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  state = &#123;<br>    message: <span class="hljs-string">&#x27;this is message&#x27;</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;Provider value=&#123;<span class="hljs-built_in">this</span>.state.message&#125;&gt;<br>        &lt;div className=<span class="hljs-string">&quot;app&quot;</span>&gt;<br>          &lt;ComA /&gt;<br>        &lt;/div&gt;<br>      &lt;/Provider&gt;<br>    )<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><h3 id="React组件进阶"><a href="#React组件进阶" class="headerlink" title="React组件进阶"></a>React组件进阶</h3><h4 id="children属性"><a href="#children属性" class="headerlink" title="children属性"></a>children属性</h4><p>children属性是什么</p><p>表示该组件的子节点，只要组件内部有子节点，props中就有该属性</p><p>children可以是什么</p><ol><li>普通文本</li><li>普通标签元素</li><li>函数</li><li>JSX</li></ol><h4 id="props校验-场景和使用"><a href="#props校验-场景和使用" class="headerlink" title="props校验-场景和使用"></a>props校验-场景和使用</h4><blockquote><p>对于组件来说，props是由外部传入的，我们其实无法保证组件使用者传入了什么格式的数据，如果传入的数据格式不对，就有可能会导致组件内部错误，有一个点很关键 - 组件的使用者可能报错了也不知道为什么，看下面的例子<br><img src="/imageO/react4.png" alt="props校验"><br>面对这样的问题，如何解决？<strong>props校验</strong></p></blockquote><p><strong>实现步骤</strong></p><ol><li>安装属性校验包：yarn add prop-types</li><li>导入prop-types 包</li><li>使用 组件名.propTypes = {} 给组件添加校验规则<br>核心代码</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;prop-types&#x27;</span><br><br><span class="hljs-keyword">const</span> List = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> arr = props.colors<br>  <span class="hljs-keyword">const</span> lis = arr.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span>&#123;item.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>)<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;lis&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>&#125;<br>List.propTypes = &#123;<br>  colors: PropTypes.array<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="props校验-规则说明"><a href="#props校验-规则说明" class="headerlink" title="props校验-规则说明"></a>props校验-规则说明</h4><p>四种常见结构</p><ol><li>常见类型：array、bool、func、number、object、string</li><li>React元素类型：element</li><li>必填项：isRequired</li><li>特定的结构对象：shape({})</li></ol><p><strong>核心代码</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 常见类型</span><br>optionalFunc: <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PropTypes</span>.</span></span>func,<br><span class="hljs-comment">// 必填 只需要在类型后面串联一个isRequired</span><br>requiredFunc: <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PropTypes</span>.</span></span>func.isRequired,<br><span class="hljs-comment">// 特定结构的对象</span><br>optionalObjectWithShape: <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PropTypes</span>.</span></span>shape(&#123;<br> color: <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PropTypes</span>.</span></span><span class="hljs-built_in">string</span>,<br> fontSize: <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PropTypes</span>.</span></span>number<br>&#125;)<br></code></pre></td></tr></table></figure><p>官网文档更多阅读：(<a href="https://reactjs.org/docs/typechecking-with-proptypes.html">https://reactjs.org/docs/typechecking-with-proptypes.html</a>)</p><h4 id="props校验-默认值"><a href="#props校验-默认值" class="headerlink" title="props校验-默认值"></a>props校验-默认值</h4><p>目标任务: 掌握如何给组件的props提供默认值</p><p>通过 defaultProps 可以给组件的props设置默认值，在未传入props的时候生效</p><ol><li>函数组件<br>直接使用函数参数默认值</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">List</span>(<span class="hljs-params">&#123;pageSize = <span class="hljs-number">10</span>&#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div&gt;<br>      此处展示props的默认值：&#123; pageSize &#125;<br>    &lt;/div&gt;<br>  )<br>&#125;<br><span class="hljs-comment">// 不传入pageSize属性</span><br>&lt;List /&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>类组件<br>使用类静态属性声明默认值，static defaultProps = {}</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  static defaultProps = &#123;<br>    pageSize: <span class="hljs-number">10</span><br>  &#125;<br><br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        此处展示props的默认值：&#123;<span class="hljs-keyword">this</span>.props.pageSize&#125;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br>&lt;<span class="hljs-type">List</span> /&gt;<br></code></pre></td></tr></table></figure><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://gitee.com/react-cp/react-pc-doc/blob/master/1.%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3/react-%E5%9F%BA%E7%A1%80.md#%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%84%8F%E4%B9%89">gitee</a><br><a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React初识&amp;&amp;生命周期&amp;&amp;Hooks</title>
    <link href="/2023/03/04/React%E5%88%9D%E8%AF%86&amp;&amp;%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&amp;&amp;Hooks/"/>
    <url>/2023/03/04/React%E5%88%9D%E8%AF%86&amp;&amp;%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&amp;&amp;Hooks/</url>
    
    <content type="html"><![CDATA[<p>学习react的笔记</p><hr><h3 id="生命周期-概述"><a href="#生命周期-概述" class="headerlink" title="生命周期 - 概述"></a>生命周期 - 概述</h3><p>组件的生命周期是指组件从被创建到挂载到页面中运行起来，再到组件不用时卸载的过程，注意，只有类组件才有生命周期（类组件 实例化 函数组件 不需要实例化）<br><img src="/imageO/react5.png" alt="生命周期"><br><a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></p><h4 id="生命周期-挂载阶段"><a href="#生命周期-挂载阶段" class="headerlink" title="生命周期 - 挂载阶段"></a>生命周期 - 挂载阶段</h4><p><img src="/imageO/react6.png" alt="挂载阶段"><br><img src="/imageO/react7.png" alt="挂载阶段"></p><h4 id="生命周期-更新阶段"><a href="#生命周期-更新阶段" class="headerlink" title="生命周期 - 更新阶段"></a>生命周期 - 更新阶段</h4><p><img src="/imageO/react8.png" alt="更新阶段"></p><h4 id="生命周期-卸载阶段"><a href="#生命周期-卸载阶段" class="headerlink" title="生命周期 - 卸载阶段"></a>生命周期 - 卸载阶段</h4><p>钩子函数 componentWillUnmount<br>触发时机 （组件卸载）（从页面中消失）<br>作用（执行清理工作（比如：清理定时器等））</p><h3 id="Hooks基础"><a href="#Hooks基础" class="headerlink" title="Hooks基础"></a>Hooks基础</h3><p>Hooks概念理解</p><h4 id="1-什么是hooks"><a href="#1-什么是hooks" class="headerlink" title="1. 什么是hooks"></a>1. 什么是hooks</h4><blockquote><p>Hooks的本质：一套能够使函数组件更强大，更灵活的“钩子”</p></blockquote><p>React体系里组件分为 <strong>类组件 和 函数组件</strong></p><p>经过多年的实战，函数组件是一个更加匹配React的设计理念 UI = f(data)，也更有利于逻辑拆分与重用的组件表达形式，而先前的函数组件是不可以有自己的状态的，为了能让函数组件可以拥有自己的状态，所以从react v16.8开始，Hooks应运而生</p><p>注意点：</p><ol><li>有了hooks之后，为了兼容老版本，class类组件并没有被移除，俩者都可以使用</li><li>有了hooks之后，不能在把函数成为无状态组件了，因为hooks为函数组件提供了状态<br>hooks只能在函数组件中使用</li></ol><h4 id="2-Hooks解决了什么问题"><a href="#2-Hooks解决了什么问题" class="headerlink" title="2. Hooks解决了什么问题"></a>2. Hooks解决了什么问题</h4><p>Hooks的出现解决了俩个问题 <strong>1. 组件的状态逻辑复用 2.class组件自身的问题</strong></p><ol><li>组件的逻辑复用</li></ol><p>在hooks出现之前，react先后尝试了 mixins混入，HOC高阶组件，render-props等模式</p><p>但是都有各自的问题，比如<strong>mixin的数据来源不清晰，高阶组件的嵌套问题</strong>等等</p><ol start="2"><li>class组件自身的问题</li></ol><p>class组件就像一个厚重的‘战舰’ 一样，大而全，提供了很多东西，有不可忽视的学习成本，比如各种生命周期，this指向问题等等，而我们更多时候需要的是一个轻快灵活的’快艇’</p><h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h4><h5 id="1-基础使用"><a href="#1-基础使用" class="headerlink" title="1. 基础使用"></a>1. 基础使用</h5><p>作用 :useState为函数组件提供状态（state）</p><p>使用步骤</p><ol><li>导入 useState 函数</li><li>调用 useState 函数，并传入状态的初始值</li><li>从useState函数的返回值中，拿到状态和修改状态的方法</li><li>在JSX中展示状态</li><li>调用修改状态的方法更新状态<br>代码实现</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 参数：状态初始值比如,传入 0 表示该状态的初始值为 0</span><br>  <span class="hljs-comment">// 返回值：数组,包含两个值：1 状态值（state） 2 修改该状态的函数（setState）</span><br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">return</span> (<br>    &lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> &#123; setCount(count + <span class="hljs-number">1</span>) &#125;&#125;&gt;&#123;count&#125;&lt;/button&gt;<br>  )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><h5 id="2-状态的读取和修改"><a href="#2-状态的读取和修改" class="headerlink" title="2. 状态的读取和修改"></a>2. 状态的读取和修改</h5><p>读取状态<br>该方式提供的状态，是函数内部的局部变量，可以在函数内的任意位置使用</p><p>修改状态</p><ol><li>setCount是一个函数，参数表示最新的状态值</li><li>调用该函数后，将使用新值替换旧值</li><li>修改状态后，由于状态发生变化，会引起视图变化<br>注意事项<br>修改状态的时候，一定要使用新的状态替换旧的状态，不能直接修改旧的状态，尤其是引用类型</li></ol><h5 id="3-组件的更新过程"><a href="#3-组件的更新过程" class="headerlink" title="3. 组件的更新过程"></a>3. 组件的更新过程</h5><p>函数组件使用 useState hook 后的执行过程，以及状态值的变化</p><ul><li>组件第一次渲染</li></ul><ol><li>从头开始执行该组件中的代码逻辑</li><li>调用 useState(0) 将传入的参数作为状态初始值，即：0</li><li>渲染组件，此时，获取到的状态 count 值为： 0</li></ol><ul><li>组件第二次渲染</li></ul><ol><li>点击按钮，调用 setCount(count + 1) 修改状态，因为状态发生改变，所以，该组件会重新渲染</li><li>组件重新渲染时，会再次执行该组件中的代码逻辑</li><li>再次调用 useState(0)，此时 <strong>React 内部会拿到最新的状态值而非初始值</strong>，比如，该案例中最新的状态值为 1</li><li>再次渲染组件，此时，获取到的状态 count 值为：1<br>注意：<strong>useState 的初始值(参数)只会在组件第一次渲染时生效</strong>。也就是说，以后的每次渲染，useState 获取到都是最新的状态值，React 组件会记住每次最新的状态值</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>)<br>  <span class="hljs-comment">// 在这里可以进行打印测试</span><br>  <span class="hljs-built_in">console</span>.log(count)<br>  <span class="hljs-keyword">return</span> (<br>    &lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> &#123; setCount(count + <span class="hljs-number">1</span>) &#125;&#125;&gt;&#123;count&#125;&lt;/button&gt;<br>  )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><h5 id="4-使用规则"><a href="#4-使用规则" class="headerlink" title="4. 使用规则"></a>4. 使用规则</h5><ol><li>useState 函数可以执行多次，每次执行互相独立，每调用一次为函数组件提供一个状态</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">List</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">// 以字符串为初始值</span><br>  <span class="hljs-keyword">const</span> [name, setName] = useState(<span class="hljs-string">&#x27;cp&#x27;</span>)<br>  <span class="hljs-comment">// 以数组为初始值</span><br>  <span class="hljs-keyword">const</span> [list,setList] = useState([])<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>useState 注意事项</li></ol><p>只能出现在函数组件中</p><p>不能嵌套在if/for/其它函数中（react按照hooks的调用顺序识别每一个hook）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart">let <span class="hljs-built_in">num</span> = <span class="hljs-number">1</span><br>function <span class="hljs-built_in">List</span>()&#123;<br>  <span class="hljs-built_in">num</span>++<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">num</span> / <span class="hljs-number">2</span> === <span class="hljs-number">0</span>)&#123;<br>     <span class="hljs-keyword">const</span> [name, setName] = useState(<span class="hljs-string">&#x27;cp&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">const</span> [list,setList] = useState([])<br>&#125;<br><span class="hljs-comment">// 俩个hook的顺序不是固定的，这是不可以的！！！</span><br><br></code></pre></td></tr></table></figure><ol start="3"><li>可以通过开发者工具查看hooks状态</li></ol><h4 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h4><h5 id="1-理解函数副作用"><a href="#1-理解函数副作用" class="headerlink" title="1. 理解函数副作用"></a>1. 理解函数副作用</h5><p>什么是副作用</p><p>​副作用是相对于主作用来说的，一个函数除了主作用，其他的作用就是副作用。对于 React 组件来说，<strong>主作用就是根据数据（state/props）渲染 UI</strong>，除此之外都是副作用（比如，手动修改 DOM）</p><p><strong>常见的副作用</strong></p><p>数据请求 ajax发送<br>手动修改dom<br>localstorage操作</p><p>useEffect函数的作用就是为react函数组件提供副作用处理的！</p><h5 id="2-基础使用"><a href="#2-基础使用" class="headerlink" title="2. 基础使用"></a>2. 基础使用</h5><p>作用： 为react函数组件提供副作用处理<br><strong>使用步骤</strong></p><ol><li>导入 useEffect 函数</li><li>调用 useEffect 函数，并传入回调函数</li><li>在回调函数中编写副作用处理（dom操作）</li><li>修改数据状态</li><li>检测副作用是否生效<br>代码实现</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useEffect, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>)<br><br>  useEffect(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-comment">// dom操作</span><br>    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`当前已点击了<span class="hljs-subst">$&#123;count&#125;</span>次`</span><br>  &#125;)<br>  <span class="hljs-keyword">return</span> (<br>    &lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> &#123; setCount(count + <span class="hljs-number">1</span>) &#125;&#125;&gt;&#123;count&#125;&lt;/button&gt;<br>  )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><h5 id="3-依赖项控制执行时机"><a href="#3-依赖项控制执行时机" class="headerlink" title="3. 依赖项控制执行时机"></a>3. 依赖项控制执行时机</h5><ol><li>不添加依赖项</li></ol><blockquote><p>组件首次渲染执行一次，以及不管是哪个状态更改引起组件更新时都会重新执行</p></blockquote><ol><li>组件初始渲染</li><li>组件更新 （不管是哪个状态引起的更新）</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;副作用执行了&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>添加空数组</li></ol><p><strong>组件只在首次渲染时执行一次</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">useEffect</span><span class="hljs-params">(()</span></span>=&gt;&#123;<br>  console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;副作用执行了&#x27;</span>)<br>&#125;,<span class="hljs-selector-attr">[]</span>)<br></code></pre></td></tr></table></figure><ol start="3"><li>添加特定依赖项</li></ol><p><strong>副作用函数在首次渲染时执行，在依赖项发生变化时重新执行</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <br>    <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">const</span> [name, setName] = useState(<span class="hljs-string">&#x27;zs&#x27;</span>)<br><br>    useEffect(<span class="hljs-function">() =&gt;</span> &#123;    <br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;副作用执行了&#x27;</span>)  <br>    &#125;, [count])  <br>    <br>    <span class="hljs-keyword">return</span> (    <br>        &lt;&gt;      <br>         &lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> &#123; setCount(count + <span class="hljs-number">1</span>) &#125;&#125;&gt;&#123;count&#125;&lt;/button&gt;      <br>         &lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> &#123; setName(<span class="hljs-string">&#x27;cp&#x27;</span>) &#125;&#125;&gt;&#123;name&#125;&lt;/button&gt;    <br>        &lt;/&gt;  <br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>注意事项<br><strong>useEffect 回调函数中用到的数据（比如，count）就是依赖数据，就应该出现在依赖项数组中，如果不添加依赖项就会有bug出现</strong></p><h4 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h4><p>需求描述：自定义一个hook函数，实现获取滚动距离Y<br>const [y] = useWindowScroll()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useWindowScroll</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [y, setY] = useState(<span class="hljs-number">0</span>)<br>  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> h = <span class="hljs-built_in">document</span>.documentElement.scrollTop<br>    setY(h)<br>  &#125;)<br>  <span class="hljs-keyword">return</span> [y]<br>&#125;<br></code></pre></td></tr></table></figure><p>需求描述： 自定义hook函数，可以自动同步到本地LocalStorage<br>const [message, setMessage] = useLocalStorage(key，defaultValue)<br>message可以通过自定义传入默认初始值<br>每次修改message数据的时候 都会自动往本地同步一份</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sas">import &#123; useEffect, useState &#125; <span class="hljs-meta">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br>export function useLocalStorage (<span class="hljs-meta">key</span>, defaultValue) &#123;<br>  const [<span class="hljs-meta">message</span>, setMessage] = useState(defaultValue)<br>  // 每次只要<span class="hljs-meta">message</span>变化 就会自动同步到本地ls<br>  useEffect(() =&gt; &#123;<br>    <span class="hljs-meta">window</span>.localStorage.setItem(<span class="hljs-meta">key</span>, <span class="hljs-meta">message</span>)<br>  &#125;, [<span class="hljs-meta">message</span>, <span class="hljs-meta">key</span>])<br>  <span class="hljs-meta">return</span> [<span class="hljs-meta">message</span>, setMessage]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Hooks进阶"><a href="#Hooks进阶" class="headerlink" title="Hooks进阶"></a>Hooks进阶</h3><h4 id="useState-回调函数的参数"><a href="#useState-回调函数的参数" class="headerlink" title="useState - 回调函数的参数"></a>useState - 回调函数的参数</h4><p>能够理解useState回调函数作为参数的使用场景</p><p><strong>使用场景</strong></p><p>参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过计算才能获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用</p><p>语法</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const [name, setName] = useState(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;    <span class="hljs-regexp">//</span> 编写计算逻辑    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;计算之后的初始值&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><p><strong>语法规则</strong></p><ol><li>回调函数return出去的值将作为 name 的初始值</li><li>回调函数中的逻辑只会在组件初始化的时候执行一次</li></ol><p><strong>语法选择</strong></p><ol><li>如果就是初始化一个普通的数据 直接使用 useState(普通数据) 即可</li><li>如果要初始化的数据无法直接得到需要通过计算才能获取到，使用useState(()=&gt;{})<br>来个需求<br><img src="/imageO/react9.png" alt="实现"></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> props.count<br>  &#125;)<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div&gt;<br>      &lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> setCount(count + <span class="hljs-number">1</span>)&#125;&gt;&#123;count&#125;&lt;/button&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;&gt;<br>      &lt;Counter count=&#123;<span class="hljs-number">10</span>&#125; /&gt;<br>      &lt;Counter count=&#123;<span class="hljs-number">20</span>&#125; /&gt;<br>    &lt;/&gt;<br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><h4 id="useEffect-清理副作用"><a href="#useEffect-清理副作用" class="headerlink" title="useEffect - 清理副作用"></a>useEffect - 清理副作用</h4><ol><li>使用场景<br>在组件被销毁时，如果有些副作用操作需要被清理，就可以使用此语法，比如常见的定时器</li></ol><p>语法及规则</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    console.log(<span class="hljs-string">&#x27;副作用函数执行了&#x27;</span>)<br>    <span class="hljs-comment">// 副作用函数的执行时机为: 在下一次副作用函数执行之前执行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        console.log(<span class="hljs-string">&#x27;清理副作用的函数执行了&#x27;</span>)<br>        <span class="hljs-comment">// 在这里写清理副作用的代码</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>定时器小案例</li></ol><p>添加副作用函数前：组件虽然已经不显示了，但是定时器依旧在运行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useEffect, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>&#123;  <br>    useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;副作用函数执行了&#x27;</span>)<br>        &#125;, <span class="hljs-number">1000</span>)  <br>    &#125;)<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Foo<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <br>    <span class="hljs-keyword">const</span> [flag, setFlag] = useState(<span class="hljs-literal">true</span>)  <br>    <span class="hljs-keyword">return</span> (<br>        &lt;&gt;<br>          &lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> setFlag(<span class="hljs-literal">false</span>)&#125;&gt;click&lt;/button&gt;<br>         &#123;flag ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Foo</span>/&gt;</span></span> : <span class="hljs-literal">null</span>&#125;<br>        &lt;/&gt;  <br>    )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><blockquote><p>添加清理副作用函数后：一旦组件被销毁，定时器也被清理</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useEffect, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>&#123;  <br>    useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> timerId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;副作用函数执行了&#x27;</span>)<br>        &#125;, <span class="hljs-number">1000</span>)<br>        <span class="hljs-comment">// 添加清理副作用函数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-built_in">clearInterval</span>(timerId)<br>        &#125;  <br>    &#125;)  <br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Foo<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <br>    <span class="hljs-keyword">const</span> [flag, setFlag] = useState(<span class="hljs-literal">true</span>)  <br>    <span class="hljs-keyword">return</span> (<br>        &lt;&gt;<br>          &lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> setFlag(<span class="hljs-literal">false</span>)&#125;&gt;click&lt;/button&gt;<br>         &#123;flag ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Foo</span>/&gt;</span></span> : <span class="hljs-literal">null</span>&#125;<br>        &lt;/&gt;<br>    )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><h5 id="useEffect-发送网络请求"><a href="#useEffect-发送网络请求" class="headerlink" title="useEffect - 发送网络请求"></a>useEffect - 发送网络请求</h5><p> 能够掌握使用useEffect hook发送网络请求</p><ol><li>使用场景</li></ol><p>如何在useEffect中发送网络请求，并且封装同步 async await操作</p><ol start="2"><li>语法要求</li></ol><p>不可以直接在useEffect的回调函数外层直接包裹 await ，因为<strong>异步会导致清理函数无法立即返回</strong></p><p>useEffect(async ()=&gt;{<br>    const res = await axios.get(‘<a href="http://geek.itheima.net/v1_0/channels&#39;">http://geek.itheima.net/v1_0/channels&#39;</a>)<br>    console.log(res)<br>},[])<br>3. 正确写法</p><p><strong>在内部单独定义一个函数，然后把这个函数包装成同步</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">useEffect(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchData</span>(<span class="hljs-params"></span>)</span>&#123;<br>       <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> axios.get(<span class="hljs-string">&#x27;http://geek.itheima.net/v1_0/channels&#x27;</span>)                            <span class="hljs-built_in">console</span>.log(res)<br>    &#125;<br>&#125;,[])<br></code></pre></td></tr></table></figure><h4 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h4><p>能够掌握使用useRef获取真实dom或组件实例的方法</p><h5 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1. 使用场景"></a>1. 使用场景</h5><p>在函数组件中获取真实的dom元素对象或者是组件对象</p><h5 id="2-使用步骤"><a href="#2-使用步骤" class="headerlink" title="2. 使用步骤"></a>2. 使用步骤</h5><ol><li>导入 useRef 函数</li><li>执行 useRef 函数并传入null，返回值为一个对象 内部有一个current属性存放拿到的dom对象（组件实例）</li><li>通过ref 绑定 要获取的元素或者组件</li></ol><p><strong>获取dom</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useEffect, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <br>    <span class="hljs-keyword">const</span> h1Ref = useRef(<span class="hljs-literal">null</span>)  <br>    useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(h1Ref)  <br>    &#125;,[])  <br>    <span class="hljs-keyword">return</span> (<br>        &lt;div&gt;<br>            &lt;h1 ref=&#123; h1Ref &#125;&gt;<span class="hljs-built_in">this</span> is h1&lt;/h1&gt;<br>        &lt;/div&gt;  <br>    )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><p><strong>获取组件实例</strong></p><blockquote><p>函数组件由于没有实例，不能使用ref获取，如果想获取组件实例，必须是类组件</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Foo.js<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <br>    sayHi = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;say hi&#x27;</span>)  <br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Foo<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  <br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Foo<br><br>App.js<br><br><span class="hljs-keyword">import</span> &#123; useEffect, useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> Foo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Foo&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <br>    <span class="hljs-keyword">const</span> h1Foo = useRef(<span class="hljs-literal">null</span>)  <br>    useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(h1Foo)  <br>    &#125;, [])  <br>    <span class="hljs-keyword">return</span> (<br>        &lt;div&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Foo</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">h1Foo</span> &#125; /&gt;</span></span>&lt;/div&gt;  <br>    )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><h4 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h4><p> 能够掌握hooks下的context使用方式</p><p><strong>实现步骤</strong></p><ol><li>使用createContext 创建Context对象</li><li>在顶层组件通过Provider 提供数据</li><li>在底层组件通过useContext函数获取数据<br>代码实现</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createContext, useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-comment">// 创建Context对象</span><br><span class="hljs-keyword">const</span> Context = createContext()<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>&#123;  <br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Foo <span class="hljs-tag">&lt;<span class="hljs-name">Bar</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>) </span>&#123;  <br>    <span class="hljs-comment">// 底层组件通过useContext函数获取数据  </span><br>    <span class="hljs-keyword">const</span> name = useContext(Context)  <br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Bar &#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <br>    <span class="hljs-keyword">return</span> (<br>        <span class="hljs-comment">// 顶层组件通过Provider 提供数据</span><br>        &lt;Context.Provider value=&#123;<span class="hljs-string">&#x27;this is name&#x27;</span>&#125;&gt;<br>            &lt;div&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Foo</span>/&gt;</span></span>&lt;/div&gt;<br>        &lt;/Context.Provider&gt;  <br>    )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App<br></code></pre></td></tr></table></figure><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://gitee.com/react-cp/react-pc-doc/blob/master/1.%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3/react-%E5%9F%BA%E7%A1%80.md#%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%84%8F%E4%B9%89">gitee</a><br><a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Js基础-类型判断等笔记</title>
    <link href="/2022/10/30/Js%E5%9F%BA%E7%A1%80+%E5%9F%BA%E7%A1%80%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
    <url>/2022/10/30/Js%E5%9F%BA%E7%A1%80+%E5%9F%BA%E7%A1%80%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h3 id="一、js中的数字0就是false，非0为true。-！表示取反。"><a href="#一、js中的数字0就是false，非0为true。-！表示取反。" class="headerlink" title="一、js中的数字0就是false，非0为true。 ！表示取反。"></a>一、js中的数字0就是false，非0为true。 ！表示取反。</h3><ol><li><p>!0–false取反–true；</p></li><li><p>!!0–false双重取反–false；</p></li><li><p>!1–true取反–false；</p></li><li><p>!!1–双重取反–true；</p></li><li><p>!-1–true取反–false;</p></li><li><p>!!-1–true双重取反–true。</p></li></ol><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><!-- [【JS迷你书】类型转换之装箱操作](https://juejin.cn/post/6844903827347341325) -->]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出Vite&amp;&amp;(3)</title>
    <link href="/2022/05/05/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAVite%E7%AC%94%E8%AE%B0(3)/"/>
    <url>/2022/05/05/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAVite%E7%AC%94%E8%AE%B0(3)/</url>
    
    <content type="html"><![CDATA[<p>大家都知道， Vite 是一个提倡 no-bundle 的构建工具，相比于传统的 Webpack，能做到开发时的模块按需编译，而不用先打包完再加载。</p><p>需要注意的是，我们所说的模块代码其实分为两部分，<strong>一部分是源代码，也就是业务代码，另一部分是第三方依赖的代码，即node_modules中的代码</strong>。所谓的<strong>no-bundle只是对于源代码</strong>而言，对于第三方依赖而言，Vite 还是选择 bundle(打包)，并且使用速度极快的打包器 Esbuild 来完成这一过程，达到秒级的依赖编译速度。</p><hr><h3 id="为什么需要预构建"><a href="#为什么需要预构建" class="headerlink" title="为什么需要预构建?"></a>为什么需要预构建?</h3><p>总之，依赖预构建主要做了两件事情：</p><h4 id="一是将其他格式-如-UMD-和-CommonJS-的产物转换为-ESM-格式-，使其在浏览器通过-lt-script-type-quot-module-quot-gt-lt-script-gt-的方式正常加载"><a href="#一是将其他格式-如-UMD-和-CommonJS-的产物转换为-ESM-格式-，使其在浏览器通过-lt-script-type-quot-module-quot-gt-lt-script-gt-的方式正常加载" class="headerlink" title="一是将其他格式**(如 UMD 和 CommonJS)的产物转换为 ESM 格式**，使其在浏览器通过 &lt;script type=&quot;module&quot;&gt;&lt;script&gt;的方式正常加载"></a>一是将其他格式**(如 UMD 和 CommonJS)的产物转换为 ESM 格式**，使其在浏览器通过 <code>&lt;script type=&quot;module&quot;&gt;&lt;script&gt;</code>的方式正常加载</h4><h4 id="二是打包第三方库的代码，将各个第三方库分散的文件合并到一起，减少-HTTP-请求数量，避免页面加载性能劣化"><a href="#二是打包第三方库的代码，将各个第三方库分散的文件合并到一起，减少-HTTP-请求数量，避免页面加载性能劣化" class="headerlink" title="二是打包第三方库的代码，将各个第三方库分散的文件合并到一起，减少 HTTP 请求数量，避免页面加载性能劣化"></a>二是打包第三方库的代码，将<strong>各个第三方库分散的文件合并到一起，减少 HTTP 请求数量</strong>，避免页面加载性能劣化</h4><p>此外，还有一个比较重要的问题——<strong>请求瀑布流问题</strong>。比如说，知名的loadsh-es库本身是有 ES 版本产物的，可以在 Vite 中直接运行。但实际上，它在加载时会发出特别多的请求，导致页面加载的前几秒几都乎处于卡顿状态，拿一个简单的 demo 项目举例，<br>我在应用代码中调用了debounce方法，这个方法会依赖很多工具函数，如下图所示:<br><img src="/imageO/vite4.jpg" alt="请求如图"><br>每个import都会触发一次新的文件请求，因此在这种<strong>依赖层级深、涉及模块数量多</strong>的情况下，会触发成百上千个网络请求，巨大的请求量加上 Chrome 对同一个域名下只能同时支持 6 个 HTTP 并发请求的限制，导致页面加载十分缓慢，与 Vite 主导性能优势的初衷背道而驰。不过，在进行<strong>依赖的预构建</strong>之后，lodash-es这个库的代码被打包成了一个文件，这样请求的数量会骤然减少，页面加载也快了许多。</p><p>而这两件事情全部由性能优异的 **Esbuild (基于 Golang 开发)**完成，而不是传统的 Webpack/Rollup，所以也不会有明显的打包性能问题，反而是 Vite 项目启动飞快(秒级启动)的一个核心原因。</p><blockquote><p>ps: Vite 1.x 使用了 Rollup 来进行依赖预构建，在 2.x 版本将 Rollup 换成了 Esbuild，编译速度提升了近 100 倍！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Vite</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端进阶</tag>
      
      <tag>Vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>现代包管理器--pnpm &amp;&amp; nvm node版本管理工具</title>
    <link href="/2022/04/30/%E7%8E%B0%E4%BB%A3%E7%AE%A1%E7%90%86%E5%99%A8pnpm/"/>
    <url>/2022/04/30/%E7%8E%B0%E4%BB%A3%E7%AE%A1%E7%90%86%E5%99%A8pnpm/</url>
    
    <content type="html"><![CDATA[<p>这篇文章给大家分享一个业内一款出色的包管理器——pnpm。目前 GitHub 已经有 star 9.8k，现在已经相对成熟且稳定了。它由 npm/yarn 衍生而来，但却解决了 npm/yarn 内部潜在的 bug，并且极大了地优化了性能，扩展了使用场景</p><hr><h2 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h2><h3 id="一、什么是-pnpm"><a href="#一、什么是-pnpm" class="headerlink" title="一、什么是 pnpm ?"></a>一、什么是 pnpm ?</h3><p>pnpm 的官方文档是这样说的:</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Fast, disk space efficient <span class="hljs-keyword">package</span> <span class="hljs-title">manager</span><br></code></pre></td></tr></table></figure><p>因此，pnpm 本质上就是一个包管理器，这一点跟 npm/yarn 没有区别，但它作为杀手锏的两个优势在于:</p><ol><li>包安装速度极快；</li><li>磁盘空间利用非常高效。</li></ol><p>它的安装也非常简单。可以有多简单?</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -g pnpm<br></code></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h4 id="1-速度快"><a href="#1-速度快" class="headerlink" title="1. 速度快"></a>1. 速度快</h4><p>在绝多大数场景下，包安装的速度都是明显优于 npm/yarn，速度会比 npm/yarn 快 2-3 倍。  </p><h4 id="2-高效利用磁盘空间"><a href="#2-高效利用磁盘空间" class="headerlink" title="2. 高效利用磁盘空间"></a>2. 高效利用磁盘空间</h4><p>pnpm 内部使用<strong>基于内容寻址</strong>的文件系统来存储磁盘上所有的文件，这个文件系统出色的地方在于:</p><ul><li><p>不会重复安装同一个包。用 npm/yarn 的时候，如果 100 个项目都依赖 lodash，那么 lodash 很可能就被安装了 100 次，磁盘中就有 100 个地方写入了这部分代码。但在使用 pnpm 只会安装一次，磁盘中只有一个地方写入，后面再次使用都会直接使用 hardlink<a href="https://www.cnblogs.com/itech/archive/2009/04/10/1433052.html">硬链接</a></p></li><li><p>即使一个包的不同版本，<strong>pnpm 也会极大程度地复用之前版本的代码</strong>。举个例子，比如 lodash 有 100 个文件，更新版本之后多了一个文件，那么磁盘当中并不会重新写入 101 个文件，而是保留原来的 100 个文件的 hardlink，仅仅写入那一个新增的文件。</p></li></ul><h4 id="3-支持-monorepo"><a href="#3-支持-monorepo" class="headerlink" title="3. 支持 monorepo"></a>3. 支持 monorepo</h4><p>随着前端工程的日益复杂，越来越多的项目开始使用 monorepo。之前对于多个项目的管理，我们一般都是使用多个 git 仓库，但 monorepo 的宗旨就是用一个 git 仓库来管理多个子项目，所有的子项目都存放在根目录的packages目录下，那么一个子项目就代表一个package。如果你之前没接触过 monorepo 的概念，建议仔细看看这篇文章以及开源的 monorepo 管理工具lerna，项目目录结构可以参考一下 babel 仓库。<br>pnpm 与 npm/yarn 另外一个很大的不同就是支持了 monorepo，体现在各个子命令的功能上，比如在根目录下 pnpm add A -r, 那么所有的 package 中都会被添加 A 这个依赖，当然也支持 –filter字段来对 package 进行过滤。</p><h4 id="4-安全性高"><a href="#4-安全性高" class="headerlink" title="4. 安全性高"></a>4. 安全性高</h4><p>之前在使用 npm/yarn 的时候，由于 node_module 的扁平结构，如果 A 依赖 B， B 依赖 C，那么 A 当中是可以直接使用 C 的，但问题是 A 当中并没有声明 C 这个依赖。因此会出现这种非法访问的情况。但 pnpm 脑洞特别大，自创了一套依赖管理方式，很好地解决了这个问题，保证了安全性，具体怎么体现<strong>安全</strong>、规避非法访问依赖的<strong>风险</strong>的，后面再来详细说说。</p><h3 id="三、依赖管理"><a href="#三、依赖管理" class="headerlink" title="三、依赖管理"></a>三、依赖管理</h3><p>npm/yarn install 原理<br>主要分为两个部分, 首先，执行 npm/yarn install之后，包如何到达项目 node_modules 当中。其次，node_modules 内部如何管理依赖。<br>执行命令后，首先会构建依赖树，然后针对每个节点下的包，会经历下面四个步骤:</p><ol><li>将依赖包的版本区间解析为某个具体的版本号</li><li>下载对应版本依赖的 tar 包到本地离线镜像</li><li>将依赖从离线镜像解压到本地缓存</li><li>将依赖从缓存拷贝到当前目录的 node_modules 目录</li><li>然后，对应的包就会到达项目的node_modules当中。<br>那么，这些依赖在node_modules内部是什么样的目录结构呢，换句话说，项目的依赖树是什么样的呢？<br>在 npm1、npm2 中呈现出的是嵌套结构，比如下面这样:</li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">node_modules<br>└─ foo<br>   ├─ index.<span class="hljs-keyword">js</span><br><span class="hljs-keyword"> </span>  ├─ package.<span class="hljs-keyword">json</span><br><span class="hljs-keyword"> </span>  └─ node_modules<br>      └─ <span class="hljs-keyword">bar</span><br><span class="hljs-keyword"> </span>        ├─ index.<span class="hljs-keyword">js</span><br><span class="hljs-keyword"> </span>        └─ package.<span class="hljs-keyword">json</span><br></code></pre></td></tr></table></figure><p>如果 bar 当中又有依赖，那么又会继续嵌套下去。试想一下这样的设计存在什么问题:</p><p>依赖层级太深，会导致文件路径过长的问题，尤其在 window 系统下。<br>大量重复的包被安装，文件体积超级大。比如跟 foo 同级目录下有一个baz，两者都依赖于同一个版本的lodash，那么 lodash 会分别在两者的 node_modules 中被安装，也就是重复安装。<br>模块实例不能共享。比如 React 有一些内部变量，在两个不同包引入的 React 不是同一个模块实例，因此无法共享内部变量，导致一些不可预知的 bug。</p><p>接着，从 npm3 开始，包括 yarn，都着手来通过扁平化依赖的方式来解决这个问题。相信大家都有这样的体验，我明明就装个 express，为什么 node_modules里面多了这么多东西？<br>没错，这就是扁平化依赖管理的结果。相比之前的嵌套结构，现在的目录结构类似下面这样:<br>node_modules<br>├─ foo<br>|  ├─ index.js<br>|  └─ package.json<br>└─ bar<br>   ├─ index.js<br>   └─ package.json<br>所有的依赖都被拍平到node_modules目录下，不再有很深层次的嵌套关系。这样在安装新的包时，根据 node require 机制，会不停往上级的node_modules当中去找，如果找到相同版本的包就不会重新安装，解决了大量包重复安装的问题，而且依赖层级也不会太深。<br>之前的问题是解决了，但仔细想想这种扁平化的处理方式，它真的就是无懈可击吗？并不是。它照样存在诸多问题，梳理一下:</p><ol><li><p>依赖结构的不确定性。</p></li><li><p>扁平化算法本身的复杂性很高，耗时较长。</p></li><li><p>项目中仍然可以非法访问没有声明过依赖的包<br><a href="https://juejin.cn/post/6932046455733485575#heading-8">掘金</a></p></li></ol><h4 id="pnpm-依赖管理"><a href="#pnpm-依赖管理" class="headerlink" title="pnpm 依赖管理"></a>pnpm 依赖管理</h4><p>pnpm 的作者Zoltan Kochan发现 yarn 并没有打算去解决上述的这些问题，于是另起炉灶，写了全新的包管理器，开创了一套新的依赖管理机制，现在就让我们去一探究竟。<br>还是以安装 express 为例，我们新建一个目录，执行:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pnpm <span class="hljs-keyword">init</span> -y<br></code></pre></td></tr></table></figure><p>然后执行:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pnpm <span class="hljs-keyword">install</span> express<br></code></pre></td></tr></table></figure><p>我们再去看看node_modules:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.pnpm<br><span class="hljs-selector-class">.modules</span>.yaml<br>express<br></code></pre></td></tr></table></figure><h3 id="四、再谈安全"><a href="#四、再谈安全" class="headerlink" title="四、再谈安全"></a>四、再谈安全</h3><p>不知道你发现没有，pnpm 这种依赖管理的方式也很巧妙地规避了非法访问依赖的问题，也就是只要一个包未在 package.json 中声明依赖，那么在项目中是无法访问的。</p><p>但在 npm/yarn 当中是做不到的，那你可能会问了，如果 A 依赖 B， B 依赖 C，那么 A 就算没有声明 C 的依赖，由于有依赖提升的存在，C 被装到了 A 的node_modules里面，那我在 A 里面用 C，跑起来没有问题呀，我上线了之后，也能正常运行啊。不是挺安全的吗？<br>还真不是。</p><h3 id="pnpm使用"><a href="#pnpm使用" class="headerlink" title="pnpm使用"></a>pnpm使用</h3><h4 id="pnpm-install"><a href="#pnpm-install" class="headerlink" title="pnpm install"></a>pnpm install</h4><p>跟 npm install 类似，安装项目下所有的依赖。但对于 monorepo 项目，会安装 workspace 下面所有 packages 的所有依赖。不过可以通过 –filter 参数来指定 package，只对满足条件的 package 进行依赖安装。<br>当然，也可以这样使用，来进行单个包的安装:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 安装 axios<br>pnpm install axios<br><span class="hljs-regexp">//</span> 安装 axios 并将 axios 添加至 devDependencies<br>pnpm install axios -D<br><span class="hljs-regexp">//</span> 安装 axios 并将 axios 添加至 dependencies<br>pnpm install axios -S<br></code></pre></td></tr></table></figure><p>当然，也可以通过 –filter 来指定 package。</p><h4 id="pnpm-update"><a href="#pnpm-update" class="headerlink" title="pnpm update"></a>pnpm update</h4><p>根据指定的范围将包更新到最新版本，monorepo 项目中可以通过 –filter 来指定 package。</p><h4 id="pnpm-uninstall"><a href="#pnpm-uninstall" class="headerlink" title="pnpm uninstall"></a>pnpm uninstall</h4><p>在 node_modules 和 package.json 中移除指定的依赖。monorepo 项目同上。举例如下:<br>// 移除 axios</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">pnpm uninstall axios <span class="hljs-comment">--filter package-a</span><br></code></pre></td></tr></table></figure><h4 id="pnpm-link"><a href="#pnpm-link" class="headerlink" title="pnpm link"></a>pnpm link</h4><p>将本地项目连接到另一个项目。注意，使用的是硬链接，而不是软链接。如:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">pnpm link ..<span class="hljs-regexp">/../</span>axios<br></code></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6932046455733485575#heading-10">关于现代包管理器的深度思考——为什么现在我更推荐 pnpm 而不是 npm/yarn?</a></p><h2 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h2><h3 id="nvm-使用场景"><a href="#nvm-使用场景" class="headerlink" title="nvm 使用场景"></a>nvm 使用场景</h3><p>node version manager（node版本管理工具）</p><p>通过将多个node 版本安装在指定路径，然后通过 nvm 命令切换时，就会切换我们环境变量中 node 命令指定的实际执行的软件路径。</p><p>使用场景：比如我们手上同时在做好几个项目，这些项目的需求都不太一样，导致了这些个项目需要依赖的nodejs版本也不同，这种情况下，我们就可以通过nvm来切换nodejs的版本，而不需要频繁地下载/卸载不同版本的nodejs来满足当前项目的要求</p><h3 id="windows系统下的nvm-安装"><a href="#windows系统下的nvm-安装" class="headerlink" title="windows系统下的nvm 安装"></a>windows系统下的nvm 安装</h3><ol><li>下载<br><a href="https://github.com/coreybutler/nvm-windows/releases">链接</a><br><a href="https://github.com/nvm-sh/nvm">官网–GitHub</a><br>可下载以下版本：</li></ol><p>nvm-noinstall.zip：绿色免安装版，但使用时需要进行配置。</p><p>nvm-setup.zip：安装版，推荐使用</p><ol start="2"><li>安装（nvm-setup)<br>双击解压后的文件nvm-setup.exe<br>选择nvm安装路径<br>遇坑警告！！！！！</li></ol><p>这里我一开始选择的路径为 C:\Program Files\nvm<br>在安装完成后，执行 nvm use 14.5.0 的时候，出现了：<br>exit code 1:‘D:\Program’ #%$#^%$^%&amp;%&amp;@#的问题（后面这些符号表示当时报错时候的乱码……）<br>查阅了一些前人的经验后得知，问题的原因是Program Files 这个文件名中含有空格@_@<br><strong>所以，各位在选择文件夹的时候，需要注意，文件夹名不要出现 中文 和 空格。</strong></p><h3 id="3-使用nvm"><a href="#3-使用nvm" class="headerlink" title="3. 使用nvm"></a>3. 使用nvm</h3><h4 id="nvm-list-命令-显示版本列表"><a href="#nvm-list-命令-显示版本列表" class="headerlink" title="nvm list 命令 - 显示版本列表"></a>nvm list 命令 - 显示版本列表</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">nvm list <span class="hljs-regexp">//</span> 显示已安装的版本（同 nvm list installed）<br>nvm list installed <span class="hljs-regexp">//</span> 显示已安装的版本<br>nvm list available <span class="hljs-regexp">//</span> 显示所有可以下载的版本<br></code></pre></td></tr></table></figure><h4 id="nvm-install-命令-安装指定版本nodejs"><a href="#nvm-install-命令-安装指定版本nodejs" class="headerlink" title="nvm install 命令 - 安装指定版本nodejs"></a>nvm install 命令 - 安装指定版本nodejs</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nvm</span> install <span class="hljs-number">14</span>.<span class="hljs-number">5</span>.<span class="hljs-number">0</span> // 安装<span class="hljs-number">14</span>.<span class="hljs-number">5</span>.<span class="hljs-number">0</span>版本node<br><span class="hljs-attribute">nvm</span> install latest // 安装最新版本node<br></code></pre></td></tr></table></figure><h4 id="vm-use-命令-使用指定版本node"><a href="#vm-use-命令-使用指定版本node" class="headerlink" title="vm use 命令 - 使用指定版本node"></a>vm use 命令 - 使用指定版本node</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nvm</span> use <span class="hljs-number">14</span>.<span class="hljs-number">5</span>.<span class="hljs-number">0</span> // 使用<span class="hljs-number">14</span>.<span class="hljs-number">5</span>.<span class="hljs-number">0</span>版本node<br><span class="hljs-attribute">nvm</span> uninstall 命令 - 卸载指定版本 node<br><span class="hljs-attribute">nvm</span> uninstall <span class="hljs-number">14</span>.<span class="hljs-number">5</span>.<span class="hljs-number">0</span> // 卸载<span class="hljs-number">14</span>.<span class="hljs-number">5</span>.<span class="hljs-number">0</span>版本node<br></code></pre></td></tr></table></figure><p>遇坑警告！！！！！<br>在运行nvm install 的时候，<strong>有可能会出现无权限安装的问题，如果遇到此问题，请 以管理员身份运行 cmd。</strong></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.jianshu.com/p/13c0b3ca7c71">简书</a><br><a href="https://juejin.cn/post/7000652162950758431#heading-3">掘金nvm 安装与使用（详细步骤）</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>pnpm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出Vite&amp;&amp;搭建vite项目&amp;&amp;css工程化&amp;&amp;代码规范&amp;&amp;静态资源优化(2)</title>
    <link href="/2022/04/30/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAVite%E7%AC%94%E8%AE%B0(2)/"/>
    <url>/2022/04/30/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAVite%E7%AC%94%E8%AE%B0(2)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="项目环境搭建"><a href="#项目环境搭建" class="headerlink" title="项目环境搭建"></a>项目环境搭建</h3><ol><li>node -v<br>推荐 12.0.0 及以上版本，如果低于这个版本，推荐使用 nvm 工具切换 Nodejs 版本。</li></ol><p>当然，在现代的前端项目中，我非常不推荐使用 npm 作为项目的包管理器，甚至也不再推荐yarn(npm 的替代方案)，因为<strong>两者都存在比较严重的性能和安全问题</strong>，而这些问题在 pnpm 中得到了很好的解决</p><ol><li>因此，包管理器方面我推荐使用 pnpm，安装方式非常简单，输入如下命令即可:</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -g pnpm<br></code></pre></td></tr></table></figure><p>由于默认的镜像源在国外，包下载速度和稳定性都不太好，因此我建议你换成国内的镜像源，这样pnpm install命令的体验会好很多，命令如下:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">pnpm config set registry https:<span class="hljs-comment">//registry.npmmirror.com/</span><br></code></pre></td></tr></table></figure><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><p>1.命令</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pnpm create vite</span><br></code></pre></td></tr></table></figure><p><a href="https://vitejs.cn/guide/#scaffolding-your-first-vite-project">官网</a></p><h3 id="项目入口加载"><a href="#项目入口加载" class="headerlink" title="项目入口加载"></a>项目入口加载</h3><p>言归正传，我们继续学习 Vite 初始化后的项目。项目的目录结构如下:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.<br>├── index.html<br>├── package.json<br>├── pnpm-lock.yaml<br>├── <span class="hljs-attribute">src</span><br>│   ├── App.css<br>│   ├── App.tsx<br>│   ├── favicon.svg<br>│   ├── index.css<br>│   ├── logo.svg<br>│   ├── <span class="hljs-selector-tag">main</span>.tsx<br>│   └── vite-env<span class="hljs-selector-class">.d</span>.ts<br>├── tsconfig.json<br>└── vite<span class="hljs-selector-class">.config</span>.ts<br></code></pre></td></tr></table></figure><p>值得注意的是，在项目根目录中有一个index.html文件，这个文件十分关键，因为 Vite 默认会把项目根目录下的index.html作为入口文件。也就是说，当你访问<code>http://localhost:3000</code>的时候，Vite 的 Dev Server 会自动返回这个 HTML 文件的内容。<br>可以看到这个 HTML 文件的内容非常简洁，在 body 标签中除了 id 为 root 的根节点之外，还包含了一个声明了<strong>type=”module”的 script</strong>标签:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/src/main.tsx&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>由于现代浏览器原生支持了 ES 模块规范，因此原生的 ES 语法也可以直接放到浏览器中执行，只需要在 script 标签中声明 type=”module” 即可。比如上面的 script 标签就声明了 type=”module”，同时 src 指向了/src/main.tsx文件，此时相当于请求了<code>http://localhost:3000/src/main.tsx</code>这个资源，Vite&gt; 的 Dev Server 此时会接受到这个请求，然后读取对应的文件内容，进行一定的中间处理，最后将处理的结果返回给浏览器。</p><p><img src="/imageO/vite1.jpg" alt="vite"><br>我们可以来看看 main.tsx 的内容:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.css&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span><br><br>ReactDOM.render(<br>  &lt;React.StrictMode&gt;<br>    &lt;App /&gt;<br>  &lt;/React.StrictMode&gt;,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure><p>到这里可能你会诧异: 浏览器并不识别 tsx 语法，也无法直接 import css 文件，上面这段代码究竟是如何被浏览器正常执行的呢？</p><p>这就归功了 Vite Dev Server 所做的“中间处理”了，也就是说，在读取到 main.tsx文件的内容之后，Vite 会对文件的内容进行编译，大家可以从 Chrome 的网络调试面板看到编译后的结果:<br><img src="/imageO/vite2.jpg" alt="调试"></p><p>这里你只需要知道，Vite 会将项目的源代码编译成浏览器可以识别的代码，与此同时，一个 import 语句即代表了一个 HTTP 请求，如下面两个 import 语句:</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;/src/index.css&quot;</span>;<br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;/src/App.tsx&quot;</span>;<br></code></pre></td></tr></table></figure><p>需要注意的是，在 Vite 项目中，<strong>一个import 语句即代表一个 HTTP 请求</strong>。上述两个语句则分别代表了两个不同的请求，Vite Dev Server 会读取本地文件，返回浏览器可以解析的代码。当浏览器解析到新的 import 语句，又会发出新的请求，以此类推，直到所有的资源都加载完成。</p><p>现在，你应该知道了 Vite 所倡导的no-bundle理念的真正含义: <strong>利用浏览器原生 ES 模块的支持，实现开发阶段的 Dev Server，进行模块的按需加载</strong>，而不是<strong>先整体打包再进行加载</strong>。相比 Webpack 这种必须打包再加载的传统构建模式，Vite 在开发阶段省略了繁琐且耗时的打包过程，这也是它为什么快的一个重要原因。</p><h3 id="CSS工程化"><a href="#CSS工程化" class="headerlink" title="CSS工程化"></a>CSS工程化</h3><h4 id="那么，如果我们不用任何-CSS-工程方案，又会出现哪些问题呢？"><a href="#那么，如果我们不用任何-CSS-工程方案，又会出现哪些问题呢？" class="headerlink" title="那么，如果我们不用任何 CSS 工程方案，又会出现哪些问题呢？"></a>那么，如果我们不用任何 CSS 工程方案，又会出现哪些问题呢？</h4><ol><li><strong>开发体验</strong>欠佳。比如原生 CSS 不支持选择器的嵌套:</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 选择器只能平铺，不能嵌套</span><br><span class="hljs-selector-class">.container</span> <span class="hljs-selector-class">.header</span> <span class="hljs-selector-class">.nav</span> <span class="hljs-selector-class">.title</span> <span class="hljs-selector-class">.text</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br><span class="hljs-selector-class">.container</span> <span class="hljs-selector-class">.header</span> <span class="hljs-selector-class">.nav</span> <span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid grey;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>样式污染</strong>问题。如果出现同样的类名，很容易造成不同的样式互相覆盖和污染。</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// a.css</span><br>.<span class="hljs-class">container </span>&#123;<br><span class="hljs-symbol">  color:</span> red;<br>&#125;<br><span class="hljs-comment">// b.css</span><br><span class="hljs-comment">// 很有可能覆盖 a.css 的样式！</span><br>.<span class="hljs-class">container </span>&#123;<br><span class="hljs-symbol">  color:</span> blue;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>浏览器兼容</strong>问题。为了兼容不同的浏览器，我们需要对一些属性(如<strong>transition</strong>)加上不同的浏览器前缀，比如 **-webkit-、-moz-、-ms-、-o-**，意味着开发者要针对同一个样式属性写很多的冗余代码。</li><li>打包后的<strong>代码体积</strong>问题。如果不用任何的 CSS 工程化方案，所有的 CSS 代码都将打包到产物中，即使有部分样式并没有在代码中使用，导致产物体积过大。</li></ol><h4 id="针对如上原生-CSS-的痛点，社区中诞生了不少解决方案，常见的有-5-类"><a href="#针对如上原生-CSS-的痛点，社区中诞生了不少解决方案，常见的有-5-类" class="headerlink" title="针对如上原生 CSS 的痛点，社区中诞生了不少解决方案，常见的有 5 类"></a>针对如上原生 CSS 的痛点，社区中诞生了不少解决方案，常见的有 5 类</h4><ol><li><strong>CSS 预处理器</strong>：主流的包括Sass/Scss、Less和Stylus。这些方案各自定义了一套语法，让 CSS 也能使用嵌套规则，甚至能像编程语言一样定义变量、写条件判断和循环语句，大大增强了样式语言的灵活性，解决原生 CSS 的开发体验问题。</li><li><strong>CSS Modules</strong>：能将 CSS 类名处理成哈希值，这样就可以避免同名的情况下样式污染的问题。</li><li>SS 后处理器<strong>PostCSS</strong>，用来解析和处理 CSS 代码，可以实现的功能非常丰富，比如将 px 转换为 rem、根据目标浏览器情况自动加上类似于–moz–、-o-的属性前缀等等。</li><li>CSS in JS 方案，主流的包括emotion、styled-components等等，顾名思义，这类方案可以实现直接在 JS 中写样式代码，基本包含CSS 预处理器和 CSS Modules 的各项优点，非常灵活，解决了开发体验和全局样式污染的问题。</li><li>CSS 原子化框架，如<strong>Tailwind CSS、Windi CSS，通过类名来指定样式，大大简化了样式写法</strong>，提高了样式开发的效率，主要解决了原生 CSS 开发体验的问题。</li></ol><p><a href="https://juejin.cn/book/7050063811973218341/section/7057872229589057576">参考</a></p><h3 id="代码规范：使用Link工具链保证代码风格和质量"><a href="#代码规范：使用Link工具链保证代码风格和质量" class="headerlink" title="代码规范：使用Link工具链保证代码风格和质量"></a>代码规范：使用Link工具链保证代码风格和质量</h3><p>介绍了 3 个方面的自动化代码规范工具:</p><ol><li>JavaScript/TypeScript 规范。主流的 Lint 工具包括 Eslint、Prettier；</li><li>样式开发规范。主流的 Lint 工具包括Stylelint、Prettier；</li><li>Git 提交规范。主流的 Lint 工具包括Commitlint。</li></ol><h3 id="如何加载静态资源和如何在生产环境中对静态资源进行优化"><a href="#如何加载静态资源和如何在生产环境中对静态资源进行优化" class="headerlink" title="如何加载静态资源和如何在生产环境中对静态资源进行优化"></a>如何加载静态资源和如何在生产环境中对静态资源进行优化</h3><p>首先是如何加载各种静态资源，如图片、svg(组件形式)、JSON、Web Worker 脚本、Web Asssembly 文件等等格式，并通过一些示例带大家进行实际的操作。</p><p>其次，我们会把关注点放到生产环境，对自定义部署域名、是否应该内联、图片压缩、svg 雪碧图等问题进行了详细的探讨和实践，对于如何解决这些问题，相信你也有了自己的答案。</p><p>当然，在编码实操的过程当中，我也给你穿插了一些 Vite 其他的知识点，比如如何定义环境变量文件、如何使用 Glob 导入的语法糖。相信在学习本节的过程中你能更加体会到 Vite 给项目开发带来的便利，同时也对 Vite 的掌握更深入了一步。</p><blockquote><p>HTTP2 的多路复用设计可以解决大量 HTTP 的请求导致的网络加载性能问题，因此雪碧图技术在 HTTP2 并没有明显的优化效果，这个技术更适合在传统的 HTTP 1.1 场景下使用(比如本地的 Dev Server)。</p></blockquote><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://juejin.cn/book/7050063811973218341/section/7058854154738860066">深入浅出 Vite</a></p>]]></content>
    
    
    <categories>
      
      <category>Vite</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端进阶</tag>
      
      <tag>Vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出Vite入门&amp;&amp;为什么ESM是前端模块化的未来(1)</title>
    <link href="/2022/04/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAVite%E7%AC%94%E8%AE%B0(1)/"/>
    <url>/2022/04/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAVite%E7%AC%94%E8%AE%B0(1)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="深入浅出-Vite"><a href="#深入浅出-Vite" class="headerlink" title="深入浅出 Vite"></a>深入浅出 Vite</h3><p>当下，在项目开发的过程中，前端工程师们越来越离不开构建工具了，可以说<strong>构建工具已经成为了前端工程项目的标配。</strong></p><p>不过，如今的前端构建工具可谓乱花渐欲迷人眼，有远古时代的<strong>browserify、grunt，有传统的Webpack、Rollup、Parcel</strong>，也有现代的<strong>Esbuild、Vite</strong> 等等，不仅种类繁多，更新也很快。</p><p>到底哪个构建工具更好用、值得学。事实上，<strong>无论工具层面如何更新，它们解决的核心问题，即前端工程的痛点是不变的</strong>。因此，想要知道哪个工具更好用，就要看它解决前端工程痛点的效果。</p><p>那么，前端工程都有哪些痛点呢？</p><p>首先是前端的<strong>模块化需求</strong>。我们知道，业界的模块标准非常多，包括 ESM、CommonJS、AMD 和 CMD 等等。前端工程一方面需要落实这些模块规范，保证模块正常加载。另一方面需要兼容不同的模块规范，以适应不同的执行环境。</p><p>其次是<strong>兼容浏览器，编译高级语法</strong>。由于浏览器的实现规范所限，只要高级语言/语法（TypeScript、 JSX 等）想要在浏览器中正常运行，就必须被转化为浏览器可以理解的形式。这都需要工具链层面的支持，而且这个需求会一直存在。</p><p>再者是<strong>线上代码的质量</strong>问题。和开发阶段的考虑侧重点不同，生产环境中，我们不仅要考虑代码的<strong>安全性、兼容性</strong>问题，保证线上代码的正常运行，也需要考虑代码运行时的性能问题。由于浏览器的版本众多，代码兼容性和安全策略各不相同，线上代码的质量问题也将是前端工程中长期存在的一个痛点。</p><p>同时，<strong>开发效率</strong>也不容忽视。 我们知道，<strong>项目的冷启动/二次启动时间、热更新时间</strong>都可能严重影响开发效率，尤其是当项目越来越庞大的时候。因此，提高项目的启动速度和热更新速度也是前端工程的重要需求。</p><h4 id="那么，前端构建工具是如何解决以上问题的呢？"><a href="#那么，前端构建工具是如何解决以上问题的呢？" class="headerlink" title="那么，前端构建工具是如何解决以上问题的呢？"></a>那么，前端构建工具是如何解决以上问题的呢？</h4><ol><li><p>模块化方面，提供模块加载方案，并兼容不同的模块规范。</p></li><li><p>语法转译方面，配合<strong>Sass、TSC、Babel</strong> 等前端工具链，完成高级语法的转译功能，同时对于静态资源也能进行处理，使之能作为一个模块正常加载。</p></li><li><p>产物质量方面，在生产环境中，配合 <strong>Terser</strong>等压缩工具进行代码压缩和混淆，通过 <strong>Tree Shaking</strong> 删除未使用的代码，提供对于低版本浏览器的语法降级处理等等。</p></li><li><p>开发效率方面，构建工具本身通过各种方式来进行性能优化，包括<strong>使用原生语言 Go/Rust、no-bundle</strong>等等思路，提高项目的启动性能和热更新的速度。</p></li></ol><h3 id="为什么-Vite-是当前最高效的构建工具？"><a href="#为什么-Vite-是当前最高效的构建工具？" class="headerlink" title="为什么 Vite 是当前最高效的构建工具？"></a>为什么 Vite 是当前最高效的构建工具？</h3><ol><li>首先是开发效率。传统构建工具普遍的缺点就是太慢了，与之相比，Vite 能将项目的启动性能提升一个量级，并且达到<strong>毫秒级的瞬间热更新效果</strong>。</li></ol><p>就拿 Webpack 来说，我在工作中发现，一般的项目使用 Webpack 之后，启动花个几分钟都是很常见的事情，热更新也经常需要等待十秒以上。这主要是因为：</p><ul><li>项目冷启动时必须递归打包整个项目的依赖树</li><li>JavaScript 语言本身的性能限制，导致构建性能遇到瓶颈，直接影响开发效率<br>这样一来，代码改动后不能立马看到效果，自然开发体验也越来越差。而其中，最占用时间的就是代码打包和文件编译。</li></ul><p>而 Vite 很好地解决了这些问题。<strong>一方面，Vite 在开发阶段基于浏览器原生 ESM 的支持实现了no-bundle服务，另一方面借助 Esbuild 超快的编译速度来做第三方库构建和 TS/JSX 语法编译，从而能够有效提高开发效率。</strong></p><p>除了开发效率，在其他三个维度上， Vite 也表现不俗。</p><ol start="2"><li><p>模块化方面，Vite <strong>基于浏览器原生 ESM 的支持实现模块加载</strong>，并且无论是开发环境还是生产环境，都可以<strong>将其他格式的产物(如 CommonJS)转换为 ESM</strong>。</p></li><li><p>语法转译方面，Vite 内置了对 TypeScript、JSX、Sass 等高级语法的支持，也能够加载各种各样的静态资源，如图片、Worker 等等。</p></li><li><p>产物质量方面，Vite 基于成熟的打包工具 Rollup 实现生产环境打包，同时可以配合Terser、Babel等工具链，可以极大程度保证构建产物的质量。</p></li></ol><p>因此，如果你想要学习一个前端构建工具，Vite 将会是你当下一个最好的选择。它不仅解决了传统构建工具的开发效率问题，而且具备一个优秀构建工具的各项要素，还经历了社区大规模的验证与落地。</p><h3 id="模块标准：为什么ESM是前端模块化的未来？"><a href="#模块标准：为什么ESM是前端模块化的未来？" class="headerlink" title="模块标准：为什么ESM是前端模块化的未来？"></a>模块标准：为什么ESM是前端模块化的未来？</h3><h4 id="CommonJS-规范-gt-AMD规范-gt-ESM规范"><a href="#CommonJS-规范-gt-AMD规范-gt-ESM规范" class="headerlink" title="CommonJS 规范 -&gt; AMD规范   -&gt; ESM规范"></a>CommonJS 规范 -&gt; AMD规范   -&gt; ESM规范</h4><p>ES6 Module 也被称作 ES Module(或 ESM)， 是由 ECMAScript 官方提出的模块化规范，作为一个官方提出的规范，ES Module 已经得到了现代浏览器的内置支持。在现代浏览器中，如果在 HTML 中加入含有type=”module”属性的 script 标签，那么浏览器会按照 ES Module 规范来进行依赖加载和模块解析，这也是 Vite 在开发阶段实现 no-bundle 的原因，由于<strong>模块加载的任务交给了浏览器，即使不打包也可以顺利运行模块代码</strong></p><p>下面是一个使用 ES Module 的简单例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; methodA &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./module-a.js&quot;</span>;<br>methodA();<br><br><span class="hljs-comment">//module-a.js</span><br><span class="hljs-keyword">const</span> methodA = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a&quot;</span>);<br>&#125;;<br><br><span class="hljs-keyword">export</span> &#123; methodA &#125;;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果在 Node.js 环境中，你可以在package.json中声明type: “module”属性:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// package.json</span><br>&#123;<br>  <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;module&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后 Node.js 便会默认以 ES Module 规范去解析模块:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">node <span class="hljs-selector-tag">main</span>.js<br><span class="hljs-comment">// 打印 a</span><br></code></pre></td></tr></table></figure><p>顺便说一句，在 Node.js 中，即使是在 CommonJS 模块里面，也可以通过 import 方法顺利加载 ES 模块，如下所示:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">async</span> function <span class="hljs-function"><span class="hljs-keyword">func</span>()</span> &#123;<br>  <span class="hljs-comment">// 加载一个 ES 模块</span><br>  <span class="hljs-comment">// 文件名后缀需要是 mjs</span><br>  const &#123; a &#125; <span class="hljs-operator">=</span> <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(&quot;./module-a.mjs&quot;);<br>  console.log(a);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span>()</span>;<br><br>module.exports <span class="hljs-operator">=</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">func</span></span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>由于前端构建工具的改革与底层模块化规范的发展息息相关，从一开始我就带你从头梳理了前端模块化的演进史，从无模块化标准的时代开始谈起，跟你介绍了<strong>文件划分</strong>的模块化方案，并分析了这个方案潜在的几个问题。随后又介绍了<strong>命名空间</strong>和<strong>IIFE</strong>两种方案，但这两种方式并没有解决模块自动加载的问题。由此展开对前端模块化规范的介绍，我主要给你分析了三个主流的模块化标准: <strong>CommonJS、AMD 以及 ES Module</strong>，针对每个规范从<strong>模块化代码标准、模块自动加载方案</strong>这两个维度给你进行了详细的拆解，最后得出 ES Module 即将成为主流前端模块化方案的结论。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://juejin.cn/book/7050063811973218341/section/7077834799208988675">深入浅出 Vite</a><br><a href="https://pengzhenglong.github.io/2022/03/01/CommonJS%E5%92%8CES6%E6%A8%A1%E5%9D%97/">博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Vite</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端进阶</tag>
      
      <tag>Vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数柯里化</title>
    <link href="/2022/03/29/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <url>/2022/03/29/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="函数柯里化-就是递归"><a href="#函数柯里化-就是递归" class="headerlink" title="函数柯里化 (就是递归)"></a>函数柯里化 (就是递归)</h3><p>在函数式编程中，函数是一等公民。那么函数柯里化是怎样的呢？<br>函数柯里化指的是将能够接收多个参数的函数转化为接收单一参数的函数，并且返回接收余下参数且返回结果的新函数的技术。<br>函数柯里化的主要作用和特点就是参数复用、提前返回和延迟执行。<br>例如：封装兼容现代浏览器和 IE 浏览器的事件监听的方法，正常情况下封装是这样的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">var</span> addEvent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, <span class="hljs-keyword">type</span>, fn, capture</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.addEventListener) &#123;<br>        el.addEventListener(<span class="hljs-keyword">type</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>            fn.call(el, e);<br>        &#125;, capture);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        el.attachEvent(<span class="hljs-string">&#x27;on&#x27;</span> + <span class="hljs-keyword">type</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>            fn.call(el, e);<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该封装的方法存在的不足是，每次写监听事件的时候调用 addEvent 函数，都会进行 if else 的兼容性判断。事实上在代码中只需要执行一次兼容性判断就可以了，后续的事件监听就不需要再去判断兼容性了。那么怎么用函数柯里化优化这个封装函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">var</span> addEvent = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.addEventListener) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, <span class="hljs-keyword">type</span>, fn, capture</span>) </span>&#123;<br>            el.addEventListener(<span class="hljs-keyword">type</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>                fn.call(el, e);<br>            &#125;, capture);<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ele, <span class="hljs-keyword">type</span>, fn</span>) </span>&#123;<br>            el.attachEvent(<span class="hljs-string">&#x27;on&#x27;</span> + <span class="hljs-keyword">type</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>                fn.call(el, e);<br>            &#125;)<br>        &#125;<br>    &#125;<br>&#125;)()<br></code></pre></td></tr></table></figure><p>js 引擎在执行该段代码的时候就会进行兼容性判断，并且返回需要使用的事件监听封装函数。这里使用了函数柯里化的两个特点：提前返回和延迟执行。<br>柯里化另一个典型的应用场景就是 bind 函数的实现。使用了函数柯里化的两个特点：参数复用和提前返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.bind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br> <span class="hljs-keyword">var</span> fn = <span class="hljs-built_in">this</span>;<br> <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototye.slice.call(<span class="hljs-built_in">arguments</span>);<br> <span class="hljs-keyword">var</span> context = args.shift();<br><br> <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> fn.apply(context, args.concat(<span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)));<br> &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>实现一个add方法，满足以下功能<br>add(1);//1<br>add(1)(2);//3<br>add(1,2);//3<br>add(1)(2)(3);//6<br>add(1,2)(3);//6<br>add(1,2,3);//6<br>其符合返回方法传入的所有参数的总和<br>add(a,b,c)(d)(e)(f,g)(h) // result=a+b+c+d+e+f+g+h</p><h4 id="答案1（来自b站某老师的视频讲解）"><a href="#答案1（来自b站某老师的视频讲解）" class="headerlink" title="答案1（来自b站某老师的视频讲解）"></a>答案1（来自b站某老师的视频讲解）</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curring</span><span class="hljs-params">(fn,length)</span> </span>&#123;<br>    length = length || fn.length<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (args.length &gt;= length)&#123;<br>        <span class="hljs-keyword">return</span> fn(...args)<br>      &#125;<br>      <span class="hljs-keyword">return</span> curring(fn.bind(<span class="hljs-literal">null</span>,...args),length-args.length)<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; arguments.length; i++) &#123;<br>      sum+=arguments[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum<br>  &#125;<br>  add=curring(add,<span class="hljs-number">6</span>)<span class="hljs-comment">//参数2为调用add方法所有柯里化参数总和</span><br>  console.log(add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>)(<span class="hljs-number">6</span>))<span class="hljs-comment">//21</span><br></code></pre></td></tr></table></figure><h4 id="答案2"><a href="#答案2" class="headerlink" title="答案2"></a>答案2</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">()</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">  for (let i = 0; i &lt; arguments.length; i++) &#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">    sum+=arguments[i]</span></span><br><span class="hljs-function"><span class="hljs-comment">  &#125;</span></span><br><span class="hljs-function">  <span class="hljs-title">return</span> <span class="hljs-title">add</span></span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">  <span class="hljs-title">add</span><span class="hljs-params">(1,2,3)</span><span class="hljs-params">(4)</span><span class="hljs-params">(5)</span><span class="hljs-params">(6)</span></span><br><span class="hljs-function">  <span class="hljs-title">console</span>.<span class="hljs-title">log</span><span class="hljs-params">(sum)</span><span class="hljs-comment">//21</span></span><br></code></pre></td></tr></table></figure><h6 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h6><p><a href="https://juejin.cn/post/6844903665308794888">从一道面试题认识函数柯里化</a></p>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023-beging(项目)</title>
    <link href="/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D2023-beging/"/>
    <url>/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D2023-beging/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><h3 id="面试总结–（一面）"><a href="#面试总结–（一面）" class="headerlink" title="面试总结–（一面）"></a>面试总结–（一面）</h3><h4 id="讲一下图谱可视化分析项目是什么？"><a href="#讲一下图谱可视化分析项目是什么？" class="headerlink" title="讲一下图谱可视化分析项目是什么？"></a>讲一下图谱可视化分析项目是什么？</h4><p>图谱可视化分析项目是指将大规模、复杂的数据转化成图谱形式，并通过可视化的方式展示出来，以便人们更好地理解和分析这些数据。这种项目通常需要使用数据挖掘、机器学习、自然语言处理等技术来将数据进行处理和转化，最终生成可视化图谱。</p><p>图谱是一种以节点和边为基础构建的数据结构，节点代表实体或概念，边表示实体或概念之间的关系。图谱可视化分析项目通过将数据转化成节点和边的形式，可以更直观地展现出数据之间的关系，以及它们的属性和特征。这种展示方式可以帮助人们发现数据中的规律和趋势，支持数据驱动的决策和分析。</p><p>图谱可视化分析项目可以应用于各种领域，例如金融、医疗、社交网络等。在金融领域，图谱可视化分析可以用于检测欺诈行为和风险分析；在医疗领域，可以用于疾病诊断和药物发现；在社交网络领域，可以用于社交网络分析和影响力分析等。</p><p>总之，图谱可视化分析项目是一种将大规模、复杂的数据通过图谱形式展示出来的技术，可以帮助人们更好地理解和分析数据，发现数据中的规律和趋势，支持数据驱动的决策和分析。</p><h4 id="d3js和echarts的区别"><a href="#d3js和echarts的区别" class="headerlink" title="d3js和echarts的区别"></a>d3js和echarts的区别</h4><p>d3.js和ECharts都是用于可视化数据的JavaScript库，但是它们有以下几点区别：</p><p>功能和用途不同：d3.js是一个数据驱动的JavaScript库，用于创建动态交互式数据可视化。ECharts则是专注于图表可视化的库，提供了一系列内置的图表类型，如折线图、柱状图、饼图等。</p><p>数据绑定方式不同：d3.js的核心理念是数据绑定，即将数据与DOM元素绑定，然后通过操作数据来控制DOM元素。而ECharts则是通过设置选项来配置图表的样式和数据。</p><p>API和使用方式不同：d3.js的API相对更为底层，需要开发者手动进行DOM操作和动画效果的编写。而ECharts则提供了更多的封装，通过简单的配置选项即可生成丰富的图表，也提供了更多的交互和动画效果。</p><p>社区支持不同：d3.js是由Mike Bostock等人创建的开源项目，拥有庞大的社区和活跃的开发者，有丰富的示例和文档资源。ECharts则是由百度开发并维护的项目，拥有庞大的用户群体和活跃的社区，也有丰富的文档和示例资源。</p><p>总的来说，d3.js更加灵活和自由，适用于开发者需要高度自定义的数据可视化场景，而ECharts则更加便捷和高效，适用于快速构建各种类型的图表。</p><h6 id="d3js是操作svg吗"><a href="#d3js是操作svg吗" class="headerlink" title="d3js是操作svg吗"></a>d3js是操作svg吗</h6><p>d3.js是一个JavaScript库，它可以用于操作HTML文档中的各种元素，包括SVG元素和HTML元素。它最初是为了操作SVG（Scalable Vector Graphics，可缩放矢量图形）而创建的，但现在它也可以用于操作HTML元素。因此，d3.js可以用于创建和操作各种图形，包括线条、圆形、矩形、文字、路径、饼图、力导向图等等。它具有强大的数据绑定和动画功能，可以使数据可视化的开发更加简单和高效。</p><h6 id="d3js可以操作canvas吗"><a href="#d3js可以操作canvas吗" class="headerlink" title="d3js可以操作canvas吗"></a>d3js可以操作canvas吗</h6><p>虽然d3.js<strong>最初是为了操作SVG而创建的，但它也可以用于操作HTML5中的canvas元素</strong>。HTML5的canvas元素提供了一种使用JavaScript绘制图形和动画的方式，它比SVG更适合于处理大量数据或高度动态的图形。d3.js提供了一些方法来在canvas上绘制基本的图形，如矩形、圆形、线条等，以及提供了一些布局算法和数据绑定功能，可以帮助我们在canvas上创建数据可视化。但需要注意的是，d3.js在canvas上的表现和在SVG上不同，需要针对canvas元素做出一些特殊的处理和适应。</p><h4 id="负责http请求的axios封装-（这一块是怎么做的能讲一下吗）"><a href="#负责http请求的axios封装-（这一块是怎么做的能讲一下吗）" class="headerlink" title="负责http请求的axios封装  （这一块是怎么做的能讲一下吗）"></a>负责http请求的axios封装  （这一块是怎么做的能讲一下吗）</h4><p>在项目中进行<em><strong>axios的封装可以提高代码的复用性和可维护性</strong></em>，可以在<strong>多个地方引用相同的axios实例</strong>，也可以通过<strong>拦截器对请求和响应进行统一处理</strong>，以<strong>减少代码的重复性</strong>。</p><p>以下是一个示例axios封装的具体步骤：</p><p>在项目中创建一个单独的文件，例如http.js，用于封装axios请求。</p><p>在http.js中引入axios，并创建一个新的axios实例：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br><br>const <span class="hljs-keyword">instance</span> = axios.create(&#123;<br>  baseURL: <span class="hljs-string">&#x27;https://example.com/api&#x27;</span>,<br>  timeout: <span class="hljs-number">5000</span>,<br>  headers: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 设置请求拦截器和响应拦截器</span><br><span class="hljs-keyword">instance</span>.interceptors.request.use(...);<br><span class="hljs-keyword">instance</span>.interceptors.response.use(...);<br><br><span class="hljs-keyword">export</span> default <span class="hljs-keyword">instance</span>;<br></code></pre></td></tr></table></figure><p>在创建axios实例时，可以设置一些默认参数，例如<strong>基础URL、超时时间和请求头信息</strong>等，这些参数将应用于所有使用该实例发出的请求。</p><p>在其他组件或模块中引入封装好的axios实例，并使用它发送请求。例如：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">import</span> http <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./http&#x27;</span>;<br><br>http.get(<span class="hljs-string">&#x27;/users&#x27;</span>)<br>  .<span class="hljs-keyword">then</span>(response =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(response);<br>  &#125;)<br>  .<span class="hljs-keyword">catch</span>(error =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.error(error);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用了在http.js中创建的axios实例，发送了一个GET请求，如果请求成功，则输出响应数据；如果请求失败，则输出错误信息。</p><p>通过这种方式进行封装，我们可以<strong>在整个项目中使用相同的axios实例</strong>，避免了在每个组件或模块中重复地创建实例，<strong>同时可以在请求拦截器和响应拦截器中对请求和响应进行统一处理</strong>，提高了代码的<strong>可维护性和可读性</strong>。</p><h5 id="中断取消请求是怎么做的"><a href="#中断取消请求是怎么做的" class="headerlink" title="中断取消请求是怎么做的"></a>中断取消请求是怎么做的</h5><p>在axios中，中断/取消请求可以通过使用<strong>CancelToken</strong>实现。CancelToken是axios提供的一个构造函数，它可以用来创建一个取消请求的令牌。当一个请求被取消时，我们可以使用该令牌来通知axios取消该请求。</p><p>以下是一个示例：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mel">import axios from <span class="hljs-string">&#x27;axios&#x27;</span>;<br><br><span class="hljs-comment">// 创建一个取消请求的令牌</span><br>const <span class="hljs-keyword">source</span> = axios.CancelToken.<span class="hljs-keyword">source</span>();<br><br><span class="hljs-comment">// 发送请求</span><br>axios.get(<span class="hljs-string">&#x27;/api&#x27;</span>, &#123;<br>  cancelToken: <span class="hljs-keyword">source</span>.token<br>&#125;)<br>  .then(response =&gt; &#123;<br>    console.<span class="hljs-keyword">log</span>(response);<br>  &#125;)<br>  .<span class="hljs-keyword">catch</span>(<span class="hljs-keyword">error</span> =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (axios.isCancel(<span class="hljs-keyword">error</span>)) &#123;<br>      console.<span class="hljs-keyword">log</span>(<span class="hljs-string">&#x27;请求已取消&#x27;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      console.<span class="hljs-keyword">error</span>(<span class="hljs-keyword">error</span>);<br>    &#125;<br>  &#125;);<br><br><span class="hljs-comment">// 取消请求</span><br><span class="hljs-keyword">source</span>.cancel(<span class="hljs-string">&#x27;请求已被取消&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个取消请求的令牌，将该令牌传递给请求的配置对象中的cancelToken属性中。当需要取消请求时，我们调用source.cancel()方法，并传入一个取消请求的原因，这个原因将被传递给请求的catch函数。</p><p>当请求被取消时，catch函数将捕获到一个带有message属性的错误对象，我们可以通过判断该错误是否是一个取消请求的错误来处理请求被取消的情况。</p><p>需要注意的是，<strong>一旦请求被取消，axios将不再执行then函数，而是直接跳转到catch函数。此外，使用CancelToken取消请求的前提是该请求必须是可取消的，即该请求必须是一个异步请求，不能是同步请求。</strong></p><h4 id="大文件上传，使用切片上传形式，支持上传、暂停、续传"><a href="#大文件上传，使用切片上传形式，支持上传、暂停、续传" class="headerlink" title="大文件上传，使用切片上传形式，支持上传、暂停、续传"></a>大文件上传，使用切片上传形式，支持上传、暂停、续传</h4><h5 id="大文件长传并发的怎么确保后端接收的顺序"><a href="#大文件长传并发的怎么确保后端接收的顺序" class="headerlink" title="大文件长传并发的怎么确保后端接收的顺序"></a>大文件长传并发的怎么确保后端接收的顺序</h5><p>另外由于是并发，<strong>传输到服务端的顺序可能会发生变化，因此我们还需要给每个切片记录顺序</strong></p><p>在生成文件切片时，需要给每个切片一个标识作为 hash，这里暂时使用文件名 + 下标，这样后端可以知道当前切片是第几个切片，用于之后的合并切片</p><p>随后调用 uploadChunks 上传所有的文件切片，将文件切片，切片 hash，以及文件名放入 formData 中，再调用上一步的 request 函数返回一个 proimise，最后调用** Promise.all **并发上传所有的切片发送合并请求</p><p><strong>使用 spark-md5 根据文件内容算出文件 hash</strong><br>生成 hash<br>无论是前端还是服务端，都必须要生成文件和切片的 hash，之前我们使用文件名 + 切片下标作为切片 hash，这样做文件名一旦修改就失去了效果，而事实上只要<strong>文件内容不变</strong>，<strong>hash 就不应该变化</strong>，所以正确的做法是根据文件内容生成 hash，所以我们修改一下 hash 的生成规则</p><h6 id="大文件上传上传几个G的，文件丢失有做处理嘛，有日志吗"><a href="#大文件上传上传几个G的，文件丢失有做处理嘛，有日志吗" class="headerlink" title="大文件上传上传几个G的，文件丢失有做处理嘛，有日志吗"></a>大文件上传上传几个G的，文件丢失有做处理嘛，有日志吗</h6><p>大文件上传过程中，文件丢失的情况通常会通过一些机制来处理，以保证上传的文件不会丢失或损坏。下面是一些处理丢失文件的机制和日志记录的建议：</p><ol><li><p>断点续传机制：上传大文件时，可以采用断点续传的方式，即将文件分成多个部分进行上传，每个部分上传完成后，服务器会记录已经上传的位置，以便于下次上传时可以从上次中断的位置继续上传，从而减小上传失败的概率。</p></li><li><p>文件校验机制：上传完整个文件后，可以对文件进行校验，验证文件的完整性和正确性，以确保文件没有丢失或损坏。一种常用的文件校验方式是使用MD5或SHA256等哈希算法计算文件的散列值，服务器可以比对客户端上传的散列值和服务器端计算的散列值是否相同来判断文件是否丢失或损坏。</p></li><li><p>日志记录：服务器应该记录每次上传的日志，包括上传时间、上传的文件名称、上传的文件大小、上传成功或失败的状态等信息。这样，在发生文件丢失或其他问题时，管理员可以查看日志文件，找出问题的原因，并采取相应的措施。</p></li></ol><p>总之，对于大文件上传，需要采用多种机制来保证上传的文件不会丢失或损坏，并建议记录上传日志，以便于快速定位和解决问题。</p><h4 id="文章列表的长列表优化，使用虚拟滚动-滚动用的是节流做的（这一块用监听滚动条做的，还有什么别的方法嘛）"><a href="#文章列表的长列表优化，使用虚拟滚动-滚动用的是节流做的（这一块用监听滚动条做的，还有什么别的方法嘛）" class="headerlink" title="文章列表的长列表优化，使用虚拟滚动  滚动用的是节流做的（这一块用监听滚动条做的，还有什么别的方法嘛）"></a>文章列表的长列表优化，使用虚拟滚动  滚动用的是节流做的（这一块用监听滚动条做的，还有什么别的方法嘛）</h4><p>虚拟滚动是处理长列表的常用技术，其原理是只渲染可见部分，当滚动时动态渲染视口内的列表项，从而减少页面渲染所需的时间和内存占用。虚拟滚动的实现方法可以基于监听滚动条，也可以使用其他方式，下面介绍几种常见的实现方式：</p><h5 id="IntersectionObserver-解决方案"><a href="#IntersectionObserver-解决方案" class="headerlink" title="IntersectionObserver 解决方案"></a>IntersectionObserver 解决方案</h5><p>通过 IntersectionObserver 的特性，当目标对象中的 entry.isIntersecting 为 true 或者 intersectionRatio &gt; 0 （元素与祖先元素交叉、可见）时，说明本来不可见的元素浮现在视图中，表示它向上或向下滑动，我们动态设置视图中的顶部和底部 id 即可对其判断。当下滑时 entry.traget.id === ‘bottom’，我们修改 start 和 end；同理，当上滑时entry.traget.id === ‘top 时，我们也一样修改 start 和 end</p><ol><li><p>Intersection Observer：Intersection Observer API是浏览器提供的一种观察元素与其祖先元素或视窗交叉情况的机制。使用<strong>Intersection Observer可以判断列表项是否在视口内，从而触发渲染和回收</strong>，<strong>相较于监听滚动条，它更加高效和灵活</strong>。</p></li><li><p>Resize Observer：Resize Observer API是浏览器提供的一种观察元素尺寸变化的机制，用于动态计算可视区域内需要渲染的列表项数量，从而实现虚拟滚动的动态调整。</p></li><li><p>使用CSS样式实现虚拟滚动：在CSS中设置滚动容器的高度和overflow属性为auto，列表项的高度为固定值，通过控制容器中的子元素数量，从而实现虚拟滚动的效果。</p></li></ol><p>总之，虚拟滚动是处理长列表的有效技术，<strong>除了监听滚动条外，还可以使用Intersection Observer、Resize Observer等API或CSS样式实现虚拟滚动</strong>，根据实际需求选择最合适的实现方式。</p><p>渲染十万条数据有三种解决方案，为虚拟列表、懒加载、时间分片。最优选是虚拟列表，DOM 树上只挂载有限的DOM；懒加载和时间分片的缺点在于插入大量的DOM，占内存运行时会造成卡顿<br>无论是虚拟列表还是懒加载，传统的做法是 scroll + 节流，这种做法的优势是老 API，兼容性刚刚的，缺点是，滑多了还是会引起性能问题，<strong>当然 IntersectionObserver 也是一样的，无非是换了个 API 做“元素是否出现在视图”判断，最好的方案是用 IntersectionObserver（交叉观察器），异步加载、性能消耗小</strong></p><h4 id="设计整套权限控制方案"><a href="#设计整套权限控制方案" class="headerlink" title="设计整套权限控制方案"></a>设计整套权限控制方案</h4><p>登录权限怎么处理 （动态路由）Vue实现动态路由（和面试官吹项目亮点）<br>登录逻辑<br>每个系统都有自己的登录登出逻辑，而我们前端所要做的其实是请求后台，拿到登录权限，带上登录权限，获取用户信息和菜单信息。 在vue项目开发当中，我们一般都是在全局路由钩子做这一系列判断。</p><p>菜单权限<br>通过带有 token 请求头的请求方法，后端可以判断到是哪一个用户，前端也可以通过获取权限接口获得该用户的权限列表，根据权限列表做一份路由映射表，如果后端返回的数据结构与前端的路由设置的数据结构不同，此时还需编写此映射路由的业务功能函数。</p><p>如果该用户拥有此路由权限，则通过在全局路由监控中 router.beforeEach 进行 router 中的 addRoutes 方法将有权限的路由配置添加到路由当中，侧边栏也可根据路由列表中的 meta 字段中关键字的判断进行相应的渲染。如果权限的颗粒度小到一个按钮，则可根据后端返回的权限列表映射出的权限参数，通过v-if 进行判断该功能组件是否渲染。在路由管理中通过 router.beforeEach 钩子中判断当前的路由权限是否为空，是的话则可执行获取权限路由的接口：</p><p>以前的菜单路由是直接写死在前端，但是当我们直接访问这个路由时，用户还是可以进入到这个功能页面；后来直接改成动态添加路由的方式router.addRoutes。</p><p>一个是操作权限，一个是路由访问权限（这里指前端路由）<br>1.后端返回一个json格式的路由表<br>2.因为后端传回来的是都是字符串格式的，但前端这里需要的是一个组件对象，写个方法遍历一下，将字符串转换为组件对象<br>3.利用vue-router的beforeEach、addRoutes、vuex来配合上边两步实现效果<br>4.左侧菜单拦截根据拿到转换好的路由列表进行展示拦截路由 -&gt; 后端取到路由 -&gt; 保存路由到vuex（用户登录进来只会从后端取一次，其余都从本地取，所以用户，只有退出在登录路由才会更新）</p><p>前端有一份动态路由表，等到用户登录拿到用户的角色之后根据当前登录用户的角色去筛选出可以访问的路由，形成一份定制路由表，然后动态挂载路由。，这样做的好处就是，前端每开发一个页面不需要让后端再去配一下路由和权限了，从而避免被后端支配。</p><p>然而，路由表又是跟角色挂钩。考虑一种情况，项目上线之后，管理员添加了一个新角色，并且要给这个角色分配菜单。<br>如果采用将路由表放在前端的话那么每个路由的可访问角色都是写死的，要给新添加的角色分配菜单，只能改前端代码，显然不是很合适。<br>所以我才用了后者，就是把路由信息放在后端，后端将路由信息和角色关联起来，用户登录之后请求对应的接口拿到属于这个用户的路由信息（也就是菜单），</p><p>然后前端对返回的数据格式化，转换成符合vue-router的路由格式，然后动态挂载。将路由信息放在后端，这样就可以对路由进行配置了，比如说超级管理员今天很不高兴，不想让某个角色下的用户访问某个路由，直接在该路由下剔除这个角色就可以了</p><h4 id="父子组件通信有哪些"><a href="#父子组件通信有哪些" class="headerlink" title="父子组件通信有哪些"></a>父子组件通信有哪些</h4><p>props/$emit<br>父子组件通信父-&gt;子props，<br>子-&gt;父 $on、$emit 获取父子组件实例</p><p>获取实例的方式调用组件的属性或者方法parent、children Ref</p><p>父-&gt;子孙 Provide、inject 官方不推荐使用，但是写组件库时很常用</p><p>$emit/$on 自定义事件 兄弟组件通信Event Bus 实现跨组件通信 Vue.prototype.$bus = new Vue() 自定义事件<br>（event-bus原理:就是一个发布订阅着模式） (注册后挂载到Vue实例，实现监听和触发)<br>vuex 跨级组件通信Vuex、$attrs、$listeners Provide、inject</p><h4 id="event-bus-发布订阅模式了解嘛"><a href="#event-bus-发布订阅模式了解嘛" class="headerlink" title="$event.bus  发布订阅模式了解嘛"></a>$event.bus  发布订阅模式了解嘛</h4><p>观察者模式和发布订阅模式有什么不同？<br>发布订阅模式其实属于广义上的观察者模式</p><p>在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。</p><p><strong>而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件</strong>。通过调<strong>度中心实现了发布者和订阅者关系的解耦</strong>。使用发布订阅者模式更利于我们代码的可维护性。</p><h5 id="发布-订阅模式（Publish-Subscribe-pattern）是一种常见的软件设计模式，用于实现应用程序内部的解耦和消息传递。该模式的基本思想是将发布者（Publisher）和订阅者（Subscriber）解耦，从而使它们不需要直接相互通信，而是通过一个称为“消息代理”或“事件总线”的中介来传递消息。"><a href="#发布-订阅模式（Publish-Subscribe-pattern）是一种常见的软件设计模式，用于实现应用程序内部的解耦和消息传递。该模式的基本思想是将发布者（Publisher）和订阅者（Subscriber）解耦，从而使它们不需要直接相互通信，而是通过一个称为“消息代理”或“事件总线”的中介来传递消息。" class="headerlink" title="发布-订阅模式（Publish-Subscribe pattern）是一种常见的软件设计模式，用于实现应用程序内部的解耦和消息传递。该模式的基本思想是将发布者（Publisher）和订阅者（Subscriber）解耦，从而使它们不需要直接相互通信，而是通过一个称为“消息代理”或“事件总线”的中介来传递消息。"></a>发布-订阅模式（Publish-Subscribe pattern）是一种常见的软件设计模式，用于实现应用程序内部的解耦和消息传递。该模式的基本思想是将发布者（Publisher）和订阅者（Subscriber）解耦，从而使它们不需要直接相互通信，而是通过一个称为“消息代理”或“事件总线”的中介来传递消息。</h5><p>在这种模式下，发布者负责产生消息并将其发送到消息代理中心，而订阅者则负责从代理中心接收它们感兴趣的消息。发布者和订阅者都不需要知道对方的存在，因为它们只需要与代理中心进行交互即可。</p><p>这种模式的好处是它可以大大降低应用程序的复杂性和耦合度，从而提高其可维护性和可扩展性。此外，它还可以方便地实现异步消息传递和多个订阅者的支持。</p><p>在实现中，发布-订阅模式可以通过事件驱动编程（Event-driven programming）来实现。许多编程语言和框架都提供了内置的实现，例如JavaScript中的Node.js框架的事件（Event）和Java中的Java Message Service（JMS）等。</p><h6 id="event-bus原理-就是一个发布订阅着模式"><a href="#event-bus原理-就是一个发布订阅着模式" class="headerlink" title="event-bus原理:就是一个发布订阅着模式"></a>event-bus原理:就是一个发布订阅着模式</h6><p>是的，事件总线是一个基于发布-订阅模式的消息传递系统，用于在应用程序内或跨应用程序之间传递事件和消息。</p><p>在事件总线中，有一个中央的事件总线对象，负责协调和处理消息的传递。发布者（也称为生产者）向事件总线发送事件或消息，而订阅者（也称为消费者）通过向事件总线注册来接收这些事件或消息。</p><p>当发布者发送事件时，事件总线会将其传递给所有订阅者。订阅者可以选择仅接收特定类型的事件或消息，也可以选择在特定条件下接收事件。这样，事件总线可以实现高度灵活的消息传递，支持异步消息处理，解耦应用程序组件，并提高应用程序的可扩展性和可维护性。</p><p>在实现事件总线时，通常会使用一些特定的框架或库，如Apache Kafka、RabbitMQ、Redis、Google Cloud Pub/Sub等，这些框架提供了各种功能和特性，以满足不同应用场景的需求。</p><h4 id="Vue中的key到底有什么⽤？"><a href="#Vue中的key到底有什么⽤？" class="headerlink" title="Vue中的key到底有什么⽤？"></a>Vue中的key到底有什么⽤？</h4><p>vue 中 key 值的作用可以分为两种情况来考虑。</p><p>第一种情况是 v-if 中使用 key<br><strong>由于Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染</strong>。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。<strong>因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用</strong>。这个时候 key 的作用是用来标识一个独立的元素。</p><p>第二种情况是 v-for 中使用 key<br>用v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。<strong>如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</strong><br>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有唯一 id。</p><h5 id="Vue-为什么不建议用数组的下标index作为key"><a href="#Vue-为什么不建议用数组的下标index作为key" class="headerlink" title="Vue-为什么不建议用数组的下标index作为key"></a>Vue-为什么不建议用数组的下标index作为key</h5><p>key 是给每一个 vnode 的唯一id,可以依靠 key,更准确,更快的拿到 oldVnode 中对应的 vnode 节点，高效的更新虚拟DOM</p><p>用组件唯一的 id（一般由后端返回）作为它的 key，实在没有的情况下，可以在获取到列表的时候通过某种规则为它们创建一个 key，并保证这个 key 在组件整个生命周期中都保持稳定。</p><p><strong>如果你的列表顺序会改变，别用 index 作为 key，和没写基本上没区别，因为不管你数组的顺序怎么颠倒，index 都是 0, 1, 2 这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。列表顺序不变也尽量别用，可能会误导新人。</strong></p><h4 id="react的Hooks讲几个"><a href="#react的Hooks讲几个" class="headerlink" title="react的Hooks讲几个"></a>react的Hooks讲几个</h4><p>当使用 React Hooks 时，可以使用以下一些最常用的 Hooks:</p><h5 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h5><p>useState 是一个函数，用于在函数式组件中添加状态。它接收一个初始状态值，并返回一个数组，其中第一个元素是当前状态的值，第二个元素是更新该状态的函数。例如，以下代码演示如何使用 useState 来跟踪一个计数器的状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">return</span> (<br>    &lt;div&gt;<br>      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;<br>      &lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> setCount(count + <span class="hljs-number">1</span>)&#125;&gt;<br>        Click me<br>      &lt;/button&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h5><p>useEffect 用于在组件渲染后执行副作用操作，例如发起网络请求或订阅事件。它接收一个函数和一个可选的依赖数组。在每次渲染后，React 都会检查依赖项数组中的每个元素是否与上一次渲染时的值相同。如果不同，useEffect 将重新运行函数。如果省略依赖项数组，则 useEffect 将在每次渲染后运行函数。以下是一个示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [data, setData] = useState(<span class="hljs-literal">null</span>);<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    fetchData();<br>  &#125;, []);<br><br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchData</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>);<br>    <span class="hljs-keyword">const</span> json = <span class="hljs-keyword">await</span> response.json();<br>    setData(json);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    &lt;div&gt;<br>      &#123;data ? (<br>        &lt;ul&gt;<br>          &#123;data.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> (<br>            &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;<br>          ))&#125;<br>        &lt;/ul&gt;<br>      ) : (<br>        &lt;p&gt;Loading...&lt;/p&gt;<br>      )&#125;<br>    &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h5><p>useContext 用于在 React 组件之间共享数据，而无需通过层层传递 props。它接收一个上下文对象（由 React.createContext 创建）并返回当前上下文值。例如，以下代码演示了如何使用 useContext 来共享主题值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; ThemeContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./theme-context&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> theme = useContext(ThemeContext);<br><br>  <span class="hljs-keyword">return</span> (<br>    &lt;div style=&#123;&#123; <span class="hljs-attr">backgroundColor</span>: theme.background &#125;&#125;&gt;<br>      &lt;p style=&#123;&#123; <span class="hljs-attr">color</span>: theme.foreground &#125;&#125;&gt;This is some text&lt;/p&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 ThemeContext 是通过 React.createContext 创建的上下文对象，其值被 MyComponent 组件及其子组件所共享。</p><h4 id="Promise讲讲-promise-all-race"><a href="#Promise讲讲-promise-all-race" class="headerlink" title="Promise讲讲  promise.all  race"></a>Promise讲讲  promise.all  race</h4><p>promise 原理 （回调函数+状态处理队列）<br>promise 的本质是回调函数，then 方法的本质是依赖收集，它把 fulfilled 状态要执行的回调函数放在一个队列， rejected 状态要执行的回调函数放在另一个队列。待 promise 从 pending 变为 fulfilled/rejected 状态后，把相应队列的所有函数，执行一遍。</p><h4 id="catch能捕捉到-then的错误吗"><a href="#catch能捕捉到-then的错误吗" class="headerlink" title=".catch能捕捉到.then的错误吗"></a>.catch能捕捉到.then的错误吗</h4><h5 id="mounted中-catch报错了是白屏还是这一块组件没用？"><a href="#mounted中-catch报错了是白屏还是这一块组件没用？" class="headerlink" title="mounted中.catch报错了是白屏还是这一块组件没用？"></a>mounted中.catch报错了是白屏还是这一块组件没用？</h5><p><strong>是白屏</strong><br>如果在 JavaScript 中使用了 .catch() 方法捕获异常，但没有对异常进行处理，可能会导致页面出现白屏或其他错误。这通常是因为未处理的异常会中断 JavaScript 的执行，并导致页面的其他部分无法正常工作。</p><p>在实际应用中，建议始终对异常进行适当的处理，以确保代码的稳定性和可靠性。可以在 .catch() 方法中添加错误处理逻辑，如向用户显示错误信息、记录错误日志、尝试恢复应用程序状态等等。</p><p>除了 .catch() 方法，还可以使用 try…catch 语句来捕获异常，并在 catch 语句块中处理异常。无论使用哪种方式，都应该确保捕获和处理所有可能的异常，以避免页面白屏或其他错误。</p><h4 id="扁平化数组js-手撕代码"><a href="#扁平化数组js-手撕代码" class="headerlink" title="扁平化数组js 手撕代码"></a>扁平化数组js 手撕代码</h4><p>以下是 JavaScript 中实现扁平化数组的几种方法：</p><p>方法一：使用递归</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> flatten<span class="hljs-constructor">Array(<span class="hljs-params">arr</span>)</span> &#123;<br>  var result = <span class="hljs-literal">[]</span>;<br>  <span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">arr</span>[<span class="hljs-params">i</span>])</span>) &#123;<br>      result = result.concat(flatten<span class="hljs-constructor">Array(<span class="hljs-params">arr</span>[<span class="hljs-params">i</span>])</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result.push(arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>);<br>    &#125;<br>  &#125;<br>  return result;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：使用 reduce 方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> flatten<span class="hljs-constructor">Array(<span class="hljs-params">arr</span>)</span> &#123;<br>  return arr.reduce(<span class="hljs-keyword">function</span> (prev, curr) &#123;<br>    return prev.concat(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">curr</span>)</span> ? flatten<span class="hljs-constructor">Array(<span class="hljs-params">curr</span>)</span> : curr);<br>  &#125;, <span class="hljs-literal">[]</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>方法三：使用扩展运算符</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> flatten<span class="hljs-constructor">Array(<span class="hljs-params">arr</span>)</span> &#123;<br>  <span class="hljs-keyword">while</span> (arr.some(item =&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">item</span>)</span>)) &#123;<br>    arr = <span class="hljs-literal">[]</span>.concat(...arr);<br>  &#125;<br>  return arr;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法四：使用迭代器</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span>* flatten<span class="hljs-constructor">Array(<span class="hljs-params">arr</span>)</span> &#123;<br>  <span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">arr</span>[<span class="hljs-params">i</span>])</span>) &#123;<br>      yield* flatten<span class="hljs-constructor">Array(<span class="hljs-params">arr</span>[<span class="hljs-params">i</span>])</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      yield arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br>var flattenedArray = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>from(flatten<span class="hljs-constructor">Array([1, [2, 3], [4, [5, 6]]])</span>);<br></code></pre></td></tr></table></figure><p>以上是一些常见的扁平化数组的方法。无论使用哪种方法，都需要确保对于所有可能的数组嵌套层次，都可以正确地扁平化数组。</p><h4 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h4><ol><li>技术栈  react</li><li>公司项目  主要做toB的sass平台   一些文件的上传，素材的处理，（公司目前前端3个左右 后端有几个，预计招聘20个开发）</li><li>反问能给一些建议<br>答： 建议多做项目，公司的项目，把事情做的最好，不只是完成。（完成之后看看有没有别的更好的方法解决）</li></ol><h3 id="面试总结-二面-000"><a href="#面试总结-二面-000" class="headerlink" title="面试总结(二面)000"></a>面试总结(二面)000</h3><h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h4><h4 id="vue和react的区别-（从原理上解释）"><a href="#vue和react的区别-（从原理上解释）" class="headerlink" title="vue和react的区别 （从原理上解释）"></a>vue和react的区别 （从原理上解释）</h4><p>从原理上来说，Vue和React的区别主要体现在以下几个方面：</p><p>数据绑定方式：<strong>Vue采用双向数据绑定，React采用单向数据流</strong>。在Vue中，每个组件都有一个响应式的数据对象，当数据发生变化时，视图会自动更新。<strong>而在React中，数据是通过props从父组件向子组件传递的，子组件需要通过回调函数向父组件传递数据</strong>。</p><p>组件化开发方式：<strong>Vue中的组件化开发更加直观和简单，每个组件都包含了模板、逻辑和样式，可以直接编写</strong>。而在React中，<strong>组件的逻辑和样式是通过JavaScript代码编写的，需要使用JSX语法进行组件开发</strong>。</p><p><strong>数据流管理方式</strong>：Vue中提供了Vuex状态管理库，可以更好地管理大型应用中的状态，包括状态的修改和响应。而React则更倾向于使用第三方状态管理库，例如Redux。</p><p>渲染性能优化：<strong>Vue和React都采用了虚拟DOM技术，但是它们的渲染性能优化方式有所不同</strong>。在Vue中，<strong>通过模板编译和静态分析等技术，可以减少虚拟DOM的比较和计算</strong>；而在React中，通过<strong>Fiber架构和异步渲染等技术</strong>，可以更好地控制渲染的流程和响应性能。</p><p>总体而言，Vue和React的区别主要在于数据绑定方式、组件化开发方式、数据流管理方式和渲染性能优化方式等方面。在实际开发中，我们可以根据具体的应用场景和需求选择合适的框架，以提高开发效率和应用程序性能。</p><h4 id="为什么vue采用的是双向数据绑定，react用的是单向数据流"><a href="#为什么vue采用的是双向数据绑定，react用的是单向数据流" class="headerlink" title="为什么vue采用的是双向数据绑定，react用的是单向数据流"></a>为什么vue采用的是双向数据绑定，react用的是单向数据流</h4><p>Vue和React是两个流行的前端框架，它们的数据绑定方式不同，其中Vue采用的是双向数据绑定，React采用的是单向数据流。</p><p><strong>双向数据绑定指的是数据的变化会立即反映到视图上，同时用户的交互操作也会立即更新数据</strong>。在Vue中，使用v-model指令可以实现双向数据绑定。双向数据绑定的优点是可以减少开发人员的代码量和重复性工作，同时也方便用户操作和体验。</p><p>而<strong>单向数据流指的是数据只能从父组件传递到子组件，子组件无法直接修改父组件的数据</strong>。在React中，父组件可以通过props将数据传递给子组件，子组件可以通过回调函数将修改后的数据传递给父组件。单向数据流的优点是可以更好地控制数据流向，避免出现意料之外的数据变化，同时也方便进行数据的追踪和调试。</p><p>选择双向数据绑定还是单向数据流，主要取决于具体的应用场景和开发需求。Vue适用于开发中小型应用，双向数据绑定可以提高开发效率；React适用于开发大型应用，单向数据流可以提高代码的可维护性和可读性。</p><h4 id="typeScript有了解嘛"><a href="#typeScript有了解嘛" class="headerlink" title="typeScript有了解嘛"></a>typeScript有了解嘛</h4><h4 id="原型链的顶端是什么（如果找不到是什么）"><a href="#原型链的顶端是什么（如果找不到是什么）" class="headerlink" title="原型链的顶端是什么（如果找不到是什么）"></a>原型链的顶端是什么（如果找不到是什么）</h4><p>在JavaScript中，每个对象都有一个原型（prototype）属性，指向它的原型对象。原型对象也有原型属性，指向它的原型对象，这样就形成了原型链。</p><p>原型链的顶端是Object.prototype，它是所有对象的祖先对象。<strong>Object.prototype的原型指向null，即它没有原型对象</strong>，所以<strong>当在原型链中找不到某个属性或方法时，就会返回undefined</strong>，而不是继续查找。</p><p>例如，当我们创建一个对象，并尝试访问它的属性或方法时，JavaScript引擎会先查找该对象本身是否具有该属性或方法，如果没有，则沿着原型链向上查找，直到找到该属性或方法或者到达Object.prototype为止。如果在整个原型链上都没有找到该属性或方法，那么就返回undefined。</p><p>总之，<strong>原型链的顶端是Object.prototype，它是所有对象的祖先对象</strong>，当在原型链中<strong>找不到某个属性或方法时，就会返回undefined</strong>。（这个答错了，回答的是null）</p><h4 id="事件循环（如果微任务里面产生了微任务是继续执行微任务还是下一个宏任务？）-—是执行完产生的所有微任务再执行下一个宏任务"><a href="#事件循环（如果微任务里面产生了微任务是继续执行微任务还是下一个宏任务？）-—是执行完产生的所有微任务再执行下一个宏任务" class="headerlink" title="事件循环（如果微任务里面产生了微任务是继续执行微任务还是下一个宏任务？） —是执行完产生的所有微任务再执行下一个宏任务"></a>事件循环（如果微任务里面产生了微任务是继续执行微任务还是下一个宏任务？） —是执行完产生的所有微任务再执行下一个宏任务</h4><p>在JavaScript中，事件循环机制（Event Loop）用于协调处理事件和执行代码的顺序。它不断地从任务队列中取出任务，执行任务，并在任务执行完毕后等待新的任务加入队列。</p><p>在事件循环中，<strong>每次执行一个宏任务（例如脚本的整体代码、setTimeout/setInterval回调函数等），都会在宏任务执行完毕后先执行所有的微任务（例如Promise回调函数、MutationObserver回调函数等），然后才会执行下一个宏任务。这个过程称为“微任务队列优先于宏任务队列”。</strong></p><p><strong>如果在微任务队列中产生了新的微任务，那么它会被添加到微任务队列的末尾，等待下一次事件循环时执行。如果在微任务执行过程中产生了新的微任务，那么这些新的微任务也会被依次添加到微任务队列的末尾。</strong></p><p>举个例子，假设有如下代码：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>.resolve().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;微任务1&#x27;</span>)<br>  <span class="hljs-built_in">Promise</span>.resolve().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;微任务2&#x27;</span>)<br>  &#125;)<br>&#125;)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;宏任务1&#x27;</span>)<br>  <span class="hljs-built_in">Promise</span>.resolve().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;微任务3&#x27;</span>)<br>  &#125;)<br>&#125;, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>当上述代码执行时，它会依次执行如下步骤：</p><ol><li><p>执行第一个宏任务（即整体代码）。</p></li><li><p>执行第一个微任务，即输出“微任务1”。</p></li><li><p>在执行微任务的过程中，产生了新的微任务“微任务2”，它会被添加到微任务队列的末尾。</p></li><li><p>第一个微任务执行完毕后，开始执行第二个微任务，即输出“微任务2”。</p></li><li><p>执行第二个宏任务，即输出“宏任务1”。</p></li><li><p>在执行第二个宏任务的过程中，产生了新的微任务“微任务3”，它会被添加到微任务队列的末尾。</p></li><li><p>第二个宏任务执行完毕后，开始执行微任务队列中的剩余任务，即输出“微任务3”。<br>综上所述，如果微任务队列中产生了新的微任务，它们会被依次添加到微任务队列的末尾，等待下一次事件循环时执行，不会影响当前的微任务执行。</p><h4 id="网络模型-（5层-7层）http在哪一层–应用层"><a href="#网络模型-（5层-7层）http在哪一层–应用层" class="headerlink" title="网络模型 （5层-7层）http在哪一层–应用层"></a>网络模型 （5层-7层）http在哪一层–应用层</h4><p>5层–（<strong>应-运-网-链-物</strong>） –（应用层-运输层-网络层-链路层-物理层）<br>7层–(应-(表现层-会话层)运-网-链-物)</p><h4 id="缓存有哪些（强缓存-协商缓存）"><a href="#缓存有哪些（强缓存-协商缓存）" class="headerlink" title="缓存有哪些（强缓存/协商缓存）"></a>缓存有哪些（强缓存/协商缓存）</h4><p>浏览器与服务器<strong>通信的方式为应答模式</strong>，即是：<strong>浏览器发起HTTP请求 – 服务器响应该请求</strong>。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中</p></li><li><p>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</p></li><li><p>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</p></li></ol><p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。</p><p><strong>强制缓存强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程</strong><br>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <strong>Expires 和 Cache-Control</strong>，其中<strong>Cache-Control优先级比Expires</strong>高。强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下： 状态仍然返回200，但不会请求数据，<strong>在浏览器中能明显看到from cache字样</strong>。</p><ol><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。</li><li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。</li><li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li></ol><p><strong>协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</strong><br><strong>Etag &gt;Last-Modifie Last-Modified</strong>与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304<br>同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since 和 Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。协商缓存主要有以下两种情况：</p><ol><li>协商缓存生效，返回304</li><li>协商缓存失效，返回200和请求结果结果<br>传送门 ☞ #彻底理解浏览器的缓存机制<br><a href="https://pengzhenglong.github.io/2022/01/07/%E8%AE%A1%E7%BD%91+%E6%B5%8F%E8%A7%88%E5%99%A8+http+%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6-%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98-amp-amp-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98">博客地址</a><h4 id="http的content-type有哪些"><a href="#http的content-type有哪些" class="headerlink" title="http的content-type有哪些"></a>http的content-type有哪些</h4>HTTP的Content-Type请求头字段用于指定发送给客户端的实体的类型。常见的Content-Type值及其含义如下：<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">text</span>/plain：纯文本格式，没有指定格式的字节流。<br><span class="hljs-type">text</span>/html：HTML格式的文本。<br><span class="hljs-type">text</span>/css：Cascading Style Sheets (CSS) 样式表。<br><span class="hljs-type">text</span>/javascript：JavaScript脚本代码。<br>application/<span class="hljs-type">json</span>：<span class="hljs-type">JSON</span>格式的数据。<br>application/<span class="hljs-type">xml</span>：<span class="hljs-type">XML</span>格式的数据。<br>application/pdf：PDF文档格式。<br>image/jpeg：JPEG格式的图片。<br>image/png：PNG格式的图片。<br>audio/mpeg：MPEG音频文件。<br>video/mp4：MP4格式的视频文件。<br></code></pre></td></tr></table></figure>除了上述列出的类型之外，还有很多其他的Content-Type类型，这些类型可以根据实际需要进行自定义。Content-Type值通常与HTTP请求的Accept头字段一起使用，以便指定客户端所期望的响应类型。例如，如果客户端希望接收JSON格式的响应，它可以将Accept头字段设置为“application/json”。</li></ol><h5 id="如何设置呢"><a href="#如何设置呢" class="headerlink" title="如何设置呢"></a>如何设置呢</h5><p>在HTTP请求中设置Content-Type请求头字段通常有两种方法：</p><p>通过手动设置请求头字段：<br>在大多数HTTP客户端中，您可以手动设置Content-Type请求头字段。例如，使用axios库发送HTTP请求时，您可以通过设置headers选项来指定Content-Type值，例如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">axios</span><span class="hljs-selector-class">.post</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>, &#123;<br>  <span class="hljs-comment">// 请求数据...</span><br>&#125;, &#123;<br>  headers: &#123;<br>    &#x27;<span class="hljs-attribute">Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>这将向服务器发送一个Content-Type值为“application/json”的请求。</p><p>使用特定的API方法：<br>在某些HTTP客户端库中，例如jQuery和Fetch API，您可以使用特定的API方法来发送不同类型的请求，这些方法将自动设置Content-Type请求头字段。例如，使用Fetch API发送JSON格式的请求时，您可以使用以下代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">fetch(<span class="hljs-string">&#x27;/api/data&#x27;</span>, &#123;<br>  method: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  body: JSON.stringify(&#123;<br>    <span class="hljs-regexp">//</span> 请求数据...<br>  &#125;),<br>  headers: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这将自动设置Content-Type请求头字段为“application/json”。</p><p>请注意，Content-Type请求头字段必须与请求实体的格式匹配，否则服务器可能无法正确解析请求。因此，在设置Content-Type值时，请确保选择正确的格式。</p><h4 id="后端怎么修改返回的status-code（状态码）"><a href="#后端怎么修改返回的status-code（状态码）" class="headerlink" title="后端怎么修改返回的status.code（状态码）"></a>后端怎么修改返回的status.code（状态码）</h4><p>HTTP状态码是由服务器返回的标准HTTP响应的一部分，它们指示请求的成功或失败状态。状态码是HTTP协议的一部分，它们定义了不同类型的响应，例如200表示成功，404表示未找到，500表示服务器错误等等。</p><p>由于HTTP状态码是由服务器返回的，客户端无法直接修改它们。只有服务器可以控制响应的状态码，根据服务器处理请求的结果来生成适当的状态码。如果您想修改HTTP状态码，您需要访问服务器并修改响应的代码。</p><p>在Node.js中，您可以使用内置的HTTP模块来创建HTTP服务器，并在响应对象上设置HTTP状态码。以下是一个简单的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><br><span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 处理请求</span><br><br>  <span class="hljs-comment">// 设置状态码为404</span><br>  res.statusCode = <span class="hljs-number">404</span>;<br><br>  <span class="hljs-comment">// 发送响应</span><br>  res.end(<span class="hljs-string">&#x27;Not found&#x27;</span>);<br>&#125;);<br><br>server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Server is running on port 3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个HTTP服务器，并在响应对象上设置了状态码为404。在实际应用中，您可以根据请求的处理结果动态设置状态码。</p><p>除了设置状态码外，您还可以设置其他HTTP响应头，例如内容类型、缓存控制、跨域等。例如，您可以使用以下代码设置响应的内容类型：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">res.setHeader(<span class="hljs-symbol">&#x27;Content</span>-<span class="hljs-keyword">Type</span>&#x27;, <span class="hljs-symbol">&#x27;text</span>/html&#x27;);<br></code></pre></td></tr></table></figure><p>在这个示例中，我们将响应的内容类型设置为HTML。</p><p>总之，在Node.js中，您可以通过设置响应对象的状态码和其他HTTP响应头来控制HTTP响应。</p><p>除了示例中设置404状态码以外，您可以通过将res.statusCode属性设置为任何有效的HTTP状态码来设置响应的状态码。例如，以下是一些常见的HTTP状态码及其含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">200：请求成功<br>201：创建成功<br>204：请求成功，但没有返回内容<br>400：请求参数不正确或格式不正确<br>401：未授权访问资源<br>403：禁止访问资源<br>404：请求的资源不存在<br>500：服务器错误<br>例如，如果您要将状态码设置为500，可以使用以下代码：<br></code></pre></td></tr></table></figure><p>res.statusCode = 500;<br>然后，您可以使用res.end()方法向客户端发送响应内容。例如：</p><p>res.end(‘Server Error’);<br>在实际应用中，您需要根据请求的处理结果设置适当的状态码，以便客户端可以正确处理响应并采取适当的行动。</p><h4 id="跨域怎么实现？jsonp的原理是什么？"><a href="#跨域怎么实现？jsonp的原理是什么？" class="headerlink" title="跨域怎么实现？jsonp的原理是什么？"></a>跨域怎么实现？jsonp的原理是什么？</h4><p><strong>跨域，指的是浏览器不能执行其他网站的脚本。浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行</strong><br>解决办法：</p><ol><li>JSONP：<strong>注意JSONP只支持GET请求，不支持POST请求</strong>。<br>原理：ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。 — callback</li><li>代理：写后端接口，在后端调用页面拿到返回值返回给html文件。相当于绕过了浏览器，就不会存在跨域问题。例；(nigx反向代理)</li><li>CORS CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin:*&#x27;</span>);<span class="hljs-comment">//允许所有来源访问</span><br><span class="hljs-selector-tag">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Method:POST,GET&#x27;</span>);<span class="hljs-comment">//允许访问的方式</span><br></code></pre></td></tr></table></figure></li><li>proxy代理 目前常用方式,通过服务器设置代理 在 vue.config.js 项目中配置 proxy 解决跨域问题</li><li>window.postMessage() 利用h5新特性window.postMessage()</li></ol><p><strong>Options(CORS跨域，非简单请求)</strong><br>1.HTTP的options方法作用</p><p>检测服务器所支持的请求方法。（比如：‘／user’路由支持哪些方法：get、post、delete…）<br>CORS中的预检请求（检测某个接口是否支持跨域）</p><p>2.allowedMethods方法<br>响应options方法，告诉它所支持的请求方法<br>相应的返回405（不允许）和501（没实现）（比如我使用delete，会返回405，因为我没有写这个接口。但我使用link接口请求，会返回501，因为koa里不支持link请求）<br>options 请求就是预检请求，可用于检测服务器允许的 http 方法。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起 OPTIONS 请求，即 CORS 预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求。</p><h4 id="uniapp为什么可以跨端"><a href="#uniapp为什么可以跨端" class="headerlink" title="uniapp为什么可以跨端"></a>uniapp为什么可以跨端</h4><p>UniApp是一种基于Vue.js框架的跨平台开发解决方案，它可以使用一套代码同时构建多个不同平台的应用程序，包括iOS、Android、H5和微信小程序等。UniApp之所以可以实现跨端，主要有以下几个原因：</p><ol><li><p>采用基于Web标准的技术：UniApp采用了基于Web标准的技术，包括HTML、CSS和JavaScript等，这些技术可以在各个平台上得到很好的支持。因此，UniApp能够实现跨端。</p></li><li><p>基于多端适配的框架：UniApp框架对多端适配进行了优化，它会根据不同的平台，生成对应的代码和样式，从而能够适配多个不同的平台。</p></li><li><p>借助原生能力实现跨端：UniApp还可以借助原生能力实现跨端。例如，UniApp可以调用原生的API来实现一些特定功能，从而使得应用程序在各个平台上都能够具有相同的特性和体验。</p></li></ol><p>综上所述，UniApp之所以可以实现跨端，是因为它采用了基于Web标准的技术，并且通过框架的多端适配以及借助原生能力的方式，来实现跨平台的开发。</p><h4 id="了解浏览器原理-–说成http请求url了"><a href="#了解浏览器原理-–说成http请求url了" class="headerlink" title="了解浏览器原理 –说成http请求url了"></a>了解浏览器原理 –说成http请求url了</h4><p>浏览器是一种用于访问互联网的软件应用程序，它通过解析 HTML、CSS、JavaScript 等网络资源，将它们呈现给用户。以下是浏览器的一些基本原理：</p><ol><li><p>用户界面：浏览器的用户界面包括地址栏、后退和前进按钮、书签等等。浏览器的用户界面通常由浏览器的开发者设计，用户可以根据自己的喜好进行个性化设置。</p></li><li><p>渲染引擎：渲染引擎负责将网页内容解析成可视化的格式。主要的渲染引擎有 Blink（Chrome 和 Opera 使用）、Gecko（Firefox 使用）以及 WebKit（Safari 使用）。渲染引擎可以理解 HTML、CSS、JavaScript 等网页资源，并将它们渲染成用户可以看到的样式。</p></li><li><p>JavaScript 解释器：JavaScript 解释器负责解析和执行 JavaScript 代码。现代浏览器通常使用 Just-in-Time（JIT）编译器，以便提高 JavaScript 的性能和效率。</p></li><li><p>布局引擎：布局引擎负责处理网页的布局和排版。它会根据渲染引擎生成的网页内容，将内容排版成适合于显示的格式，并在用户界面中进行展示。</p></li><li><p>网络：浏览器的网络组件负责从网络中获取所需的资源，如 HTML 文件、CSS 样式表、JavaScript 脚本等等。它通过使用 HTTP 或 HTTPS 协议，向服务器请求资源并获取响应，然后将响应的内容提供给渲染引擎进行解析和渲染。</p></li><li><p>数据存储：浏览器还提供了一些数据存储的机制，用于存储本地数据，如 cookie、localStorage 和 sessionStorage 等等。这些存储机制使得网站可以保存用户的偏好设置、登录状态等等，并提供一种用于在浏览器和服务器之间传输数据的机制。</p></li></ol><h4 id="性能优化有了解吗-–能讲讲吗"><a href="#性能优化有了解吗-–能讲讲吗" class="headerlink" title="性能优化有了解吗 –能讲讲吗"></a>性能优化有了解吗 –能讲讲吗</h4><p>http2&gt;http1(优势？)<br>后面讲了一下项目中的防抖节流</p><h4 id="如何减少项目中的bug"><a href="#如何减少项目中的bug" class="headerlink" title="如何减少项目中的bug"></a>如何减少项目中的bug</h4><p>需求澄清，串讲，反串讲，设计，编码，代码检视，用例评审，自测。</p><p>减少项目中的bug需要采取一系列措施，下面是一些可能有用的建议：</p><p>1.编写高质量的代码：编写高质量的代码是减少bug的最有效方法之一。为了使代码更加清晰、简洁、可读性更好，可以通过代码规范、注释、文档以及自动化测试等方式来实现。</p><p>2.使用自动化测试：自动化测试可以提高代码质量，减少bug的出现。可以采用单元测试、集成测试、接口测试、性能测试等方式来确保代码可靠性。</p><p>3.代码审查：定期进行代码审查，及时发现并修复潜在的问题，这有助于提高代码质量。</p><p>4.使用版本控制工具：使用版本控制工具可以追踪代码变更，并允许你回退到之前的版本。这可以防止错误代码被部署到生产环境，并使团队成员更容易协作。</p><p>5.使用可靠的第三方库：对于需要使用第三方库的项目，选择一个可靠的、有良好口碑的库，可以减少出现bug的机会。同时，需要及时更新第三方库，以避免遗留的安全漏洞和错误。</p><p>总之，为了减少项目中的bug，需要具备高质量的代码、自动化测试和代码审查等技能来检查、分发并减少代码错误。</p><h4 id="配置一套符合团队习惯且规范的husky能讲讲吗"><a href="#配置一套符合团队习惯且规范的husky能讲讲吗" class="headerlink" title="配置一套符合团队习惯且规范的husky能讲讲吗"></a>配置一套符合团队习惯且规范的husky能讲讲吗</h4><h4 id="反问？-公司的业务和项目-–公司的培养计划和晋升计划？"><a href="#反问？-公司的业务和项目-–公司的培养计划和晋升计划？" class="headerlink" title="反问？ 公司的业务和项目 –公司的培养计划和晋升计划？"></a>反问？ 公司的业务和项目 –公司的培养计划和晋升计划？</h4><h4 id="建议-（不只是要会用，原理这一块得熟悉）"><a href="#建议-（不只是要会用，原理这一块得熟悉）" class="headerlink" title="建议 （不只是要会用，原理这一块得熟悉）"></a>建议 （不只是要会用，原理这一块得熟悉）</h4><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><h3 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h3><h4 id="图谱可视化分析项目-是干啥的（详细讲讲是有啥作用，分析了啥，数据挖掘了什么）"><a href="#图谱可视化分析项目-是干啥的（详细讲讲是有啥作用，分析了啥，数据挖掘了什么）" class="headerlink" title="图谱可视化分析项目 是干啥的（详细讲讲是有啥作用，分析了啥，数据挖掘了什么）"></a>图谱可视化分析项目 是干啥的（详细讲讲是有啥作用，分析了啥，数据挖掘了什么）</h4><p>应用知识图谱技术和图分析算法进行知识挖掘、知识分析的工具。与统计分析相比，GKP图谱可视分析在社群发现、最短路径分析、关键节点/因素洞察、活跃因素分析、异常发现等领域更加直观和高效。</p><h5 id="司法-知识卡片-检索卡片功能实现"><a href="#司法-知识卡片-检索卡片功能实现" class="headerlink" title="[司法-知识卡片]检索卡片功能实现"></a>[司法-知识卡片]检索卡片功能实现</h5><p>卡片类型      —卡片类型包含案由卡片、案件卡片、内部文书卡片、裁判文书卡片、典型案例卡片、法律法规卡片、法律条文卡片、当事人卡片、法院卡片、法官卡片、律师事务所卡片、律师卡片等。根据命中的实体显示卡片内容，无命中实体时，只显示检索结果，不显示卡片信息。</p><p>案件卡片     —-案件卡片主要显示案件的字段信息，包含案件的名称、案由、适用程序、法院名称、承办部门、承办人、简要案情等。可直接链接进入案件详情页进行查看。</p><p>裁判文书卡片  —-显示裁判文书的名称、法院、案号、案由、案件类型、文书类型、裁判日期、判决结果(原告胜诉) 、案件要素等，:并切换显示事实认定段、裁判理由段、引用法条段、裁判结果段的内容支持跳转到裁判文书详情页进行查看。</p><h5 id="司法-实体对比-对比功能实现"><a href="#司法-实体对比-对比功能实现" class="headerlink" title="[司法-实体对比)]对比功能实现"></a>[司法-实体对比)]对比功能实现</h5><p>加入对比—  列表加入对比      律师、当事人的列表页可加入对比栏<br>            详情页加入对比    律师、当事人、法院、法官、律师事务所等的详情页可加入对比栏<br>            卡片加入对比    律师、当事人、法院、法官、律师事务所检索结果的卡片显示中，可加入对比栏<br>对比栏  —  去对比        点击去对比，进入对比详情页<br>            取消对比项     点击对比栏中某个对比项中的取消按钮，可排除该对比项<br>            同类对比     对比栏中的对比项，必须为同一类，当加入不同类时，之前的对比项自动取消，只保留最新加入的对比项。<br>对比详情 —对比详情    以表格的形式，对比各个对比想的对比维度。</p><p>律师画像《图谱版》 – 搜索与筛选—维度检索   支持选择搜索维度进行搜索，可选维度包括律师姓名、所在律所等维度进行检索。<br>                                检索结果列表显示   支持显示律所的姓名、所在律所、裁判文书数量等信息<br>                                列表分页       支持检索结果列表分页展示<br>                                可配置检索功能     升级可配置检索功能<br>                                律师信息显示      律师详情页显示律师的基本信息，包括姓名、所在律所、裁判文书数量等<br>                     画像详情     律师信息显示    律师详情页显示律师的基本信息，包括姓名、所在律所、裁判文书数量等<br>                                可视化画像      画像信息包括作为原告代理人案件胜败诉分析、作为被告代理人胜败诉分析、法院分布案由分布、案件裁判时间分布、案件审理程序分布、法官分布、结案方式分布等。<br>                                筛选条件        支持对律师相关的裁判文书按照多维检索条件进行进一步检索，检索结果影响画像统计以及数据列表的显示筛选条件默认收起，可手动展开</p><p>当事人画像(图谱版)   搜索与筛选   维度检索           支持选择搜索维度进行搜索，可选维度包括当事人名称等维度进行检索。<br>                                检索结果列表显示    支持显示当事人的姓名/名称、住所地、裁判文书数量等信息<br>                                列表分页           支持检索结果列表分页展示<br>                                可配置检索功能     升级可配置检索功能</p><pre><code>                画像详情     当事人信息显示     当事人详情页显示律师的基本信息，包括姓名/名称、住所地数量等                            可视化画像         画像信息包括作为原告案件胜败诉分析、作为被告胜败诉分析、法院分布、案由分布案件裁判时间分布、案件审理程序分布、法官分布、结案方式分布等。                            筛选条件        支持对当事人相关的裁判文书按照多维检索条件进行进一步检索 检索结果影响画像统计以及数据列表的显示。筛选条件默认收起可手动展开</code></pre><h5 id="后端返回的数据类型是什么？"><a href="#后端返回的数据类型是什么？" class="headerlink" title="后端返回的数据类型是什么？"></a>后端返回的数据类型是什么？</h5><p>后端返回的数据类型可以是多种形式，最常见的包括：</p><ol><li><p>JSON（JavaScript Object Notation）：JSON是一种轻量级的数据交换格式，它基于JavaScript语法，易于读写和解析。许多Web应用程序使用JSON作为数据传输格式，使得前端可以方便地处理和展示后端返回的数据。</p></li><li><p>XML（Extensible Markup Language）：XML是一种标记语言，可用于描述和传输数据。与JSON相比，XML通常更为复杂，但也具有广泛的支持和应用场景。</p></li><li><p>HTML（Hypertext Markup Language）：HTML是一种用于开发Web页面的标记语言。虽然HTML主要用于前端显示，但在某些场景下，后端也可以将数据以HTML格式返回给客户端。</p></li><li><p>Text：后端有时也可能将数据以纯文本形式返回，这种情况下需要前端自行解析和处理数据。</p></li><li><p>二进制数据：有些情况下，后端可能会返回二进制数据，如图像、视频、音频等。此时，前端需要根据数据类型进行解析和处理。</p></li></ol><p>需要注意的是，不同的后端接口可能采用不同的数据格式，因此前端需要根据实际情况进行处理。同时，后端返回的数据还需要考虑数据安全性和可靠性等问题。</p><h5 id="后端返回的数据结构可能有多种形式，以下是一些常见的数据结构："><a href="#后端返回的数据结构可能有多种形式，以下是一些常见的数据结构：" class="headerlink" title="后端返回的数据结构可能有多种形式，以下是一些常见的数据结构："></a>后端返回的数据结构可能有多种形式，以下是一些常见的数据结构：</h5><ol><li><p>数组（Array）：数组是一组有序的数据集合，每个元素可以是任何类型的数据。在很多场景下，后端会将一组数据封装为一个数组，并将其返回给前端。</p></li><li><p>对象（Object）：对象是一组键值对的集合，其中每个键对应一个值。后端通常会将一些相关联的数据封装在一个对象中，并将其作为响应数据返回给前端。</p></li><li><p>树形结构（Tree）：树形结构是一种层级化的数据结构，它由根节点、子节点等组成，并且节点之间具有父子关系。在某些情况下，后端会将返回的数据组织成树形结构，以帮助前端更好地处理和展示数据。</p></li><li><p>图形结构（Graph）：图形结构是由节点和边组成的数据结构，它可以用于表示复杂的关系和网络。在某些场景下，后端可能会将返回的数据组织成图形结构，以便前端进行处理和分析。</p></li><li><p>集合（Set）：集合是一组互不相同的元素的集合。在某些场景下，后端也可能会将数据封装为一个集合，并将其返回给前端。</p></li><li><p>键值对（Key-Value）：键值对是一种简单的数据结构，它由一个键和一个与之对应的值组成。后端通常会使用键值对来描述一些配置信息或元数据等。</p></li></ol><p>需要注意的是，以上数据结构并不是一成不变的，实际上，后端会根据不同的业务需求和开发场景，采用不同的数据结构来组织和返回数据。前端需要根据实际情况进行选择和解析，以便更好地利用后端返回的数据。</p><p>后端返回的数组结构和树形结构js代码示例</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 数组结构</span><br>[<br>  &#123;<br>    <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>    <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">18</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;李四&quot;</span>,<br>    <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">20</span><br>  &#125;<br>]<br><span class="hljs-comment">// 树形结构</span><br>&#123;<br>  <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>  <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">&quot;children&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-number">2</span>,<br>      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;李四&quot;</span>,<br>      <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">20</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-number">3</span>,<br>      <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;王五&quot;</span>,<br>      <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">22</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="大文件上传，使用切片上传形式，支持上传、暂停、续传-1"><a href="#大文件上传，使用切片上传形式，支持上传、暂停、续传-1" class="headerlink" title="大文件上传，使用切片上传形式，支持上传、暂停、续传"></a>大文件上传，使用切片上传形式，支持上传、暂停、续传</h4><h4 id="虚拟dom–Virtual-DOM讲讲–还有应用场景"><a href="#虚拟dom–Virtual-DOM讲讲–还有应用场景" class="headerlink" title="虚拟dom–Virtual DOM讲讲–还有应用场景"></a>虚拟dom–Virtual DOM讲讲–还有应用场景</h4><h4 id="闭包是应用场景–项目中的–防抖"><a href="#闭包是应用场景–项目中的–防抖" class="headerlink" title="闭包是应用场景–项目中的–防抖"></a>闭包是应用场景–项目中的–防抖</h4><h4 id="私下的学习习惯"><a href="#私下的学习习惯" class="headerlink" title="私下的学习习惯"></a>私下的学习习惯</h4><h4 id="再讲讲你项目中的难点–（我讲了这个–实现select下拉搜索，无限滚动）"><a href="#再讲讲你项目中的难点–（我讲了这个–实现select下拉搜索，无限滚动）" class="headerlink" title="再讲讲你项目中的难点–（我讲了这个–实现select下拉搜索，无限滚动）"></a>再讲讲你项目中的难点–（我讲了这个–实现select下拉搜索，无限滚动）</h4><h4 id="反问-1"><a href="#反问-1" class="headerlink" title="反问"></a>反问</h4><p>建议–多了解业务（前端更贴近用户）<br>技术栈Vue</p><h4 id="1-负责实体”全息档案”画像配置、实体”全息档案”对比开发、文档分析模块开发"><a href="#1-负责实体”全息档案”画像配置、实体”全息档案”对比开发、文档分析模块开发" class="headerlink" title="1. 负责实体”全息档案”画像配置、实体”全息档案”对比开发、文档分析模块开发"></a>1. 负责实体”全息档案”画像配置、实体”全息档案”对比开发、文档分析模块开发</h4><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><p>对于多个数组的情况，可以使用 JavaScript 的 reduce 方法结合上一步的判断逻辑来实现。</p><p>示例代码如下：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compareArrays</span><span class="hljs-params">(<span class="hljs-rest_arg">...arrays</span>)</span> </span>&#123;<br>  <span class="hljs-comment">// 利用 reduce 方法将所有数组两两比较</span><br>  <span class="hljs-keyword">return</span> arrays.reduce((prev, curr) =&gt; &#123;<br>    <span class="hljs-comment">// 如果前后两个数组长度不相等，则直接返回 false</span><br>    <span class="hljs-keyword">if</span> (prev.length !== curr.length) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历两个数组，判断每个元素是否相等</span><br>    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; prev.length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (prev[i] !== curr[i]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 数组元素全部相等，返回 true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// 示例用法</span><br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> arr3 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> arr4 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br>console.log(compareArrays(arr1, arr2)); <span class="hljs-comment">// 输出 true</span><br>console.log(compareArrays(arr1, arr3)); <span class="hljs-comment">// 输出 false</span><br>console.log(compareArrays(arr1, arr2, arr3)); <span class="hljs-comment">// 输出 false</span><br>console.log(compareArrays(arr1, arr2, arr4)); <span class="hljs-comment">// 输出 false</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个名为 compareArrays 的函数，该函数使用了 ES6 的 rest 参数语法来接收任意数量的数组参数。然后，我们使用 reduce 方法将所有数组两两比较，并根据前文所述的判断逻辑返回最终比较结果。</p><p>需要注意的是，reduce 方法遍历数组时是从第 2 个元素开始的，因此我们需要在比较之前先判断前后两个数组长度是否相等。此外，如果传入空数组或只有一个数组参数，则该方法会直接返回 undefined，因此需要特殊处理这种情况。</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><h3 id="面试记录-（面试那边有我这的回声-面试体验不怎么好）（数组和对象的方法不怎么熟悉了，回去看看）"><a href="#面试记录-（面试那边有我这的回声-面试体验不怎么好）（数组和对象的方法不怎么熟悉了，回去看看）" class="headerlink" title="面试记录 （面试那边有我这的回声-面试体验不怎么好）（数组和对象的方法不怎么熟悉了，回去看看）"></a>面试记录 （面试那边有我这的回声-面试体验不怎么好）（数组和对象的方法不怎么熟悉了，回去看看）</h3><h3 id="自我介绍-1"><a href="#自我介绍-1" class="headerlink" title="自我介绍"></a>自我介绍</h3><h3 id="问为什么没有写CSS，这家公司比较注重基础"><a href="#问为什么没有写CSS，这家公司比较注重基础" class="headerlink" title="问为什么没有写CSS，这家公司比较注重基础"></a>问为什么没有写CSS，这家公司比较注重基础</h3><h3 id="js数据类型"><a href="#js数据类型" class="headerlink" title="js数据类型"></a>js数据类型</h3><p>boolean, number, string,null,undefined,object（6中基本数据类型）</p><p>symbol,bigInt（新增的数据类型）</p><h3 id="js判断类型"><a href="#js判断类型" class="headerlink" title="js判断类型"></a>js判断类型</h3><p>判断方法：<strong>typeof()，instanceof，constructor,Object.prototype.toString.call()等</strong></p><h4 id="1-typeof-其中数组、对象、null都会被判断为Object，其他判断都正确"><a href="#1-typeof-其中数组、对象、null都会被判断为Object，其他判断都正确" class="headerlink" title="1. typeof   其中数组、对象、null都会被判断为Object，其他判断都正确"></a>1. typeof   其中数组、对象、null都会被判断为Object，其他判断都正确</h4><p>返回数据类型，包含这7种： number、boolean、symbol、string、object、undefined、function。typeof null   返回类型错误，返回object ,引用类型，除了function返回function类型外，其他均返回object。其中，null 有属于自己的数据类型 Null</p><h4 id="2-instanceof-只能判断引用数据类型-不能判断基本数据类型"><a href="#2-instanceof-只能判断引用数据类型-不能判断基本数据类型" class="headerlink" title="2. instanceof 只能判断引用数据类型,不能判断基本数据类型"></a>2. instanceof 只能判断引用数据类型,不能判断基本数据类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">　　<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>];<br>　　<span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型，<br><img src="/imageO/instance.jpg" alt="instance"><br> 由上图可以看出[]的原型指向Array.prototype，间接指向Object.prototype, 因此 [] instanceof Array 返回true， [] instanceof Object 也返回true。<br>instanceof <strong>只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</strong></p><h4 id="3-constructor-2个作用-一是判断数据的类型，二是对象实例通过constructor对象访问它的构造函数。需要注意的事情是如果创建一个对象来改变它的原型-constructor就不能来判断数据类型了"><a href="#3-constructor-2个作用-一是判断数据的类型，二是对象实例通过constructor对象访问它的构造函数。需要注意的事情是如果创建一个对象来改变它的原型-constructor就不能来判断数据类型了" class="headerlink" title="3. constructor(2个作用 一是判断数据的类型，二是对象实例通过constructor对象访问它的构造函数。需要注意的事情是如果创建一个对象来改变它的原型,constructor就不能来判断数据类型了)"></a>3. constructor(2个作用 一是判断数据的类型，二是对象实例通过constructor对象访问它的构造函数。需要注意的事情是如果创建一个对象来改变它的原型,constructor就不能来判断数据类型了)</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><br>　　<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>];<br>　　console.log(arr.<span class="hljs-keyword">constructor</span> === <span class="hljs-keyword">Array</span>)<span class="hljs-comment">//true</span><br><br></code></pre></td></tr></table></figure><p>constructor是原型prototype的一个属性，当函数被定义时候，js引擎会为函数添加原型prototype，并且这个prototype中constructor属性指向函数引用， 因此重写prototype会丢失原来的constructor。<br>不过这种方法有问题：<br>1：<strong>null 和 undefined 无constructor，这种方法判断不了</strong>。<br>2：还有，如果自定义对象，开发者重写prototype之后，原有的constructor会丢失，因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改。</p><h4 id="4-toString-这个是最完美的"><a href="#4-toString-这个是最完美的" class="headerlink" title="4. toString 这个是最完美的"></a>4. toString 这个是最完美的</h4><p>toString() 是 Object 的原型方法，调用该方法，<strong>默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。</strong><br>对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。<strong>而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</strong></p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>在toString方法被调用时,会执行下面的操作步骤:</p><ol><li><p>获取this对象的[[Class]]属性的值.</p></li><li><p>计算出三个字符串”[object “, 第一步的操作结果Result(1), 以及 “]”连接后的新字符串.</p></li><li><p>返回第二步的操作结果Result(2).<br>判断类型举例：</p></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;&#x27;</span>) ;   // [<span class="hljs-keyword">object</span> String]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-number">1</span>) ;    // [<span class="hljs-keyword">object</span> Number]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">true</span>) ; // [<span class="hljs-keyword">object</span> <span class="hljs-type">Boolean</span>]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(Symbol()); //[<span class="hljs-keyword">object</span> Symbol]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(undefined) ; // [<span class="hljs-keyword">object</span> Undefined]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">null</span>) ; // [<span class="hljs-keyword">object</span> <span class="hljs-keyword">Null</span>]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> <span class="hljs-keyword">Function</span>()) ; // [<span class="hljs-keyword">object</span> <span class="hljs-keyword">Function</span>]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>()) ; // [<span class="hljs-keyword">object</span> <span class="hljs-type">Date</span>]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>([]) ; // [<span class="hljs-keyword">object</span> <span class="hljs-keyword">Array</span>]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> RegExp()) ; // [<span class="hljs-keyword">object</span> RegExp]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> Error()) ; // [<span class="hljs-keyword">object</span> Error]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(document) ; // [<span class="hljs-keyword">object</span> HTMLDocument]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">window</span>) ; //[<span class="hljs-keyword">object</span> <span class="hljs-keyword">global</span>] <span class="hljs-keyword">window</span> 是全局对象 <span class="hljs-keyword">global</span> 的引用<br></code></pre></td></tr></table></figure><h3 id="如何判断一个对象是数组还是对象"><a href="#如何判断一个对象是数组还是对象" class="headerlink" title="如何判断一个对象是数组还是对象"></a>如何判断一个对象是数组还是对象</h3><p>一、typeof判断数据类型（判断数组跟对象都返回object）<br>二、instanceof判断对象的原型链是否是指向构造函数的prototype</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">　　<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>];<br>　　<span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>三、对象的constructor属性</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">　　<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>];<br>　　console.log(arr.<span class="hljs-keyword">constructor</span> === <span class="hljs-keyword">Array</span>)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>四、Object.prototype.toString.call(arr)<br>　　利用对象的toString可以准确判断是什么类型，call()改变this指向，这里是借用Object的方法，然后有人可能会问为什么不直接用arr.toString而要借用Object的方法，</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(&quot;jerry&quot;));//[<span class="hljs-keyword">object</span> String]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-number">12</span>));//[<span class="hljs-keyword">object</span> Number]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">true</span>));//[<span class="hljs-keyword">object</span> <span class="hljs-type">Boolean</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(undefined));//[<span class="hljs-keyword">object</span> Undefined]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">null</span>));//[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Null</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(&#123;<span class="hljs-type">name</span>: &quot;jerry&quot;&#125;));//[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Object</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">function</span>()&#123;&#125;));//[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Function</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>([]));//[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Array</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>));//[<span class="hljs-keyword">object</span> <span class="hljs-type">Date</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(/\d/));//[<span class="hljs-keyword">object</span> RegExp]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> Person));//[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Object</span>]<br></code></pre></td></tr></table></figure><p>直接用tostring()</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">console.log(<span class="hljs-string">&quot;jerry&quot;</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//jerry</span><br>console.log((<span class="hljs-number">1</span>).<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//1</span><br>console.log(<span class="hljs-literal">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//1,2</span><br>console.log(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//Wed Dec 21 2016 20:35:48 GMT+0800 (中国标准时间)</span><br>console.log(<span class="hljs-keyword">function</span><span class="hljs-literal">()</span>&#123;&#125;.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//function ()&#123;&#125;</span><br>console.log(null.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//error</span><br>console.log(undefined.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure><h4 id="因为toString为Object原型上的方法，而Array、Function都是Object的实例，实例重新改写了原型上的toString方法，不同的对象调用toString方法，调用的是改写之后的方法"><a href="#因为toString为Object原型上的方法，而Array、Function都是Object的实例，实例重新改写了原型上的toString方法，不同的对象调用toString方法，调用的是改写之后的方法" class="headerlink" title="因为toString为Object原型上的方法，而Array、Function都是Object的实例，实例重新改写了原型上的toString方法，不同的对象调用toString方法，调用的是改写之后的方法"></a>因为toString为Object原型上的方法，而Array、Function都是Object的实例，实例重新改写了原型上的toString方法，不同的对象调用toString方法，调用的是改写之后的方法</h4><p>（转成各种类型的字符串），而不会调用Object原型上的toString()方法，因此直接调用不能判断对象类型</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var arr=<span class="hljs-literal">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]</span>;<br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>prototype.has<span class="hljs-constructor">OwnProperty(<span class="hljs-string">&quot;toString&quot;</span>)</span>);<span class="hljs-comment">//true</span><br>console.log(arr.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//1,2,3</span><br>delete <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>prototype.toString;<span class="hljs-comment">//delete操作符可以删除实例属性</span><br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>prototype.has<span class="hljs-constructor">OwnProperty(<span class="hljs-string">&quot;toString&quot;</span>)</span>);<span class="hljs-comment">//false</span><br>console.log(arr.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//&quot;[object Array]&quot;</span><br></code></pre></td></tr></table></figure><p>　我们可以看到，删除实例上的toString方法后调用的是Object原型上的toString()方法，返回对象类型</p><p>五、es6的方法——Array.isArray()</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array([])</span> <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>六、看好多博客说用length判断，这个其实不准确</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> obj=&#123;<span class="hljs-selector-tag">a</span>:<span class="hljs-number">1</span>&#125;<br><span class="hljs-selector-tag">var</span> arr = <span class="hljs-selector-attr">[]</span><br>console<span class="hljs-selector-class">.log</span>(obj.length)<span class="hljs-comment">//undefined</span><br>console<span class="hljs-selector-class">.log</span>(arr.length)<span class="hljs-comment">//0</span><br><br>obj<span class="hljs-selector-class">.length</span> = <span class="hljs-number">1</span><br>console<span class="hljs-selector-class">.log</span>(obj.length)<span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><p>对象可以直接添加length这个属性，就无法区分了</p><h3 id="数组常用方法-一般方法"><a href="#数组常用方法-一般方法" class="headerlink" title="数组常用方法(一般方法)"></a>数组常用方法(一般方法)</h3><p>push()，pop()，shift()，unshift()，splice()，sort()，reverse()，map()等</p><h4 id="会改变原始数组的方法有"><a href="#会改变原始数组的方法有" class="headerlink" title="会改变原始数组的方法有"></a>会改变原始数组的方法有</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">push</span><span class="hljs-params">()</span></span>  压入到尾部        pop:  弹出尾部的一个元素<br>unshift  压入到头部           shift    弹出头部的一个元素<br><span class="hljs-function"><span class="hljs-title">sort</span><span class="hljs-params">()</span></span>  方法用于对数组的元素进行排序。 排序顺序可以是字母或数字，并按升序或降序。默认排序顺序为按字母升序。<br><span class="hljs-function"><span class="hljs-title">reverse</span><span class="hljs-params">()</span></span>   方法用于颠倒数组中元素的顺序。<br><span class="hljs-function"><span class="hljs-title">splice</span><span class="hljs-params">()</span></span>    方法用于添加或删除数组中的元素。注意：这种方法会改变原始数组。<br><br></code></pre></td></tr></table></figure><h4 id="不改变原始数组的方法有"><a href="#不改变原始数组的方法有" class="headerlink" title="不改变原始数组的方法有"></a>不改变原始数组的方法有</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">filter</span>()   返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组<br>concat()   方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。<br><span class="hljs-keyword">slice</span>() 截取<span class="hljs-keyword">Array</span>的一部分，返回一个新数组，类似于String中的substring  [)<br>map()   <span class="hljs-keyword">forEach</span>()   (数据为基本类型,改变其值（不会改变）)(数据为引用类型,改变其属性方法的值（会改变）)<br>every、<span class="hljs-keyword">some</span>、<span class="hljs-keyword">filter</span>、reduce ES6新增的方法entries、find、findIndex、keys、<span class="hljs-keyword">values</span><br></code></pre></td></tr></table></figure><h3 id="forEach-map-ES5-的区别"><a href="#forEach-map-ES5-的区别" class="headerlink" title="forEach map(ES5)的区别"></a>forEach map(ES5)的区别</h3><p>能用forEach()做到的，map()同样可以。反过来也是如此<br>map()会<strong>分配内存空间存储新数组并返回，forEach()不会返回数据。</strong><br>forEach()<strong>允许callback更改原始数组的元素</strong>。map()<strong>返回新的数组</strong>。 map() <strong>不会改变原始数组</strong>。<br>map()   forEach()   <strong>(数据为基本类型,改变其值（不会改变）)(数据为引用类型,改变其属性方法的值（会改变）)</strong><br>map() <strong>可以利用 return</strong> 语句来返回值，该值将被放入新数组中。forEach() 方法<strong>不能</strong>使用 return 语句返回值。</p><h4 id="map和forEach是按-（value-key）的方式遍历的"><a href="#map和forEach是按-（value-key）的方式遍历的" class="headerlink" title="map和forEach是按 （value,key）的方式遍历的"></a>map和forEach是按 （value,key）的方式遍历的</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">const  arr = [1,2,3]</span><br><span class="xml">arr.forEach((value,index)=&gt;</span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">console.log(value,index)</span><br><span class="hljs-template-variable">&#125;</span><span class="xml">)</span><br><span class="xml">arr.map((value,key)=&gt;</span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    console.log(value,key)</span><br><span class="hljs-template-variable">&#125;</span><span class="xml">)</span><br><span class="xml"><span class="hljs-comment">&lt;!-- 两个打印的结果为 --&gt;</span></span><br><span class="xml">1 0</span><br><span class="xml">2 1</span><br><span class="xml">3 2</span><br></code></pre></td></tr></table></figure><h3 id="如何判断一个对象为空"><a href="#如何判断一个对象为空" class="headerlink" title="如何判断一个对象为空"></a>如何判断一个对象为空</h3><p>判断一个对象为空，可以使用以下方法：</p><ol><li>使用<code>Object.keys()</code>方法判断对象是否有属性</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> isEmpty = <span class="hljs-built_in">Object</span>.keys(obj).length === <span class="hljs-number">0</span>;<br><span class="hljs-built_in">console</span>.log(isEmpty); <span class="hljs-comment">// 输出 true</span><br></code></pre></td></tr></table></figure><p>该方法将返回一个由对象的所有可枚举属性组成的数组，如果数组长度为0，则表示该对象没有属性，即为空对象。</p><ol start="2"><li>使用<code>for...in</code>循环判断对象是否有属性</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-keyword">let</span> isEmpty = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-keyword">if</span>(obj.hasOwnProperty(key)) &#123; <span class="hljs-comment">// 必须判断对象自身属性，忽略原型链上的属性</span><br>    isEmpty = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log(isEmpty); <span class="hljs-comment">// 输出 true</span><br></code></pre></td></tr></table></figure><ol start="3"><li>使用<code>JSON.stringify()</code>方法判断对象是否为空</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><span class="hljs-keyword">const</span> jsonString = <span class="hljs-built_in">JSON</span>.stringify(obj);<br><span class="hljs-keyword">const</span> isEmpty = jsonString === <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(isEmpty); <span class="hljs-comment">// 输出 true</span><br></code></pre></td></tr></table></figure><p>该方法将对象序列化为JSON字符串，如果该字符串内容为’{}’，则表示该对象为空对象。</p><p>需要注意的是，以上三种方法都是判断对象是否完全为空（即没有任何属性），如果对象有原型链上的属性或者仅包含空字符串、null、undefined等值，则不算为空对象。</p><h4 id="Array-from-方法"><a href="#Array-from-方法" class="headerlink" title="Array.from()方法"></a>Array.from()方法</h4><p><code>Array.from()</code> 方法是 JavaScript 内置的一个静态方法，用于将类数组对象或可遍历对象（例如 Set 和 Map）转换为真正的数组。</p><p><code>Array.from()</code> 方法有两个参数：第一个参数指定要转换的对象，第二个参数（可选）指定一个映射函数，可以对每个元素进行处理。如果没有提供第二个参数，则相当于只做了一次浅拷贝。</p><p>例如，将一个字符串转换为字符数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.from(str);<br><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br></code></pre></td></tr></table></figure><p>使用映射函数将数组中的每个元素都平方：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> arr2 = <span class="hljs-built_in">Array</span>.from(arr1, <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * x);<br><span class="hljs-built_in">console</span>.log(arr2); <span class="hljs-comment">// [1, 4, 9]</span><br></code></pre></td></tr></table></figure><p>使用 <code>Array.from()</code> 方法可以方便地将一个类数组对象或可遍历对象转换为数组，避免手动写循环或者使用其他方法来实现这个功能。需要注意的是，在转换过程中，原始对象的属性和方法会被忽略，只有索引位置上的值会被保留。</p><h3 id="JavaScript-原型，原型链？-有什么特点？"><a href="#JavaScript-原型，原型链？-有什么特点？" class="headerlink" title="JavaScript 原型，原型链？ 有什么特点？"></a>JavaScript 原型，原型链？ 有什么特点？</h3><p>在 js 中我们是<strong>使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。</strong></p><p>当我们使用构造函数新建一个对象后，<strong>在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值</strong>，在 ES5 中这个指针被称为对象的原型。</p><p>一般来说我们是不应该能够获取到这个值的，但是现在浏览器中都实现了<code>__proto__</code>属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个Object.<strong>getPrototypeOf() 方法</strong>，我们可以通过这个方法来获取对象的原型。</p><p>当我们<strong>访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype</strong>所以这就是我们新建的对象为什么能够使用 toString() 等方法的原因。</p><p>2、隐式原型也是一个对象,是指向我们构造函数的原型</p><p>3、除了最顶层的Object对象没有__proto_，其他所有的对象都有__proto__,这是隐式原型</p><p>4、<strong>隐式原型__proto__的作用是让对象通过它来一直往上查找属性或方法，直到找到最顶层的Object的__proto__属性，它的值是null,这个查找的过程就是原型链</strong><br>特点：<br>JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p><h4 id="面试题–原型链的顶端是什么（如果找不到是什么）"><a href="#面试题–原型链的顶端是什么（如果找不到是什么）" class="headerlink" title="面试题–原型链的顶端是什么（如果找不到是什么）"></a>面试题–原型链的顶端是什么（如果找不到是什么）</h4><p>在JavaScript中，每个对象都有一个原型（prototype）属性，指向它的原型对象。原型对象也有原型属性，指向它的原型对象，这样就形成了原型链。</p><p>原型链的顶端是Object.prototype，它是所有对象的祖先对象。<strong>Object.prototype的原型指向null，即它没有原型对象</strong>，所以<strong>当在原型链中找不到某个属性或方法时，就会返回undefined</strong>，而不是继续查找。</p><p>例如，当我们创建一个对象，并尝试访问它的属性或方法时，JavaScript引擎会先查找该对象本身是否具有该属性或方法，如果没有，则沿着原型链向上查找，直到找到该属性或方法或者到达Object.prototype为止。如果在整个原型链上都没有找到该属性或方法，那么就返回undefined。</p><p>总之，<strong>原型链的顶端是Object.prototype，它是所有对象的祖先对象</strong>，当在原型链中<strong>找不到某个属性或方法时，就会返回undefined</strong>。（这个答错了，回答的是null）</p><h4 id="js-获取原型的方法？"><a href="#js-获取原型的方法？" class="headerlink" title="js 获取原型的方法？"></a>js 获取原型的方法？</h4><p>p.<code>__proto__</code><br>p.constructor.prototype<br>Object.getPrototypeOf(p)</p><h4 id="hasOwnProperty表示是否有自己的属性。这个方法会查找一个对象是否有某个属性，但是不会去查找它的原型链"><a href="#hasOwnProperty表示是否有自己的属性。这个方法会查找一个对象是否有某个属性，但是不会去查找它的原型链" class="headerlink" title="hasOwnProperty表示是否有自己的属性。这个方法会查找一个对象是否有某个属性，但是不会去查找它的原型链"></a>hasOwnProperty表示是否有自己的属性。这个方法会查找一个对象是否有某个属性，但是不会去查找它的原型链</h4><h3 id="了解Vue底层原理（简历上写了，讲讲Object-definProperty从原生上讲讲）-除了getter-setter还有？"><a href="#了解Vue底层原理（简历上写了，讲讲Object-definProperty从原生上讲讲）-除了getter-setter还有？" class="headerlink" title="了解Vue底层原理（简历上写了，讲讲Object.definProperty从原生上讲讲） 除了getter,setter还有？"></a>了解Vue底层原理（简历上写了，讲讲Object.definProperty从原生上讲讲） 除了getter,setter还有？</h3><p><code>Object.defineProperty()</code> 是 JavaScript 中一个原生的方法，用于在一个对象上定义新属性或者修改现有属性的特性（例如可写性、可枚举性和可配置性）。</p><p>该方法接收三个参数：要定义属性或特性的对象、属性名称或符号、以及一个描述符对象。描述符对象包含如下可选属性：</p><ul><li><code>value</code>：属性的值。</li><li><code>writable</code>：是否允许修改属性的值，默认为 <code>false</code>。</li><li><code>enumerable</code>：属性是否可以被枚举，默认为 <code>false</code>。</li><li><code>configurable</code>：属性是否可以被删除或者修改特性，默认为 <code>false</code>。</li></ul><p>例如，使用 <code>Object.defineProperty()</code> 方法定义一个只读属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;readOnly&#x27;</span>, &#123;<br>  value: <span class="hljs-number">42</span>,<br>  writable: <span class="hljs-literal">false</span>,<br>  enumerable: <span class="hljs-literal">true</span>,<br>  configurable: <span class="hljs-literal">false</span><br>&#125;);<br><br><span class="hljs-built_in">console</span>.log(obj.readOnly); <span class="hljs-comment">// 42</span><br>obj.readOnly = <span class="hljs-number">23</span>; <span class="hljs-comment">// TypeError: Cannot assign to read only property &#x27;readOnly&#x27; of object &#x27;#&lt;Object&gt;&#x27;</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，使用 <code>Object.defineProperty()</code> 方法将一个只读属性 <code>readOnly</code> 添加到了对象 <code>obj</code> 上，并且指定了其属性值为 <code>42</code>，不可写但可枚举。当尝试修改该属性时，会抛出一个类型错误。</p><p><code>Object.defineProperty()</code> 方法可以用于创建一些高度定制化的对象特性，例如实现类似 Vue.js 的数据双向绑定功能。需要注意的是，在使用该方法时，应避免过多地修改对象的特性，以免影响代码的可读性和维护性。</p><h3 id="promise有多个-then方法如何中断第二个-then呢-（这里紧张了答成promise-resolved了-是rejected）"><a href="#promise有多个-then方法如何中断第二个-then呢-（这里紧张了答成promise-resolved了-是rejected）" class="headerlink" title="promise有多个.then方法如何中断第二个.then呢  （这里紧张了答成promise.resolved了,是rejected）"></a>promise有多个.then方法如何中断第二个.then呢  （这里紧张了答成promise.resolved了,是rejected）</h3><p>在 Promise 中，如果想要中断执行链中的某个 <code>.then()</code> 方法，可以<strong>通过抛出一个错误（或返回一个被拒绝的 Promise）</strong>来实现。这样做会导致 Promise 执行链跳过后续的 <code>.then()</code> 方法，直接进入 <code>.catch()</code> 或者全局异常处理程序。</p><p>具体来说，可以在 <code>.then()</code> 方法中进行条件判断，如果不满足条件，则抛出一个错误。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise<br>  .then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (result === <span class="hljs-string">&#x27;some value&#x27;</span>) &#123;<br>      <span class="hljs-comment">// 满足条件，继续执行下一个 .then()</span><br>      <span class="hljs-keyword">return</span> doSomethingElse(result);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 不满足条件，中断执行链，进入 catch</span><br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Condition not met&#x27;</span>);<br>    &#125;<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">anotherResult</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 这里的代码只有在上一个 .then() 正常返回时才会被执行</span><br>    <span class="hljs-built_in">console</span>.log(anotherResult);<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 如果中途出现错误或者上一个 .then() 抛出了异常，就会跳转到这里</span><br>    <span class="hljs-built_in">console</span>.error(error);<br>  &#125;);<br></code></pre></td></tr></table></figure><p>在上面的例子中，如果上一个 <code>.then()</code> 返回的结果是 <code>&#39;some value&#39;</code>，则会继续执行下一个 <code>.then()</code>；否则，就会抛出一个 <code>Error</code>，中断执行链，直接进入 <code>.catch()</code> 部分处理异常情况。</p><p>需要注意的是，由于 Promise 的异步特性，上述中断操作并不能立即生效，而是需要等到执行栈清空后才会被捕获和处理。因此，在使用 Promise 进行条件判断时，应该特别注意错误处理和异常情况的处理，以避免不必要的问题和副作用。</p><h3 id="不使用for循环如何生成长度100的数组，数组的值为他的下标"><a href="#不使用for循环如何生成长度100的数组，数组的值为他的下标" class="headerlink" title="不使用for循环如何生成长度100的数组，数组的值为他的下标"></a>不使用for循环如何生成长度100的数组，数组的值为他的下标</h3><p>可以使用 Array.from() 方法来生成指定长度的数组，然后结合第二个参数中定义的映射函数将每个元素转换为其下标。</p><p>以下是示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.from(&#123; <span class="hljs-attr">length</span>: <span class="hljs-number">100</span> &#125;, <span class="hljs-function">(<span class="hljs-params">_, index</span>) =&gt;</span> index);<br><span class="hljs-built_in">console</span>.log(arr);<br></code></pre></td></tr></table></figure><p>这将生成一个长度为 100 的数组，其中每个元素的值都等于它的下标。第一个参数 <code>&#123; length: 100 &#125;</code> 定义了数组的长度为 100，而第二个参数 <code>(item, index) =&gt; index</code> 将每个元素转换为其下标。在这里，我们使用了下划线 <code>_</code> 来占位 item 参数，因为它不需要使用。</p><h3 id="讲一下https和http的区别"><a href="#讲一下https和http的区别" class="headerlink" title="讲一下https和http的区别"></a>讲一下https和http的区别</h3><p>https加密</p><h3 id="入行前端做项目最大的收获是（自我价值-公司价值）"><a href="#入行前端做项目最大的收获是（自我价值-公司价值）" class="headerlink" title="入行前端做项目最大的收获是（自我价值/公司价值）"></a>入行前端做项目最大的收获是（自我价值/公司价值）</h3><p>作为一个 AI 而非人类，我没有亲身经历过前端开发的工作和项目经验。不过，根据从程序员们的反馈中综合整理，以下是一些可能会获得的收获：</p><ol><li><p>实践能力：通过实际的项目开发，可以更好地理解并熟悉前端技术栈，提高自己的实践能力。</p></li><li><p>团队协作：在团队中完成项目需要与其他成员进行合作和沟通，这有助于锻炼自己的团队协作能力，了解如何协调各方之间的工作。</p></li><li><p>代码风格：在项目开发过程中，可以学习借鉴其他成员的代码风格和编写习惯，提高自己的代码质量和可读性。</p></li><li><p>错误处理：在项目开发过程中难免会遇到各种各样的错误和异常情况，这可以让自己更加熟悉如何进行错误处理和调试技术。</p></li><li><p>用户体验：在项目开发中需要考虑用户体验，例如界面设计、交互效果等，这有助于让自己更加关注用户需求和体验，提高产品的用户满意度。</p></li></ol><p>总之，通过参与前端开发项目，可以不断提高自己的技术水平和综合能力，为未来的职业发展奠定坚实的基础。</p><h3 id="入行三年规划"><a href="#入行三年规划" class="headerlink" title="入行三年规划"></a>入行三年规划</h3><p>如果面试官问到前端行业三年规划，可以考虑以下几个方面来回答：</p><ol><li><p>技术深度：在前端领域，技术更新非常快，三年时间大概可以掌握一些比较核心和深入的技术，例如 React 或 Vue 框架、Webpack 构建工具、Node.js 后端开发等。同时还可以尝试学习一些新的技术，例如 WebAssembly、PWA 等，以便跟上前端技术的最新发展。</p></li><li><p>行业趋势：前端行业的趋势和发展方向也需要关注，例如前端组件化、前后端分离、微前端、GraphQL 等，这些技术和思想都是近年来比较热门的话题，了解并掌握它们可以提高自己的职业竞争力。</p></li><li><p>团队协作：随着工作经验的增加，可能会逐渐接触到团队协作和项目管理等方面，因此可以考虑学习一些相关的知识和技能，例如敏捷开发、DevOps、代码评审、团队协作工具等，以提高自己与团队合作的效率和质量。</p></li><li><p>跨界拓展：如果有兴趣或者机会，也可以考虑学习和拓展其他领域的知识和技能，例如设计、产品经理等，以便更好地理解和协作其他团队成员，并为自己未来的职业发展打下更广阔的基础。</p></li></ol><p>总之，前端行业的三年规划需要综合考虑个人兴趣、技术水平、市场需求和行业趋势等多方面因素，制定具体的计划，并不断学习和实践，才能实现自身价值的提升和职业规划的成功。</p><h3 id="反问-2"><a href="#反问-2" class="headerlink" title="反问"></a>反问</h3><h4 id="技术栈Vue"><a href="#技术栈Vue" class="headerlink" title="技术栈Vue"></a>技术栈Vue</h4><h4 id="进去是可能会一直写一些简单的业务（刚毕业比较注重基础）"><a href="#进去是可能会一直写一些简单的业务（刚毕业比较注重基础）" class="headerlink" title="进去是可能会一直写一些简单的业务（刚毕业比较注重基础）"></a>进去是可能会一直写一些简单的业务（刚毕业比较注重基础）</h4>]]></content>
    
    
    <categories>
      
      <category>项目优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置一套符合团队习惯且规范的husky(项目)</title>
    <link href="/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D%E9%85%8D%E7%BD%AE%E4%B8%80%E5%A5%97%E7%AC%A6%E5%90%88%E5%9B%A2%E9%98%9F%E4%B9%A0%E6%83%AF%E4%B8%94%E8%A7%84%E8%8C%83%E7%9A%84husky/"/>
    <url>/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D%E9%85%8D%E7%BD%AE%E4%B8%80%E5%A5%97%E7%AC%A6%E5%90%88%E5%9B%A2%E9%98%9F%E4%B9%A0%E6%83%AF%E4%B8%94%E8%A7%84%E8%8C%83%E7%9A%84husky/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="配置一套符合团队习惯且规范的husky"><a href="#配置一套符合团队习惯且规范的husky" class="headerlink" title="配置一套符合团队习惯且规范的husky"></a>配置一套符合团队习惯且规范的husky</h2><h3 id="git提交信息规范"><a href="#git提交信息规范" class="headerlink" title="git提交信息规范"></a>git提交信息规范</h3><h4 id="具体规范"><a href="#具体规范" class="headerlink" title="具体规范"></a>具体规范</h4><p>推荐基于开源的 commitlint 来实现公司在git提交信息的规范，通过覆盖等手段扩展该开源规范以适应公司前端团队的需求。</p><p>主要使用的是<a href="https://github.com/conventional-changelog/commitlint">commitlint</a>的@commitlint/config-conventional规则，其中在type-enum新增了“merge”类型，具体细则如下：</p><ul><li><code>type-enum</code>：类型允许范围改为<code>[&#39;build&#39;, &#39;ci&#39;, docs&#39;, &#39;feat&#39;, &#39;merge&#39;, &#39;fix&#39;, &#39;perf&#39;, &#39;refactor&#39;, &#39;style&#39;, &#39;test&#39;, &#39;revert&#39;, &#39;chore&#39;]</code><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>  feat: &#123;<br>    description: <span class="hljs-string">&#x27;A new feature&#x27;</span>,<br>    title: <span class="hljs-string">&#x27;Features&#x27;</span>,<br>    emoji: <span class="hljs-string">&#x27;✨&#x27;</span>,<br>  &#125;,<br>  fix: &#123;<br>    description: <span class="hljs-string">&#x27;A bug fix&#x27;</span>,<br>    title: <span class="hljs-string">&#x27;Bug Fixes&#x27;</span>,<br>    emoji: <span class="hljs-string">&#x27;🐛&#x27;</span>,<br>  &#125;,<br>  docs: &#123;<br>    description: <span class="hljs-string">&#x27;Documentation only changes&#x27;</span>,<br>    title: <span class="hljs-string">&#x27;Documentation&#x27;</span>,<br>    emoji: <span class="hljs-string">&#x27;📚&#x27;</span>,<br>  &#125;,<br>  style: &#123;<br>    description:<br>      <span class="hljs-string">&#x27;Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)&#x27;</span>,<br>    title: <span class="hljs-string">&#x27;Styles&#x27;</span>,<br>    emoji: <span class="hljs-string">&#x27;💎&#x27;</span>,<br>  &#125;,<br>  refactor: &#123;<br>    description:<br>      <span class="hljs-string">&#x27;A code change that neither fixes a bug nor adds a feature&#x27;</span>,<br>    title: <span class="hljs-string">&#x27;Code Refactoring&#x27;</span>,<br>    emoji: <span class="hljs-string">&#x27;📦&#x27;</span>,<br>  &#125;,<br>  perf: &#123;<br>    description: <span class="hljs-string">&#x27;A code change that improves performance&#x27;</span>,<br>    title: <span class="hljs-string">&#x27;Performance Improvements&#x27;</span>,<br>    emoji: <span class="hljs-string">&#x27;🚀&#x27;</span>,<br>  &#125;,<br>  test: &#123;<br>    description: <span class="hljs-string">&#x27;Adding missing tests or correcting existing tests&#x27;</span>,<br>    title: <span class="hljs-string">&#x27;Tests&#x27;</span>,<br>    emoji: <span class="hljs-string">&#x27;🚨&#x27;</span>,<br>  &#125;,<br>  build: &#123;<br>    description:<br>      <span class="hljs-string">&#x27;Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)&#x27;</span>,<br>    title: <span class="hljs-string">&#x27;Builds&#x27;</span>,<br>    emoji: <span class="hljs-string">&#x27;🛠&#x27;</span>,<br>  &#125;,<br>  ci: &#123;<br>    description:<br>      <span class="hljs-string">&#x27;Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs)&#x27;</span>,<br>    title: <span class="hljs-string">&#x27;Continuous Integrations&#x27;</span>,<br>    emoji: <span class="hljs-string">&#x27;⚙️&#x27;</span>,<br>  &#125;,<br>  chore: &#123;<br>    description: <span class="hljs-string">&quot;Other changes that don&#x27;t modify src or test files&quot;</span>,<br>    title: <span class="hljs-string">&#x27;Chores&#x27;</span>,<br>    emoji: <span class="hljs-string">&#x27;♻️&#x27;</span>,<br>  &#125;,<br>  revert: &#123;<br>    description: <span class="hljs-string">&#x27;Reverts a previous commit&#x27;</span>,<br>    title: <span class="hljs-string">&#x27;Reverts&#x27;</span>,<br>    emoji: <span class="hljs-string">&#x27;🗑&#x27;</span>,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>详细类型的解说可以查看这里<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//gi</span>t commit 使用示例：<br><br><span class="hljs-string">&quot;foo: 修复登录出错的bug&quot;</span> <span class="hljs-comment"># 失败</span><br><span class="hljs-string">&quot;fix: 修复登录出错的bug&quot;</span> <span class="hljs-comment"># 成功</span><br></code></pre></td></tr></table></figure><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4></li></ul><blockquote><p>首次使用git commit之前，需要配置好用户名和邮箱：<br>设置用户名字为中文名，例如：git config –global user.name “张三” ；<br>设置用户邮箱为个人的国双邮箱账号（带有@gridsum.com后缀），例如：git config –global user.email “<a href="mailto:&#x7a;&#104;&#x61;&#110;&#103;&#115;&#x61;&#110;&#64;&#x67;&#114;&#105;&#100;&#115;&#117;&#109;&#46;&#x63;&#x6f;&#109;">&#x7a;&#104;&#x61;&#110;&#103;&#115;&#x61;&#110;&#64;&#x67;&#114;&#105;&#100;&#115;&#117;&#109;&#46;&#x63;&#x6f;&#109;</a>“。</p></blockquote><ul><li>git commit的具体用法：<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">git</span> commit -m &lt;<span class="hljs-keyword">type</span>&gt;[(optional scope)]: &lt;description&gt;<br></code></pre></td></tr></table></figure></li><li>type：表示这次提交改动的类型，允许的类型详情可见下方； </li><li>optional scope：可选，表示修改范围。用于标识此次提交主要涉及到代码中哪个模块；</li><li>description：描述此次提交的主要内容。</li><li>type的可选类型：</li></ul><ol><li>build：主要目的是修改项目构建系统(例如 glup，webpack，rollup 的配置等)的提交</li><li>ci：主要目的是修改项目继续集成流程(例如 Travis，Jenkins，GitLab CI，Circle等)的提交</li><li>docs：文档更新</li><li>feat：新增功能</li><li>merge：分支合并</li><li>fix：bug 修复</li><li>perf：性能, 体验优化</li><li>refactor：重构代码(既没有新增功能，也没有修复 bug)</li><li>style：不影响程序逻辑的代码修改(修改空白字符，格式缩进，补全缺失的分号等，没有改变代码逻辑)</li><li>test：新增测试用例或是更新现有测试</li><li>revert：回滚某个更早之前的提交</li><li>chore：不属于以上类型的其他类型</li></ol><h4 id="配置校验工具"><a href="#配置校验工具" class="headerlink" title="配置校验工具"></a>配置校验工具</h4><p>代码提交时通过githook进行校验，符合规范的提交信息才能commit</p><ol><li>配置commitlint<br>主要使用commitlint来约束项目git commit的操作规范。<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install -D @commitlint/cli<br></code></pre></td></tr></table></figure><a href="https://github.com/conventional-changelog/commitlint">commitlint</a>是git提交信息校验的主流工具，基于以上建议的提交信息规范，我们可以给出一份相应的commitlint规则配置文件，如下：<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-comment">// commitlint.config.js</span><br><span class="hljs-keyword">module</span>.exports = &#123;<br>  <span class="hljs-keyword">extends</span>: [<span class="hljs-string">&#x27;@commitlint/config-conventional&#x27;</span>],<br>  rules: &#123;<br>    <span class="hljs-string">&#x27;type-enum&#x27;</span>: [<br>      <span class="hljs-number">2</span>,<br>      <span class="hljs-string">&#x27;always&#x27;</span>,<br>      [<br>        <span class="hljs-string">&#x27;build&#x27;</span>,<br>        <span class="hljs-string">&#x27;ci&#x27;</span>,<br>        <span class="hljs-string">&#x27;docs&#x27;</span>,<br>        <span class="hljs-string">&#x27;feat&#x27;</span>,<br>        <span class="hljs-string">&#x27;merge&#x27;</span>,<br>        <span class="hljs-string">&#x27;fix&#x27;</span>,<br>        <span class="hljs-string">&#x27;perf&#x27;</span>,<br>        <span class="hljs-string">&#x27;refactor&#x27;</span>,<br>        <span class="hljs-string">&#x27;style&#x27;</span>,<br>        <span class="hljs-string">&#x27;test&#x27;</span>,<br>        <span class="hljs-string">&#x27;revert&#x27;</span>,<br>        <span class="hljs-string">&#x27;chore&#x27;</span>,<br>      ],<br>    ],<br>  &#125;,<br><br>&#125;;<br></code></pre></td></tr></table></figure></li><li>使用husky</li></ol><p>husky是一个让配置git钩子变得更简单的工具，支持所有的git钩子。它可以将git内置的钩子暴露出来，很方便地进行钩子命令注入，而不需要在.git/hooks目录下自己写shell脚本了。您可以使用它来lint您的提交消息、运行测试、lint代码等。当你<strong>commit或push</strong>的时候。husky触发所有git钩子脚本。</p><p>配合<a href="https://github.com/typicode/husky">husky</a>，可以帮助我们实现代码commit前进行提交信息校验。使用配置如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// package.json 以下只展示了husky和commitlint实现代码commit前进行校验的配置</span><br>&#123;<br>  <span class="hljs-string">&quot;husky&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;hooks: &#123;</span><br><span class="hljs-string">      &quot;</span>commit<span class="hljs-operator">-</span>msg<span class="hljs-string">&quot;: &quot;</span>commitlint <span class="hljs-operator">-</span>e <span class="hljs-variable">$HUSKY_GIT_PARAMS</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  &#125;,</span><br><span class="hljs-string">  &quot;</span>devDependencies<span class="hljs-string">&quot;: &#123;</span><br><span class="hljs-string">    &quot;</span>husky<span class="hljs-string">&quot;: &quot;</span><span class="hljs-number">0.14</span>.<span class="hljs-number">3</span><span class="hljs-string">&quot;,</span><br><span class="hljs-string">    &quot;</span><span class="hljs-meta">@commitlint</span><span class="hljs-operator">/</span>cli<span class="hljs-string">&quot;: &quot;</span><span class="hljs-operator">^</span><span class="hljs-number">13.1</span>.<span class="hljs-number">0</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6937203232464699429">基于eslint和husky的代码规范配置</a><br><a href="https://juejin.cn/post/7140443283209060383#comment">手把手教你搭建规范的团队vue项目，包含commitlint，eslint，prettier，husky，commitizen等等</a><br><a href="https://juejin.cn/post/7004045635620405278#heading-14">每周轮子之 husky：统一规范团队 Git Hooks</a></p>]]></content>
    
    
    <categories>
      
      <category>项目优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识图谱基础知识摘要(项目)</title>
    <link href="/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    <url>/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</url>
    
    <content type="html"><![CDATA[<hr><h4 id="知识图谱基础知识摘要"><a href="#知识图谱基础知识摘要" class="headerlink" title="知识图谱基础知识摘要"></a>知识图谱基础知识摘要</h4><h5 id="什么是知识图谱？"><a href="#什么是知识图谱？" class="headerlink" title="什么是知识图谱？"></a>什么是知识图谱？</h5><p>简单理解就是一个图，节点是各种各样的现实当中的实体，如人、物、组织等，线是反应节点之间的关系或者属性。如图所示。<br><img src="/img/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.png" alt="知识图谱"></p><h5 id="知识图谱的作用"><a href="#知识图谱的作用" class="headerlink" title="知识图谱的作用"></a>知识图谱的作用</h5><p>如今知识图谱广泛应用于聊天机器人，推荐系统等方面，而在金融、农业、电商、医疗健康、环境保护、工业制造场景等各种不同的垂直领域，得益于知识图谱的先验知识的特性，均得到了广泛的应用。说的抽象点，知识图谱就是把离散的符号表述，变成了连续的向量表示的巨大的知识网络图。</p><h5 id="知识图谱的表示和存储"><a href="#知识图谱的表示和存储" class="headerlink" title="知识图谱的表示和存储"></a>知识图谱的表示和存储</h5><p>目前有两种方法，一种是 RDF ，它是由很多三元组组成的，优点是易于发布分享，缺点是不支持实体或者关系拥有属性，如果非要加属性则需要做特殊的修改，目前多用于学术场景，常见的有 Jena 。另一种方法是图数据库，主要是由高校的查询和搜索，，如 Neo4j 应用最广泛，界面比较清晰，更容易表达现实的业务场景中的关系，数据量在不过亿级的情况下效果还是可以的，唯一的缺点就是不支持分布式。<br><img src="/img/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B11.png" alt="知识图谱"></p><h5 id="知识抽取"><a href="#知识抽取" class="headerlink" title="知识抽取"></a>知识抽取</h5><p>构建知识图谱的数据无非就两个来源：一个是公司内部的业务数据，一般都存在结构化的数据库中，可以直接拿来用。另一种是需要通过爬虫从网上抓取的网页，或者外部提供的数据，此类数据比较杂乱无结构，需要进行必要的处理。所以难点主要来源于后者。主要涉及到自然语言的相关技术，如实体命名识别，关系抽取，实体统一，指代消解。如下图使用非结构化的文本构建知识图谱。</p><h2 id="今天不写代码，聊聊热门的知识图谱"><a href="#今天不写代码，聊聊热门的知识图谱" class="headerlink" title="今天不写代码，聊聊热门的知识图谱"></a>今天不写代码，聊聊热门的知识图谱</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>诞生<br>知识图谱的概念诞生于2012年，由谷歌公司首先提出。大家都知道，谷歌是做搜索引擎的，所以他们最早提出了Google Knowledge Graph后，首先利用知识图谱技术改善了搜索引擎核心。<br>注意上面的说法，虽然知识图谱诞生于2012年，但其实在更早的时间它还有另外一个名字，那就是语义。那么语义又是什么呢？引用《统计自然语言处理基础》中的两句话来解答这个问题：</p><blockquote><p>语义可以分成两部分，研究单个词的语义（即词义）以及单个词的含义是怎么联合起来组成句子（或者更大的单位）的含义。<br>语义研究的是词语的含义、结构和说话的方式。</p></blockquote><p>那么，知识图谱究竟是个什么东西呢？</p><p>你可以将它理解为<strong>是在自然界建立实体关系</strong>的知识数据库，它的提出是为了准确地阐述人、事、物之间的关系。</p><p>目前在学术界还没有给知识图谱一个统一的定义，但是在谷歌发布的文档中有明确的描述：<strong>“知识图谱是一种用图模型来描述知识和建模世界万物之间关联关系的技术方法”。</strong></p><h4 id="演进"><a href="#演进" class="headerlink" title="演进"></a>演进</h4><p>谷歌的Singhal博士用三个词点出了知识图谱加入之后搜索发生的变化：</p><p>“Things，not string.”</p><p>这寥寥的几个单词，点出了知识图谱的核心。以前的搜索，都是将要搜索的内容看作字符串，结果是和字符串进行匹配，将匹配程度高的排在前面，后面按照匹配度依次显示。而利用知识图谱之后，将搜索的内容不再看作字符串，而是看作客观世界的事物，也就是一个个的个体。</p><p><strong>举个例子，当我们在搜索比尔盖茨的时候，搜索引擎不是搜索“比尔盖茨”这个字符串，而是搜索比尔盖茨这个人，围绕比尔盖茨这个人，展示与他相关的人和事。</strong></p><p>在上面的图中，左侧百科会把比尔盖茨的主要情况列举出来，右侧显示比尔盖茨的微软产品和与他类似的人，主要是一些IT行业的创始人。这样，一个搜索结果页面就把和比尔盖茨的基本情况和他的主要关系都列出来了，搜索的人很容易找到自己感兴趣的结果。</p><h4 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h4><p>在知识图谱中，通过三元组 &lt;<strong>实体 × 关系 × 属性&gt;</strong> 集合的形式来描述事物之间的关系：</p><p>实体：又叫作本体，指客观存在并可相互区别的事物，可以是具体的人、事、物，也可以是抽象的概念或联系，实体是知识图谱中最基本的元素<br>关系：在知识图谱中，边表示知识图谱中的关系，用来表示不同实体间的某种联系<br>属性：知识图谱中的实体和关系都可以有各自的属性<br>这里所说的实体和普通意义上的实体略有不同，借用NLP中本体的概念来理解它会比较好：</p><blockquote><p>本体定义了组成主题领域的词汇表的基本术语及其关系，以及结合这些术语和关系来定义词汇表外延的规则。</p></blockquote><p>例如我们要描述大学这一领域时，对它来说教工、学生、课程就是相对比较重要的概念，并且教工和学生之间也存在一定的关联关系，此外对象之间还存在一定的约束关系，例如一个系的教职员工数量不能少于10人。</p><p>在了解了上面的三元组后，我们可以基于它构建下面这样的一个关系：</p><p>可以看到，女王和王储通过母子关系关联在一起，并且每个人拥有自己的属性。</p><p>当知识图谱中的节点逐渐增多后，它的表现形式就会类似于化学分子式的结构，一个知识图谱往往存在多种类型的实体与关系。</p><p>知识图谱将非线性世界中的知识信息进行加工，<strong>做到这样的结构化、可视化，从而辅助人类进行推理、预判、归类</strong>。</p><p>到这里，可以简单概括一下知识图谱的基本特征：</p><ol><li>知识结构网络化</li><li>网络结构复杂</li><li>网络由三元组构成</li><li>数据主要由知识库承载<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5>前面提到过，以前的搜索引擎是从海量的关键词中找出与查询匹配度最高的内容，按照查询结果把排序分值最高的一些结果返回给用户。在整个过程中，搜索引擎可能并不需要知道用户输入的是什么，因为系统不具备推理能力，在精准搜索方面也略显不足。<strong>而基于知识图谱的搜索引擎，除了能够直接回答用户的问题外，还具有一定的语义推理能力，大大提高了搜索的精确度。</strong></li></ol><h5 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h5><p>在传统的推荐系统中，存在两个典型问题：</p><ol><li>数据稀疏问题：在实际应用场景中，用户和物品的交互信息往往是非常稀疏的，预测会产生过拟合风险</li><li>冷启动问题：对于新加入的用户或者物品，由于系统没有其历史交互信息，因此无法进行准确地建模和推荐<br>例如，在一个电影类网站中可能包含了上万部电影，然而一个用户打过分的电影可能平均只有几十部。使用如此少量的已观测数据来预测大量的未知信息，会极大地增加算法的过拟合风险。</li></ol><p>因此在推荐算法中会额外引入一些辅助信息作为输入，这些辅助信息可以丰富对用户和物品的描述，从而有效地弥补交互信息的稀疏或缺失。在各种辅助信息中，知识图谱作为一种新兴类型的辅助信息，这几年的相关研究比较多。</p><p>下面就是一个基于知识图谱的推荐例子：</p><p>在将知识图谱引入推荐系统后，具有以下优势：</p><ol><li>精确性：知识图谱为物品引入了更多的语义关系，可以深层次地发现用户兴趣</li><li>多样性：知识图谱提供了实体之间不同的关系连接种类，有利于推荐结果的发散，避免推荐结果局限于单一类型</li><li>可解释性：知识图谱可以连接用户的历史记录和推荐结果，从而提高用户对推荐结果的满意度和接受度，增强用户对推荐系统的信<br>此外，知识图谱技术还在问答与对话系统、语言理解、决策分析等多个领域被广泛应用，它被挂载在这些系统之后，充当背景知识库的角色。总的来说，在这些场景下的应用，可以概括整个AI的发展趋势，就是<strong>从感知到认知</strong>的一个过程。</li></ol><p>架构<br>知识图谱的构建目前已有一套比较完善的架构体系，可以先来看一下下面这张图，然后我们再慢慢解释：</p><p><img src="/img/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B12.png" alt="知识图谱"></p><p>总的来说，整体过程可以分为下面5步：</p><p>1.数据获取：主要获取半结构化数据，为后续的实体与实体属性构建做准备。结构化数据则为数值属性做准备<br>2.知识获取：从文本数据集中自动识别出命名实体，包括抽取人名、地名、机构名等；从语料中抽取实体之间的关系，形成关系网络；从不同的信息源中采集特定的属性信息<br>3.知识融合：完成指示代词与先行词的合并；完成同一实体的歧义消除；将已识别的实体对象，无歧义地指向知识库中的目标实体<br>4.知识加工：构建知识概念模块，抽取本体；进行知识图谱推理，并对知识图谱的可信度进行量化评估，评估过关的知识图谱流入知识图谱库中存储，评估不过关的知识图谱返回一开始的数据环节进行调整，而后重复相同环节直到评估过关<br>5.知识存储与计算：存储是为了快速查询与运用知识，需支持底层数据描述与上层计算，有的主体计算包含在存储中<br>下面，我们拆解其中部分重要核心细节，来具体描述。</p><h4 id="知识获取"><a href="#知识获取" class="headerlink" title="知识获取"></a>知识获取</h4><p>数据是知识图谱的根基，直接关系到知识图谱构建的效率和质量。所以我们先从数据源进行分析它们的优势与劣势：</p><ol><li><p>站内数据：优势在于类别明确，结构化好，易于获取；而劣势在于类型有限，已有数据并不是广义上的知识类型</p></li><li><p>垂直网站数据：优势在于类别明确；而劣势在于获取解析成本高，数据质量参差不齐</p></li><li><p>百科类网站数据：优势在于数据量大，内容丰富；而劣势在于没有分类信息，结构不完全固定</p></li><li><p>人工创建的数据：优势在于类别明确；而劣势在于类别明确</p><h4 id="实体抽取"><a href="#实体抽取" class="headerlink" title="实体抽取"></a>实体抽取</h4><p>实体抽取，是指从数据中识别和抽取实体的属性与关系信息，这一过程还是针对不同结构的数据来看：</p></li><li><p>结构化数据：包括站内/垂直网站信息、部分百科网站信息，可以利用策略模式，将抽取的具体规则用groovy脚本来实现</p></li><li><p>半结构化数据：包括百科网站中的表格以及列表，可以利用基于监督学习的包装器归纳方法进行抽取</p></li><li><p>非结构化数据：包括百科网站中的文本以及站内文本，可以利用自然语言处理的手段处理</p><h4 id="关系抽取"><a href="#关系抽取" class="headerlink" title="关系抽取"></a>关系抽取</h4><p>回顾一下我们前面提到过的知识图谱三要素，分别是实体、关系和属性。关系抽取我们同样可以用一个三元组表示的RDF graph：</p></li></ol><p><img src="/img/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B12.png" alt="知识图谱"></p><p>这样的一个（S,P,O）三元组，就可以将一份知识分解为主语、谓语、宾语。这样的SPO结构，在配合知识图谱进行存储时可以被用来当做存储单元。</p><p>在RDF中可以声明一些规则，从一些关系推导出另一些关系，这些规则被称为RDF Schema。规则可以用一些词汇表示，如class、subClassOf、type、property、subPropertyOf、domain、range等。</p><p>下面这个例子中，节点到节点之间的关系就可以理解为前面提到的本体中的联系，而这一关联过程就可以被称为知识图谱中的推导或关联推理：</p><h4 id="知识融合"><a href="#知识融合" class="headerlink" title="知识融合"></a>知识融合</h4><p>知识融合这一过程中，主要包括指代消解、实体对齐、实体链接等过程，我们主要来看一下这个过程中比较重要的实体对齐（Object Alignment）。</p><p>完成实体抽取后，存在实体ID不同但代表真实世界中同一对象的情况。知识融合即是将这些实体合并成一个具有全局唯一标识的实体对象，添加到知识图谱中。</p><ol><li>首先在索引中根据<strong>名字、别名等字段查询出若干个可能是相同实体</strong>的候选列表，这个步骤的目的是减少接下来流程的计算量</li><li>然后经过实体判别模型，根据模型得分识别出待合并对齐的原始实体</li><li>最后经过属性融合模型，将各原始实体的属性字段进行融合，生成最终的实体。<br>这一过程可以用下面的图来表示：</li></ol><p>实际上，这个流程中的合并判断模型大家都比较熟悉，它就是通过机器学习训练生成的二分类器。</p><h4 id="知识存储"><a href="#知识存储" class="headerlink" title="知识存储"></a>知识存储</h4><p>知识图谱的存储依赖于图数据库及其引擎，不同厂商的实现可能大有不同，例如可以选用的图数据库有RDF4j、Virtuoso、Neo4j等。例如爱奇艺的图数据库引擎选择了JanusGraph，借助云平台的Hbase和ES集群，搭建了自己的JanusGraph分布式图数据库引擎。</p><p>JanusGraph通过借助外部的存储系统与外部索引系统的支持，支撑了上游的在线查询服务。</p><p>补充<br>底层存储数据三元组的逻辑层次可以被称为数据层，通常通过本体库来管理数据层，本体库的概念相当于对象中“类”的概念。而建立在数据层之上的模式层，是知识图谱的核心，它借助本体库来管理公理、规则和约束条件，规范实体、关系、属性这些具体对象间的关系。</p><p>从不同的视角去审视知识图谱，可以更方便我们对其进行了解：</p><ol><li>在Web视角下，知识图谱如同简单文本之间的超链接一样，通过建立数据之间的语义链接，支持语义搜索</li><li>在自然语言处理视角下，知识图谱就是从文本中抽取语义和结构化的数据</li><li>在知识表示视角下，知识图谱是采用计算机符号表示和处理知识的方法</li><li>在人工智能视角下，知识图谱是利用知识库来辅助理解人类语言的工具</li><li>在数据库视角下，知识图谱是利用图的方式去存储知识的方法</li></ol>]]></content>
    
    
    <categories>
      
      <category>项目优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uniapp小程序(项目)</title>
    <link href="/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5DMousoul%E6%89%8B%E7%BB%98%E5%95%86%E5%9F%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <url>/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5DMousoul%E6%89%8B%E7%BB%98%E5%95%86%E5%9F%8E%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<hr><h4 id="封装各类通用组件如自定导航栏、返回上一页自动更新数据功能以及其他基础功能"><a href="#封装各类通用组件如自定导航栏、返回上一页自动更新数据功能以及其他基础功能" class="headerlink" title="封装各类通用组件如自定导航栏、返回上一页自动更新数据功能以及其他基础功能"></a>封装各类通用组件如自定导航栏、返回上一页自动更新数据功能以及其他基础功能</h4><p>实现这样的功能可以通过以下步骤：</p><ol><li><p>创建自定义导航栏组件和返回按钮组件，将其封装为独立的组件。</p></li><li><p>在每个页面中引入该自定义导航栏组件，并设置相应的参数（如标题、菜单项等）。</p></li><li><p>在返回按钮组件中使用路由API实现返回上一页的功能，并通过 props 将需要更新的数据传递给上一页。</p></li><li><p>在需要更新数据的页面中，在路由钩子函数中监听上一页传递过来的数据，并在数据更新后重新渲染页面。</p></li></ol><p>总体思路是将通用组件封装为独立的模块，使得它们可以在多个页面中复用，从而提高代码的可维护性和可重用性。</p><p>封装通用组件可以提高代码复用率和开发效率，下面是封装一个自定义导航栏的基本步骤：</p><ol><li><p>创建一个Navbar组件的文件夹，并在该文件夹中创建Navbar.vue文件。</p></li><li><p>在Navbar.vue文件中编写导航栏的HTML结构和CSS样式。</p></li><li><p>在Navbar.vue文件中定义导航栏的props属性，以接收从父级组件传递过来的数据（例如导航栏标题、链接等）。</p></li><li><p>在Navbar.vue文件中定义导航栏的methods方法，以处理导航栏的交互事件（例如点击链接跳转）。</p></li><li><p>在Navbar.vue文件中定义导航栏的computed计算属性，以根据props属性动态生成导航栏的内容。</p></li><li><p>在需要使用导航栏的父级组件中引入Navbar组件，并传递所需的props属性。</p></li><li><p>在父级组件中使用Navbar组件并传递所需的props属性，即可显示自定义导航栏。</p></li></ol><p>这是一个简单的封装自定义导航栏的步骤，具体实现可以根据需求进行调整和优化。同时，在进行通用组件封装时，建议将组件的功能封装得尽可能独立，以便在其他项目或场景中进行重复使用。</p><h4 id="性能优化：引入iconfont图标库，以及运行代码imagemin-linter对图片进行的规范"><a href="#性能优化：引入iconfont图标库，以及运行代码imagemin-linter对图片进行的规范" class="headerlink" title="性能优化：引入iconfont图标库，以及运行代码imagemin-linter对图片进行的规范"></a>性能优化：引入iconfont图标库，以及运行代码imagemin-linter对图片进行的规范</h4><h5 id="引入iconfont图标库："><a href="#引入iconfont图标库：" class="headerlink" title="引入iconfont图标库："></a>引入iconfont图标库：</h5><ol><li><p>登录iconfont官网，创建项目并添加所需图标。</p></li><li><p>在生成代码选项卡中选择使用font-class，并下载所生成的文件。</p></li><li><p>将下载的文件解压至项目目录中，并在HTML文件中引用font.css文件。</p></li><li><p>在HTML文件中使用i标签并为其添加相应class名称即可使用图标。</p></li></ol><h5 id="运行imagemin-linter对图片进行规范："><a href="#运行imagemin-linter对图片进行规范：" class="headerlink" title="运行imagemin-linter对图片进行规范："></a>运行imagemin-linter对图片进行规范：</h5><p>imagemin-linter 是一个用于检测和修复不规范图片的工具，它依赖于 imagemin 和 ESLint。</p><p>要使用 imagemin-linter 对图片进行规范化，可以按照以下步骤：</p><ol><li><p>安装 Node.js 和 npm 环境。</p></li><li><p>使用 npm 安装 imagemin-linter 和相关的插件。例如，要支持 JPEG 图片的检测和修复，可以安装 <code>imagemin-linter-plugin-jpeg</code> 插件，命令如下：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">npm install --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> imagemin-linter imagemin-linter-plugin-jpeg<br></code></pre></td></tr></table></figure></li><li><p>配置 imagemin-linter。在项目根目录下创建 <code>.eslintrc.js</code> 文件，并在其中添加如下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-keyword">extends</span>: [<span class="hljs-string">&#x27;imagemin-linter/config&#x27;</span>],<br>  rules: &#123;<br>    <span class="hljs-comment">// 自定义 ESLint 规则</span><br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>在 package.json 中添加脚本命令，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;lint-images&quot;</span>: <span class="hljs-string">&quot;imagemin-linter ./src/assets/images/**/*.jpg&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>运行脚本即可进行检测和修复，例如：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-builtin-name">run</span> lint-images<br></code></pre></td></tr></table></figure></li></ol><p>通过上述步骤配置运行 imagemin-linter，可以帮助我们在开发过程中自动发现和修复不规范的图片，提高项目的质量和可维护性。</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>imagemin-linter 的原理是将图片文件通过 imagemin 进行压缩和优化，然后使用 ESLint 对压缩后的文件进行静态分析和修复。</p><p>具体来说，imagemin-linter 主要涉及以下几个方面的技术：</p><ol><li><p>imagemin：一个用于压缩和优化图片的工具库，支持多种格式的图片（如 JPEG、PNG、GIF、SVG 等），并提供了丰富的插件实现不同的优化效果。imagemin-linter 使用 imagemin 将图片进行压缩和优化，以达到减小图片大小、提高加载速度等目的。</p></li><li><p>ESLint：一个用于代码质量检测和修复的工具，在 JavaScript 项目中广泛应用。imagemin-linter 基于 ESLint 实现对压缩后的图片文件进行静态分析和修复，从而发现和修复不规范的图片。</p></li><li><p>插件机制：imagemin-linter 采用插件机制，可以根据需要安装和配置不同的插件，实现对不同格式图片的检测和修复。例如，<code>imagemin-linter-plugin-jpeg</code> 插件可以对 JPEG 格式的图片进行检测和修复，<code>imagemin-linter-plugin-png</code> 插件可以对 PNG 格式的图片进行检测和修复等。</p></li></ol><p>综上所述，imagemin-linter 的原理是通过 imagemin 对图片进行压缩和优化，然后使用 ESLint 对压缩后的文件进行静态分析和修复，从而帮助开发者发现和修复不规范的图片，提高项目的质量和可维护性。</p><h4 id="使用IntersectionObserver实现图片懒加载"><a href="#使用IntersectionObserver实现图片懒加载" class="headerlink" title="使用IntersectionObserver实现图片懒加载"></a>使用IntersectionObserver实现图片懒加载</h4><p>前端图片懒加载优化是一种常见的性能优化策略，可以有效减少页面加载时间和带宽占用。以下是实现前端图片懒加载优化的几种方法：</p><ol><li><p>IntersectionObserver：使用IntersectionObserver API，当图片进入可视区域时再进行加载。这种方法不仅可以节省带宽，还能避免过早地加载图片，从而提高用户体验。</p></li><li><p>Lazyload.js：使用Lazyload.js库，该库支持对图像、背景图、视频等元素的懒加载，并且支持响应式布局和多种触发事件。</p></li><li><p>jQuery.lazyload：使用jQuery.lazyload插件，通过在图片标签上添加”data-original”属性，将图片的URL存储在该属性中，然后通过调用lazyload()函数来实现图片的懒加载。</p></li><li><p>原生JavaScript：使用原生JavaScript编写懒加载代码，监听滚动事件，当图片进入浏览器可视区域内时，通过修改img标签的src属性来进行图片的懒加载。</p></li></ol><p>需要注意的是，无论采用哪种懒加载方案，都要确保在图片加载前显示占位符，以防止页面布局因未加载图片而出现抖动等问题。此外，也要合理设置图片的尺寸和压缩比例，避免图片文件过大导致页面速度变慢。</p><h4 id="采用路由懒加载，优化性能"><a href="#采用路由懒加载，优化性能" class="headerlink" title="采用路由懒加载，优化性能"></a>采用路由懒加载，优化性能</h4><p>路由懒加载是一种常用的性能优化策略，它可以将页面组件按需分割为多个小模块进行异步加载，从而减少页面加载时间和消耗带宽。</p><p>以下是实现路由懒加载的步骤：</p><ol><li>使用动态导入语法：使用ES6中的import()函数来引入需要懒加载的组件。例如，对于Vue.js项目，可以使用下面的代码：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Home = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;home&quot; */</span> <span class="hljs-string">&#x27;./views/Home.vue&#x27;</span>)<br></code></pre></td></tr></table></figure><p>其中，webpackChunkName选项表示生成的代码块名称，用于区分不同的代码块。</p><ol start="2"><li>配置Webpack打包工具：在Webpack配置文件中，需要开启代码分割(splitChunks)和动态导入(import())特性，并设置chunkFilename选项。</li></ol><p>例如，在Vue CLI3.x中，可以在vue.config.js中修改配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;<br>  configureWebpack: &#123;<br>    optimization: &#123;<br>      splitChunks: &#123;<br>        chunks: <span class="hljs-string">&#x27;async&#x27;</span>,<br>        minSize: <span class="hljs-number">30000</span>,<br>        maxSize: <span class="hljs-number">0</span>,<br>        minChunks: <span class="hljs-number">1</span>,<br>        maxAsyncRequests: <span class="hljs-number">5</span>,<br>        maxInitialRequests: <span class="hljs-number">3</span>,<br>        automaticNameDelimiter: <span class="hljs-string">&#x27;~&#x27;</span>,<br>        name: <span class="hljs-literal">true</span>,<br>        cacheGroups: &#123;<br>          vendors: &#123;<br>            test: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,<br>            priority: -<span class="hljs-number">10</span><br>          &#125;,<br>          <span class="hljs-keyword">default</span>: &#123;<br>            minChunks: <span class="hljs-number">2</span>,<br>            priority: -<span class="hljs-number">20</span>,<br>            reuseExistingChunk: <span class="hljs-literal">true</span><br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>在路由中配置懒加载：在Vue.js的路由中，可以通过component选项来配置懒加载组件。例如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> Home = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;home&quot; */</span> <span class="hljs-string">&#x27;./views/Home.vue&#x27;</span>)<br><span class="hljs-keyword">const</span> About = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="hljs-string">&#x27;./views/About.vue&#x27;</span>)<br><span class="hljs-keyword">const</span> Contact = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;contact&quot; */</span> <span class="hljs-string">&#x27;./views/Contact.vue&#x27;</span>)<br><br>Vue.use(Router)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Router(&#123;<br>  routes: [<br>    &#123;<br>      path: <span class="hljs-string">&#x27;/&#x27;</span>,<br>      name: <span class="hljs-string">&#x27;home&#x27;</span>,<br>      component: Home<br>    &#125;,<br>    &#123;<br>      path: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>      name: <span class="hljs-string">&#x27;about&#x27;</span>,<br>      component: About<br>    &#125;,<br>    &#123;<br>      path: <span class="hljs-string">&#x27;/contact&#x27;</span>,<br>      name: <span class="hljs-string">&#x27;contact&#x27;</span>,<br>      component: Contact<br>    &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>通过以上步骤，就可以实现路由懒加载，并提高应用程序的性能表现。需要注意的是，在实际应用中，还需要根据具体情况进行调整和优化，避免过多的代码分割导致网络请求时间过长、页面渲染闪烁等问题。</p><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>路由懒加载的核心原理是使用Webpack等打包工具，将代码按需分割为多个小模块，并在需要时动态地进行加载。</p><p>具体来说，当应用程序首次加载时，只会下载最基础的代码（如路由配置、公共组件等），而对于其他页面组件则不会立即下载。当用户访问某个页面时，才会异步加载该页面对应的代码块，并渲染页面内容。</p><p>这种方式可以大幅减少应用程序的初始加载时间和带宽消耗，并且针对移动端或低速网络环境尤为有效。同时，还可以利用webpack的chunkhash特性对代码块进行版本控制，避免缓存问题和请求冲突。</p><p>在Vue.js等框架中，路由懒加载可以通过ES6的动态导入(import())和webpack的代码分割机制来实现。开发者只需要在路由配置中指定懒加载组件的路径，打包工具就会自动生成对应的代码块并进行异步加载。</p><p>总之，路由懒加载提供了一种高效的前端性能优化方案，可以显著提升应用程序的响应速度和用户体验。</p><h4 id="微信小程序登录怎么实现"><a href="#微信小程序登录怎么实现" class="headerlink" title="微信小程序登录怎么实现"></a>微信小程序登录怎么实现</h4><p>微信小程序登录实现需要以下步骤：</p><ol><li><p>获取用户授权：在小程序中，需要通过wx.login() API获取用户的临时登录凭证code并调用wx.getUserInfo() API获取用户信息。需要先调用wx.getSetting() API检查用户是否已经授权，如果未授权则需要引导用户进入授权页面。</p></li><li><p>发送请求至后端服务器：将code和userInfo发送给后端服务器，使用服务器端的语言进行解密、验证以及生成自己的登录态。一般情况下，可以使用JWT(Token)来生成登录态并返回给前端。</p></li><li><p>缓存登录态：将后端返回的登录态缓存在本地，并在进行需要认证的API请求时带上该登录态作为认证凭据。在小程序中，可以使用wx.setStorageSync() / wx.getStorageSync()等API来进行本地缓存操作。请注意保护用户隐私，避免敏感信息被恶意窃取。</p></li><li><p>登录态维护：在小程序的生命周期函数中，需要对登录态进行有效性校验和维护。当登录态过期或失效时，需要引导用户重新进行登录授权。</p></li></ol><p>需要注意的是，在实际应用中，还要考虑安全性和用户体验问题。例如，需要使用HTTPS协议加密通信，避免传输过程中信息泄露；同时，可以使用loading动画、提示框等方式提高用户操作体验。</p>]]></content>
    
    
    <categories>
      
      <category>项目优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vuex数据可持久化(项目)</title>
    <link href="/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5Dvuex%E6%95%B0%E6%8D%AE%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5Dvuex%E6%95%B0%E6%8D%AE%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="vuex数据可持久化-对于刷新也需要保留状态的需要同步到本地存储"><a href="#vuex数据可持久化-对于刷新也需要保留状态的需要同步到本地存储" class="headerlink" title="vuex数据可持久化-对于刷新也需要保留状态的需要同步到本地存储"></a>vuex数据可持久化-对于刷新也需要保留状态的需要同步到本地存储</h2><h4 id="Vuex实现数据持久化，解决浏览器刷新数据丢失问题"><a href="#Vuex实现数据持久化，解决浏览器刷新数据丢失问题" class="headerlink" title="Vuex实现数据持久化，解决浏览器刷新数据丢失问题"></a>Vuex实现数据持久化，解决浏览器刷新数据丢失问题</h4><p>vuex的 store 中的数据是保存在运行内存中的，当页面刷新时，页面会重新加载 vue 实例，vuex 里面的数据就会被重新赋值，这样就会出现页面刷新vuex中的数据丢失的问题。 如何解决浏览器刷新数据丢失问题呢？</p><h5 id="方法一：全局监听，页面刷新的时候将-store-里-state-的值存到-sessionStorage-中，然后从sessionStorage-中获取，再赋值给-store-，并移除-sessionStorage-中的数据。在-app-vue-中添加以下代码："><a href="#方法一：全局监听，页面刷新的时候将-store-里-state-的值存到-sessionStorage-中，然后从sessionStorage-中获取，再赋值给-store-，并移除-sessionStorage-中的数据。在-app-vue-中添加以下代码：" class="headerlink" title="方法一：全局监听，页面刷新的时候将 store 里 state 的值存到 sessionStorage 中，然后从sessionStorage 中获取，再赋值给 store ，并移除 sessionStorage 中的数据。在 app.vue 中添加以下代码："></a>方法一：全局监听，页面刷新的时候将 store 里 state 的值存到 sessionStorage 中，然后从sessionStorage 中获取，再赋值给 store ，并移除 sessionStorage 中的数据。在 app.vue 中添加以下代码：</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">created<span class="hljs-literal">()</span> &#123;<br>   window.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">beforeunload</span>&#x27;,()</span>=&gt;&#123;<br>      sessionStorage.set<span class="hljs-constructor">Item(&#x27;<span class="hljs-params">list</span>&#x27;, JSON.<span class="hljs-params">stringify</span>(<span class="hljs-params">this</span>.$<span class="hljs-params">store</span>.<span class="hljs-params">state</span>)</span>)<br>   &#125;)<br>   <br>   <span class="hljs-keyword">try</span>&#123;<br>     sessionStorage.get<span class="hljs-constructor">Item(&#x27;<span class="hljs-params">list</span>&#x27;)</span><span class="hljs-operator"> &amp;&amp; </span>this.$store.replace<span class="hljs-constructor">State(Object.<span class="hljs-params">assign</span>(&#123;&#125;,<span class="hljs-params">this</span>.$<span class="hljs-params">store</span>.<span class="hljs-params">state</span>,JSON.<span class="hljs-params">parse</span>(<span class="hljs-params">sessionStorage</span>.<span class="hljs-params">getItem</span>(&#x27;<span class="hljs-params">list</span>&#x27;)</span>)))<br>   &#125;catch(err) &#123;<br>     console.log(err);<br>   &#125;<br> <br>   sessionStorage.remove<span class="hljs-constructor">Item(<span class="hljs-string">&quot;list&quot;</span>)</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>注意!!! storage 只能存储字符串的数据，对于 JS 中常用的数组或对象不能直接存储。但我们可以通过JSON 对象提供的 parse 和 stringify 方法将其他数据类型转化成字符串，再存储到storage中就可以了。</strong></p><h4 id="方法二：安装-vuex-persistedstate-插件"><a href="#方法二：安装-vuex-persistedstate-插件" class="headerlink" title="方法二：安装 vuex-persistedstate 插件"></a>方法二：安装 vuex-persistedstate 插件</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-number">1.</span> npm install vuex-persistedstate -S <span class="hljs-comment">//安装插件</span><br><span class="hljs-number">2.</span> 在 store/<span class="hljs-keyword">index</span>.js 文件中添加以下代码：<br>import persistedState <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex-persistedstate&#x27;</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br> state:&#123;&#125;,<br> getters:&#123;&#125;,<br> ...<br> plugins: [persistedState()] <span class="hljs-comment">//添加插件</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>注意!!! vuex-persistedstate 默认使用 localStorage 来存储数据，若要实现无痕浏览该如何实现呢？</strong></p><p>这时候就<strong>需要使用 sessionStorage 进行存储，修改 plugins 中的代码</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">plugins: [<br>    <span class="hljs-built_in">persistedState</span>(&#123; storage: window.sessionStorage &#125;)<br>]<br></code></pre></td></tr></table></figure><h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><ol><li>storage为存储方式，可选值为localStorage、sessionStorage和cookies；</li><li>localStorage和sessionStorage两种存储方式可以采用上述代码中的写法，若想采用cookies坐位数据存储方式，则需要另外一种写法；</li><li>render接收一个函数，返回值为一个对象；返回的对象中的键值对既是要持久化存储的数据；</li><li>若想持久化存储部分数据，请在return的对象中采用key：value键值对的方式进行数据存储，render函数中的参数既为state对象。</li></ol><h4 id="方案三：vuex-persist"><a href="#方案三：vuex-persist" class="headerlink" title="方案三：vuex-persist"></a>方案三：vuex-persist</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">安装插件<br>yarn <span class="hljs-built_in">add</span> vuex-persist<br>// 或<br>npm install <span class="hljs-comment">--save vuex-persist</span><br></code></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs pf">import Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span>;<br>// 引入插件<br>import VuexPersistence <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex-persist&quot;</span>;<br><br>Vue.use(Vuex);<br>//  初始化<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">state</span> = &#123;<br><span class="hljs-keyword">user</span>Name:&#x27;admin&#x27;<br>&#125;;<br><span class="hljs-keyword">const</span> mutations = &#123;&#125;;<br><span class="hljs-keyword">const</span> actions = &#123;&#125;;<br>// 创建实例<br><span class="hljs-keyword">const</span> vuexPersisted = new VuexPersistence(&#123;<br>storage: window.sessionStorage,<br>  render:<span class="hljs-keyword">state</span>=&gt;(&#123;<br>  <span class="hljs-keyword">user</span>Name:<span class="hljs-keyword">state</span>.<span class="hljs-keyword">user</span>Name<br>    // 或<br>    ...<span class="hljs-keyword">state</span><br>  &#125;)<br>&#125;);<br><br><span class="hljs-keyword">const</span> store = new Vuex.Store(&#123;<br><span class="hljs-keyword">state</span>,<br>  actions,<br>  mutations,<br>  // 数据持久化设置<br>  plugins:[vuexPersisted]<br>&#125;);<br><br>export <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/6973916613506498567">Vuex实现数据持久化，解决浏览器刷新数据丢失问题</a><br><a href="https://juejin.cn/post/6918684399659646989">Vuex数据持久化存储</a></p><h4 id="比vuex更好用的Pinia-pinia模块化如何实现-pinia如何实现数据持久化"><a href="#比vuex更好用的Pinia-pinia模块化如何实现-pinia如何实现数据持久化" class="headerlink" title="比vuex更好用的Pinia,pinia模块化如何实现?pinia如何实现数据持久化?"></a>比vuex更好用的Pinia,pinia模块化如何实现?pinia如何实现数据持久化?</h4><h5 id="pinia模块化如何实现"><a href="#pinia模块化如何实现" class="headerlink" title="pinia模块化如何实现?"></a>pinia模块化如何实现?</h5><p>pinia相比vuex没有modules,那么如何实现模块化呢?<br>在复杂项目中，不可能把多个模块的数据都定义到一个store中，一般来说会一个模块对应一个store，最后通过一个根store进行整合</p><p>假设我们目前store中有两个模块user.js和counter.js,我们再手动设置一个index.js</p><p>1.我们在index.js中导入user.js和counter.js,</p><p>2.并统一导出useStore方法,返回user和counter中的内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> useCounterStore <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./counter.js&#x27;</span><br><span class="hljs-keyword">import</span> useUserStore <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user.js&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useStore</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        user:useUserStore(),<br>        counter:useCounterStore()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.那么如何在组件中具体使用呢?</p><p>首先从store/index.js导入useStore方法</p><p>由于使用useStore方法会返回一个对象,对象中有user和counter,</p><p>我们使用解构赋值可以从useStore方法得到具体的某个模块</p><p>注意:import useStore from ‘./store’ 虽然没有在后面加上/index.js,但是会默认选中文件夹下的index.js</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span></span><br><span class="xml">import useStore from &#x27;./store&#x27;</span><br><span class="xml">const &#123; counter &#125; = useStore()</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>主页组件<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>计数:</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">counter.count</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>计数加倍: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">counter.double</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="vuex中实现模块化的方法"><a href="#vuex中实现模块化的方法" class="headerlink" title="vuex中实现模块化的方法"></a>vuex中实现模块化的方法</h5><p>1.把各个模块导入index.js 2.把所有模块名放到mudules下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-keyword">import</span> getters <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./getters&#x27;</span><br><span class="hljs-keyword">import</span> app <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./modules/app&#x27;</span><br><span class="hljs-keyword">import</span> settings <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./modules/settings&#x27;</span><br><span class="hljs-keyword">import</span> user <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./modules/user&#x27;</span><br><span class="hljs-keyword">import</span> menu <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./modules/menu&#x27;</span><br><br>Vue.use(Vuex)<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  modules: &#123;<br>    app,<br>    settings,<br>    user,<br>    menu<br>  &#125;,<br>  getters<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store<br></code></pre></td></tr></table></figure><h4 id="pinia如何实现数据持久化"><a href="#pinia如何实现数据持久化" class="headerlink" title="pinia如何实现数据持久化?"></a>pinia如何实现数据持久化?</h4><p>我们可以通过通过 Pinia 插件pinia-plugin-persistedstate实现持久化存储</p><p>配置pinia持久化插件</p><p>1.下载安装pinia-plugin-persistedstate</p><p>2.main.js导入pinia-plugin-persistedstate创建对象并挂载</p><p>3.在具体的pinia模块中开启持久化</p><p>下载安装插件</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">yarn <span class="hljs-keyword">add </span>pinia-plugin-persistedstate<br><span class="hljs-keyword">or</span><br><span class="hljs-keyword">npm </span>i  pinia-plugin-persistedstate<br></code></pre></td></tr></table></figure><p>在main.js中导入并且注册挂载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 配置pinia持久化插件</span><br><span class="hljs-comment">// 1.下载安装pinia-plugin-persistedstate</span><br><span class="hljs-comment">// 2.main.js导入pinia-plugin-persistedstate创建对象并挂载</span><br><span class="hljs-comment">// 3.在具体的pinia模块中开启持久化</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; createPinia &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-keyword">import</span> piniaPluginPersistedstate <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia-plugin-persistedstate&#x27;</span><br><span class="hljs-keyword">const</span> pinia = createPinia()<br>pinia.use(piniaPluginPersistedstate)<br><br>createApp(App).use(pinia).mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>注意:当createApp(App)需要挂载多个时</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript">createApp(App).use(router).use(pinia).mount(<span class="hljs-string">&quot;#app&quot;</span>)<br>复制代码<br>在具体的pinia模块中开启持久化<br>在user.js中设置 persist: <span class="hljs-literal">true</span><br><br><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">const</span> useUserStore = defineStore(<span class="hljs-string">&#x27;user&#x27;</span>,&#123;<br>    <span class="hljs-function"><span class="hljs-title">state</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            userInfo:&#123;<br>                name:<span class="hljs-string">&#x27;tom&#x27;</span>,<br>                age:<span class="hljs-number">4</span><br>            &#125;<br>        &#125;<br>    &#125;,<br>    actions:&#123;<br>        <span class="hljs-function"><span class="hljs-title">addAge</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">this</span>.userInfo.age++<br>        &#125;<br>    &#125;,<br>    getters:&#123;<br>        <br>    &#125;,<br>    <span class="hljs-comment">//开启数据持久化</span><br>    persist: <span class="hljs-literal">true</span><br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useUserStore<br></code></pre></td></tr></table></figure><p>实现效果,state数据存储在了LocalStorage中<br>总结</p><ul><li>pinia相比vuex有许多优化比如取消了mutations,同步异步修改数据都在actions中进行</li><li>但是pinia取消了modules,我们可以手动实现模块化,导入把所有模块导入index.js,函数返回一个对象</li><li>pinia实现持久化方法有许多种,此处使用插件比较简单<br><a href="https://juejin.cn/post/7164957663522979848#heading-2">比vuex更好用的Pinia,pinia模块化如何实现?pinia如何实现数据持久化?</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计整套权限控制方案(项目)</title>
    <link href="/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D%E8%AE%BE%E8%AE%A1%E6%95%B4%E5%A5%97%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%96%B9%E6%A1%88/"/>
    <url>/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D%E8%AE%BE%E8%AE%A1%E6%95%B4%E5%A5%97%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="设计整套权限控制方案"><a href="#设计整套权限控制方案" class="headerlink" title="设计整套权限控制方案"></a>设计整套权限控制方案</h2><p>根据路由动态渲染菜单以及角色权限信息控制按设计按纽级别的显隐-封装V-permission指令</p><h3 id="V-permission自定义指令"><a href="#V-permission自定义指令" class="headerlink" title="V-permission自定义指令"></a>V-permission自定义指令</h3><p>vue项目实现不同用户角色权限管控：</p><h4 id="第一种方式：自定义指令实现用户角色权限控制v-permission："><a href="#第一种方式：自定义指令实现用户角色权限控制v-permission：" class="headerlink" title="第一种方式：自定义指令实现用户角色权限控制v-permission："></a>第一种方式：自定义指令实现用户角色权限控制v-permission：</h4><p>实现方法：Vue.directive+install+Vue.use</p><p>步骤：</p><ol><li>新建permission.js 实现自定义指令的钩子方法：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">inserted</span>(<span class="hljs-params">el, binding</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; value &#125; = binding<br>    <span class="hljs-keyword">const</span> roles = store.getters &amp;&amp; store.getters.roles<br>    <span class="hljs-keyword">if</span> (value &amp;&amp; value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) &#123;<br>      <span class="hljs-keyword">if</span> (value.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">const</span> permissionRoles = value<br>        <span class="hljs-keyword">const</span> hasPermission = roles.some(<span class="hljs-function"><span class="hljs-params">role</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">return</span> permissionRoles.includes(role)<br>        &#125;)<br>        <span class="hljs-keyword">if</span> (!hasPermission) &#123;<br>          el.parentNode &amp;&amp; el.parentNode.removeChild(el)<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`使用方式： v-permission=&quot;[&#x27;admin&#x27;,&#x27;editor&#x27;]&quot;`</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>新建index.js 将permission转为install：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> permission <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./permission&#x27;</span><br><br><span class="hljs-keyword">const</span> install = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Vue</span>) </span>&#123;<br>  Vue.directive(<span class="hljs-string">&#x27;permission&#x27;</span>, permission)<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.Vue) &#123;<br>  <span class="hljs-built_in">window</span>[<span class="hljs-string">&#x27;permission&#x27;</span>] = permission<br>  Vue.use(install); <span class="hljs-comment">// eslint-disable-line</span><br>&#125;<br><br>permission.install = install<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> permission<br></code></pre></td></tr></table></figure><ol start="3"><li>在main.js中用use方法使用permission：</li></ol><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-comment">// 权限指令</span><br><span class="hljs-keyword">import</span> permission <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Permission&#x27;</span><br>Vue.use(permission)<br></code></pre></td></tr></table></figure><ol start="4"><li>在模板中使用v-permission控制访问权限:</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala">&lt;el-button<br>        slot=<span class="hljs-string">&quot;left&quot;</span><br>        v-permission=<span class="hljs-string">&quot;[&#x27;admin&#x27;, &#x27;storage:add&#x27;]&quot;</span><br>        <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;filter-item&quot;</span><br>        size=<span class="hljs-string">&quot;mini&quot;</span><br>        <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">&quot;primary&quot;</span><br>        icon=<span class="hljs-string">&quot;el-icon-upload&quot;</span><br>        <span class="hljs-meta">@click</span>=<span class="hljs-string">&quot;mainadd = true&quot;</span><br>        &gt;添加&lt;/el-button<br>      &gt;<br></code></pre></td></tr></table></figure><h4 id="第二种方式：Vue-prototype-install-v-if实现用户角色权限控制："><a href="#第二种方式：Vue-prototype-install-v-if实现用户角色权限控制：" class="headerlink" title="第二种方式：Vue.prototype+install+v-if实现用户角色权限控制："></a>第二种方式：Vue.prototype+install+v-if实现用户角色权限控制：</h4><ol><li>新建permission.js，将checkPer方法注册到Vue.prototype，并注册为install方法：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store&#x27;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Array&#125;</span> <span class="hljs-variable">value</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns <span class="hljs-type">&#123;Boolean&#125;</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@example </span>see @/views/permission/directive.vue</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">install</span>(<span class="hljs-params">Vue</span>)</span> &#123;<br>    Vue.prototype.checkPer = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (value &amp;&amp; value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> &amp;&amp; value.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">const</span> roles = store.getters &amp;&amp; store.getters.roles<br>        <span class="hljs-keyword">const</span> permissionRoles = value<br>        <span class="hljs-keyword">return</span> roles.some(<span class="hljs-function"><span class="hljs-params">role</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">return</span> permissionRoles.includes(role)<br>        &#125;)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`need roles! Like v-permission=&quot;[&#x27;admin&#x27;,&#x27;editor&#x27;]&quot;`</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>在main.js中引入permission, 并用use方法:<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-comment">// 权限指令</span><br><span class="hljs-keyword">import</span> checkPer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/permission&#x27;</span><br>Vue.use(checkPer)<br></code></pre></td></tr></table></figure>使用：配合 v-if 在模板中实现权限控制：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;el-table-column <span class="hljs-attribute">v-if</span>=<span class="hljs-string">&quot;checkPer([&#x27;admin&#x27;,&#x27;app:edit&#x27;,&#x27;app:del&#x27;])&quot;</span> <span class="hljs-attribute">label</span>=<span class="hljs-string">&quot;操作&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;150px&quot;</span> <span class="hljs-attribute">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;<br></code></pre></td></tr></table></figure><a href="https://www.jianshu.com/p/b9f3c43cf07a">vue权限管控permission实现</a><h4 id="vue自定义指令合集之权限校验v-permission"><a href="#vue自定义指令合集之权限校验v-permission" class="headerlink" title="vue自定义指令合集之权限校验v-permission"></a>vue自定义指令合集之权限校验v-permission</h4><blockquote><p>在我们日常开发中权限校验是必不可少的一个环节，尤其是对于一些应用系统或一些中后台的开发，更是需要用到权限校验的。那么权限校验也有很多种类，比如菜单权限、组件权限甚至是小到元素权限等等，本文我们就将以元素权限为例，实现一个简单的权限校验自定义指令。<br>在有一些场景中我们可能会根据用户登录后所拥有的权限来决定哪些元素该显示，哪些元素不该显示。比如我们最常使用的就是增删改查操作，那么对于管理员来说权限很大，增删改查都有权限操作，而对于普通用户来说可能只有查询操作，这个时候就需要根据不同用户权限来决定元素的显示和隐藏了。</p></blockquote></li></ol><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><ol><li>首先因为会涉及到元素的展示和隐藏操作，所以在我们自定义指令时就不能再用beforeMount钩子函数了，而是需要用mounted函数，也就是说等元素渲染后再去控制是否展示。</li><li>在mounted函数中，我们首先需要获取登录用户所拥有的权限。一般情况下在用户登录后会去请求服务器获取用户权限，然后再把权限数据保存在vuex中。这里我们要做的就是把权限数据从vuex中解析出来，便于后续使用。（为了方便展示，我们就直接使用字符串代替了）</li><li>权限数据拿到以后，我们还需要判断当前元素需要哪些权限，比如删除按钮需要的就是对应的删除权限，而这个权限在元素被定义时就应该已经确定了，所以我们应该在对应的元素中把需要的权限传给我们的自定义指令，然后再通过binding.value拿到该权限</li><li>最后就是对比校验，看看当前元素所需要的权限是否存在于用户的权限列表中，如果存在则说明有权限元素应该显示，否则没有权限移除对应的元素。</li><li>以上便是权限自定义指令的整体实现思路，相对来说还是比较简单的，下面我们来看一下具体的代码实现。<br>权限校验代码实现<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-permission</span>=<span class="hljs-string">&quot;&#x27;add&#x27;&quot;</span>&gt;</span>add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-permission</span>=<span class="hljs-string">&quot;&#x27;del&#x27;&quot;</span>&gt;</span>del<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-permission</span>=<span class="hljs-string">&quot;&#x27;update&#x27;&quot;</span>&gt;</span>update<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-permission</span>=<span class="hljs-string">&quot;&#x27;query&#x27;&quot;</span>&gt;</span>query<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs awk">const app = createApp();<br>app.directive(<span class="hljs-string">&#x27;permission&#x27;</span>,&#123;<br>mounted(el,binding)&#123;<br><span class="hljs-regexp">//</span>从服务获取用户的权限列表，一般获取后存放于vuex中，本案例为了方便演示将直接以字符串的形式展示<br><span class="hljs-regexp">//</span>权限之间以分号分隔<br><span class="hljs-regexp">//</span>管理员权限：<span class="hljs-string">&quot;add;del;update;query&quot;</span><br><span class="hljs-regexp">//</span>普通用户权限：<span class="hljs-string">&quot;add;del;update;query&quot;</span><br>let permission = <span class="hljs-string">&quot;update;query&quot;</span>,<span class="hljs-regexp">//</span>权限字符串<br>permissionList = [];<span class="hljs-regexp">//</span>权限列表<br><span class="hljs-keyword">if</span>(!permission) permission = <span class="hljs-string">&quot;&quot;</span>;<br>permissionList = permission.split(<span class="hljs-string">&quot;;&quot;</span>);<br><br><span class="hljs-regexp">//</span>获取需要的权限标识，即元素给指令传进来的参数值<br>let passText = binding.value,<span class="hljs-regexp">//</span>可以是多个值，中间以分号分隔<br>passTextArr = [];<span class="hljs-regexp">//</span>将权限解析到数组中<br><span class="hljs-keyword">if</span>(!passText) passText = <span class="hljs-string">&quot;&quot;</span>;<br>passTextArr = passText.split(<span class="hljs-string">&#x27;;&#x27;</span>);<br><br><span class="hljs-regexp">//</span>定义一个权限标识变量，用于标识是否有权限<br>let flag = false;<br><span class="hljs-regexp">//</span>循环遍历权限列表，检测用户是否有相应的操作权限<br><span class="hljs-keyword">for</span>(let i = <span class="hljs-number">0</span>; i &lt; passTextArr.length; i++)&#123;<br><span class="hljs-keyword">if</span>(permissionList.includes(passTextArr[i]))&#123;<br><span class="hljs-regexp">//</span>如果从服务器中获取的权限列表中有组件所需的权限，则将flag置为true,同时跳出循环<br>flag = true;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-regexp">//</span>如果flag为false，也就是没权限则直接将元素移除或者隐藏<br><span class="hljs-keyword">if</span>(!flag) el.parentNode &amp;&amp; el.parentNode.removeChild(el);<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure>代码运行起来后，我们会发现对应管理员来说，会看到全部按钮，而对于普通用户来说则只能看到update和query按钮。</li></ol><p><a href="https://juejin.cn/post/6981031288803164173">Vue后台管理系统怎么做权限验证和动态路由，谁来做？</a></p><h3 id="首屏看板优化，解决拖拉拽卡顿问题一-渲染优化重新封装组件-重新设计数据-设计vuex持久化存储"><a href="#首屏看板优化，解决拖拉拽卡顿问题一-渲染优化重新封装组件-重新设计数据-设计vuex持久化存储" class="headerlink" title="首屏看板优化，解决拖拉拽卡顿问题一 渲染优化重新封装组件 重新设计数据 设计vuex持久化存储"></a>首屏看板优化，解决拖拉拽卡顿问题一 渲染优化重新封装组件 重新设计数据 设计vuex持久化存储</h3><h3 id="vuex数据可持久化-对于刷新也需要保留状态的需要同步到本地存储"><a href="#vuex数据可持久化-对于刷新也需要保留状态的需要同步到本地存储" class="headerlink" title="vuex数据可持久化-对于刷新也需要保留状态的需要同步到本地存储"></a>vuex数据可持久化-对于刷新也需要保留状态的需要同步到本地存储</h3><h3 id="多条产品线共享sso单点登录设计"><a href="#多条产品线共享sso单点登录设计" class="headerlink" title="多条产品线共享sso单点登录设计"></a>多条产品线共享sso单点登录设计</h3><h4 id="单独提取登录模块-利用cookie-使二级域名可以共卓教据的持点来实现单点登录"><a href="#单独提取登录模块-利用cookie-使二级域名可以共卓教据的持点来实现单点登录" class="headerlink" title="单独提取登录模块 利用cookie 使二级域名可以共卓教据的持点来实现单点登录"></a>单独提取登录模块 利用cookie 使二级域名可以共卓教据的持点来实现单点登录</h4><p>涉及到cookie过大超过请求数据量–只保留必须的用户登录信息-token和userinfo至于项目个性信息保存在本地存储</p>]]></content>
    
    
    <categories>
      
      <category>项目优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端性能优化建议(项目)</title>
    <link href="/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/"/>
    <url>/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>先来看第一个面试问题。性能是前端面试的必考问题，结合我自己10多年的经验见闻，在问做过哪些<br>性能优化的时候：<br>。70％的同学上来就说减少合并资源、减少请求、数据缓存这些优化手段；<br>。15％的同学会提到需要在DevTools下先看看首屏时间，围绕首屏来优化；<br>。10％的同学会提到需要接入一个性能平台来看看现状，诊断一下；<br>。而只有5％的同学会从前端性能体系来系统考虑性能优化。</p><hr><h3 id="1-减少-HTTP-请求"><a href="#1-减少-HTTP-请求" class="headerlink" title="1. 减少 HTTP 请求"></a>1. 减少 HTTP 请求</h3><p>一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程。接下来看一个具体的例子帮助理解 HTTP ：</p><p>这是一个 HTTP 请求，请求的文件大小为 28.4KB。<br>名词解释：</p><p>Queueing: 在请求队列中的时间。<br>Stalled: 从TCP 连接建立完成，到真正可以传输数据之间的时间差，此时间包括代理协商时间。<br>Proxy negotiation: 与代理服务器连接进行协商所花费的时间。<br>DNS Lookup: 执行DNS查找所花费的时间，页面上的每个不同的域都需要进行DNS查找。<br>Initial Connection / Connecting: 建立连接所花费的时间，包括TCP握手/重试和协商SSL。<br>SSL: 完成SSL握手所花费的时间。<br>Request sent: 发出网络请求所花费的时间，通常为一毫秒的时间。<br>Waiting(TFFB): TFFB 是发出页面请求到接收到应答数据第一个字节的时间。<br>Content Download: 接收响应数据所花费的时间。</p><p>从这个例子可以看出，真正下载数据的时间占比为 13.05 / 204.16 = 6.39%，文件越小，这个比例越小，文件越大，比例就越高。这就是为什么要建议将多个小文件合并为一个大文件，从而减少 HTTP 请求次数的原因。</p><h3 id="2-使用-HTTP2"><a href="#2-使用-HTTP2" class="headerlink" title="2. 使用 HTTP2"></a>2. 使用 HTTP2</h3><p><a href="https://pengzhenglong.github.io/2022/01/07/%E8%AE%A1%E7%BD%91+%E6%B5%8F%E8%A7%88%E5%99%A8+http+%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/#HTTP2%E7%9B%B8%E5%AF%B9%E4%BA%8EHTTP1-x%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%E5%92%8C%E7%89%B9%E7%82%B9%EF%BC%9F">博客</a><br>HTTP2 相比 HTTP1.1 有如下几个优点：</p><h5 id="解析速度快"><a href="#解析速度快" class="headerlink" title="解析速度快"></a>解析速度快</h5><p>服务器解析 HTTP1.1 的请求时，必须不断地读入字节，直到遇到分隔符 CRLF 为止。而解析 HTTP2 的请求就不用这么麻烦，因为 HTTP2 是基于帧的协议，每个帧都有表示帧长度的字段。</p><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>HTTP1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求。<br>在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。<br>多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建。</p><h4 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h4><p>HTTP2 提供了首部压缩功能。<br>从上面两个请求可以看出来，有很多数据都是重复的。如果可以把相同的首部存储起来，仅发送它们之间不同的部分，就可以节省不少的流量，加快请求的时间。<br>HTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。<br>下面再来看一个简化的例子，假设客户端按顺序发送如下请求首部：</p><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>HTTP2 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>由于一个 TCP 连接流量带宽（根据客户端到服务器的网络带宽而定）是固定的，当有多个请求并发时，一个请求占的流量多，另一个请求占的流量就会少。流量控制可以对不同的流的流量进行精确控制。</p><h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>HTTP2 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。<br>例如当浏览器请求一个网站时，除了返回 HTML 页面外，服务器还可以根据 HTML 页面中的资源的 URL，来提前推送资源。<br>现在有很多网站已经开始使用 HTTP2 了，例如知乎：</p><p>其中 h2 是指 HTTP2 协议，http/1.1 则是指 HTTP1.1 协议。</p><h3 id="3-使用服务端渲染"><a href="#3-使用服务端渲染" class="headerlink" title="3. 使用服务端渲染"></a>3. 使用服务端渲染</h3><p>客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。<br>服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。</p><p>优点：首屏渲染快，SEO 好。<br>缺点：配置麻烦，增加了服务器的计算压力。</p><p>下面我用 Vue SSR 做示例，简单的描述一下 SSR 过程。</p><h3 id="4-静态资源使用-CDN"><a href="#4-静态资源使用-CDN" class="headerlink" title="4. 静态资源使用 CDN"></a>4. 静态资源使用 CDN</h3><p>内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。<br>CDN 原理<br>当用户访问一个网站时，如果没有 CDN，过程是这样的：</p><ol><li>浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。</li><li>本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到网站服务器的 IP 地址。</li><li>本地 DNS 将 IP 地址发回给浏览器，浏览器向网站服务器 IP 地址发出请求并得到资源。</li></ol><p>如果用户访问的网站部署了 CDN，过程是这样的：</p><ol><li>浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。</li><li>本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。</li><li>本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。</li><li>本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。</li><li>SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。</li><li>浏览器再根据 SLB 发回的地址重定向到缓存服务器。</li><li>如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。</li></ol><h3 id="5-将-CSS-放在文件头部，JavaScript-文件放在底部"><a href="#5-将-CSS-放在文件头部，JavaScript-文件放在底部" class="headerlink" title="5. 将 CSS 放在文件头部，JavaScript 文件放在底部"></a>5. 将 CSS 放在文件头部，JavaScript 文件放在底部</h3><p>CSS 执行会阻塞渲染，阻止 JS 执行<br>JS 加载和执行会阻塞 HTML 解析，阻止 CSSOM 构建</p><p>如果这些 CSS、JS 标签放在 HEAD 标签里，并且需要加载和解析很久的话，那么页面就空白了。所以 JS 文件要放在底部（不阻止 DOM 解析，但会阻塞渲染），等 HTML 解析完了再加载 JS 文件，尽早向用户呈现页面的内容。<br>那为什么 CSS 文件还要放在头部呢？<br>因为先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、“丑陋”的，为了避免这种情况发生，就要将 CSS 文件放在头部了。<br>另外，JS 文件也不是不可以放在头部，只要给 script 标签加上 defer 属性就可以了，异步下载，延迟执行。</p><h3 id="6-使用字体图标-iconfont-代替图片图标"><a href="#6-使用字体图标-iconfont-代替图片图标" class="headerlink" title="6. 使用字体图标 iconfont 代替图片图标"></a>6. 使用字体图标 iconfont 代替图片图标</h3><p>字体图标就是将图标制作成一个字体，使用时就跟字体一样，可以设置属性，例如 font-size、color 等等，非常方便。并且字体图标是矢量图，不会失真。还有一个优点是生成的文件特别小。</p><h3 id="9-图片优化"><a href="#9-图片优化" class="headerlink" title="9. 图片优化"></a>9. 图片优化</h3><p>(1). 图片延迟加载<br>在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。对于图片很多的网站来说，一次性加载全部图片，会对用户体验造成很大的影响，所以需要使用图片延迟加载。</p><h4 id="2-响应式图片"><a href="#2-响应式图片" class="headerlink" title="(2). 响应式图片"></a>(2). 响应式图片</h4><p>响应式图片的优点是浏览器能够根据屏幕大小自动加载合适的图片。<br>通过 picture 实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;banner_w1000.jpg&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(min-width: 801px)&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;banner_w800.jpg&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(max-width: 800px)&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;banner_w800.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过 @media 实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">769px</span>) &#123;<br> <span class="hljs-selector-class">.bg</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">bg1080.jpg</span>);<br> &#125;<br>&#125;<br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span>) &#123;<br> <span class="hljs-selector-class">.bg</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">bg768.jpg</span>);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-减少重绘重排"><a href="#11-减少重绘重排" class="headerlink" title="11. 减少重绘重排"></a>11. 减少重绘重排</h3><p>浏览器渲染过程</p><p>解析HTML生成DOM树。<br>解析CSS生成CSSOM规则树。<br>解析JS，操作 DOM 树和 CSSOM 规则树。<br>将DOM树与CSSOM规则树合并在一起生成渲染树。<br>遍历渲染树开始布局，计算每个节点的位置大小信息。<br>浏览器将所有图层的数据发送给GPU，GPU将图层合成并显示在屏幕上。</p><h4 id="如何减少重排重绘？"><a href="#如何减少重排重绘？" class="headerlink" title="如何减少重排重绘？"></a>如何减少重排重绘？</h4><p>用 JavaScript 修改样式时，最好不要直接写样式，而是替换 class 来改变样式。<br>如果要对 DOM 元素执行一系列操作，可以将 DOM 元素脱离文档流，修改完成后，再将它带回文档。推荐使用隐藏元素（display:none）或文档碎片（DocumentFragement），都能很好的实现这个方案。</p><h3 id="21-降低-CSS-选择器的复杂性"><a href="#21-降低-CSS-选择器的复杂性" class="headerlink" title="21. 降低 CSS 选择器的复杂性"></a>21. 降低 CSS 选择器的复杂性</h3><p>(1). 浏览器读取选择器，遵循的原则是从选择器的右边到左边读取。<br>看个示例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"># block <span class="hljs-selector-class">.text</span> <span class="hljs-selector-tag">p</span> &#123;<br><br> <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>查找所有 P 元素。<br>查找结果 1 中的元素是否有类名为 text 的父元素<br>查找结果 2 中的元素是否有 id 为 block 的父元素</p><h4 id="2-CSS-选择器优先级"><a href="#2-CSS-选择器优先级" class="headerlink" title="(2). CSS 选择器优先级"></a>(2). CSS 选择器优先级</h4><p>内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器<br>根据以上两个信息可以得出结论。</p><blockquote><p>选择器越短越好。<br>尽量使用高优先级的选择器，例如 ID 和类选择器。<br>避免使用通配符 *。</p></blockquote><p>最后要说一句，据我查找的资料所得，CSS 选择器没有优化的必要，因为最慢和慢快的选择器性能差别非常小。</p><h3 id="检查加载性能"><a href="#检查加载性能" class="headerlink" title="检查加载性能"></a>检查加载性能</h3><p>一个网站加载性能如何主要看白屏时间和首屏时间。</p><ol><li>白屏时间：指从输入网址，到页面开始显示内容的时间。</li><li>首屏时间：指从输入网址，到页面完全渲染的时间。</li></ol><p>将以下脚本放在 <code>&lt;/head&gt;</code> 前面就能获取白屏时间。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&lt;script&gt;<br>  new Date() - performance<span class="hljs-selector-class">.timing</span>.navigationStart<br>  <span class="hljs-comment">// 通过 domLoading 和 navigationStart 也可以</span><br>  performance<span class="hljs-selector-class">.timing</span><span class="hljs-selector-class">.domLoading</span> - performance<span class="hljs-selector-class">.timing</span>.navigationStart<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>在 window.onload 事件里执行 new Date() - performance.timing.navigationStart 即可获取首屏时间。</p><h3 id="检查运行性能"><a href="#检查运行性能" class="headerlink" title="检查运行性能"></a>检查运行性能</h3><p>配合 chrome 的开发者工具，我们可以查看网站在运行时的性能。<br>打开网站，按 F12 选择 performance，点击左上角的灰色圆点，变成红色就代表开始记录了。这时可以模仿用户使用网站，在使用完毕后，点击 stop，然后你就能看到网站运行期间的性能报告。如果有红色的块，代表有掉帧的情况；如果是绿色，则代表 FPS 很好。performance 的具体使用方法请用搜索引擎搜索一下，毕竟篇幅有限。</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6892994632968306702#heading-47">前端性能优化 24 条建议（2020）</a></p>]]></content>
    
    
    <categories>
      
      <category>项目优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多条产品线共享sso单点登录设计(项目)</title>
    <link href="/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D%E5%A4%9A%E6%9D%A1%E4%BA%A7%E5%93%81%E7%BA%BF%E5%85%B1%E4%BA%ABsso%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D%E5%A4%9A%E6%9D%A1%E4%BA%A7%E5%93%81%E7%BA%BF%E5%85%B1%E4%BA%ABsso%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="多条产品线共享sso单点登录设计"><a href="#多条产品线共享sso单点登录设计" class="headerlink" title="多条产品线共享sso单点登录设计"></a>多条产品线共享sso单点登录设计</h2><h5 id="单独提取登录模块-利用cookie和二级域名可以共卓教据的持点来实现单点登录"><a href="#单独提取登录模块-利用cookie和二级域名可以共卓教据的持点来实现单点登录" class="headerlink" title="单独提取登录模块 利用cookie和二级域名可以共卓教据的持点来实现单点登录"></a>单独提取登录模块 利用cookie和二级域名可以共卓教据的持点来实现单点登录</h5><p>涉及到cookie过大超过请求数据量–只保留必须的用户登录信息-token和userinfo至于项目个性信息保存在本地存储</p><h3 id="什么是单点登录-SSO"><a href="#什么是单点登录-SSO" class="headerlink" title="什么是单点登录(SSO)"></a>什么是单点登录(SSO)</h3><h4 id="一、什么是单点登录？"><a href="#一、什么是单点登录？" class="headerlink" title="一、什么是单点登录？"></a>一、什么是单点登录？</h4><p>单点登录的英文名叫做：Single Sign On（简称SSO）。</p><p>在初学/以前的时候，一般我们就单系统，所有的功能都在同一个系统上。<br><img src="/img/sso.png" alt="sso"><br>所有的功能都在同一个系统上<br>后来，我们为了合理利用资源和降低耦合性，于是把单系统拆分成多个子系统。</p><p>回顾：分布式基础知识<br><img src="/img/sso1.png" alt="sso"></p><p>拆分成多个子系统<br>比如阿里系的<strong>淘宝和天猫</strong>，很明显地我们可以知道这是两个系统，但是你在使用的时候，登录了天猫，淘宝也会自动登录。</p><p>登录了天猫，淘宝也登录了<br>简单来说，单点登录就是在<strong>多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录</strong>。</p><h4 id="一、早期的多系统登录解决方案"><a href="#一、早期的多系统登录解决方案" class="headerlink" title="一、早期的多系统登录解决方案"></a>一、早期的多系统登录解决方案</h4><ul><li>单系统登录解决方案的<strong>核心是cookie</strong>，cookie携带会话id在浏览器与服务器之间维护会话状态。但cookie是有限制的，这个限制就是cookie的域（通常对应网站的域名），浏览器发送http请求时会自动携带与该域匹配的cookie，而不是所有cookie</li><li>既然这样，为什么不将web应用群中所有子系统的域名统一在一个顶级域名下，例如“*.baidu.com”，然后将它们的cookie域设置为“baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享cookie的方式。</li><li>共享cookie的方式存在众多局限。<ol><li>应用群域名得统一</li><li>应用群各系统使用的技术（至少是web服务器）要相同，不然cookie的key值（tomcat为JSESSIONID）不同，无法维持会话，共享cookie的方式是无法实现跨语言技术平台登录的，比如java、php、.net系统之间</li><li>cookie本身不安全。<br>因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录</li></ol></li></ul><h4 id="二、什么是单点登录"><a href="#二、什么是单点登录" class="headerlink" title="二、什么是单点登录"></a>二、什么是单点登录</h4><p>单点登录英文全称Single Sign On，简称SSO。</p><p>指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分</p><h4 id="三、为什么需要单点登录"><a href="#三、为什么需要单点登录" class="headerlink" title="三、为什么需要单点登录"></a>三、为什么需要单点登录</h4><ul><li>web系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？</li><li>web系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问web系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了<h4 id="四、单点登录原理"><a href="#四、单点登录原理" class="headerlink" title="四、单点登录原理"></a>四、单点登录原理</h4>单点登录原理来源参考：(<a href="https://www.cnblogs.com/ywlaker/p/6113927.html">www.cnblogs.com/ywlaker/p/6…</a>)</li></ul>]]></content>
    
    
    <categories>
      
      <category>项目优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现select下拉搜索，无限滚动(项目)</title>
    <link href="/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D%E5%AE%9E%E7%8E%B0select%E4%B8%8B%E6%8B%89%E6%90%9C%E7%B4%A2%EF%BC%8C%E6%97%A0%E9%99%90%E6%BB%9A%E5%8A%A8/"/>
    <url>/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D%E5%AE%9E%E7%8E%B0select%E4%B8%8B%E6%8B%89%E6%90%9C%E7%B4%A2%EF%BC%8C%E6%97%A0%E9%99%90%E6%BB%9A%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="实现select下拉搜索，无限滚动"><a href="#实现select下拉搜索，无限滚动" class="headerlink" title="实现select下拉搜索，无限滚动"></a>实现select下拉搜索，无限滚动</h2><h3 id="xxxxx改造下拉列表-大数据量渲染"><a href="#xxxxx改造下拉列表-大数据量渲染" class="headerlink" title="xxxxx改造下拉列表-大数据量渲染"></a>xxxxx改造下拉列表-大数据量渲染</h3><h4 id="实现select下拉搜索-无限动-虚拟列表一封成指令–性能优化"><a href="#实现select下拉搜索-无限动-虚拟列表一封成指令–性能优化" class="headerlink" title="实现select下拉搜索 无限动-虚拟列表一封成指令–性能优化"></a>实现select下拉搜索 无限动-虚拟列表一封成指令–性能优化</h4><ol><li>取得可见区域的可见列表项数量</li><li>取得可见区域的起始数据索引和结束数据索引</li><li>计算出可见区域对应的数据，让 Vue.js 更新</li><li>把可见区域的 top 设置为起始元素在整个列表中的位置(使用 transform 是为了更好的性能)</li></ol><h3 id="二次封装el-select实现下拉滚动加载"><a href="#二次封装el-select实现下拉滚动加载" class="headerlink" title="二次封装el-select实现下拉滚动加载"></a>二次封装el-select实现下拉滚动加载</h3><p>平时我们做业务需求的时候，可能会遇到非常大量的数据，有时候成百上千条，一般后端都会写一个分页的接口，只要我们请求的时候加上页码参数即可。<br>但是在使用element-ui的el-select下拉菜单组件中，官方没有提供相应的方法进行多页加载。<br>这时候我们可以实现一个<strong>Vue的自定义指令directive</strong>，每当使用el-select滚动到列表底部的时候就请求下一页数据，来达到下拉滚动加载更多的目的。<br>实现自定义指令<br>首先实现一个el-select下拉加载的自定义指令v-loadmore：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// directives.js</span><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br>Vue.directive(<span class="hljs-string">&quot;loadmore&quot;</span>, &#123;<br>    <span class="hljs-function"><span class="hljs-title">bind</span>(<span class="hljs-params">el, binding, vnode</span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> SELECTWRAP = el.querySelector(<br>            <span class="hljs-string">&quot;.el-select-dropdown .el-select-dropdown__wrap&quot;</span><br>        );<br>        SELECTWRAP.addEventListener(<span class="hljs-string">&quot;scroll&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-comment">// scrollTop 这里可能因为浏览器缩放存在小数点的情况，导致了滚动到底部时</span><br>            <span class="hljs-comment">// scrollHeight 减去滚动到底部时的scrollTop ，依然大于clientHeight 导致无法请求更多数据</span><br>            <span class="hljs-comment">// 这里将scrollTop向上取整 保证滚到底部时，触发调用</span><br>            <span class="hljs-keyword">const</span> CONDITION = <span class="hljs-built_in">this</span>.scrollHeight - <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">this</span>.scrollTop) &lt;= <span class="hljs-built_in">this</span>.clientHeight;<br>            <span class="hljs-comment">// el.scrollTop !== 0 当输入时，如果搜索结果很少，以至于没看到滚动条，那么此时的CONDITION计算结果是true，会执行bind.value()，此时不应该执行，否则搜索结果不匹配</span><br>            <span class="hljs-keyword">if</span> (CONDITION &amp;&amp; <span class="hljs-built_in">this</span>.scrollTop !== <span class="hljs-number">0</span>) &#123;<br>                binding.value();<br>            &#125;<br>        &#125;);<br>    &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>代码说明：</p><p>document.querySelector：querySelector() 方法仅仅返回匹配指定选择器的第一个元素。<br>Element.scrollHeight：在不使用滚动条的情况下为了适应视口中所用内容所需的最小高度（只读）。<br>Element.scrollTop：获取或设置一个元素的内容垂直滚动的像素数。<br>Element.clientHeight：读取元素的可见高度（只读）。<br>如果元素滚动到底，下面等式返回true，没有则返回false。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">element</span>.scrollHeight - <span class="hljs-keyword">element</span>.scrollTop === <span class="hljs-keyword">element</span>.clientHeight<br></code></pre></td></tr></table></figure><p>在项目中全局注册v-loadmore指令：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-comment">// main.js</span><br><br><span class="hljs-keyword">import</span> directives <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./directive.js&#x27;</span><br>Vue.use(directives)<br></code></pre></td></tr></table></figure><p>最后在组件el-select中使用该指令：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- vue.js --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;selected&quot;</span> <span class="hljs-attr">v-loadmore</span>=<span class="hljs-string">&quot;loadMore&quot;</span>&gt;</span><br>        &lt;el-option<br>            v-for=&quot;option in options&quot;<br>            :label=&quot;option.label&quot;<br>            :value=&quot;option.value&quot;<br>            :key=&quot;option.value&quot;<br>        &gt;<span class="hljs-tag">&lt;/<span class="hljs-name">el-option</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">            selected: <span class="hljs-string">&quot;&quot;</span>,</span><br>            options: [<br>                &#123;<br><span class="javascript">                    label: <span class="hljs-string">&quot;1&quot;</span>,</span><br>                    value: 1<br>                &#125;,<br><span class="javascript">                <span class="hljs-comment">// ... 此处省略多个选项</span></span><br>                &#123;<br><span class="javascript">                    label: <span class="hljs-string">&quot;到达底部啦&quot;</span>,</span><br>                    value: 9<br>                &#125;<br>            ]<br>        &#125;;<br>    &#125;,<br>    methods: &#123;<br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">loadMore</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;more&quot;</span>)</span><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用效果如下：<br>下拉加载<br>从效果图可以看出，每当菜单列表滚动到底部时，指令就会调用传入的loadMore函数，控制台随即打印出 “more”。</p><p>注意事项：<br>传入的数组个数必须大于或者等于8个选项时才能让<strong>el-select</strong>组件出现下拉滚动。<br>列表里不存在滚动时，无法触发传入指令的函数。</p><h3 id="进行二次封装"><a href="#进行二次封装" class="headerlink" title="进行二次封装"></a>进行二次封装</h3><p>滚动到底部调用函数的指令已经实现了，下面只要调用接口，把获取到下一页的数据拼接到当前的数据中即可。</p><p>接下来把el-select进行二次封装，封装成公用的组件之后，传入必要的参数就可以在项目中调用。</p><p>首先新建一个文件load-select.vue：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- load-select.vue --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-select</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;value&quot;</span> <span class="hljs-attr">v-loadmore</span>=<span class="hljs-string">&quot;loadMore&quot;</span> @<span class="hljs-attr">focus</span>=<span class="hljs-string">&quot;focus&quot;</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span> <span class="hljs-attr">v-on</span>=<span class="hljs-string">&quot;$listeners&quot;</span>&gt;</span><br>        &lt;el-option<br>            v-for=&quot;option in data&quot;<br>            :label=&quot;option[dictLabel]&quot;<br>            :value=&quot;option[dictValue]&quot;<br>            :key=&quot;option.value&quot;<br>        &gt;<span class="hljs-tag">&lt;/<span class="hljs-name">el-option</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>    props: &#123;<br>        value: &#123;<br><span class="javascript">            type: <span class="hljs-built_in">String</span>,</span><br><span class="javascript">            <span class="hljs-keyword">default</span>: <span class="hljs-string">&quot;&quot;</span></span><br>        &#125;,<br><span class="javascript">        <span class="hljs-comment">// 列表数据</span></span><br>        data: &#123;<br><span class="javascript">            type: <span class="hljs-built_in">Array</span>,</span><br><span class="javascript">            <span class="hljs-keyword">default</span>: <span class="hljs-function">() =&gt;</span> []</span><br>        &#125;,<br>        dictLabel: &#123;<br><span class="javascript">            type: <span class="hljs-built_in">String</span>,</span><br><span class="javascript">            <span class="hljs-keyword">default</span>: <span class="hljs-string">&quot;label&quot;</span></span><br>        &#125;,<br>        dictValue: &#123;<br><span class="javascript">            type: <span class="hljs-built_in">String</span>,</span><br><span class="javascript">            <span class="hljs-keyword">default</span>: <span class="hljs-string">&quot;value&quot;</span></span><br>        &#125;,<br><span class="javascript">        <span class="hljs-comment">// 调用页数的接口</span></span><br>        request: &#123;<br><span class="javascript">            type: <span class="hljs-built_in">Function</span>,</span><br><span class="javascript">            <span class="hljs-keyword">default</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;</span><br>        &#125;,<br>        page: &#123;<br><span class="javascript">            type: [<span class="hljs-built_in">Number</span>, <span class="hljs-built_in">String</span>],</span><br><span class="javascript">            <span class="hljs-keyword">default</span>: <span class="hljs-number">1</span></span><br>        &#125;<br>    &#125;,<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> &#123;&#125;;</span><br>    &#125;,<br>    methods: &#123;<br><span class="javascript">        <span class="hljs-comment">// 请求下一页的数据</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">loadMore</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.request(&#123; <span class="hljs-attr">page</span>: <span class="hljs-built_in">this</span>.page + <span class="hljs-number">1</span> &#125;)</span><br>        &#125;,<br><span class="javascript">        <span class="hljs-comment">// 选中下拉框没有数据时，自动请求第一页的数据</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">focus</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.data.length) &#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.request(&#123;<span class="hljs-attr">page</span>: <span class="hljs-number">1</span>&#125;)</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在页面组件中调用load-select.vue：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- page.vue --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxx-page&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;selected&quot;</span> <span class="hljs-attr">:data</span>=<span class="hljs-string">&quot;data&quot;</span> <span class="hljs-attr">:page</span>=<span class="hljs-string">&quot;page&quot;</span> <span class="hljs-attr">:request</span>=<span class="hljs-string">&quot;getData&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">load-select</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-comment">// 导入该组件</span></span><br><span class="javascript"><span class="hljs-keyword">import</span> loadSelect <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/components/load-select/index&quot;</span>;</span><br><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    name: <span class="hljs-string">&quot;app&quot;</span>,</span><br>    components: &#123;<br>        loadSelect<br>    &#125;,<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">            selected: <span class="hljs-string">&quot;&quot;</span>,</span><br>            page: 1,<br><span class="javascript">            more: <span class="hljs-literal">true</span>,</span><br>            data: []<br>        &#125;;<br>    &#125;,<br>    methods: &#123;<br><span class="javascript">        <span class="hljs-comment">// 传入给load-select组件的函数</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">getData</span>(<span class="hljs-params">&#123; page = <span class="hljs-number">1</span> &#125; = &#123;&#125;</span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-comment">// 输出页数</span></span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(page)</span><br><span class="javascript">            <span class="hljs-comment">// 访问后端接口API</span></span><br><span class="javascript">            <span class="hljs-built_in">this</span>.requestAPI(&#123; page &#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.data = [...this.data, ...res.result]</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.page = res.page</span><br>            &#125;);<br>        &#125;,<br><span class="javascript">        <span class="hljs-comment">// 模拟后端接口的API</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">requestAPI</span>(<span class="hljs-params">&#123; page = <span class="hljs-number">1</span>, size = <span class="hljs-number">10</span> &#125; = &#123;&#125;</span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;</span><br><span class="javascript">                <span class="hljs-keyword">let</span> responseData = []</span><br><span class="javascript">                <span class="hljs-comment">// 假设总共的数据有50条</span></span><br><span class="javascript">                <span class="hljs-keyword">let</span> total = <span class="hljs-number">50</span>; </span><br><span class="javascript">                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>; index &lt;= size; index++) &#123;</span><br><span class="javascript">                    <span class="hljs-comment">// serial：处于第几个元素，就显示多少序号</span></span><br><span class="javascript">                    <span class="hljs-keyword">let</span> serial = index + (page - <span class="hljs-number">1</span>) * size</span><br>                    if (serial &lt;= 50) &#123;<br>                        responseData.push(&#123;<br>                            label: serial,<br>                            value: serial<br>                        &#125;);<br>                    &#125;<br>                &#125;<br><span class="javascript">                <span class="hljs-comment">// 模拟异步请求，500ms之后返回接口的数据</span></span><br><span class="javascript">                <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br>                    resolve(&#123;<br>                        total,<br>                        page,<br>                        size,<br>                        result: responseData<br>                    &#125;);<br>                &#125;, 500);<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>代码解析：</p><p>首次点击下拉框时，会触发<strong>focus</strong>事件请求第一页的数据，之后只要每次滚动列表到底部，就会自动请求下一页的数据然后拼接到当前的数组中。</p><p>我们来看看效果：<br>测试下拉组件<br>完美！但是在实际使用的过程中，可能会因为接口还来不及返回数据，然后列表又向下滚动再次触发了请求，结果就是返回了两份相同的数据。</p><p>现在把接口的延迟调到2000ms重现这个场景：</p><p>重复数据</p><p>在两次快速滚动到底部的时候，请求的参数页数都是2，如何解决这个问题？<strong>可以在加载函数中加入一个拦截操作，在接口没有响应之前，不调用加载函数</strong>，不过这样做要把getData转换成异步函数的形式。</p><p>首先在load-select.vue中的loadMore()中加入一个拦截操作：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- load-select.vue --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">// 请求下一页的数据</span></span><br>    methods: &#123;<br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">loadMore</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-comment">// 如果 intercept 属性为 true 则不请求数据</span></span><br><span class="javascript">            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.loadMore.intercept) &#123;</span><br><span class="javascript">                <span class="hljs-keyword">return</span> </span><br>            &#125;<br><span class="javascript">            <span class="hljs-built_in">this</span>.loadMore.intercept = <span class="hljs-literal">true</span></span><br><span class="javascript">            <span class="hljs-built_in">this</span>.request(&#123; <span class="hljs-attr">page</span>: <span class="hljs-built_in">this</span>.page + <span class="hljs-number">1</span> &#125;).then(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">                <span class="hljs-comment">// 接口响应之后才把 intercept 设置为 false</span></span><br><span class="javascript">                <span class="hljs-built_in">this</span>.loadMore.intercept = <span class="hljs-literal">false</span></span><br>            &#125;)<br>        &#125;<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在page.vue中的getData()函数转换成异步函数的形式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- page.vue --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    methods: &#123;<br><span class="javascript">        <span class="hljs-comment">// 传入给load-select组件的函数</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">getData</span>(<span class="hljs-params">&#123; page = <span class="hljs-number">1</span> &#125; = &#123;&#125;</span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-comment">// 返回 Promise 对象</span></span><br><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>( <span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;</span><br><span class="javascript">                <span class="hljs-comment">// 访问后端接口API</span></span><br><span class="javascript">                <span class="hljs-built_in">this</span>.requestAPI(&#123; page &#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.data = [...this.data, ...res.result]</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.page = res.page</span><br>                    resolve()<br>                &#125;);<br>            &#125;)<br>        &#125;, <br>    <br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在问题来了：</p><p>一般分页的接口都支持关键字的搜索，load-select.vue组件能不能加入关键字搜索的功能呢？</p><h4 id="关键字搜索功能"><a href="#关键字搜索功能" class="headerlink" title="关键字搜索功能"></a>关键字搜索功能</h4><p>还好el-select组件支持远程搜索功能，只要传入<strong>filterable和remote</strong>参数，具体的可以查看element-ui的官方文档。</p><p>接下来对load-select.vue进行以下修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- load-select.vue --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    &lt;el-select<br>        :value=&quot;value&quot;<br>        v-loadmore=&quot;loadMore&quot;<br>        @focus=&quot;focus&quot;<br>        filterable<br>        remote<br>        :filter-method=&quot;handleSearch&quot;<br>        :loading=&quot;loading&quot;<br>        clearable<br>        v-bind=&quot;$attrs&quot;<br>        v-on=&quot;$listeners&quot;<br>    &gt;<br>        &lt;el-option<br>            v-for=&quot;option in data&quot;<br>            :label=&quot;option[dictLabel]&quot;<br>            :value=&quot;option[dictValue]&quot;<br>            :key=&quot;option.value&quot;<br>        &gt;<span class="hljs-tag">&lt;/<span class="hljs-name">el-option</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 此处加载中的value可以随便设置，只要不与其他数据重复即可 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">el-option</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;hasMore&quot;</span> <span class="hljs-attr">disabled</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;加载中...&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;-1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-option</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>    props: &#123;<br>        value: &#123;<br><span class="javascript">            <span class="hljs-keyword">default</span>: <span class="hljs-string">&quot;&quot;</span></span><br>        &#125;,<br><span class="javascript">        <span class="hljs-comment">// 列表数据</span></span><br>        data: &#123;<br><span class="javascript">            type: <span class="hljs-built_in">Array</span>,</span><br><span class="javascript">            <span class="hljs-keyword">default</span>: <span class="hljs-function">() =&gt;</span> []</span><br>        &#125;,<br>        dictLabel: &#123;<br><span class="javascript">            type: <span class="hljs-built_in">String</span>,</span><br><span class="javascript">            <span class="hljs-keyword">default</span>: <span class="hljs-string">&quot;label&quot;</span></span><br>        &#125;,<br>        dictValue: &#123;<br><span class="javascript">            type: <span class="hljs-built_in">String</span>,</span><br><span class="javascript">            <span class="hljs-keyword">default</span>: <span class="hljs-string">&quot;value&quot;</span></span><br>        &#125;,<br><span class="javascript">        <span class="hljs-comment">// 调用页数的接口</span></span><br>        request: &#123;<br><span class="javascript">            type: <span class="hljs-built_in">Function</span>,</span><br><span class="javascript">            <span class="hljs-keyword">default</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125;</span><br>        &#125;,<br><span class="javascript">        <span class="hljs-comment">// 传入的页码</span></span><br>        page: &#123;<br><span class="javascript">            type: [<span class="hljs-built_in">Number</span>, <span class="hljs-built_in">String</span>],</span><br><span class="javascript">            <span class="hljs-keyword">default</span>: <span class="hljs-number">1</span></span><br>        &#125;,<br><span class="javascript">        <span class="hljs-comment">// 是否还有更多数据</span></span><br>        hasMore: &#123;<br><span class="javascript">            type: <span class="hljs-built_in">Boolean</span>,</span><br><span class="javascript">            <span class="hljs-keyword">default</span>: <span class="hljs-literal">true</span></span><br>        &#125;<br>    &#125;,<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">            <span class="hljs-comment">// 存储关键字用</span></span><br><span class="javascript">            keyword: <span class="hljs-string">&quot;&quot;</span>, </span><br><span class="javascript">            loading: <span class="hljs-literal">false</span></span><br>        &#125;;<br>    &#125;,<br>    methods: &#123;<br><span class="javascript">        <span class="hljs-comment">// 请求下一页的数据</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">loadMore</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-comment">// 如果没有更多数据，则不请求</span></span><br><span class="javascript">            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.hasMore) &#123;</span><br><span class="javascript">                <span class="hljs-keyword">return</span></span><br>            &#125;<br><span class="javascript">            <span class="hljs-comment">// 如果intercept属性为true则不请求数据，</span></span><br><span class="javascript">            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.loadMore.intercept) &#123;</span><br><span class="javascript">                <span class="hljs-keyword">return</span></span><br>            &#125;<br><span class="javascript">            <span class="hljs-built_in">this</span>.loadMore.intercept = <span class="hljs-literal">true</span>;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.request(&#123;</span><br><span class="javascript">                page: <span class="hljs-built_in">this</span>.page + <span class="hljs-number">1</span>,</span><br><span class="javascript">                more: <span class="hljs-literal">true</span>,</span><br><span class="javascript">                keyword: <span class="hljs-built_in">this</span>.keyword</span><br><span class="javascript">            &#125;).then(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.loadMore.intercept = <span class="hljs-literal">false</span></span><br>            &#125;);<br>        &#125;,<br><span class="javascript">        <span class="hljs-comment">// 选中下拉框没有数据时，自动请求第一页的数据</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">focus</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.data.length) &#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.request(&#123; <span class="hljs-attr">page</span>: <span class="hljs-number">1</span> &#125;)</span><br>            &#125;<br>        &#125;,<br><span class="javascript">        <span class="hljs-comment">// 关键字搜索</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">handleSearch</span>(<span class="hljs-params">keyword</span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.keyword = keyword</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">true</span></span><br><span class="javascript">            <span class="hljs-built_in">this</span>.request(&#123; <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>, keyword &#125;).then(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">false</span></span><br>            &#125;);<br>        &#125;,<br><span class="javascript">        <span class="hljs-comment">// 删除选中时，如果请求了关键字，则清除关键字再请求第一页的数据</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">clear</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.keyword) &#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.keyword = <span class="hljs-string">&quot;&quot;</span></span><br><span class="javascript">                <span class="hljs-built_in">this</span>.request(&#123; <span class="hljs-attr">page</span>: <span class="hljs-number">1</span> &#125;)</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>页面调用时，getData()请求函数需要接收keyword和more参数并进行相应的处理：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- page.vue --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;xxx-page&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;selected&quot;</span> <span class="hljs-attr">:data</span>=<span class="hljs-string">&quot;data&quot;</span> <span class="hljs-attr">:page</span>=<span class="hljs-string">&quot;page&quot;</span> <span class="hljs-attr">:hasMore</span>=<span class="hljs-string">&quot;more&quot;</span> <span class="hljs-attr">:request</span>=<span class="hljs-string">&quot;getData&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">load-select</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-comment">// 导入该组件</span></span><br><span class="javascript"><span class="hljs-keyword">import</span> loadSelect <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/components/load-select/index&quot;</span>;</span><br><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    name: <span class="hljs-string">&quot;app&quot;</span>,</span><br>    components: &#123;<br>        loadSelect<br>    &#125;,<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">            selected: <span class="hljs-string">&quot;&quot;</span>,</span><br>            page: 1,<br><span class="javascript">            more: <span class="hljs-literal">true</span>,</span><br>            data: []<br>        &#125;;<br>    &#125;,<br>    methods: &#123;<br><span class="javascript">        <span class="hljs-comment">// 传入给load-select组件的函数</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">getData</span>(<span class="hljs-params">&#123; page = <span class="hljs-number">1</span>, more = <span class="hljs-literal">false</span>, keyword = <span class="hljs-string">&quot;&quot;</span> &#125; = &#123;&#125;</span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;</span><br><span class="javascript">                <span class="hljs-comment">// 访问后端接口API</span></span><br><span class="javascript">                <span class="hljs-built_in">this</span>.requestAPI(&#123; page, keyword &#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="javascript">                    <span class="hljs-comment">// 如果是加载更多，则合并之前的数据</span></span><br>                    if (more) &#123;<br><span class="javascript">                        <span class="hljs-built_in">this</span>.data = [...this.data, ...res.result]</span><br><span class="javascript">                    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">                        <span class="hljs-built_in">this</span>.data = res.result</span><br>                    &#125;<br><br><span class="javascript">                    <span class="hljs-built_in">this</span>.page = res.page;</span><br><span class="javascript">                    <span class="hljs-keyword">let</span> &#123; total, page, size &#125; = res</span><br><span class="javascript">                    <span class="hljs-comment">// 如果为最后一页，则设置more为false</span></span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.more = page * size &lt; total</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.page = page</span><br>                    resolve()<br>                &#125;);<br>            &#125;);<br>        &#125;,<br><span class="javascript">        <span class="hljs-comment">// 模拟后端接口的API</span></span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">requestAPI</span>(<span class="hljs-params">&#123; page = <span class="hljs-number">1</span>, size = <span class="hljs-number">10</span>, keyword = <span class="hljs-string">&quot;&quot;</span> &#125; = &#123;&#125;</span>)</span> &#123;</span><br><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;</span><br><span class="javascript">                <span class="hljs-comment">// 如果有 keyword 参数，则返回带有 keyword 的数据</span></span><br>                if (keyword) &#123;<br><span class="javascript">                    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br>                        resolve(&#123;<br>                            total: 3,<br>                            page: 1,<br>                            size: 10,<br>                            result: [<br>                                &#123;<br>                                    label: keyword,<br>                                    value: 1<br>                                &#125;,<br>                                &#123;<br>                                    label: keyword + 1,<br>                                    value: 2<br>                                &#125;,<br>                                &#123;<br>                                    label: keyword + 2,<br>                                    value: 3<br>                                &#125;<br>                            ]<br>                        &#125;)<br>                    &#125;, 500)<br><span class="javascript">                    <span class="hljs-keyword">return</span></span><br>                &#125;<br><br><span class="javascript">                <span class="hljs-keyword">let</span> responseData = [];</span><br><span class="javascript">                <span class="hljs-comment">// 假设总共的数据有50条</span></span><br><span class="javascript">                <span class="hljs-keyword">let</span> total = <span class="hljs-number">50</span>; </span><br><span class="javascript">                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">1</span>; index &lt;= size; index++) &#123;</span><br><span class="javascript">                    <span class="hljs-comment">// serial：处于第几个元素，就显示多少序号</span></span><br><span class="javascript">                    <span class="hljs-keyword">let</span> serial = index + (page - <span class="hljs-number">1</span>) * size</span><br>                    if (serial &lt;= 50) &#123;<br>                        responseData.push(&#123;<br>                            label: serial,<br>                            value: serial<br>                        &#125;);<br>                    &#125;<br>                &#125;<br><span class="javascript">                <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br>                    resolve(&#123;<br>                        total,<br>                        page,<br>                        size,<br>                        result: responseData<br>                    &#125;)<br>                &#125;, 500)<br>            &#125;)<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接下来看看搜索关键字的效果：关键字搜索 搜索功能也完成啦！</p><p>总结<br>为了适用于大部分的请求接口，因此在设计这个组件的时候只能把请求与组件剥离开来，易用程度不算太高，不过我们可以适当地传入一些简单必要的参数去维持基本地使用。<br>当然，在项目中遇到某些固定的加载请求时，我们也可以对该组件进行再次封装，具体可以根据自身的业务需求进行修改。</p><h3 id="vue对el-autocomplete二次封装增加下拉分页-参考文章"><a href="#vue对el-autocomplete二次封装增加下拉分页-参考文章" class="headerlink" title="vue对el-autocomplete二次封装增加下拉分页 (参考文章)"></a>vue对el-autocomplete二次封装增加下拉分页 (参考文章)</h3><p>项目中的联想输入框现在都是采用的el-autocomplete实现的，但是随着数据量越来越多，产品要求一次不要返回所有的联想数据，要做分页处理，所以需要添加一个分页的功能。</p><p>注：看懂下面的代码需要先对vue和element有一定的学习。</p><p>废话不多数，先上完整代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  &lt;el-autocomplete<br>    ref=&quot;autocomplete&quot;<br>    value-key=&quot;value&quot;<br>    v-scrollLoad=&quot;selectLoadMore&quot;<br>    v-loading=&quot;loading&quot;<br>    v-model=&quot;state&quot;<br>    :fetch-suggestions=&quot;querySearch&quot;<br>    :placeholder=&quot;placeholder&quot;<br>    :trigger-on-focus=&quot;false&quot;<br>    @select=&quot;handleSelect&quot;<br>  &gt;<span class="hljs-tag">&lt;/<span class="hljs-name">el-autocomplete</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&#x27;InputLoadMore&#x27;</span>,</span><br>  props: &#123;<br><span class="javascript">    <span class="hljs-comment">// 封装的查数据方法</span></span><br>    getOptionFn: &#123;<br><span class="javascript">      <span class="hljs-built_in">require</span>: <span class="hljs-literal">true</span></span><br>    &#125;,<br><span class="javascript">    <span class="hljs-comment">// 后端定义的联想的key</span></span><br>    searchKey: &#123;<br><span class="javascript">      type: <span class="hljs-built_in">String</span>,</span><br><span class="javascript">      <span class="hljs-built_in">require</span>: <span class="hljs-literal">true</span></span><br>    &#125;,<br><span class="javascript">    <span class="hljs-comment">// v-model的绑定值</span></span><br>    value: &#123;<br><span class="javascript">      type: <span class="hljs-built_in">String</span>,</span><br><span class="javascript">      <span class="hljs-built_in">require</span>: <span class="hljs-literal">true</span></span><br>    &#125;,<br><span class="javascript">    <span class="hljs-comment">// placehoder</span></span><br>    placeholder: &#123;<br><span class="javascript">      type: <span class="hljs-built_in">String</span>,</span><br><span class="javascript">      <span class="hljs-keyword">default</span>: <span class="hljs-string">&#x27;请输入&#x27;</span></span><br>    &#125;<br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      state: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="javascript">      loading: <span class="hljs-literal">false</span>,</span><br>      page: 1,<br>      pageTotal: 0<br>    &#125;<br>  &#125;,<br>  watch: &#123;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">state</span>(<span class="hljs-params">val</span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;input&#x27;</span>, val)</span><br>    &#125;,<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">value</span>(<span class="hljs-params">val</span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.state = val</span><br>    &#125;<br>  &#125;,<br>  directives: &#123;<br><span class="javascript">    <span class="hljs-comment">// 自定义指令，监听下拉框的滚动，滚动到底部就加载下一页</span></span><br>    scrollLoad: &#123;<br><span class="javascript">      <span class="hljs-function"><span class="hljs-title">bind</span>(<span class="hljs-params">el, binding, vnode</span>)</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> wrapDom = el.querySelector(<span class="hljs-string">&#x27;.el-autocomplete-suggestion__wrap&#x27;</span>)</span><br><span class="javascript">        <span class="hljs-keyword">let</span> listDom = el.querySelector(<span class="hljs-string">&#x27;.el-autocomplete-suggestion__wrap  .el-autocomplete-suggestion__list&#x27;</span>)</span><br>        wrapDom.addEventListener(<br><span class="javascript">          <span class="hljs-string">&#x27;scroll&#x27;</span>,</span><br>          e =&gt; &#123;<br><span class="javascript">            <span class="hljs-comment">// 注意load的使用，节流</span></span><br><span class="javascript">            <span class="hljs-keyword">let</span> condition = wrapDom.offsetHeight + wrapDom.scrollTop + <span class="hljs-number">10</span> - listDom.offsetHeight</span><br>            if (condition &gt; 0 &amp;&amp; !vnode.context.loading) &#123;<br><span class="javascript">              <span class="hljs-comment">//滚动到底部则执行滚动方法load，binding.value就是v-scrollLoad绑定的值，加()表示执行绑定的方法</span></span><br>              binding.value()<br>            &#125;<br>          &#125;,<br><span class="javascript">          <span class="hljs-literal">false</span></span><br>        )<br>      &#125;<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br><span class="javascript">    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">querySearch</span>(<span class="hljs-params">queryString, cb</span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.page = <span class="hljs-number">1</span></span><br><span class="javascript">      <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">true</span></span><br><span class="javascript">      <span class="hljs-keyword">try</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> &#123; result &#125; = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getOptionFn(&#123;</span><br>          page: 1,<br>          pageSize: 50,<br><span class="javascript">          [<span class="hljs-built_in">this</span>.searchKey]: queryString</span><br>        &#125;)<br><span class="javascript">        <span class="hljs-comment">// 根据实际情况修改下面的代码，展示数据</span></span><br>        if (result.rows) &#123;<br><span class="javascript">          <span class="hljs-keyword">let</span> arr = []</span><br><span class="javascript">          result.rows.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;</span><br>            arr.push(&#123; value: item &#125;)<br>          &#125;)<br>          cb(arr)<br><span class="javascript">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br>          cb([])<br>        &#125;<br><span class="javascript">        <span class="hljs-built_in">this</span>.pageTotal = result.total || <span class="hljs-number">0</span></span><br><span class="javascript">      &#125; <span class="hljs-keyword">catch</span>(e) &#123;</span><br><span class="javascript">        <span class="hljs-comment">// console.log(e)</span></span><br><span class="javascript">      &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">false</span></span><br>      &#125;<br>    &#125;,<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">handleSelect</span>(<span class="hljs-params">item</span>)</span> &#123;&#125;,</span><br><span class="javascript">    <span class="hljs-comment">// 加载更多</span></span><br><span class="javascript">    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">selectLoadMore</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-built_in">this</span>.pageTotal) &lt;= <span class="hljs-built_in">this</span>.$refs[<span class="hljs-string">&#x27;autocomplete&#x27;</span>].$data.suggestions.length) &#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span></span><br>      &#125;<br><span class="javascript">      <span class="hljs-built_in">this</span>.page = <span class="hljs-built_in">this</span>.page + <span class="hljs-number">1</span></span><br><span class="javascript">      <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">true</span></span><br><span class="javascript">      <span class="hljs-keyword">try</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> &#123; result &#125; = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getOptionFn(&#123;</span><br><span class="javascript">          page: <span class="hljs-built_in">this</span>.page,</span><br>          pageSize: 50,<br><span class="javascript">          [<span class="hljs-built_in">this</span>.searchKey]: <span class="hljs-built_in">this</span>.state</span><br>        &#125;)<br><span class="javascript">        <span class="hljs-comment">// 根据实际情况修改下面的代码，展示数据</span></span><br>        if (result.rows) &#123;<br><span class="javascript">          <span class="hljs-keyword">const</span> arr = result.rows.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;</span><br><span class="javascript">            <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: item &#125;</span><br>          &#125;)<br><span class="javascript">          <span class="hljs-comment">// 将数据添加到下拉列表</span></span><br><span class="javascript">          <span class="hljs-built_in">this</span>.$refs[<span class="hljs-string">&#x27;autocomplete&#x27;</span>].$data.suggestions = <span class="hljs-built_in">this</span>.$refs[<span class="hljs-string">&#x27;autocomplete&#x27;</span>].$data.suggestions.concat(arr)</span><br>        &#125;<br><span class="javascript">        <span class="hljs-built_in">this</span>.pageTotal = result.total || <span class="hljs-number">0</span></span><br><span class="javascript">      &#125; <span class="hljs-keyword">catch</span>(e) &#123;</span><br><span class="javascript">        <span class="hljs-comment">// console.log(e)</span></span><br><span class="javascript">      &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.loading = <span class="hljs-literal">false</span></span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="下面对主要的地方进行讲解。"><a href="#下面对主要的地方进行讲解。" class="headerlink" title="下面对主要的地方进行讲解。"></a>下面对主要的地方进行讲解。</h4><h5 id="1-自定义指令实现下拉加载更多。"><a href="#1-自定义指令实现下拉加载更多。" class="headerlink" title="1.自定义指令实现下拉加载更多。"></a>1.自定义指令实现下拉加载更多。</h5><p>主要代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 自定义指令，监听下拉框的滚动，滚动到底部就加载下一页</span><br>    scrollLoad: &#123;<br>      bind(el, binding, vnode) &#123;<br>        let wrapDom = el<span class="hljs-selector-class">.querySelector</span>(<span class="hljs-string">&#x27;.el-autocomplete-suggestion__wrap&#x27;</span>)<br>        let listDom = el<span class="hljs-selector-class">.querySelector</span>(<span class="hljs-string">&#x27;.el-autocomplete-suggestion__wrap  .el-autocomplete-suggestion__list&#x27;</span>)<br>        wrapDom<span class="hljs-selector-class">.addEventListener</span>(<br>          <span class="hljs-string">&#x27;scroll&#x27;</span>,<br>          e =&gt; &#123;<br>            <span class="hljs-comment">// 注意load的使用，节流</span><br>            let condition = wrapDom<span class="hljs-selector-class">.offsetHeight</span> + wrapDom<span class="hljs-selector-class">.scrollTop</span> + <span class="hljs-number">10</span> - listDom.offsetHeight<br>            <span class="hljs-keyword">if</span> (condition &gt; <span class="hljs-number">0</span> &amp;&amp; !vnode<span class="hljs-selector-class">.context</span>.loading) &#123;<br>              <span class="hljs-comment">//滚动到底部则执行滚动方法load，binding.value就是v-scrollLoad绑定的值，加()表示执行绑定的方法</span><br>              binding<span class="hljs-selector-class">.value</span>()<br>            &#125;<br>          &#125;,<br>          false<br>        )<br>      &#125;<br></code></pre></td></tr></table></figure><p>上面主要是运用了vue的自定义指令的bind钩子。不太了解的可以先看这个<a href="https://cn.vuejs.org/v2/guide/custom-directive.html">官方文档</a> 。bind有四个参数（el、binding、vnode、oldVnode）这里用前三个，el代表绑定的元素，用来操作dom，这里用来添加scroll事件，以及计算下拉框是否滑动到底部（注意计算中的+10高度）；binding是一个对象，包含旧值、新值、指令名等，这里主要用绑定值value，用来执行加载更多的方法；Vnode指的是虚拟节点，这里取他的context即为this控制loading来节流。</p><h5 id="2-增加props（getOptionFn、searchKey、value、placeholder）抽离业务。成为公共组件"><a href="#2-增加props（getOptionFn、searchKey、value、placeholder）抽离业务。成为公共组件" class="headerlink" title="2.增加props（getOptionFn、searchKey、value、placeholder）抽离业务。成为公共组件"></a>2.增加props（getOptionFn、searchKey、value、placeholder）抽离业务。成为公共组件</h5><ol><li>getOptionFn为接口封装的方法。fetch-suggestions和加载更多里面都要用到</li><li>searchKey表示接口需要传的参数的key，不同的接口的key可能不一致。</li><li>value是外面v-modle的绑定值，注意在watch里面设置值，不知道的可以看看v-model的实现原理。</li><li>placeholder不解释</li></ol><h5 id="3-可能需要解释的"><a href="#3-可能需要解释的" class="headerlink" title="3.可能需要解释的"></a>3.可能需要解释的</h5><p>在加载到更多数据后怎么把输入加到下拉里面？</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">this.<span class="hljs-variable">$refs</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;autocomplete&#x27;</span>]</span>.<span class="hljs-variable">$data</span><span class="hljs-selector-class">.suggestions</span> <span class="hljs-comment">// 下拉的列表</span><br></code></pre></td></tr></table></figure><p>怎么避免加载完了还加载更多。<br>这里是用的数量比较，也可以加一个标识符，加载完了设置为true，变化条件后设为false。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span>(Number(<span class="hljs-keyword">this</span>.pageTotal) &lt;= <span class="hljs-keyword">this</span>.$refs[<span class="hljs-string">&#x27;autocomplete&#x27;</span>].$<span class="hljs-keyword">data</span>.suggestions.length) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.jb51.net/article/240061.htm">vue对el-autocomplete二次封装增加下拉分页</a><br><a href="http://www.seozhijia.net/vue/196.html">el-autocomplete实现滚动分页加载的方法</a><br><a href="https://blog.csdn.net/weixin_46074961/article/details/127449047">ElementUI el-dropdown 如何实现下拉框出现“触发元素”样式修改</a></p><h3 id="使用-transform-是为了更好的性能-重绘回流"><a href="#使用-transform-是为了更好的性能-重绘回流" class="headerlink" title="使用 transform 是为了更好的性能(重绘回流)"></a>使用 transform 是为了更好的性能(重绘回流)</h3><p><img src="/img/transform.png" alt="transform"><br>通过以下performance调试可以看出时间也有差异，使用transform会比top少一个layout延时（因为使用top引起了回流）。<br><img src="/img/transform2.png" alt="transform"></p><p><a href="https://blog.csdn.net/weixin_43996061/article/details/122977367">为什么使用transform偏移比使用定位top性能更好？重绘、回流是什么？</a></p><h4 id="居中为什么用transform，而不是margin-top-left"><a href="#居中为什么用transform，而不是margin-top-left" class="headerlink" title="居中为什么用transform，而不是margin top/left"></a>居中为什么用transform，而不是margin top/left</h4><p>首先。我们了解下transform是干嘛的。</p><p>在MDN中的官方解释：CSS <code>transform</code>属性允许你旋转，缩放，倾斜或平移给定元素。这是通过修改CSS视觉格式化模型的坐标空间来实现的。简言之，transform可以操作一些动画、位移效果。</p><p>margin top/left，我们应该很熟悉，用得比较多。</p><p>那为什么说，居中显示，CSS3标准的transform更胜一筹呢？我们主要还是<strong>从浏览器渲染的性能方面</strong>考虑。</p><ol><li>浏览器渲染过程</li></ol><p>我们知道，浏览器中有JS引擎和渲染引擎，对于HTML页面的渲染就靠渲染引擎来完成。下面是chrome浏览器页面渲染的整体过程图：<br><a href="https://juejin.cn/post/6844903753783443463">居中为什么用transform，而不是margin top/left</a></p><p>从上面的流程图中不难看出，Chrome渲染主要包括Parse Html、Recalculate Style、Layout、Paint、Image Decode、Image Resize和Composite Layers等。相对应的中文表述就是：<strong>html解析、查找并计算样式、排布、绘制、图片解码、图片大小设置、合并图层并输出页面到屏幕。浏览器最终渲染出来的页面，跟Photoshop有点类似，是由多个图层合并而来。</strong></p><ol start="2"><li>transform的原理：</li></ol><p>transform是通过创建一个RenderLayers合成层，拥有独立的GraphicsLayers。每一个GraphicsLayers都有一个Graphics Context，其对应的RenderLayers会paint进Graphics Context中。合成器（Compositor）最终会负责将由Graphics Context输出的位图合并成最终屏幕展示的图案。<br>满足如下条件的RenderLayers，会被认为是一个独立的合成层：</p><ul><li>有3D或者perspective transform的CSS属性的层</li><li>video元素的层</li><li>canvas元素的层</li><li>flash</li><li>对opacity和transform应用了CSS动画的层</li><li>使用了CSS滤镜（filters）的层</li><li>有合成层后代的层</li><li>同合成层重叠，且在该合成层上面（z-index）渲染的层<br>如果RenderLayer是一个合成层，那么它有属于它自己的单独的GraphicsLayer，否则它和它的最近的拥有GraphicsLayer的父layer共用一个GraphicsLayer。</li></ul><p>由此可见，transform发生在Composite Layer这一步，它所引起的paint也只是发生在单独的GraphicsLayer中，并不会引起整个页面的回流重绘。</p><ol start="3"><li>GPU</li></ol><p>我们经常会听到GPU会加速渲染，那GPU在这里又扮演什么角色呢？</p><p>前面说到，合成器会负责将层合成绘制为最终的屏幕画面。在硬件加速体系结构，合成由GPU负责。在chrome浏览器多进程模型中，<strong>有一个专门的进程来负责传递Render进程的命令，即GPU进程</strong>。Render进程和GPU进程是通过共享内存传递的。</p><p><strong>Render进程可以快速 的将命令发给命令缓冲区，并且返回到CPU密集的render活动中，留给GPU进程去处理这些命令</strong>。我们可以充分利用多内核机器上的GPU进程和CPU进程。这也是为什么GPU会加速渲染，使transform渲染速度更快的又一原因。</p><ol start="4"><li>margin top/left</li></ol><p>marign：外边距，定义元素周围的空间；简言之，可以改变元素的位移。在浏览器页面渲染的时候，margin可以控制元素的位置，也就是说，改变margin，<strong>就会改变render tree的结构，必定会引起页面layout回流和repaint重绘</strong>。</p><p>因此，从浏览器性能考虑，transform会比margin更省时间。</p><p><strong>但是，transform真的处处适用吗？</strong></p><ol start="5"><li>transform的局限性</li></ol><p>上面提到，transform实际上也是用到了GPU加速，也就是说占用了内存。由此可见创建GraphicsLayer，虽然节省了layout，paint阶段，但Layer创建的越多，占用内存就会越大，而过多的渲染开销会超过性能的改善。</p><p>因此，<strong>当且仅当需要的时候，才会为元素创建渲染层。</strong><br><a href="https://juejin.cn/post/6844903753783443463">居中为什么用transform，而不是margin top/left</a></p>]]></content>
    
    
    <categories>
      
      <category>项目优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大文件上传以及断点续传(项目)</title>
    <link href="/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%BB%A5%E5%8F%8A%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/"/>
    <url>/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%BB%A5%E5%8F%8A%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="字节跳动面试官：请你实现一个大文件上传和断点续传"><a href="#字节跳动面试官：请你实现一个大文件上传和断点续传" class="headerlink" title="字节跳动面试官：请你实现一个大文件上传和断点续传"></a>字节跳动面试官：请你实现一个大文件上传和断点续传</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">前端：<span class="hljs-symbol">Vue@</span><span class="hljs-number">2</span> + Element-ui<br><br>服务端：<span class="hljs-symbol">Nodejs@</span><span class="hljs-number">14</span> + multiparty<br></code></pre></td></tr></table></figure><h3 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h3><h4 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h4><h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>前端大文件上传网上的大部分文章已经给出了解决方案，核心是利用 <strong>Blob.prototype.slice</strong> 方法，和数组的 <code>slice</code> 方法相似，文件的 <code>slice</code> 方法可以返回原文件的某个切</p><p>预先定义好单个切片大小，将文件切分为一个个切片，然后<strong>借助 http 的可并发性，同时上传多个切片</strong>。这样从原本传一个大文件，变成了并发传多个小的文件切片，可以大大减少上传时间</p><p>另外由于是<strong>并发</strong>，传输到服务端的顺序可能会发生变化，<strong>因此我们还需要给每个切片记录顺序</strong></p><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><p>服务端负责接受前端传输的切片，并在接收到所有切片后<strong>合并</strong>所有切片</p><p>这里又引伸出两个问题</p><p>何时合并切片，即切片什么时候传输完成<br>如何合并切片<br>第一个问题需要前端配合，前端在每个切片中都携带切片最大数量的信息，当服务端接受到这个数量的切片时自动合并。或者也可以额外发一个请求，主动通知服务端进行切片的合并</p><p>第二个问题，具体如何合并切片呢？这里可以使用 Nodejs 的 读写流（readStream/writeStream），将所有切片的流传输到最终文件的流里talk is cheap,show me the code，接着我们用代码实现上面的思路</p><h3 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h3><p>前端使用 Vue 作为开发框架，对界面没有太大要求，原生也可以，考虑到美观使用 Element-ui 作为 UI 框架</p><h4 id="上传控件"><a href="#上传控件" class="headerlink" title="上传控件"></a>上传控件</h4><p>首先创建选择文件的控件并监听 change 事件，另外就是上传按钮</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;handleFileChange&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleUpload&quot;</span>&gt;</span>upload<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>​<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  data: <span class="hljs-function">() =&gt;</span> (&#123;</span><br>    container: &#123;<br><span class="javascript">      file: <span class="hljs-literal">null</span></span><br>    &#125;<br>  &#125;),<br>  methods: &#123;<br><span class="javascript">     <span class="hljs-function"><span class="hljs-title">handleFileChange</span>(<span class="hljs-params">e</span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-keyword">const</span> [file] = e.target.files;</span><br><span class="javascript">      <span class="hljs-keyword">if</span> (!file) <span class="hljs-keyword">return</span>;</span><br><span class="javascript">      <span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">this</span>.$data, <span class="hljs-built_in">this</span>.$options.data());</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.container.file = file;</span><br>    &#125;,<br><span class="javascript">    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">handleUpload</span>(<span class="hljs-params"></span>)</span> &#123;&#125;</span><br>  &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="请求逻辑"><a href="#请求逻辑" class="headerlink" title="请求逻辑"></a>请求逻辑</h4><p>考虑到通用性，这里没有用第三方的请求库，而是用原生 XMLHttpRequest 做一层简单的封装来发请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">request(&#123;<br>      url,<br>      method = <span class="hljs-string">&quot;post&quot;</span>,<br>      data,<br>      headers = &#123;&#125;,<br>      requestList<br>    &#125;) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>        xhr.open(method, url);<br>        <span class="hljs-built_in">Object</span>.keys(headers).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span><br>          xhr.setRequestHeader(key, headers[key])<br>        );<br>        xhr.send(data);<br>        xhr.onload = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>          resolve(&#123;<br>            data: e.target.response<br>          &#125;);<br>        &#125;;<br>      &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="上传切片"><a href="#上传切片" class="headerlink" title="上传切片"></a>上传切片</h3><p>接着实现比较重要的上传功能，上传需要做两件事</p><ol><li>对文件进行切片</li><li>将切片传输给服务端<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;handleFileChange&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleUpload&quot;</span>&gt;</span>上传<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>​<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">+ <span class="hljs-comment">// 切片大小</span></span><br><span class="javascript">+ <span class="hljs-comment">// the chunk size</span></span><br><span class="javascript">+ <span class="hljs-keyword">const</span> SIZE = <span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>; </span><br>​<br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  data: <span class="hljs-function">() =&gt;</span> (&#123;</span><br>    container: &#123;<br><span class="javascript">      file: <span class="hljs-literal">null</span></span><br>    &#125;，<br>+   data: []<br>  &#125;),<br>  methods: &#123;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">request</span>(<span class="hljs-params"></span>)</span> &#123;&#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">handleFileChange</span>(<span class="hljs-params"></span>)</span> &#123;&#125;,</span><br><span class="javascript">+    <span class="hljs-comment">// 生成文件切片</span></span><br><span class="javascript">+    <span class="hljs-function"><span class="hljs-title">createFileChunk</span>(<span class="hljs-params">file, size = SIZE</span>)</span> &#123;</span><br><span class="javascript">+     <span class="hljs-keyword">const</span> fileChunkList = [];</span><br><span class="javascript">+      <span class="hljs-keyword">let</span> cur = <span class="hljs-number">0</span>;</span><br><span class="javascript">+      <span class="hljs-keyword">while</span> (cur &lt; file.size) &#123;</span><br>+        fileChunkList.push(&#123; file: file.slice(cur, cur + size) &#125;);<br>+        cur += size;<br>+      &#125;<br><span class="javascript">+      <span class="hljs-keyword">return</span> fileChunkList;</span><br>+    &#125;,<br><span class="javascript">+   <span class="hljs-comment">// 上传切片</span></span><br><span class="javascript">+    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">uploadChunks</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">+      <span class="hljs-keyword">const</span> requestList = <span class="hljs-built_in">this</span>.data</span><br><span class="javascript">+        .map(<span class="hljs-function">(<span class="hljs-params">&#123; chunk，hash &#125;</span>) =&gt;</span> &#123;</span><br><span class="javascript">+          <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> FormData();</span><br><span class="javascript">+          formData.append(<span class="hljs-string">&quot;chunk&quot;</span>, chunk);</span><br><span class="javascript">+          formData.append(<span class="hljs-string">&quot;hash&quot;</span>, hash);</span><br><span class="javascript">+          formData.append(<span class="hljs-string">&quot;filename&quot;</span>, <span class="hljs-built_in">this</span>.container.file.name);</span><br><span class="javascript">+          <span class="hljs-keyword">return</span> &#123; formData &#125;;</span><br>+        &#125;)<br><span class="javascript">+        .map(<span class="hljs-function">(<span class="hljs-params">&#123; formData &#125;</span>) =&gt;</span></span><br><span class="javascript">+          <span class="hljs-built_in">this</span>.request(&#123;</span><br><span class="javascript">+            url: <span class="hljs-string">&quot;http://localhost:3000&quot;</span>,</span><br>+            data: formData<br>+          &#125;)<br>+        );<br><span class="javascript">+      <span class="hljs-comment">// 并发请求</span></span><br><span class="javascript">+      <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(requestList); </span><br>+    &#125;,<br><span class="javascript">+    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">handleUpload</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">+      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.container.file) <span class="hljs-keyword">return</span>;</span><br><span class="javascript">+      <span class="hljs-keyword">const</span> fileChunkList = <span class="hljs-built_in">this</span>.createFileChunk(<span class="hljs-built_in">this</span>.container.file);</span><br><span class="javascript">+      <span class="hljs-built_in">this</span>.data = fileChunkList.map(<span class="hljs-function">(<span class="hljs-params">&#123; file &#125;，index</span>) =&gt;</span> (&#123;</span><br>+        chunk: file,<br><span class="javascript">+        <span class="hljs-comment">// 文件名 + 数组下标</span></span><br><span class="javascript">+        hash: <span class="hljs-built_in">this</span>.container.file.name + <span class="hljs-string">&quot;-&quot;</span> + index</span><br>+      &#125;));<br><span class="javascript">+      <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.uploadChunks();</span><br>+    &#125;<br>  &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>当点击上传按钮时，调用 <strong>createFileChunk</strong> 将文件切片，切片数量通过文件大小控制，这里设置 10MB，也就是说一个 100 MB 的文件会被分成 10 个 10MB 的切片</li></ol><p>createFileChunk 内使用 while 循环和 slice 方法将切片放入 <strong>fileChunkList</strong> 数组中返回</p><p>在生成文件切片时，需要给每个切片一个标识作为 hash，这里暂时使用<strong>文件名 + 下标</strong>，这样后端可以知道当前切片是第几个切片，用于之后的合并切片</p><p>随后调用 <strong>uploadChunks</strong> 上传所有的文件切片，将文件切片，切片 hash，以及文件名放入 formData 中，再调用上一步的 <strong>request</strong> 函数返回一个 proimise，最后调用 Promise.all 并发上传所有的切片</p><h3 id="发送合并请求"><a href="#发送合并请求" class="headerlink" title="发送合并请求"></a>发送合并请求</h3><p>使用整体思路中提到的第二种合并切片的方式，即前端主动通知服务端进行合并</p><p>前端发送额外的合并请求，服务端接受到请求时合并切片</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;handleFileChange&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleUpload&quot;</span>&gt;</span>upload<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>​<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  data: <span class="hljs-function">() =&gt;</span> (&#123;</span><br>    container: &#123;<br><span class="javascript">      file: <span class="hljs-literal">null</span></span><br>    &#125;,<br>    data: []<br>  &#125;),<br>  methods: &#123;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">request</span>(<span class="hljs-params"></span>)</span> &#123;&#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">handleFileChange</span>(<span class="hljs-params"></span>)</span> &#123;&#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">createFileChunk</span>(<span class="hljs-params"></span>)</span> &#123;&#125;,</span><br><span class="javascript">    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">uploadChunks</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-keyword">const</span> requestList = <span class="hljs-built_in">this</span>.data</span><br><span class="javascript">        .map(<span class="hljs-function">(<span class="hljs-params">&#123; chunk，hash &#125;</span>) =&gt;</span> &#123;</span><br><span class="javascript">          <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> FormData();</span><br><span class="javascript">          formData.append(<span class="hljs-string">&quot;chunk&quot;</span>, chunk);</span><br><span class="javascript">          formData.append(<span class="hljs-string">&quot;hash&quot;</span>, hash);</span><br><span class="javascript">          formData.append(<span class="hljs-string">&quot;filename&quot;</span>, <span class="hljs-built_in">this</span>.container.file.name);</span><br><span class="javascript">          <span class="hljs-keyword">return</span> &#123; formData &#125;;</span><br>        &#125;)<br><span class="javascript">        .map(<span class="hljs-function">(<span class="hljs-params">&#123; formData &#125;</span>) =&gt;</span></span><br><span class="javascript">          <span class="hljs-built_in">this</span>.request(&#123;</span><br><span class="javascript">            url: <span class="hljs-string">&quot;http://localhost:3000&quot;</span>,</span><br>            data: formData<br>          &#125;)<br>        );<br><span class="javascript">      <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(requestList);</span><br><span class="javascript">+     <span class="hljs-comment">// 合并切片</span></span><br><span class="javascript">+     <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.mergeRequest();</span><br>    &#125;,<br><span class="javascript">+    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">mergeRequest</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">+      <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.request(&#123;</span><br><span class="javascript">+        url: <span class="hljs-string">&quot;http://localhost:3000/merge&quot;</span>,</span><br>+        headers: &#123;<br><span class="javascript">+          <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span></span><br>+        &#125;,<br><span class="javascript">+        data: <span class="hljs-built_in">JSON</span>.stringify(&#123;</span><br><span class="javascript">+          filename: <span class="hljs-built_in">this</span>.container.file.name</span><br>+        &#125;)<br>+      &#125;);<br>+    &#125;,    <br><span class="javascript">    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">handleUpload</span>(<span class="hljs-params"></span>)</span> &#123;&#125;</span><br>  &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="服务端部分"><a href="#服务端部分" class="headerlink" title="服务端部分"></a>服务端部分</h3><p>使用 http 模块搭建一个简单服务端</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-keyword">const</span> server = http.createServer();<br>​<br>server.<span class="hljs-literal">on</span>(<span class="hljs-string">&quot;request&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;<br>  res.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>  res.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>  <span class="hljs-keyword">if</span> (req.method === <span class="hljs-string">&quot;OPTIONS&quot;</span>) &#123;<br>    res.status = <span class="hljs-number">200</span>;<br>    res.end();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>&#125;);<br>​<br>server.listen(<span class="hljs-number">3000</span>, () =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;listening port 3000&quot;</span>));<br></code></pre></td></tr></table></figure><h4 id="接受切片"><a href="#接受切片" class="headerlink" title="接受切片"></a>接受切片</h4><p>使用 multiparty 处理前端传来的 formData</p><p>在 multiparty.parse 的回调中，files 参数保存了 formData 中文件，fields 参数保存了 formData 中非文件的字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br>+ <span class="hljs-keyword">const</span> fse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs-extra&quot;</span>);<br>+ <span class="hljs-keyword">const</span> multiparty = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;multiparty&quot;</span>);<br>​<br><span class="hljs-keyword">const</span> server = http.createServer();<br>+ <span class="hljs-comment">// 大文件存储目录</span><br>+ <span class="hljs-keyword">const</span> UPLOAD_DIR = path.resolve(__dirname, <span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-string">&quot;target&quot;</span>);<br>​<br>server.on(<span class="hljs-string">&quot;request&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;<br>  res.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>  res.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>  <span class="hljs-keyword">if</span> (req.method === <span class="hljs-string">&quot;OPTIONS&quot;</span>) &#123;<br>    res.status = <span class="hljs-number">200</span>;<br>    res.end();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>​<br>+  <span class="hljs-keyword">const</span> multipart = <span class="hljs-keyword">new</span> multiparty.Form();<br>​<br>+  multipart.parse(req, <span class="hljs-keyword">async</span> (err, fields, files) =&gt; &#123;<br>+    <span class="hljs-keyword">if</span> (err) &#123;<br>+      <span class="hljs-keyword">return</span>;<br>+    &#125;<br>+    <span class="hljs-keyword">const</span> [chunk] = files.chunk;<br>+    <span class="hljs-keyword">const</span> [hash] = fields.hash;<br>+    <span class="hljs-keyword">const</span> [filename] = fields.filename;<br>+    <span class="hljs-comment">// 创建临时文件夹用于临时存储 chunk</span><br>+    <span class="hljs-comment">// 添加 chunkDir 前缀与文件名做区分</span><br>+    <span class="hljs-keyword">const</span> chunkDir = path.resolve(UPLOAD_DIR, <span class="hljs-string">&#x27;chunkDir&#x27;</span> + filename);<br>​<br>+    <span class="hljs-keyword">if</span> (!fse.existsSync(chunkDir)) &#123;<br>+      <span class="hljs-keyword">await</span> fse.mkdirs(chunkDir);<br>+    &#125;<br>​<br>+    <span class="hljs-comment">// fs-extra 的 rename 方法 windows 平台会有权限问题</span><br>+    <span class="hljs-comment">// @see https://github.com/meteor/meteor/issues/7852#issuecomment-255767835</span><br>+    <span class="hljs-keyword">await</span> fse.move(chunk.path, <span class="hljs-string">`<span class="hljs-subst">$&#123;chunkDir&#125;</span>/<span class="hljs-subst">$&#123;hash&#125;</span>`</span>);<br>+    res.end(<span class="hljs-string">&quot;received file chunk&quot;</span>);<br>+  &#125;);<br>&#125;);<br>​<br>server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;listening port 3000&quot;</span>));<br></code></pre></td></tr></table></figure><p>查看 multiparty 处理后的 chunk 对象，path 是存储临时文件的路径，size 是临时文件大小，在 multiparty 文档中提到可以使用 fs.rename（这里换成了 fs.remove, 因为 fs-extra 的 rename 方法在 windows 平台存在权限问题）</p><p>在接受文件切片时，需要先创建临时存储切片的文件夹，以 chunkDir 作为前缀，文件名作为后缀</p><p>由于前端在发送每个切片时额外携带了唯一值 hash，所以以 hash 作为文件名，将切片从临时路径移动切片文件夹中，最后的结果如下</p><h4 id="合并切片"><a href="#合并切片" class="headerlink" title="合并切片"></a>合并切片</h4><p>在接收到前端发送的合并请求后，服务端将文件夹下的所有切片进行合并</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-keyword">const</span> fse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs-extra&quot;</span>);<br>​<br><span class="hljs-keyword">const</span> server = http.createServer();<br><span class="hljs-keyword">const</span> UPLOAD_DIR = path.resolve(__dirname, <span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-string">&quot;target&quot;</span>);<br>​<br>+ <span class="hljs-keyword">const</span> resolvePost = <span class="hljs-function"><span class="hljs-params">req</span> =&gt;</span><br>+   <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>+     <span class="hljs-keyword">let</span> chunk = <span class="hljs-string">&quot;&quot;</span>;<br>+     req.on(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>+       chunk += data;<br>+     &#125;);<br>+     req.on(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>+       resolve(<span class="hljs-built_in">JSON</span>.parse(chunk));<br>+     &#125;);<br>+   &#125;);<br>​<br>+ <span class="hljs-comment">// 写入文件流</span><br>+ <span class="hljs-keyword">const</span> pipeStream = <span class="hljs-function">(<span class="hljs-params">path, writeStream</span>) =&gt;</span><br>+  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>+    <span class="hljs-keyword">const</span> readStream = fse.createReadStream(path);<br>+    readStream.on(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>+      fse.unlinkSync(path);<br>+      resolve();<br>+    &#125;);<br>+    readStream.pipe(writeStream);<br>+  &#125;);<br>​<br><span class="hljs-comment">// 合并切片</span><br>+ <span class="hljs-keyword">const</span> mergeFileChunk = <span class="hljs-keyword">async</span> (filePath, filename, size) =&gt; &#123;<br>+   <span class="hljs-keyword">const</span> chunkDir = path.resolve(UPLOAD_DIR, <span class="hljs-string">&#x27;chunkDir&#x27;</span> + filename);<br>+   <span class="hljs-keyword">const</span> chunkPaths = <span class="hljs-keyword">await</span> fse.readdir(chunkDir);<br>+   <span class="hljs-comment">// 根据切片下标进行排序</span><br>+   <span class="hljs-comment">// 否则直接读取目录的获得的顺序会错乱</span><br>+   chunkPaths.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.split(<span class="hljs-string">&quot;-&quot;</span>)[<span class="hljs-number">1</span>] - b.split(<span class="hljs-string">&quot;-&quot;</span>)[<span class="hljs-number">1</span>]);<br>+   <span class="hljs-comment">// 并发写入文件</span><br>+   <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(<br>+     chunkPaths.map(<span class="hljs-function">(<span class="hljs-params">chunkPath, index</span>) =&gt;</span><br>+       pipeStream(<br>+         path.resolve(chunkDir, chunkPath),<br>+         <span class="hljs-comment">// 根据 size 在指定位置创建可写流</span><br>+         fse.createWriteStream(filePath, &#123;<br>+           start: index * size,<br>+         &#125;)<br>+       )<br>+     )<br>+  );<br>+  <span class="hljs-comment">// 合并后删除保存切片的目录</span><br>+  fse.rmdirSync(chunkDir);<br>+&#125;;<br>​<br>server.on(<span class="hljs-string">&quot;request&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;<br>  res.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>  res.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>  <span class="hljs-keyword">if</span> (req.method === <span class="hljs-string">&quot;OPTIONS&quot;</span>) &#123;<br>    res.status = <span class="hljs-number">200</span>;<br>    res.end();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>​<br>+   <span class="hljs-keyword">if</span> (req.url === <span class="hljs-string">&quot;/merge&quot;</span>) &#123;<br>+     <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> resolvePost(req);<br>+     <span class="hljs-keyword">const</span> &#123; filename,size &#125; = data;<br>+     <span class="hljs-keyword">const</span> filePath = path.resolve(UPLOAD_DIR, <span class="hljs-string">`<span class="hljs-subst">$&#123;filename&#125;</span>`</span>);<br>+     <span class="hljs-keyword">await</span> mergeFileChunk(filePath, filename);<br>+     res.end(<br>+       <span class="hljs-built_in">JSON</span>.stringify(&#123;<br>+         code: <span class="hljs-number">0</span>,<br>+         message: <span class="hljs-string">&quot;file merged success&quot;</span><br>+       &#125;)<br>+     );<br>+   &#125;<br>​<br>&#125;);<br>​<br>server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;listening port 3000&quot;</span>));<br></code></pre></td></tr></table></figure><p>由于前端在发送合并请求时会携带文件名，服务端根据文件名可以找到上一步创建的切片文件夹</p><p>接着使用 fs.createWriteStream 创建一个可写流，可写流文件名就是上传时的文件名</p><p>随后遍历整个切片文件夹，将切片通过 fs.createReadStream 创建可读流，传输合并到目标文件中</p><p>值得注意的是每次可读流都会传输到可写流的指定位置，这是通过 createWriteStream 的第二个参数 start 控制的，目的是能够并发合并多个可读流至可写流中，这样即使并发时流的顺序不同，也能传输到正确的位置</p><p>所以还需要让前端在请求的时候提供之前设定好的 size 给服务端，服务端根据 size 指定可读流的起始位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">   <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">mergeRequest</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.request(&#123;<br>        url: <span class="hljs-string">&quot;http://localhost:3000/merge&quot;</span>,<br>        headers: &#123;<br>          <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span><br>        &#125;,<br>        data: <span class="hljs-built_in">JSON</span>.stringify(&#123;<br>+         size: SIZE,<br>          filename: <span class="hljs-built_in">this</span>.container.file.name<br>        &#125;)<br>      &#125;);<br>    &#125;,<br></code></pre></td></tr></table></figure><p>其实也可以等上一个切片合并完后再合并下个切片，这样就不需要指定位置，但传输速度会降低，所以使用了并发合并的手段</p><p>接着只要保证每次合并完成后删除这个切片，等所有切片都合并完毕后最后删除切片文件夹即可</p><h4 id="显示上传进度条"><a href="#显示上传进度条" class="headerlink" title="显示上传进度条"></a>显示上传进度条</h4><p>上传进度分两种，一个是每个切片的上传进度，另一个是整个文件的上传进度，而整个文件的上传进度是基于每个切片上传进度计算而来，所以我们先实现单个切片的进度条</p><p>单个切片进度条<br>XMLHttpRequest 原生支持上传进度的监听，只需要监听 upload.onprogress 即可，我们在原来的 request 基础上传入 onProgress 参数，给 XMLHttpRequest 注册监听事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-comment">// xhr</span><br>    request(&#123;<br>      url,<br>      method = <span class="hljs-string">&quot;post&quot;</span>,<br>      data,<br>      headers = &#123;&#125;,<br>+     onProgress = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e,<br>      requestList<br>    &#125;) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>+       xhr.upload.onprogress = onProgress;<br>        xhr.open(method, url);<br>        <span class="hljs-built_in">Object</span>.keys(headers).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span><br>          xhr.setRequestHeader(key, headers[key])<br>        );<br>        xhr.send(data);<br>        xhr.onload = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>          resolve(&#123;<br>            data: e.target.response<br>          &#125;);<br>        &#125;;<br>      &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><p>由于每个切片都需要触发独立的监听事件，所以需要一个工厂函数，根据传入的切片返回不同的监听函数</p><p>在原先的前端上传逻辑中新增监听函数部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript">    <span class="hljs-comment">// 上传切片，同时过滤已上传的切片</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">uploadChunks</span>(<span class="hljs-params">uploadedList = []</span>)</span> &#123;<br>      <span class="hljs-keyword">const</span> requestList = <span class="hljs-built_in">this</span>.data<br>+       .map(<span class="hljs-function">(<span class="hljs-params">&#123; chunk,hash,index &#125;</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> FormData();<br>          formData.append(<span class="hljs-string">&quot;chunk&quot;</span>, chunk);<br>          formData.append(<span class="hljs-string">&quot;hash&quot;</span>, hash);<br>          formData.append(<span class="hljs-string">&quot;filename&quot;</span>, <span class="hljs-built_in">this</span>.container.file.name);<br>+         <span class="hljs-keyword">return</span> &#123; formData,index &#125;;<br>        &#125;)<br>+       .map(<span class="hljs-function">(<span class="hljs-params">&#123; formData,index &#125;</span>) =&gt;</span><br>          <span class="hljs-built_in">this</span>.request(&#123;<br>            url: <span class="hljs-string">&quot;http://localhost:3000&quot;</span>,<br>            data: formData，<br>+           onProgress: <span class="hljs-built_in">this</span>.createProgressHandler(<span class="hljs-built_in">this</span>.data[index]),<br>          &#125;)<br>        );<br>      <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(requestList);<br>      <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.mergeRequest();<br>    &#125;,<br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">handleUpload</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.container.file) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-keyword">const</span> fileChunkList = <span class="hljs-built_in">this</span>.createFileChunk(<span class="hljs-built_in">this</span>.container.file);<br>      <span class="hljs-built_in">this</span>.data = fileChunkList.map(<span class="hljs-function">(<span class="hljs-params">&#123; file &#125;，index</span>) =&gt;</span> (&#123;<br>        chunk: file,<br>+       index,<br>        hash: <span class="hljs-built_in">this</span>.container.file.name + <span class="hljs-string">&quot;-&quot;</span> + index<br>+       percentage:<span class="hljs-number">0</span><br>      &#125;));<br>      <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.uploadChunks();<br>    &#125;    <br>+   <span class="hljs-function"><span class="hljs-title">createProgressHandler</span>(<span class="hljs-params">item</span>)</span> &#123;<br>+      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>+        item.percentage = <span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">String</span>((e.loaded / e.total) * <span class="hljs-number">100</span>));<br>+      &#125;;<br>+   &#125;<br></code></pre></td></tr></table></figure><p>每个切片在上传时都会通过监听函数更新 data 数组对应元素的 percentage 属性，之后把将 data 数组放到视图中展示即可</p><h4 id="总进度条"><a href="#总进度条" class="headerlink" title="总进度条"></a>总进度条</h4><p>将每个切片已上传的部分累加，除以整个文件的大小，就能得出当前文件的上传进度，所以这里使用 Vue 的计算属性</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"> computed: &#123;<br>      uploadPercentage() &#123;<br>         <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.container.file || !<span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>.length) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">const</span> loaded = <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span><br>           .map(item =&gt; item.size * item.percentage)<br>           .reduce((acc, cur) =&gt; acc + cur);<br>         <span class="hljs-keyword">return</span> parseInt((loaded / <span class="hljs-keyword">this</span>.container.file.size).toFixed(<span class="hljs-number">2</span>));<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>断点续传的原理在于前端/服务端需要记住已上传的切片，这样下次上传就可以跳过之前已上传的部分，有两种方案实现记忆的功能</p><p>前端使用 localStorage 记录已上传的切片 hash<br>服务端保存已上传的切片 hash，前端每次上传前向服务端获取已上传的切片<br>第一种是前端的解决方案，第二种是服务端，而前端方案有一个缺陷，如果换了个浏览器就失去了记忆的效果，所以这里选后者</p><h4 id="生成-hash"><a href="#生成-hash" class="headerlink" title="生成 hash"></a>生成 hash</h4><p>无论是前端还是服务端，都必须要生成文件和切片的 hash，之前我们使用文件名 + 切片下标作为切片 hash，这样做文件名一旦修改就失去了效果，<strong>而事实上只要文件内容不变，hash 就不应该变化，所以正确的做法是根据文件内容生成 hash</strong>，所以我们修改一下 hash 的生成规则</p><blockquote><p>webpack 的产物 contenthash 也是基于这个思路实现的</p></blockquote><p>这里用到另一个库 spark-md5，它可以根据文件内容计算出文件的 hash 值</p><p>另外考虑到如果上传一个超大文件，读取文件内容计算 hash 是非常耗费时间的，并且会<strong>引起 UI 的阻塞</strong>，导致页面假死状态，所以我们使用 web-worker 在 worker 线程计算 hash，这样用户仍可以在主界面正常的交互</p><p>由于实例化 web-worker 时，参数是一个 js 文件路径且不能跨域，所以我们单独创建一个 hash.js 文件放在 public 目录下，另外在 worker 中也是不允许访问 dom 的，但它提供了importScripts 函数用于导入外部脚本，通过它导入 spark-md5</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// /public/hash.js</span><br>​<br><span class="hljs-comment">// 导入脚本</span><br><span class="hljs-keyword">self</span>.importScripts(<span class="hljs-string">&quot;/spark-md5.min.js&quot;</span>);<br>​<br><span class="hljs-comment">// 生成文件 hash</span><br><span class="hljs-keyword">self</span>.onmessage = e =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; fileChunkList &#125; = e.data;<br>  <span class="hljs-keyword">const</span> spark = <span class="hljs-keyword">new</span> <span class="hljs-keyword">self</span>.SparkMD5.ArrayBuffer();<br>  <span class="hljs-keyword">let</span> percentage = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> loadNext = index =&gt; &#123;<br>    <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> FileReader();<br>    reader.readAsArrayBuffer(fileChunkList[index].file);<br>    reader.onload = e =&gt; &#123;<br>      count++;<br>      spark.append(e.target.result);<br>      <span class="hljs-keyword">if</span> (count === fileChunkList.length) &#123;<br>        <span class="hljs-keyword">self</span>.postMessage(&#123;<br>          percentage: <span class="hljs-number">100</span>,<br>          hash: spark.end()<br>        &#125;);<br>        <span class="hljs-keyword">self</span>.close();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        percentage += <span class="hljs-number">100</span> / fileChunkList.length;<br>        <span class="hljs-keyword">self</span>.postMessage(&#123;<br>          percentage<br>        &#125;);<br>        <span class="hljs-comment">// calculate recursively</span><br>        loadNext(count);<br>      &#125;<br>    &#125;;<br>  &#125;;<br>  loadNext(<span class="hljs-number">0</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 worker 线程中，接受文件切片 fileChunkList，利用 fileReader 读取每个切片的 ArrayBuffer 并不断传入 spark-md5 中，每计算完一个切片通过 postMessage 向主线程发送一个进度事件，全部完成后将最终的 hash 发送给主线程</p><blockquote><p>spark-md5 文档中要求传入所有切片并算出 hash 值，不能直接将整个文件放入计算，否则即使不同文件也会有相同的 hash</p></blockquote><p>接着编写主线程与 worker 线程通讯的逻辑</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">+    <span class="hljs-comment">// 生成文件 hash（web-worker）</span><br>+    calculateHash(fileChunkList) &#123;<br>+      <span class="hljs-keyword">return</span> new Promise(resolve =&gt; &#123;<br>+        <span class="hljs-comment">// 添加 worker 属性</span><br>+        <span class="hljs-keyword">this</span>.container.worker = new Worker(<span class="hljs-string">&quot;/hash.js&quot;</span>);<br>+        <span class="hljs-keyword">this</span>.container.worker.postMessage(&#123; fileChunkList &#125;);<br>+        <span class="hljs-keyword">this</span>.container.worker.onmessage = e =&gt; &#123;<br>+          <span class="hljs-keyword">const</span> &#123; percentage, hash &#125; = e.<span class="hljs-keyword">data</span>;<br>+          <span class="hljs-keyword">this</span>.hashPercentage = percentage;<br>+          <span class="hljs-keyword">if</span> (hash) &#123;<br>+            resolve(hash);<br>+          &#125;<br>+        &#125;;<br>+      &#125;);<br>    &#125;,<br>    async handleUpload() &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.container.file) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-keyword">const</span> fileChunkList = <span class="hljs-keyword">this</span>.createFileChunk(<span class="hljs-keyword">this</span>.container.file);<br>+     <span class="hljs-keyword">this</span>.container.hash = await <span class="hljs-keyword">this</span>.calculateHash(fileChunkList);<br>      <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span> = fileChunkList.map((&#123; file &#125;，index) =&gt; (&#123;<br>+       fileHash: <span class="hljs-keyword">this</span>.container.hash,<br>        chunk: file,<br>        hash: <span class="hljs-keyword">this</span>.container.file.name + <span class="hljs-string">&quot;-&quot;</span> + index,<br>        percentage:<span class="hljs-number">0</span><br>      &#125;));<br>      await <span class="hljs-keyword">this</span>.uploadChunks();<span class="hljs-number">000</span><br>    &#125;   <br></code></pre></td></tr></table></figure><p>主线程使用 <strong>postMessage</strong> 给 worker 线程传入所有切片 fileChunkList，并监听 worker 线程发出的 postMessage 事件拿到文件 hash<br>加上显示计算 hash 的进度条，看起来像这样</p><p>至此前端需要将之前用文件名作为 hash 的地方改写为 worker 返回的 hash</p><p>服务端则使用固定前缀 + hash 作为切片文件夹名，hash + 下标作为切片名，hash + 扩展名作为文件名</p><h4 id="文件秒传"><a href="#文件秒传" class="headerlink" title="文件秒传"></a>文件秒传</h4><p>在实现断点续传前先简单介绍一下文件秒传</p><p>所谓的文件秒传，即在服务端已经存在了上传的资源，所以当用户再次上传时会直接提示上传成功</p><p>文件秒传需要依赖上一步生成的 hash，即在上传前，先计算出文件 hash，并把 hash 发送给服务端进行验证，由于 hash 的唯一性，所以一旦服务端能找到 hash 相同的文件，则直接返回上传成功的信息即可</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">+    async verifyUpload(filename, fileHash) &#123;<br>+       <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">data</span> &#125; = await <span class="hljs-keyword">this</span>.request(&#123;<br>+         url: <span class="hljs-string">&quot;http://localhost:3000/verify&quot;</span>,<br>+         headers: &#123;<br>+           <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span><br>+         &#125;,<br>+         <span class="hljs-keyword">data</span>: JSON.stringify(&#123;<br>+           filename,<br>+           fileHash<br>+         &#125;)<br>+       &#125;);<br>+       <span class="hljs-keyword">return</span> JSON.parse(<span class="hljs-keyword">data</span>);<br>+     &#125;,<br>   async handleUpload() &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.container.file) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-keyword">const</span> fileChunkList = <span class="hljs-keyword">this</span>.createFileChunk(<span class="hljs-keyword">this</span>.container.file);<br>      <span class="hljs-keyword">this</span>.container.hash = await <span class="hljs-keyword">this</span>.calculateHash(fileChunkList);<br>+     <span class="hljs-keyword">const</span> &#123; shouldUpload &#125; = await <span class="hljs-keyword">this</span>.verifyUpload(<br>+       <span class="hljs-keyword">this</span>.container.file.name,<br>+       <span class="hljs-keyword">this</span>.container.hash<br>+     );<br>+     <span class="hljs-keyword">if</span> (!shouldUpload) &#123;<br>+       <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">&quot;skip upload：file upload success&quot;</span>);<br>+       <span class="hljs-keyword">return</span>;<br>+    &#125;<br>     <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span> = fileChunkList.map((&#123; file &#125;, index) =&gt; (&#123;<br>        fileHash: <span class="hljs-keyword">this</span>.container.hash,<br>        index,<br>        hash: <span class="hljs-keyword">this</span>.container.hash + <span class="hljs-string">&quot;-&quot;</span> + index,<br>        chunk: file,<br>        percentage: <span class="hljs-number">0</span><br>      &#125;));<br>      await <span class="hljs-keyword">this</span>.uploadChunks();<br>    &#125;   <br></code></pre></td></tr></table></figure><p>秒传其实就是给用户看的障眼法，实质上根本没有上传</p><p>服务端的逻辑非常简单，新增一个验证接口，验证文件是否存在即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript">+ <span class="hljs-comment">// 提取后缀名</span><br>+ <span class="hljs-keyword">const</span> extractExt = <span class="hljs-function"><span class="hljs-params">filename</span> =&gt;</span><br>+  filename.slice(filename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>), filename.length);<br><span class="hljs-keyword">const</span> UPLOAD_DIR = path.resolve(__dirname, <span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-string">&quot;target&quot;</span>);<br>​<br><span class="hljs-keyword">const</span> resolvePost = <span class="hljs-function"><span class="hljs-params">req</span> =&gt;</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> chunk = <span class="hljs-string">&quot;&quot;</span>;<br>    req.on(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>      chunk += data;<br>    &#125;);<br>    req.on(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      resolve(<span class="hljs-built_in">JSON</span>.parse(chunk));<br>    &#125;);<br>  &#125;);<br>​<br>server.on(<span class="hljs-string">&quot;request&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (req.url === <span class="hljs-string">&quot;/verify&quot;</span>) &#123;<br>+    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> resolvePost(req);<br>+    <span class="hljs-keyword">const</span> &#123; fileHash, filename &#125; = data;<br>+    <span class="hljs-keyword">const</span> ext = extractExt(filename);<br>+    <span class="hljs-keyword">const</span> filePath = path.resolve(UPLOAD_DIR, <span class="hljs-string">`<span class="hljs-subst">$&#123;fileHash&#125;</span><span class="hljs-subst">$&#123;ext&#125;</span>`</span>);<br>+    <span class="hljs-keyword">if</span> (fse.existsSync(filePath)) &#123;<br>+      res.end(<br>+        <span class="hljs-built_in">JSON</span>.stringify(&#123;<br>+          shouldUpload: <span class="hljs-literal">false</span><br>+        &#125;)<br>+      );<br>+    &#125; <span class="hljs-keyword">else</span> &#123;<br>+      res.end(<br>+        <span class="hljs-built_in">JSON</span>.stringify(&#123;<br>+          shouldUpload: <span class="hljs-literal">true</span><br>+        &#125;)<br>+      );<br>+    &#125;<br>  &#125;<br>&#125;);<br>​<br>server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;listening port 3000&quot;</span>));<br></code></pre></td></tr></table></figure><h4 id="暂停上传"><a href="#暂停上传" class="headerlink" title="暂停上传"></a>暂停上传</h4><p>讲完了生成 hash 和文件秒传，回到断点续传</p><p>断点续传顾名思义即断点 + 续传，所以我们第一步先实现“断点”，也就是暂停上传</p><p>原理是使用 XMLHttpRequest 的 <strong>abort</strong> 方法，可以取消一个 xhr 请求的发送，为此我们需要将上传每个切片的 xhr 对象保存起来，我们再改造一下 request 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript">request(&#123;<br>      url,<br>      method = <span class="hljs-string">&quot;post&quot;</span>,<br>      data,<br>      headers = &#123;&#125;,<br>      onProgress = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e,<br>+     requestList<br>    &#125;) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>        xhr.upload.onprogress = onProgress;<br>        xhr.open(method, url);<br>        <span class="hljs-built_in">Object</span>.keys(headers).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span><br>          xhr.setRequestHeader(key, headers[key])<br>        );<br>        xhr.send(data);<br>        xhr.onload = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>+          <span class="hljs-comment">// 将请求成功的 xhr 从列表中删除</span><br>+          <span class="hljs-keyword">if</span> (requestList) &#123;<br>+            <span class="hljs-keyword">const</span> xhrIndex = requestList.findIndex(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item === xhr);<br>+            requestList.splice(xhrIndex, <span class="hljs-number">1</span>);<br>+          &#125;<br>          resolve(&#123;<br>            data: e.target.response<br>          &#125;);<br>        &#125;;<br>+        <span class="hljs-comment">// 暴露当前 xhr 给外部</span><br>+        requestList?.push(xhr);<br>      &#125;);<br>    &#125;,<br></code></pre></td></tr></table></figure><p>这样在上传切片时传入 requestList 数组作为参数，request 方法就会将所有的 xhr 保存在数组中了</p><p>每当一个切片上传成功时，将对应的 xhr 从 requestList 中删除，所以 requestList 中只保存<strong>正在上传切片的 xhr</strong></p><p>之后新建一个暂停按钮，当点击按钮时，调用保存在 requestList 中 xhr 的 abort 方法，即取消并清空所有正在上传的切片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">handlePause</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.requestList.forEach(<span class="hljs-function"><span class="hljs-params">xhr</span> =&gt;</span> xhr?.abort());<br>    <span class="hljs-built_in">this</span>.requestList = [];<br>&#125;<br></code></pre></td></tr></table></figure><p>点击暂停按钮可以看到 xhr 都被取消了</p><h4 id="恢复上传"><a href="#恢复上传" class="headerlink" title="恢复上传"></a>恢复上传</h4><p>之前在介绍断点续传的时提到使用第二种服务端存储的方式实现续传</p><p>由于当文件切片上传后，服务端会建立一个文件夹存储所有上传的切片，所以每次前端上传前可以调用一个接口，服务端将已上传的切片的切片名返回，前端再跳过这些已经上传切片，这样就实现了“续传”的效果</p><p>而这个接口可以和之前秒传的验证接口合并，前端每次上传前发送一个验证的请求，返回两种结果</p><ol><li>服务端已存在该文件，不需要再次上传</li><li>服务端不存在该文件或者已上传部分文件切片，通知前端进行上传，并把<strong>已上传</strong>的文件切片返回给前端<br>所以我们改造一下之前文件秒传的服务端验证接口<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> extractExt = <span class="hljs-function"><span class="hljs-params">filename</span> =&gt;</span><br>  filename.slice(filename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>), filename.length);<br><span class="hljs-keyword">const</span> UPLOAD_DIR = path.resolve(__dirname, <span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-string">&quot;target&quot;</span>);<br>​<br><span class="hljs-keyword">const</span> resolvePost = <span class="hljs-function"><span class="hljs-params">req</span> =&gt;</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> chunk = <span class="hljs-string">&quot;&quot;</span>;<br>    req.on(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>      chunk += data;<br>    &#125;);<br>    req.on(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      resolve(<span class="hljs-built_in">JSON</span>.parse(chunk));<br>    &#125;);<br>  &#125;);<br>  <br>+ <span class="hljs-comment">// 返回已上传的所有切片名</span><br>+ <span class="hljs-keyword">const</span> createUploadedList = <span class="hljs-keyword">async</span> fileHash =&gt;<br>+   fse.existsSync(path.resolve(UPLOAD_DIR, fileHash))<br>+    ? <span class="hljs-keyword">await</span> fse.readdir(path.resolve(UPLOAD_DIR, fileHash))<br>+    : [];<br>​<br>server.on(<span class="hljs-string">&quot;request&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (req.url === <span class="hljs-string">&quot;/verify&quot;</span>) &#123;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> resolvePost(req);<br>    <span class="hljs-keyword">const</span> &#123; fileHash, filename &#125; = data;<br>    <span class="hljs-keyword">const</span> ext = extractExt(filename);<br>    <span class="hljs-keyword">const</span> filePath = path.resolve(UPLOAD_DIR, <span class="hljs-string">`<span class="hljs-subst">$&#123;fileHash&#125;</span><span class="hljs-subst">$&#123;ext&#125;</span>`</span>);<br>    <span class="hljs-keyword">if</span> (fse.existsSync(filePath)) &#123;<br>      res.end(<br>        <span class="hljs-built_in">JSON</span>.stringify(&#123;<br>          shouldUpload: <span class="hljs-literal">false</span><br>        &#125;)<br>      );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res.end(<br>        <span class="hljs-built_in">JSON</span>.stringify(&#123;<br>          shouldUpload: <span class="hljs-literal">true</span>，<br>+         uploadedList: <span class="hljs-keyword">await</span> createUploadedList(fileHash)<br>        &#125;)<br>      );<br>    &#125;<br>  &#125;<br>&#125;);<br>​<br>server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;listening port 3000&quot;</span>));<br></code></pre></td></tr></table></figure>接着回到前端，前端有两个地方需要调用验证的接口</li></ol><p>点击上传时，检查是否需要上传和已上传的切片<br>点击暂停后的恢复上传，返回已上传的切片<br>新增恢复按钮并改造原来上传切片的逻辑</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&lt;template&gt;<br>  &lt;div id=<span class="hljs-string">&quot;app&quot;</span>&gt;<br>      &lt;input<br>        type=<span class="hljs-string">&quot;file&quot;</span><br>        <span class="hljs-meta">@change</span>=<span class="hljs-string">&quot;handleFileChange&quot;</span><br>      /&gt;<br>       &lt;el-button <span class="hljs-meta">@click</span>=<span class="hljs-string">&quot;handleUpload&quot;</span>&gt;upload&lt;/el-button&gt;<br>       &lt;el-button <span class="hljs-meta">@click</span>=<span class="hljs-string">&quot;handlePause&quot;</span> v-<span class="hljs-keyword">if</span>=<span class="hljs-string">&quot;isPaused&quot;</span>&gt;pause&lt;/el-button&gt;<br>+      &lt;el-button <span class="hljs-meta">@click</span>=<span class="hljs-string">&quot;handleResume&quot;</span> v-<span class="hljs-keyword">else</span>&gt;resume&lt;/el-button&gt;<br>      <span class="hljs-comment">//...</span><br>    &lt;/div&gt;<br>&lt;/template&gt;<br>​<br>+   async handleResume() &#123;<br>+      <span class="hljs-keyword">const</span> &#123; uploadedList &#125; = await <span class="hljs-keyword">this</span>.verifyUpload(<br>+        <span class="hljs-keyword">this</span>.container.file.name,<br>+        <span class="hljs-keyword">this</span>.container.hash<br>+      );<br>+      await <span class="hljs-keyword">this</span>.uploadChunks(uploadedList);<br>    &#125;,<br>    async handleUpload() &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.container.file) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-keyword">const</span> fileChunkList = <span class="hljs-keyword">this</span>.createFileChunk(<span class="hljs-keyword">this</span>.container.file);<br>      <span class="hljs-keyword">this</span>.container.hash = await <span class="hljs-keyword">this</span>.calculateHash(fileChunkList);<br>+     <span class="hljs-keyword">const</span> &#123; shouldUpload, uploadedList &#125; = await <span class="hljs-keyword">this</span>.verifyUpload(<br>+       <span class="hljs-keyword">this</span>.container.file.name,<br>+       <span class="hljs-keyword">this</span>.container.hash<br>+     );<br>+     <span class="hljs-keyword">if</span> (!shouldUpload) &#123;<br>+       <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">&quot;skip upload：file upload success&quot;</span>);<br>+       <span class="hljs-keyword">return</span>;<br>+     &#125;<br>      <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span> = fileChunkList.map((&#123; file &#125;, index) =&gt; (&#123;<br>        fileHash: <span class="hljs-keyword">this</span>.container.hash,<br>        index,<br>        hash: <span class="hljs-keyword">this</span>.container.hash + <span class="hljs-string">&quot;-&quot;</span> + index,<br>        chunk: file，<br>        percentage: <span class="hljs-number">0</span><br>      &#125;));<br>+      await <span class="hljs-keyword">this</span>.uploadChunks(uploadedList);<br>    &#125;,<br>    <span class="hljs-comment">// 上传切片，同时过滤已上传的切片</span><br>+   async uploadChunks(uploadedList = []) &#123;<br>      <span class="hljs-keyword">const</span> requestList = <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span><br>+       .filter((&#123; hash &#125;) =&gt; !uploadedList.includes(hash))<br>        .map((&#123; chunk, hash, index &#125;) =&gt; &#123;<br>          <span class="hljs-keyword">const</span> formData = new FormData();<br>          formData.append(<span class="hljs-string">&quot;chunk&quot;</span>, chunk);<br>          formData.append(<span class="hljs-string">&quot;hash&quot;</span>, hash);<br>          formData.append(<span class="hljs-string">&quot;filename&quot;</span>, <span class="hljs-keyword">this</span>.container.file.name);<br>          formData.append(<span class="hljs-string">&quot;fileHash&quot;</span>, <span class="hljs-keyword">this</span>.container.hash);<br>          <span class="hljs-keyword">return</span> &#123; formData, index &#125;;<br>        &#125;)<br>        .map((&#123; formData, index &#125;) =&gt;<br>          <span class="hljs-keyword">this</span>.request(&#123;<br>            url: <span class="hljs-string">&quot;http://localhost:3000&quot;</span>,<br>            <span class="hljs-keyword">data</span>: formData,<br>            onProgress: <span class="hljs-keyword">this</span>.createProgressHandler(<span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>[index]),<br>            requestList: <span class="hljs-keyword">this</span>.requestList<br>          &#125;)<br>        );<br>      await Promise.all(requestList);<br>+     <span class="hljs-comment">// 之前上传的切片数量 + 本次上传的切片数量 = 所有切片数量时合并切片</span><br>+     <span class="hljs-keyword">if</span> (uploadedList.length + requestList.length === <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>.length) &#123;<br>         await <span class="hljs-keyword">this</span>.mergeRequest();<br>+     &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里给原来上传切片的函数新增 uploadedList 参数，即上图中服务端返回的切片名列表，通过 filter 过滤掉已上传的切片，并且由于新增了已上传的部分，所以之前合并接口的触发条件做了一些改动</p><p>到这里断点续传的功能基本完成了</p><h4 id="进度条改进"><a href="#进度条改进" class="headerlink" title="进度条改进"></a>进度条改进</h4><p>虽然实现了断点续传，但还需要修改一下进度条的显示规则，否则在暂停上传/接收到已上传切片时的进度条会出现偏差</p><p>单个切片进度条<br>由于在点击上传/恢复上传时，会调用验证接口返回已上传的切片，所以需要将已上传切片的进度变成 100%</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">   async handleUpload() &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.container.file) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-keyword">const</span> fileChunkList = <span class="hljs-keyword">this</span>.createFileChunk(<span class="hljs-keyword">this</span>.container.file);<br>      <span class="hljs-keyword">this</span>.container.hash = await <span class="hljs-keyword">this</span>.calculateHash(fileChunkList);<br>      <span class="hljs-keyword">const</span> &#123; shouldUpload, uploadedList &#125; = await <span class="hljs-keyword">this</span>.verifyUpload(<br>        <span class="hljs-keyword">this</span>.container.file.name,<br>        <span class="hljs-keyword">this</span>.container.hash<br>      );<br>      <span class="hljs-keyword">if</span> (!shouldUpload) &#123;<br>        <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">&quot;skip upload：file upload success&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span> = fileChunkList.map((&#123; file &#125;, index) =&gt; (&#123;<br>        fileHash: <span class="hljs-keyword">this</span>.container.hash,<br>        index,<br>        hash: <span class="hljs-keyword">this</span>.container.hash + <span class="hljs-string">&quot;-&quot;</span> + index,<br>        chunk: file,<br>+       percentage: uploadedList.includes(index) ? <span class="hljs-number">100</span> : <span class="hljs-number">0</span><br>      &#125;));<br>      await <span class="hljs-keyword">this</span>.uploadChunks(uploadedList);<br>    &#125;,<br></code></pre></td></tr></table></figure><p>uploadedList 会返回已上传的切片，在遍历所有切片时判断当前切片是否在已上传列表里即可</p><h4 id="总进度条-1"><a href="#总进度条-1" class="headerlink" title="总进度条"></a>总进度条</h4><p>之前说到总进度条是一个计算属性，根据所有切片的上传进度计算而来，这就遇到了一个问题</p><p>点击暂停会取消并清空切片的 xhr 请求，此时如果已经上传了一部分，就会发现文件进度条有倒退的现象</p><p>当点击恢复时，由于重新创建了 xhr 导致切片进度清零，所以总进度条就会倒退</p><p>解决方案是创建一个“假”的进度条，这个假进度条基于文件进度条，但只会停止和增加，然后给用户展示这个假的进度条</p><p>这里我们使用 Vue 的监听属性</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"> <span class="hljs-keyword">data</span>: () =&gt; (&#123;<br>+    fakeUploadPercentage: <span class="hljs-number">0</span><br>  &#125;),<br>  computed: &#123;<br>    uploadPercentage() &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.container.file || !<span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>.length) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">const</span> loaded = <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span><br>        .map(item =&gt; item.size * item.percentage)<br>        .reduce((acc, cur) =&gt; acc + cur);<br>      <span class="hljs-keyword">return</span> parseInt((loaded / <span class="hljs-keyword">this</span>.container.file.size).toFixed(<span class="hljs-number">2</span>));<br>    &#125;<br>  &#125;,  <br>  watch: &#123;<br>+    uploadPercentage(now) &#123;<br>+      <span class="hljs-keyword">if</span> (now &gt; <span class="hljs-keyword">this</span>.fakeUploadPercentage) &#123;<br>+        <span class="hljs-keyword">this</span>.fakeUploadPercentage = now;<br>+      &#125;<br>    &#125;<br>  &#125;,<br></code></pre></td></tr></table></figure><p>当 uploadPercentage 即真的文件进度条增加时，fakeUploadPercentage 也增加，一旦文件进度条后退，假的进度条只需停止即可</p><p>至此一个大文件上传 + 断点续传的解决方案就完成了</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大文件上传</p><ol><li>前端上传大文件时使用 Blob.prototype.slice 将文件切片，并发上传多个切片，最后发送一个合并的请求通知服务端合并切片</li><li>服务端接收切片并存储，收到合并请求后使用流将切片合并到最终文件</li><li>原生 XMLHttpRequest 的 upload.onprogress 对切片上传进度的监听</li><li>使用 Vue 计算属性根据每个切片的进度算出整个文件的上传进度</li></ol><p>断点续传</p><ol><li>使用 spark-md5 根据文件内容算出文件 hash</li><li>通过 hash 可以判断服务端是否已经上传该文件，从而直接提示用户上传成功（秒传）</li><li>通过 XMLHttpRequest 的 abort 方法暂停切片的上传</li><li>上传前服务端返回已经上传的切片名，前端跳过这些切片的上传<h3 id="大文件上传，使用切片上传形式，支持上传、暂停、续传你怎么实现的？"><a href="#大文件上传，使用切片上传形式，支持上传、暂停、续传你怎么实现的？" class="headerlink" title="大文件上传，使用切片上传形式，支持上传、暂停、续传你怎么实现的？"></a>大文件上传，使用切片上传形式，支持上传、暂停、续传你怎么实现的？</h3></li></ol><h4 id="1-发现问题"><a href="#1-发现问题" class="headerlink" title="1. 发现问题"></a>1. 发现问题</h4><p>如果前端不使用大文件上传，可能会导致以下问题：</p><ol><li><p><strong>用户体验下降</strong>：如果用户需要上传较大的文件，而前端没有实现大文件上传功能，那么用户上传文件的速度将受到较大的限制，<strong>可能需要等待较长的时间</strong>，这将导致用户体验下降。</p></li><li><p><strong>网络带宽消耗过大</strong>：如果前端没有实现大文件上传功能，那么上传一个大文件将会占用较多的网络带宽，这可能会影响其他用户的网络使用，尤其是在网络资源有限的情况下。</p></li><li><p><strong>上传失败的风险增加</strong>：如果前端没有实现大文件上传功能，那么上传一个大文件的失败概率将会增加。这是因为在上传较大的文件时，<strong>一旦上传失败，需要重新上传整个文件</strong>，这将会浪费大量时间和网络资源。</p></li></ol><p>因此，为了提高用户体验，减少网络资源占用和降低上传失败的风险，前端需要实现大文件上传功能。</p><h4 id="大文件上传-原理-gt-实现思路"><a href="#大文件上传-原理-gt-实现思路" class="headerlink" title="大文件上传(原理 -&gt;实现思路)"></a>大文件上传(原理 -&gt;实现思路)</h4><ol><li>前端上传大文件时使用 <strong>Blob.prototype.slice</strong> 将文件切片，并发上传多个切片，最后发送一个合并的请求通知服务端合并切片</li></ol><p>预先定义好单个切片大小，将文件切分为一个个切片，然后<strong>借助 http 的可并发性，同时上传多个切片</strong>。这样从原本传一个大文件，变成了并发传多个小的文件切片，可以大大减少上传时间.—(HTTP 的可并发性指的是在同一时间内可以同时处理多个 HTTP 请求。HTTP 是一种无状态的协议，每个请求之间都是相互独立的。因此，HTTP 协议天生就具备可并发性，允许客户端在同一时间内向服务器发起多个请求，而服务器也可以同时处理多个请求。)</p><p>另外由于是并发，传输到服务端的顺序可能会发生变化，因此我们<strong>还需要给每个切片记录顺序</strong></p><ul><li>详细<br>（当点击上传按钮时，调用 createFileChunk 将文件切片，切片数量通过文件大小控制，<strong>这里设置 10MB，也就是说一个 100 MB 的文件会被分成 10 个 10MB 的切片</strong><br>createFileChunk 内使用 while 循环和 slice 方法将切片放入 <strong>fileChunkList</strong> 数组中返回</li></ul><p>在生成文件切片时，需要给每个切片一个标识作为 hash，这里暂时使用<strong>文件名 + 下标</strong>，这样<strong>后端可以知道当前切片是第几个切片，用于之后的合并切片</strong></p><p>随后调用 uploadChunks 上传所有的文件切片，将文件切片，切片 hash，以及文件名放入 formData 中，再调用上一步的 request 函数返回一个 proimise，最后<strong>调用 Promise.all 并发上传所有的切片</strong>发送合并请求<br>2. 服务端接收切片并存储，收到合并请求后使用流将切片合并到最终文件<br>3. 原生 XMLHttpRequest 的 upload.onprogress 对切片上传进度的监听<br>4. 使用 Vue 计算属性根据每个切片的进度算出整个文件的上传进度</p><h4 id="断点续传-1"><a href="#断点续传-1" class="headerlink" title="断点续传"></a>断点续传</h4><ul><li>原理<br>断点续传的<strong>原理在于前端/服务端需要记住已上传的切片，这样下次上传就可以跳过之前已上传的部分，有两种方案实现记忆的功能</strong></li></ul><p>前端使用 localStorage 记录已上传的切片 hash<br>服务端保存已上传的切片 hash，前端每次上传前向服务端获取已上传的切片<br>第一种是前端的解决方案，第二种是服务端，而<strong>前端方案有一个缺陷，如果换了个浏览器就失去了记忆的效果，所以这里选后者</strong></p><h5 id="1-使用-spark-md5-根据文件内容算出文件-hash"><a href="#1-使用-spark-md5-根据文件内容算出文件-hash" class="headerlink" title="1. 使用 spark-md5 根据文件内容算出文件 hash"></a>1. <strong>使用 spark-md5 根据文件内容算出文件 hash</strong></h5><p>生成 hash<br>无论是前端还是服务端，都必须要生成文件和切片的 hash，之前我们使用<strong>文件名 + 切片下标作为切片 hash</strong>，这样做文件名<strong>一旦修改就失去了效果，而事实上只要文件内容不变，hash 就不应该变化，所以正确的做法是根据文件内容生成 hash</strong>，所以我们修改一下 hash 的生成规则</p><blockquote><p>webpack 的产物 contenthash 也是基于这个思路实现的</p></blockquote><p>这里用到另一个库 spark-md5，它可以<strong>根据文件内容计算出文件的 hash 值</strong><br>另外考虑到如果上传一个超大文件，读取文件内容计算 hash 是非常耗费时间的，并且会引起 UI 的阻塞，导致页面假死状态，所以我们使用 <strong>web-worker 在 worker 线程计算 hash</strong>，这样用户仍可以在主界面正常的交互</p><h4 id="文件秒传-1"><a href="#文件秒传-1" class="headerlink" title="文件秒传"></a>文件秒传</h4><ol start="2"><li>通过<strong>hash 可以判断服务端是否已经上传该文件</strong>，从而直接提示用户上传成功（秒传）<br>所谓的文件秒传，即在服务端已经存在了上传的资源，所以当用户再次上传时会直接提示上传成功</li></ol><p><strong>文件秒传需要依赖上一步生成的 hash，即在上传前，先计算出文件 hash</strong>，并把 hash 发送给服务端进行验证，由于 hash 的唯一性，所以一旦服务端能找到 hash 相同的文件，则直接返回上传成功的信息即可</p><p>秒传其实就是给用户看的障眼法，实质上根本没有上传<br>服务端的逻辑非常简单，<strong>新增一个验证接口，验证文件是否存在即可</strong></p><h4 id="暂停上传-1"><a href="#暂停上传-1" class="headerlink" title="暂停上传"></a>暂停上传</h4><ol start="3"><li>通过 XMLHttpRequest 的 abort 方法暂停切片的上传<br>讲完了生成 hash 和文件秒传，回到断点续传</li></ol><p>断点续传顾名思义即<strong>断点 + 续传</strong>，所以我们第一步先实现“断点”，也就是暂停上传</p><p>原理是使用 XMLHttpRequest 的 <strong>abort</strong> 方法，可以取消一个 xhr 请求的发送，为此我们需要将上传每个切片的 xhr 对象保存起来，我们再改造一下 request 方法</p><h4 id="恢复上传-1"><a href="#恢复上传-1" class="headerlink" title="恢复上传"></a>恢复上传</h4><ol start="4"><li>上传前服务端返回已经上传的切片名，前端跳过这些切片的上传<br>之前在介绍断点续传的时提到使用第二种服务端存储的方式实现续传</li></ol><p>由于当文件切片上传后，<strong>服务端会建立一个文件夹存储所有上传的切片，所以每次前端上传前可以调用一个接口，服务端将已上传的切片的切片名返回，前端再跳过这些已经上传切片，这样就实现了“续传”的效果</strong></p><p>而这个接口可以和之前秒传的验证接口合并，前端每次上传前发送一个验证的请求，返回两种结果</p><ol><li>服务端已存在该文件，不需要再次上传</li><li>服务端不存在该文件或者已上传部分文件切片，通知前端进行上传，并把已上传的文件切片返回给前端<br>所以我们改造一下之前文件秒传的服务端验证接口</li></ol><h3 id="xxxxx导入财务以及销售报表–大文件上传以及断点续传"><a href="#xxxxx导入财务以及销售报表–大文件上传以及断点续传" class="headerlink" title="xxxxx导入财务以及销售报表–大文件上传以及断点续传"></a>xxxxx导入财务以及销售报表–大文件上传以及断点续传</h3><h4 id="大文件上传-1"><a href="#大文件上传-1" class="headerlink" title="大文件上传"></a>大文件上传</h4><ol><li>将大文件转换成二进制流的格式</li><li>利用流可以切割的属性，将二进制流切割成多份</li><li>组装和分割块同等数量的请求块，并行或串行的形式发出请求</li><li>待我们监听到所有请求都成功发出去以后，再给服务端发出一个合并的信号</li></ol><h4 id="断点续传-2"><a href="#断点续传-2" class="headerlink" title="断点续传"></a>断点续传</h4><ol><li>为每一个文件切割块添加不同的标识hash</li><li>当上传成功的之后，服务器记录上传成功的标识 </li><li>下次继续上传的时候从服务端获取已经上传的文件分片hash 下次上传的时候不需要上传这个分片</li><li>当我们暂停或者发送失败后，可以重新发送没有上传成功的切割文件</li><li>最后全部上传成功还是给服务端发出一个合并的信号–服务器可以清除所有的分片</li><li>这里存在服务器临时存储分片文件过多占用磁盘过大的问题–所以可以设置过期时间定期清除过期的分片 避免资源浪费</li></ol><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6844904046436843527#heading-20">字节跳动面试官：请你实现一个大文件上传和断点续传</a></p>]]></content>
    
    
    <categories>
      
      <category>项目优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>长列表优化之虚拟列表(项目)</title>
    <link href="/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D%E9%95%BF%E5%88%97%E8%A1%A8%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F/"/>
    <url>/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D%E9%95%BF%E5%88%97%E8%A1%A8%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="长列表优化之虚拟列表"><a href="#长列表优化之虚拟列表" class="headerlink" title="长列表优化之虚拟列表"></a>长列表优化之虚拟列表</h2><h4 id="用Vue代码实现上面的问题"><a href="#用Vue代码实现上面的问题" class="headerlink" title="用Vue代码实现上面的问题"></a>用Vue代码实现上面的问题</h4><p>好的，以下是一个使用Vue实现虚拟列表的代码示例：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-container&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;listContainer&quot;</span> @<span class="hljs-attr">scroll</span>=<span class="hljs-string">&quot;handleScroll&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-item&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in visibleItems&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="xml">      </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.text</span> &#125;&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">export default &#123;</span><br><span class="xml">  data() &#123;</span><br><span class="xml">    return &#123;</span><br><span class="xml">      items: [], // 列表数据</span><br><span class="xml">      visibleStartIndex: 0, // 当前可见列表项的起始索引</span><br><span class="xml">      visibleItemCount: 0, // 当前可见列表项的数量</span><br><span class="xml">      itemHeight: 50 // 每个列表项的高度</span><br><span class="xml">    &#125;;</span><br><span class="xml">  &#125;,</span><br><span class="xml">  mounted() &#123;</span><br><span class="xml">    // 模拟异步获取数据</span><br><span class="xml">    this.fetchData().then((data) =&gt; &#123;</span><br><span class="xml">      this.items = data;</span><br><span class="xml">    &#125;);</span><br><span class="xml">  &#125;,</span><br><span class="xml">  computed: &#123;</span><br><span class="xml">    // 计算当前可见列表项</span><br><span class="xml">    visibleItems() &#123;</span><br><span class="xml">      return this.items.slice(</span><br><span class="xml">        this.visibleStartIndex,</span><br><span class="xml">        this.visibleStartIndex + this.visibleItemCount</span><br><span class="xml">      );</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;,</span><br><span class="xml">  methods: &#123;</span><br><span class="xml">    // 处理滚动事件</span><br><span class="xml">    handleScroll() &#123;</span><br><span class="xml">      const scrollTop = this.$refs.listContainer.scrollTop;</span><br><span class="xml">      this.visibleStartIndex = Math.floor(scrollTop / this.itemHeight);</span><br><span class="xml">      this.visibleItemCount = Math.ceil(</span><br><span class="xml">        this.$refs.listContainer.clientHeight / this.itemHeight</span><br><span class="xml">      );</span><br><span class="xml">    &#125;,</span><br><span class="xml">    // 模拟异步获取数据</span><br><span class="xml">    fetchData() &#123;</span><br><span class="xml">      return new Promise((resolve) =&gt; &#123;</span><br><span class="xml">        setTimeout(() =&gt; &#123;</span><br><span class="xml">          const data = [];</span><br><span class="xml">          for (let i = 0; i &lt; 1000; i++) &#123;</span><br><span class="xml">            data.push(&#123;</span><br><span class="xml">              id: i,</span><br><span class="xml">              text: `Item $&#123;i&#125;`</span><br><span class="xml">            &#125;);</span><br><span class="xml">          &#125;</span><br><span class="xml">          resolve(data);</span><br><span class="xml">        &#125;, 1000);</span><br><span class="xml">      &#125;);</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span></span><br><span class="xml">.list-container &#123;</span><br><span class="xml">  height: 500px;</span><br><span class="xml">  overflow-y: scroll;</span><br><span class="xml">&#125;</span><br><span class="xml">.list-item &#123;</span><br><span class="xml">  height: 50px;</span><br><span class="xml">  line-height: 50px;</span><br><span class="xml">  border-bottom: 1px solid #eee;</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这个示例中，我们首先通过fetchData方法模拟异步获取列表数据，然后在mounted生命周期函数中获取数据，并将其保存到items数据属性中。在模板中，我们使用一个v-for指令来动态渲染当前可见的列表项，并使用visibleItems计算属性来计算当前可见的列表项。在handleScroll方法中，我们处理滚动事件，根据滚动条的位置计算出当前可见列表项的起始索引和数量，然后更新visibleStartIndex和visibleItemCount数据属性。最后，我们使用一些简单的样式来设置列表的高度和样式。</p><h3 id="分析需求"><a href="#分析需求" class="headerlink" title="分析需求"></a>分析需求</h3><p>首先，因为同事们对这个列表的长时间的使用已经习惯了，所以<strong>最好在体验上不要进行大的修改</strong>。为此，我需要把之前大概的功能列举出来:</p><ol><li>每次列表有新的消息传入的时候，都要能看到最新的那条数据。</li><li>当用户点击列表中的其中一条数据的时候，列表需要停止更新，也就是停止滚动。</li><li>当列表处于锁定状态，滚动条滚动到最底部的时候，列表恢复自动滚动。</li><li>当列表中有被选中状态的数据时，可以通过上下左右键来让聚焦移动。</li></ol><p>总结完之前的功能之后，我需要再梳理一下我的需求：</p><ol><li>列表随着时间会越来越长，需要控制展示的节点数量。</li><li>列表长度随着WebSocket的通信而增加，数据更新频度过快，需要有缓冲池。</li><li>增加一个列表锁定的提示，可以手动解开列表的锁定。</li><li>移动聚焦的时候会随即展示日志详情，因为移动速度过快，所以需要增加防抖。<br>梳理完成之后，经过考虑我决定使用虚拟列表来代替现有的长列表，这也是踩坑之路的开始。</li></ol><p>开始开发<br>长列表转虚拟列表</p><h4 id="为什么需要虚拟列表"><a href="#为什么需要虚拟列表" class="headerlink" title="为什么需要虚拟列表"></a>为什么需要虚拟列表</h4><p>我们知道，在浏览器渲染页面的时候，当DOM节点的数量越多，每一次重绘的时候，对性能的影响也就越大。</p><p>假如我们需要展示一个信息量很大，<strong>大约有数十万条数据</strong>。遇到这样子的情况，其实现在有许多的方案，我们最常见的方案就类似PC上的下一页、上一页，但是这个方案在体验上其实并不友好。<strong>大部分的用户会比较喜欢不停的向下滚动就可以看到新的内容，但是这个就会遇到一个问题，不停的加载数据，导致页面堆积的节点越来越多，所消耗的内存不断增 大，最后连滚动都会卡顿。</strong></p><p>这时候我们重新分析一下，就会发现其实有很多数据我们大多数情况下是不需要看见的，如果只考虑我们能看到数据的话，其实需要渲染的数据量就会非常的少了，很好的提高了渲染的效率，减少因为大量的重绘照成不必要的影响。<br>这么一梳理一下，答案简直呼之欲出—-虚拟列表。</p><h4 id="什么是虚拟列表"><a href="#什么是虚拟列表" class="headerlink" title="什么是虚拟列表"></a>什么是虚拟列表</h4><p>虚拟列表其实没有什么特别神奇的地方，说白了就是一种展示列表的思路，<strong>在页面上创建一个容器作为可视区，在这个可视区内展示长列表中的一部分</strong>，也就是在可视区渲染列表。</p><p>如图中所示，是一个简单的虚拟列表的模型，图中有几个概念需要大家稍微了解一下：</p><ol><li>可视区。</li><li>真实列表。</li><li>startIndex。</li><li>endIndex。<h4 id="可视区"><a href="#可视区" class="headerlink" title="可视区"></a>可视区</h4>可视区大家可以这么理解，我们现在有一个<code>&lt;div class=&quot;show-box&quot;&gt;</code>，给这个元素加一些样式。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.show-box</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">375px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这个样式我们可以看出这个可视区容器的高度为500px。</p><h4 id="真实列表"><a href="#真实列表" class="headerlink" title="真实列表"></a>真实列表</h4><p>真实列表就是会被渲染出来的列表，这么说可能不太理解，举个栗子：现在需要被渲染出来的列表数量一共有<strong>1000</strong>条，但是实际上在页面需要被渲染的列表数量(需要被看到的数据)只需要100条，<strong>这个100条就是所谓的真实列表</strong>。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">&lt;<span class="hljs-string">div</span> <span class="hljs-string">class</span>=<span class="hljs-string">&quot;list-body-box&quot;</span> @<span class="hljs-string">scroll</span>=<span class="hljs-string">&quot;listScroll&quot;</span>&gt; ----- 真实列表<br>  &lt;<span class="hljs-string">div</span> <span class="hljs-string">class</span>=<span class="hljs-string">&quot;list-body&quot;</span>&gt; ------ 载体<br>  &lt;/<span class="hljs-string">div</span>&gt;<br>&lt;/<span class="hljs-string">div</span>&gt;<br>-------------------------- <span class="hljs-string">style</span> --------------------------------<br>.<span class="hljs-built_in">list-body</span> &#123;<br>  <span class="hljs-string">min-height</span>: <span class="hljs-string">10px</span>;<br>  <span class="hljs-string">position</span>: <span class="hljs-string">absolute</span>;<br>  <span class="hljs-string">width</span>: <span class="hljs-string">100</span>%;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，建议<strong>真实列表的长度需要比可视区的高度长一些</strong>，有一个滚动条的话，之后可以通过scroll监听做一些其他的操作。</p><p>可能有一个点需要和大家解释一下为什么我的<code>&lt;div class=&quot;list-body&quot;&gt;</code>是绝对定位。</p><p>当你的某一个元素会频繁发生变化的时候，最好将这个模块通过绝对定位的方式，脱离文档流，可以减少回流带来的影响。</p><h4 id="我们先看一下浏览器的渲染机制"><a href="#我们先看一下浏览器的渲染机制" class="headerlink" title="我们先看一下浏览器的渲染机制"></a>我们先看一下浏览器的渲染机制</h4><ul><li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li><li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li><li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li><li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li><li>Display:将像素发送给GPU，展示在页面上。</li></ul><p>绝对定位或者浮动脱离了正常的文档流，相当于只是在节点上存放了一个token，然后通过这个token去进行映射，所以如果你采用了绝对定位的方法，也只会对这一块元素进行重绘。 </p><h5 id="startIndex"><a href="#startIndex" class="headerlink" title="startIndex"></a>startIndex</h5><p>之前也说到了，真实列表实际上只是总列表其中很小的一部分，在这之外还有很多列表需要被渲染。因此，大家可以把真实列表理解为一个片段。被渲染的第一个元素的index就是片段中第一个元素在总列表中的位置，也就是数组中的index。</p><p>举个栗子：我的总列表(数组)的长度为1000，而需要渲染的列表片段为100—200，那么这个开始的位置，也就是数组的index则为99。</p><h5 id="edIndex"><a href="#edIndex" class="headerlink" title="edIndex"></a>edIndex</h5><p>解释同上，最后一个元素的index是199。</p><p>虚拟列表的实现<br>这里要提一下，我的框架用的是vue，所以虚拟列表的实现也是比较方便的。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-body-box&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-body&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">templete</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, idx) in list&quot;</span> &gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> </span></span><br><span class="xml">        v-if=&quot;idx &gt;= startIdx &amp;&amp; idx &lt;= endIdx&quot; </span><br><span class="xml">        :key=&quot;idx&quot;</span><br><span class="xml">        class=&quot;list-row&quot;&gt;</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-item col-1&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.col_1</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-item col-2&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.col_2</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-item col-3&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.col_3</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-item col-4&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.col_4</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-item col-5&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.col_5</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-item col-6&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.col_6</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-item col-7&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.col_7</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">templete</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>模板上，没有什么太特别的地方，主要就是<strong>通过v-if去控制列表的展</strong>示，通过startIdx和endIdx的增减，去展示不同位置的数据，<strong>让这两个值递增就可以实现列表滚动</strong>。</p><p>下边我们会说一下自动滚动在代码上的实现，主要是通过一个主动的事件去频繁的触发对startIdx和endIdx递增或者递减。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> time = <span class="hljs-literal">null</span>;<br>...<br><span class="hljs-function"><span class="hljs-title">autoScroll</span>(<span class="hljs-params"></span>)</span>&#123;<br>  time = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">let</span> listLen = <span class="hljs-built_in">this</span>.list.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">this</span>.endIdx = listLen;<br>    <span class="hljs-built_in">this</span>.startIdx = (listLen + <span class="hljs-number">1</span>) &lt;= <span class="hljs-number">100</span> ? <span class="hljs-number">0</span> : listLen - <span class="hljs-number">100</span>;<br>    <span class="hljs-built_in">this</span>.autoScroll();<br>  &#125;,<span class="hljs-number">300</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码所示，我只需要再让一个方法去触发<strong>autoScroll()<strong>，这个方法就会在</strong>setTimeout</strong>的作用下自调用，<strong>startIdx和endIdx</strong>会不断递增列表就可以自动滚动了,在这里边有一个表达式</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">this</span>.startIdx = (listLen + <span class="hljs-number">1</span>) &lt;= <span class="hljs-number">100</span> ? <span class="hljs-number">0</span> : listLen - <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p><strong>这一块的话主要是解决当页面刚打开或者清空列表的时候，实际上列表的长度比较短，是不需要进行滚动的，换句话说，startIndex需要在列表总长度在到达一个值之前一直为0。</strong></p><p>到这里，简单的虚拟列表就实现了。</p><h3 id="WebSocket缓冲池"><a href="#WebSocket缓冲池" class="headerlink" title="WebSocket缓冲池"></a>WebSocket缓冲池</h3><p>我们使用的是WebSocket来传递数据，数据量不少。因此很可能会出现过于频繁更新数据的情况，数据一更新，页面也会随之改变，这样会对性能照成一定的影响。所以我们需要对这个频度进行把控。目前的方案是加一个缓冲池。</p><p> 这缓冲池的思路大概是这样的，WebSocket传递数据的时候，我们把这段时间的数据先存在一个数组中，然后每隔一段时间，比如500ms，再把数据push到完整的列表中，这个方案可能就会涉及到节流。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> socketPool = [];    <span class="hljs-comment">//存储一段时间的数据</span><br><span class="hljs-keyword">let</span> socketTimer;<br>socketFun( <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">//先制造一个缓存区间，用来做缓存socket的数据</span><br>  socketPool.push(data);<br>  <span class="hljs-comment">//每次都把当前的数据进行push到list</span><br>  <span class="hljs-keyword">if</span>(!socketTimer)&#123;<br>    socketTimer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>      <span class="hljs-built_in">this</span>.appendRecord(socketPool);<br>      socketPool.length = <span class="hljs-number">0</span>;<br>      <span class="hljs-built_in">this</span>.scrollToBottom();<br>      socketTimer = <span class="hljs-literal">null</span>;<br>    &#125;,<span class="hljs-number">500</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这里边 <strong>appendRecord()</strong> 是用来处理数据，并且把数据放入list中的方法，而 <strong>scrollToBottom()</strong> 就是为了当数据push到list之后，列表能直接展示最新的数据，也就是让页面滚动到列表的最底部。</p><p>缓冲池其实也是提升性能的一个方案，<strong>这个方案最核心的地方</strong>就是<strong>减少页面渲染的次数</strong>。大家可以这么理解：每秒钟可能会有10条数据需要被渲染，假如我每次都老老实实的渲染，那么10秒的时间我就要渲染10次，其实是没有必要的，因此我们可以考虑每2秒渲染一次，这样10s的时间内我的渲染次数就会减少到5次。<strong>你可以理解为性能提升了一倍</strong>。 </p><h4 id="列表锁定"><a href="#列表锁定" class="headerlink" title="列表锁定"></a>列表锁定</h4><p>按照之前的需求，当用户点击列表中的其中一条数据的时候，列表是需要停止滚动的。所以我加了一个滚动锁<strong>autoScrollLoack</strong>，<strong>这个锁的作用就是当我点击到列表中的某一条的时候，执行autoScrollLoack = true页面就不会滚动了</strong>。这个锁的判断会放在 <strong>this.scrollToBottom()</strong> 中，代码大家稍微看看就行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">scrollToBottom</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">if</span>(autoScrollLoack)&#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  ...do something<br>&#125;,<br></code></pre></td></tr></table></figure><p>这个<strong>autoScrollLoack</strong>在页面中会与一个单选框进行双向绑定，因此用户就可以通过改变单选框的选中状态来控制锁的状态，其实在有了这个锁之后，页面如果因为需求停止滚动了，用户也能有所感知，不至于突然滚动就停止了，看起来像个bug。</p><h3 id="聚焦移动"><a href="#聚焦移动" class="headerlink" title="聚焦移动"></a>聚焦移动</h3><p>聚焦移动的功能之前需求也说过了，就是选中了一条信息，可以通过上下键将聚焦指向上一个或者下一个，这个其实也比较好实现</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;div <br>  <span class="hljs-attribute">v-for</span>=<span class="hljs-string">&quot;(item, idx) in list&quot;</span> <br>  <span class="hljs-attribute">v-if</span>=<span class="hljs-string">&quot;idx &gt;= startIdx &amp;&amp; idx &lt;= endIdx&quot;</span> <br>  :<span class="hljs-attribute">key</span>=<span class="hljs-string">&quot;item.id&quot;</span><br>  :<span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;&#123;&#x27;active&#x27;:curIdx==idx&#125;&quot;</span><br>  <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;list-row&quot;</span><br>  @<span class="hljs-attribute">click</span>=<span class="hljs-string">&quot;showDetail(item.id)&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>在这里，大家可以看到，active就是聚焦的时候列表的样式。在逻辑上，把当前选中项的index赋给curIndex，前端模板上通过vue对class的绑定来控制样式，判断条件就是curIndex == index。</p><p>聚焦功能已经实现了，那么接下来要实现通过键盘中的上下键，实现移动聚焦的效果。这个功能很简单，我们完全可以通过vue提供的监听事件来实现，具体的实现大家可以在官网上搜一下keyup。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;list-body-box&quot;</span> <span class="hljs-meta">@scroll</span>=<span class="hljs-string">&quot;listScroll&quot;</span> <span class="hljs-meta">@keyup</span>=<span class="hljs-string">&quot;moveFocus&quot;</span>&gt;<br>...<br>...<br><span class="hljs-function"><span class="hljs-title">moveFocus</span>(<span class="hljs-params">e</span>)</span>&#123;<br>  <span class="hljs-keyword">let</span> keyCode = <span class="hljs-built_in">Number</span>(e.keyCode);<br>  <span class="hljs-keyword">switch</span>(keyCode)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">38</span>:<br>      <span class="hljs-built_in">this</span>.curIdx -= <span class="hljs-number">1</span>;<br>      <span class="hljs-built_in">this</span>.showDetail();<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">40</span>:<br>      <span class="hljs-built_in">this</span>.curIdx += <span class="hljs-number">1</span>;<br>      <span class="hljs-built_in">this</span>.showDetail();<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>这段代码实现了聚焦的上下挪动。根据需求我们每一次聚焦的时候需要展示聚焦项对应的日志详情，详情是需要发ajax请求来获取的。问题来了，有一个场景：我想通过键盘把当前的聚焦向下挪动10次，在不停聚焦的过程中我会触发10次请求，这个其实没必要，我在<strong>快速移动的过程中，是不care详情的</strong>，我只需要展示目标详情就行了。综上，我们需要再加一个防抖。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> detailTimer;<br><span class="hljs-function"><span class="hljs-title">showDetail</span>(<span class="hljs-params">id</span>)</span>&#123;<br>  <span class="hljs-keyword">if</span>(detailTimer)&#123;<br>    <span class="hljs-built_in">clearTimeout</span>(detailTimer);<br>  &#125;<br>  detailTimer = setTimeOut(<span class="hljs-function">() =&gt;</span> &#123;<br>    $.post(<span class="hljs-string">&#x27;...&#x27;</span>,&#123;<br>      id:id<br>    &#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">do</span> something...  <br>    &#125;);<br>  &#125;,<span class="hljs-number">300</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>从上边的逻辑我们可以看出来，当用户在快速挪动聚焦的时候是不会触发请求的，实际上这个改动很大程度上提升了用户的流畅度。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>计算可见列表项：首先，我需要计算当前可见的列表项数量和位置。这可以通过测量列表容器和列表项高度，以及滚动条的位置来实现。</p></li><li><p>动态渲染列表项：接下来，我需要根据当前可见的列表项数量和位置，动态地渲染这些列表项。这可以通过使用一个v-for指令来实现，只渲染当前可见的列表项。</p></li><li><p>优化性能：为了优化性能，我可以使用一些技巧，例如使用keep-alive缓存列表项，避免不必要的渲染，或使用Vue组件的生命周期钩子函数来处理列表项的渲染和销毁，以提高性能。</p></li><li><p>处理滚动事件：当用户滚动列表时，我需要根据滚动条的位置，重新计算当前可见的列表项，并相应地更新列表。这可以通过添加滚动事件监听器来实现。</p></li><li><p>处理列表项点击事件：最后，我需要处理列表项的点击事件。由于虚拟列表只渲染了当前可见的列表项，所以我需要确保只为当前可见的列表项添加事件处理程序，以避免不必要的性能开销。</p></li></ol><p>总之，实现虚拟列表需要一定的计算和渲染技巧，需要注意性能优化和细节处理，可以借助第三方库来提高开发效率。当回答这个问题时，我需要清晰地表达我的思路和实现方案，注重细节和实现的可行性，并尽可能展示我的Vue编程技能和经验。</p><h3 id="文章长列表优化这一块讲讲是怎么做的？"><a href="#文章长列表优化这一块讲讲是怎么做的？" class="headerlink" title="文章长列表优化这一块讲讲是怎么做的？"></a>文章长列表优化这一块讲讲是怎么做的？</h3><ol><li> 发现问题</li><li> 解决问题  （原理 -&gt;实现思路） <h4 id="1-发现问题"><a href="#1-发现问题" class="headerlink" title="1. 发现问题"></a>1. 发现问题</h4></li></ol><p>项目中文档分析模块显示的文档长列表会卡顿（如果数据量大的较大<strong>大约有数十万条数据</strong>，直接渲染所有数据会导致页面加载缓慢、卡顿等问题）–（performance查看可以看到执行栈task-帧执行（正常15ms,超过60ms））—-长列表是指<strong>包含大量数据项的列表</strong>，如果在渲染这些数据项时没有进行优化，则会导致应用程序变慢并占用更多的系统资源，从而影响用户体验。因此，需要对长列表进行优化。</p><h5 id="2-解决问题"><a href="#2-解决问题" class="headerlink" title="2. 解决问题"></a>2. 解决问题</h5><p>优化的方法包括使用<strong>虚拟列表、懒加载、分页、无限滚动</strong>等技术。</p><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><ul><li>简要解释虚拟列表的<strong>概念和原理</strong>：虚拟列表是一种在<strong>渲染大型列表</strong>时非常有效的优化技术，<strong>它只会渲染可见的列表项，而不会渲染整个列表</strong>。它的原理是<strong>通过监听列表的滚动事件</strong>，在用户滚动列表时动态地渲染新出现的列表项，并销毁已经滚出视图的列表项，从而避免了长列表中大量无用数据的渲染和占用内存资源。</li></ul><h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><h6 id="讲解虚拟列表的优点：虚拟列表的主要优点包括："><a href="#讲解虚拟列表的优点：虚拟列表的主要优点包括：" class="headerlink" title="讲解虚拟列表的优点：虚拟列表的主要优点包括："></a>讲解虚拟列表的优点：虚拟列表的主要优点包括：</h6><p>优化性能：虚拟列表可以极大地减少在渲染长列表时的开销，从而提高应用程序的性能和响应速度。<br>节省内存：虚拟列表只渲染可见的列表项，而不会渲染整个列表，因此可以节省内存资源。<br>支持无限滚动：虚拟列表可以支持无限滚动，用户可以不断向下滚动列表，而不必等待整个列表渲染完成。<br>支持异步数据加载：虚拟列表可以与异步数据加载技术结合使用，当用户滚动到新的列表区域时，可以异步地加载数据并渲染新的列表项。<br>说明虚拟列表的缺点：虚拟列表的主要缺点是在实现时需要更多的代码复杂度和技术要求。特别是需要进行高级优化时，可能需要进行更多的计算和代码调试。此外，虚拟列表在处理动态高度的列表项时可能会存在一些问题，需要进行更多的测试和优化。</p><h5 id="面试问你为什么这里使用虚拟列表而不使用懒加载、分页、无限滚动该怎么回答呢"><a href="#面试问你为什么这里使用虚拟列表而不使用懒加载、分页、无限滚动该怎么回答呢" class="headerlink" title="面试问你为什么这里使用虚拟列表而不使用懒加载、分页、无限滚动该怎么回答呢"></a>面试问你为什么这里使用虚拟列表而不使用懒加载、分页、无限滚动该怎么回答呢</h5><ol><li><p>虚拟列表可以提升用户体验：虚拟列表可以在页面上显示一定数量的列表项，而不会导致整个页面的渲染和布局都被阻塞。因此，当用户在列表中滚动时，新的列表项会被动态加载，而不会导致页面的重新渲染，从而提升了用户的体验。相比之下，<strong>懒加载、分页、无限滚动的加载方式可能会导致页面闪烁或整体布局变化，用户体验相对较差。</strong></p></li><li><p>虚拟列表可以提高页面性能：由于虚拟列表只会渲染当前可视区域内的列表项，因此可以大大降低页面的渲染负担，提高页面的性能。相比之下，<strong>懒加载、分页、无限滚动的加载方式可能会导致不必要的DOM操作和数据绑定，从而影响页面性能。</strong></p></li><li><p>虚拟列表适用于大数据量的列表展示：当需要在页面上展示大量数据时，虚拟列表是一种非常适用的方式。相比之下，<strong>懒加载、分页、无限滚动的加载方式通常只适用于数据量较小的列表展示，因为这些方式需要预先加载所有数据，并在用户滚动到相应位置时再进行渲染。</strong></p></li></ol><p>综上所述，虚拟列表相比于懒加载、分页、无限滚动具有更好的用户体验和页面性能，并且<strong>适用于大数据量的列表展示</strong>。因此，当需要在Web应用中展示大量数据时，使用虚拟列表是一种非常优秀的解决方案。</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6844903893441183751">长列表优化之虚拟列表</a></p>]]></content>
    
    
    <categories>
      
      <category>项目优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何中断已经发出去的请求&amp;&amp;大文件上传处理（项目）</title>
    <link href="/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    <url>/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p>总结了最近的一些面试题和之前的知识点</p><hr><h3 id="Axios-如何取消重复请求？"><a href="#Axios-如何取消重复请求？" class="headerlink" title="Axios 如何取消重复请求？"></a>Axios 如何取消重复请求？</h3><p>在 Web 项目开发过程中，我们经常会遇到重复请求的场景，如果系统不对重复的请求进行处理，则可能会导致系统出现各种问题。比如重复的 post 请求可能会导致服务端产生两笔记录。那么重复请求是如何产生的呢？这里我们举 2 个常见的场景：</p><p>假设页面中有一个按钮，用户点击按钮后会发起一个 AJAX 请求。如果未对该按钮进行控制，当用户快速点击按钮时，则会发出重复请求。<br>假设在考试结果查询页面中，用户可以根据 “已通过”、“未通过” 和 “全部” 3 种查询条件来查询考试结果。如果请求的响应比较慢，当用户在不同的查询条件之前快速切换时，就会产生重复请求。</p><h4 id="一、如何取消请求"><a href="#一、如何取消请求" class="headerlink" title="一、如何取消请求"></a>一、如何取消请求</h4><p>Axios 是一个基于 Promise 的 HTTP 客户端，同时支持浏览器和 Node.js 环境。它是一个优秀的 HTTP 客户端，被广泛地应用在大量的 Web 项目中。对于浏览器环境来说，Axios 底层是利用 XMLHttpRequest 对象来发起 HTTP 请求。如果要取消请求的话，我们可以通过调用<strong> XMLHttpRequest 对象上的 abort 方法</strong>来取消请求：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">let xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>xhr.open(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;https://developer.mozilla.org/&quot;</span>, <span class="hljs-literal">true</span>);<br>xhr.send();<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> xhr.abort(), <span class="hljs-number">300</span>);<br></code></pre></td></tr></table></figure><p>而对于 Axios 来说，我们可以通过 Axios 内部提供的<strong> CancelToken </strong>来取消请求：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle">const CancelToken = axios.CancelToken;<br>const <span class="hljs-keyword">source</span> = CancelToken.<span class="hljs-keyword">source</span>();<br><br>axios.post(<span class="hljs-string">&#x27;/user/12345&#x27;</span>, &#123;<br>  name: <span class="hljs-string">&#x27;semlinker&#x27;</span><br>&#125;, &#123;<br>  cancelToken: <span class="hljs-keyword">source</span>.token<br>&#125;)<br><br><span class="hljs-keyword">source</span>.cancel(<span class="hljs-string">&#x27;Operation canceled by the user.&#x27;</span>); <span class="hljs-comment">// 取消请求，参数是可选的</span><br></code></pre></td></tr></table></figure><p>此外，你也可以通过调用 CancelToken 的构造函数来创建 CancelToken，具体如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> CancelToken = axios.CancelToken;<br><span class="hljs-keyword">let</span> cancel;<br><br>axios.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;/user/12345&#x27;</span>, &#123;<br>  cancelToken: <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function">function <span class="hljs-title">executor</span>(<span class="hljs-params">c</span>)</span> &#123;<br>    cancel = c;<br>  &#125;)<br>&#125;);<br><br>cancel(); <span class="hljs-comment">// 取消请求</span><br></code></pre></td></tr></table></figure><p>现在我们已经知道在 Axios 中如何使用 CancelToken 来取消请求了，那么 CancelToken 内部是如何工作的呢？这里我们先记住这个问题，后面揭开 CancelToken 背后的秘密。接下来，我们来分析一下如何判断重复请求。</p><h4 id="二、如何判断重复请求"><a href="#二、如何判断重复请求" class="headerlink" title="二、如何判断重复请求"></a>二、如何判断重复请求</h4><p>当<strong>请求方式、请求 URL 地址和请求参数都一样时，我们就可以认为请求是一样的</strong>。因此在每次发起请求时，我们就可以根据当前请求的请求方式、请求 URL 地址和请求参数来生成一个唯一的 key，同时为每个请求创建一个专属的 CancelToken，然后把 key 和 cancel 函数以键值对的形式保存到 Map 对象中，使用 Map 的好处是可以快速的判断是否有重复的请求：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">import qs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;qs&#x27;</span><br><br><span class="hljs-keyword">const</span> pendingRequest = <span class="hljs-keyword">new</span> Map();<br><span class="hljs-comment">// GET -&gt; params；POST -&gt; data</span><br><span class="hljs-keyword">const</span> requestKey = [<span class="hljs-function"><span class="hljs-keyword">method</span>, <span class="hljs-title">url</span>, <span class="hljs-title">qs</span>.<span class="hljs-title">stringify</span><span class="hljs-params">(<span class="hljs-keyword">params</span>)</span>, <span class="hljs-title">qs</span>.<span class="hljs-title">stringify</span><span class="hljs-params">(data)</span>].<span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-string">&#x27;&amp;&#x27;</span>)</span>;</span> <br><span class="hljs-keyword">const</span> cancelToken = <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">executor</span><span class="hljs-params">(cancel)</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">  if(!pendingRequest.has(requestKey))&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">    pendingRequest.set(requestKey, cancel);</span></span><br><span class="hljs-function"><span class="hljs-comment">  &#125;</span></span><br><span class="hljs-function">&#125;)</span><br></code></pre></td></tr></table></figure><p>当出现重复请求的时候，我们就可以使用 cancel 函数来取消前面已经发出的请求，在取消请求之后，我们还需要把取消的请求从<strong> pendingRequest</strong> 中移除。现在我们已经知道如何取消请求和如何判断重复请求，下面我们来介绍如何取消重复请求。</p><h4 id="三、如何取消重复请求"><a href="#三、如何取消重复请求" class="headerlink" title="三、如何取消重复请求"></a>三、如何取消重复请求</h4><p>因为我们需要对所有的请求都进行处理，所以我们可以考虑使用 Axios 的拦截器机制来实现取消重复请求的功能。Axios 为开发者提供了请求拦截器和响应拦截器，它们的作用如下：</p><ol><li>请求拦截器：该类拦截器的作用是在请求发送前统一执行某些操作，比如在请求头中添加 token 字段。</li><li>响应拦截器：该类拦截器的作用是在接收到服务器响应后统一执行某些操作，比如发现响应状态码为 401 时，自动跳转到登录页。</li></ol><p><img src="/imageO/Cancle.jpg" alt="流程"></p><h4 id="四、CancelToken-的工作原理"><a href="#四、CancelToken-的工作原理" class="headerlink" title="四、CancelToken 的工作原理"></a>四、CancelToken 的工作原理</h4><p>在前面的示例中，我们是通过调用 CancelToken 构造函数来创建 CancelToken 对象：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> axios.CancelToken(<span class="hljs-function"><span class="hljs-params">(cancel)</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (!pendingRequest.has(requestKey)) &#123;<br>    pendingRequest.set(requestKey, cancel);<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>所以接下来，我们来分析 CancelToken 构造函数，该函数被定义在 lib/cancel/CancelToken.js 文件中：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// lib/cancel/CancelToken.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">CancelToken(<span class="hljs-params">executor</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (typeof executor !== &#x27;<span class="hljs-keyword">function</span>&#x27;) &#123;<br>    throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">TypeError(&#x27;<span class="hljs-params">executor</span> <span class="hljs-params">must</span> <span class="hljs-params">be</span> <span class="hljs-params">a</span> <span class="hljs-params">function</span>.&#x27;)</span>;<br>  &#125;<br><br>  var resolvePromise;<br>  this.promise = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span> <span class="hljs-params">promiseExecutor</span>(<span class="hljs-params">resolve</span>)</span> &#123;<br>    resolvePromise = resolve;<br>  &#125;);<br><br>  var token = this;<br>  executor(<span class="hljs-keyword">function</span> cancel(message) &#123; <span class="hljs-comment">// 设置cancel对象</span><br>    <span class="hljs-keyword">if</span> (token.reason) &#123;<br>      return; <span class="hljs-comment">// Cancellation has already been requested</span><br>    &#125;<br>    token.reason = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Cancel(<span class="hljs-params">message</span>)</span>;<br>    resolve<span class="hljs-constructor">Promise(<span class="hljs-params">token</span>.<span class="hljs-params">reason</span>)</span>;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>由以上代码可知，cancel 对象是一个函数，当我们调用该函数后，会创建 Cancel 对象并调用 resolvePromise 方法。该方法执行后，CancelToken 对象上 promise 属性所指向的 promise 对象的状态将变为 resolved。那么这样做的目的是什么呢？这里我们从 lib/adapters/xhr.js 文件中找到了答案：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> lib<span class="hljs-regexp">/adapters/</span>xhr.js <br><span class="hljs-keyword">if</span> (config.cancelToken) &#123;<br>  config.cancelToken.promise.then(<span class="hljs-keyword">function</span> onCanceled(cancel) &#123;<br>    <span class="hljs-keyword">if</span> (!request) &#123; return; &#125;<br>    request.abort(); <span class="hljs-regexp">//</span> 取消请求<br>    reject(cancel);<br>    request = null;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/imageO/Token.jpg" alt="流程"><br>本文介绍了在 Axios 中如何取消重复请求及 CancelToken 的工作原理，需要注意的是已取消的请求可能已经达到服务端，针对这种情形，服务端的对应接口需要进行幂等控制</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6955610207036801031#heading-8">Axios 如何取消重复请求？</a></p><h3 id="前端上传大文件怎么处理"><a href="#前端上传大文件怎么处理" class="headerlink" title="前端上传大文件怎么处理"></a>前端上传大文件怎么处理</h3><p>背景<br>当我们在做文件的导入功能的时候,如果导入的文件过大,可能会导所需要的时间够长,且失败后需要重新上传,我们需要前后端结合的方式解决这个问题</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们需要做几件事情如下:</p><ol><li><strong>对文件做切片</strong>,即将一个请求拆分成多个请求，每个请求的时间就会缩短，且如果某个请求失败，只需要重新发送这一次请求即可，无需从头开始</li><li><strong>通知服务器合并切片</strong>,在上传完切片后,前端通知服务器做合并切片操作</li><li><strong>控制多个请求的并发量</strong>,防止多个请求同时发送,造成浏览器内存溢出,导致页面卡死</li><li><strong>做断点续传</strong>,当多个请求中有请求发送失败,例如出现网络故障、页面关闭等,我们得对失败的请求做处理,让它们重复发送</li></ol><h5 id="步骤1-切片-合并切片"><a href="#步骤1-切片-合并切片" class="headerlink" title="步骤1-切片,合并切片"></a>步骤1-切片,合并切片</h5><p>在JavaScript中，<strong>文件FIle对象是Blob对象的子类，Blob对象包含一个重要的方法slice通过这个方法</strong>，我们就可以对二进制文件进行拆分,具体代码如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=s, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.24.0/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fileInput&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uploadBtn&quot;</span>&gt;</span>上传<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-comment">// 请求基准地址</span></span><br><span class="javascript">axios.defaults.baseURL = <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span></span><br><span class="javascript"><span class="hljs-comment">// 选中的文件</span></span><br><span class="javascript"><span class="hljs-keyword">var</span> file = <span class="hljs-literal">null</span></span><br><span class="javascript"><span class="hljs-comment">// 选择文件</span></span><br><span class="javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;fileInput&#x27;</span>).onchange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">&#123;target: &#123;files&#125;&#125;</span>)</span>&#123;</span><br>    file = files[0]<br>&#125;<br><span class="javascript"><span class="hljs-comment">// 开始上传</span></span><br><span class="javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;uploadBtn&#x27;</span>).onclick = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">if</span> (!file) <span class="hljs-keyword">return</span></span><br><span class="javascript">    <span class="hljs-comment">// 创建切片</span></span><br><span class="javascript">    <span class="hljs-comment">// let size = 1024 *1024* 10 //10MB 切片大小</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> size = <span class="hljs-number">1024</span> *<span class="hljs-number">50</span>  <span class="hljs-comment">//50KB 切片大小</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> fileChunks = []</span><br><span class="javascript">    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span> <span class="hljs-comment">//切片序号</span></span><br><span class="javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> cur = <span class="hljs-number">0</span>; cur &lt; file.size; cur += size)&#123;</span><br>        fileChunks.push(&#123;<br>            hash: index++,<br>            chunk: file.slice(cur, cur + size)<br>        &#125;)<br>    &#125;<br><span class="javascript">    <span class="hljs-comment">// 上传切片</span></span><br><span class="javascript">    <span class="hljs-keyword">const</span> uploadList = fileChunks.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> formData = <span class="hljs-keyword">new</span> FormData()</span><br><span class="javascript">        formData.append(<span class="hljs-string">&#x27;filename&#x27;</span>, file.name)</span><br><span class="javascript">        formData.append(<span class="hljs-string">&#x27;hash&#x27;</span>, item.hash)</span><br><span class="javascript">        formData.append(<span class="hljs-string">&#x27;chunk&#x27;</span>, item.chunk)</span><br><span class="javascript">        <span class="hljs-keyword">return</span> axios(&#123;</span><br><span class="javascript">            method: <span class="hljs-string">&#x27;post&#x27;</span>,</span><br><span class="javascript">            url: <span class="hljs-string">&#x27;/upload&#x27;</span>,</span><br>            data: formData<br>        &#125;)<br>    &#125;)<br><span class="javascript">    <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(uploadList)</span><br><span class="javascript">    <span class="hljs-comment">// 合并切片</span></span><br><span class="javascript">    <span class="hljs-keyword">await</span> axios(&#123;</span><br><span class="javascript">        method: <span class="hljs-string">&#x27;get&#x27;</span>,</span><br><span class="javascript">        url: <span class="hljs-string">&#x27;/merge&#x27;</span>,</span><br>        params: &#123;<br>            filename: file.name<br>        &#125;<br>    &#125;);<br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;上传完成&#x27;</span>)</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="步骤2-并发控制"><a href="#步骤2-并发控制" class="headerlink" title="步骤2-并发控制"></a>步骤2-并发控制</h5><p>结合<strong>Promise.race和异步函数</strong>实现,多个请求同时并发的数量,防止浏览器内存溢出,具体代码如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=s, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.24.0/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fileInput&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uploadBtn&quot;</span>&gt;</span>上传<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-comment">// 请求基准地址</span></span><br><span class="javascript">axios.defaults.baseURL = <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span></span><br><span class="javascript"><span class="hljs-comment">// 选中的文件</span></span><br><span class="javascript"><span class="hljs-keyword">var</span> file = <span class="hljs-literal">null</span></span><br><span class="javascript"><span class="hljs-comment">// 选择文件</span></span><br><span class="javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;fileInput&#x27;</span>).onchange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">&#123;target: &#123;files&#125;&#125;</span>)</span>&#123;</span><br>    file = files[0]<br>&#125;<br><span class="javascript"><span class="hljs-comment">// 开始上传</span></span><br><span class="javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;uploadBtn&#x27;</span>).onclick = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">if</span> (!file) <span class="hljs-keyword">return</span></span><br><span class="javascript">    <span class="hljs-comment">// 创建切片</span></span><br><span class="javascript"><span class="hljs-comment">// let size = 1024*1024*10; //10MB 切片大小</span></span><br><span class="javascript"><span class="hljs-keyword">let</span> size = <span class="hljs-number">1024</span>*<span class="hljs-number">50</span> <span class="hljs-comment">//50KB 切片大小</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> fileChunks = []</span><br><span class="javascript">    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span> <span class="hljs-comment">//切片序号</span></span><br><span class="javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> cur = <span class="hljs-number">0</span>; cur &lt; file.size; cur += size)&#123;</span><br>        fileChunks.push(&#123;<br>            hash: index++,<br>            chunk: file.slice(cur, cur + size)<br>        &#125;);<br>    &#125;<br><span class="javascript">    <span class="hljs-comment">// 控制并发</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> pool = []<span class="hljs-comment">//并发池</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> max = <span class="hljs-number">3</span> <span class="hljs-comment">//最大并发量</span></span><br><span class="javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;fileChunks.length;i++)&#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> item = fileChunks[i]</span><br><span class="javascript">        <span class="hljs-keyword">let</span> formData = <span class="hljs-keyword">new</span> FormData()</span><br><span class="javascript">        formData.append(<span class="hljs-string">&#x27;filename&#x27;</span>, file.name)</span><br><span class="javascript">        formData.append(<span class="hljs-string">&#x27;hash&#x27;</span>, item.hash)</span><br><span class="javascript">        formData.append(<span class="hljs-string">&#x27;chunk&#x27;</span>, item.chunk)</span><br><span class="javascript">        <span class="hljs-comment">// 上传切片</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> task = axios(&#123;</span><br><span class="javascript">            method: <span class="hljs-string">&#x27;post&#x27;</span>,</span><br><span class="javascript">            url: <span class="hljs-string">&#x27;/upload&#x27;</span>,</span><br>            data: formData<br>        &#125;)<br><span class="javascript">        task.then(<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span>&#123;</span><br><span class="javascript">            <span class="hljs-comment">//请求结束后将该Promise任务从并发池中移除</span></span><br><span class="javascript">            <span class="hljs-keyword">let</span> index = pool.findIndex(<span class="hljs-function"><span class="hljs-params">t</span>=&gt;</span> t===task)</span><br>            pool.splice(index)<br>        &#125;)<br>        pool.push(task)<br>        if(pool.length === max)&#123;<br><span class="javascript">            <span class="hljs-comment">//每当并发池跑完一个任务，就再塞入一个任务</span></span><br><span class="javascript">            <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.race(pool)</span><br>        &#125;<br>    &#125;<br><span class="javascript">    <span class="hljs-comment">//所有任务完成,合并切片</span></span><br><span class="javascript">    <span class="hljs-keyword">await</span> axios(&#123;</span><br><span class="javascript">        method: <span class="hljs-string">&#x27;get&#x27;</span>,</span><br><span class="javascript">        url: <span class="hljs-string">&#x27;/merge&#x27;</span>,</span><br>        params: &#123;<br>            filename: file.name<br>        &#125;<br>    &#125;);<br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;上传完成&#x27;</span>)</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="步骤3-断点续传"><a href="#步骤3-断点续传" class="headerlink" title="步骤3-断点续传"></a>步骤3-断点续传</h5><p>在单个请求失败后,触发<strong>catch</strong>的方法的时候,讲当前请求放到失败列表中,在本轮请求完成后,重复对失败请求做处理,具体代码如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=s, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.24.0/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fileInput&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uploadBtn&quot;</span>&gt;</span>上传<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-comment">// 请求基准地址</span></span><br><span class="javascript">axios.defaults.baseURL = <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span></span><br><span class="javascript"><span class="hljs-comment">// 选中的文件</span></span><br><span class="javascript"><span class="hljs-keyword">var</span> file = <span class="hljs-literal">null</span></span><br><span class="javascript"><span class="hljs-comment">// 选择文件</span></span><br><span class="javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;fileInput&#x27;</span>).onchange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">&#123;target: &#123;files&#125;&#125;</span>)</span>&#123;</span><br>    file = files[0]<br>&#125;<br><span class="javascript"><span class="hljs-comment">// 开始上传</span></span><br><span class="javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;uploadBtn&#x27;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">if</span> (!file) <span class="hljs-keyword">return</span>;</span><br><span class="javascript">    <span class="hljs-comment">// 创建切片</span></span><br><span class="javascript"><span class="hljs-comment">// let size = 1024*1024*10; //10MB 切片大小</span></span><br><span class="javascript"><span class="hljs-keyword">let</span> size = <span class="hljs-number">1024</span>* <span class="hljs-number">50</span>; <span class="hljs-comment">//50KB 切片大小</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> fileChunks = [];</span><br><span class="javascript">    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span> <span class="hljs-comment">//切片序号</span></span><br><span class="javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> cur = <span class="hljs-number">0</span>; cur &lt; file.size; cur += size)&#123;</span><br>        fileChunks.push(&#123;<br>            hash: index++,<br>            chunk: file.slice(cur, cur + size)<br>        &#125;)<br>    &#125;<br><span class="javascript">    <span class="hljs-comment">// 控制并发和断点续传</span></span><br><span class="javascript">    <span class="hljs-keyword">const</span> uploadFileChunks = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">list</span>)</span>&#123;</span><br>        if(list.length === 0)&#123;<br><span class="javascript">            <span class="hljs-comment">//所有任务完成,合并切片</span></span><br><span class="javascript">            <span class="hljs-keyword">await</span> axios(&#123;</span><br><span class="javascript">                method: <span class="hljs-string">&#x27;get&#x27;</span>,</span><br><span class="javascript">                url: <span class="hljs-string">&#x27;/merge&#x27;</span>,</span><br>                params: &#123;<br>                    filename: file.name<br>                &#125;<br>            &#125;);<br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;上传完成&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-keyword">return</span></span><br>        &#125;<br><span class="javascript">        <span class="hljs-keyword">let</span> pool = []<span class="hljs-comment">//并发池</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> max = <span class="hljs-number">3</span> <span class="hljs-comment">//最大并发量</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> finish = <span class="hljs-number">0</span><span class="hljs-comment">//完成的数量</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> failList = []<span class="hljs-comment">//失败的列表</span></span><br><span class="javascript">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;list.length;i++)&#123;</span><br><span class="javascript">            <span class="hljs-keyword">let</span> item = list[i]</span><br><span class="javascript">            <span class="hljs-keyword">let</span> formData = <span class="hljs-keyword">new</span> FormData()</span><br><span class="javascript">            formData.append(<span class="hljs-string">&#x27;filename&#x27;</span>, file.name)</span><br><span class="javascript">            formData.append(<span class="hljs-string">&#x27;hash&#x27;</span>, item.hash)</span><br><span class="javascript">            formData.append(<span class="hljs-string">&#x27;chunk&#x27;</span>, item.chunk)</span><br><span class="javascript">            <span class="hljs-comment">// 上传切片</span></span><br><span class="javascript">            <span class="hljs-keyword">let</span> task = axios(&#123;</span><br><span class="javascript">                method: <span class="hljs-string">&#x27;post&#x27;</span>,</span><br><span class="javascript">                url: <span class="hljs-string">&#x27;/upload&#x27;</span>,</span><br>                data: formData<br>            &#125;)<br><span class="javascript">            task.then(<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span>&#123;</span><br><span class="javascript">                <span class="hljs-comment">//请求结束后将该Promise任务从并发池中移除</span></span><br><span class="javascript">                <span class="hljs-keyword">let</span> index = pool.findIndex(<span class="hljs-function"><span class="hljs-params">t</span>=&gt;</span> t===task)</span><br>                pool.splice(index)<br><span class="javascript">            &#125;).catch(<span class="hljs-function">()=&gt;</span>&#123;</span><br>                failList.push(item)<br><span class="javascript">            &#125;).finally(<span class="hljs-function">()=&gt;</span>&#123;</span><br>                finish++<br><span class="javascript">                <span class="hljs-comment">//所有请求都请求完成</span></span><br>                if(finish===list.length)&#123;<br>                    uploadFileChunks(failList)<br>                &#125;<br>            &#125;)<br>            pool.push(task)<br>            if(pool.length === max)&#123;<br><span class="javascript">                <span class="hljs-comment">//每当并发池跑完一个任务，就再塞入一个任务</span></span><br><span class="javascript">                <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.race(pool)</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    uploadFileChunks(fileChunks)<br><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><h5 id="步骤1-安装依赖"><a href="#步骤1-安装依赖" class="headerlink" title="步骤1.安装依赖"></a>步骤1.安装依赖</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> i express@<span class="hljs-number">4</span>.<span class="hljs-number">17</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">npm</span> i multiparty@<span class="hljs-number">4</span>.<span class="hljs-number">2</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h6 id="步骤2-接口实现"><a href="#步骤2-接口实现" class="headerlink" title="步骤2.接口实现"></a>步骤2.接口实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> multiparty = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;multiparty&#x27;</span>)<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> &#123; Buffer &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;buffer&#x27;</span>)<br><span class="hljs-comment">// 上传文件最终路径</span><br><span class="hljs-keyword">const</span> STATIC_FILES = path.join(__dirname, <span class="hljs-string">&#x27;./static/files&#x27;</span>)<br><span class="hljs-comment">// 上传文件临时路径</span><br><span class="hljs-keyword">const</span> STATIC_TEMPORARY = path.join(__dirname, <span class="hljs-string">&#x27;./static/temporary&#x27;</span>)<br><span class="hljs-keyword">const</span> server = express()<br><span class="hljs-comment">// 静态文件托管</span><br>server.use(express.static(path.join(__dirname, <span class="hljs-string">&#x27;./dist&#x27;</span>)))<br><span class="hljs-comment">// 切片上传的接口</span><br>server.post(<span class="hljs-string">&#x27;/upload&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> form = <span class="hljs-keyword">new</span> multiparty.Form();<br>    form.parse(req, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, fields, files</span>) </span>&#123;<br>        <span class="hljs-keyword">let</span> filename = fields.filename[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">let</span> hash = fields.hash[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">let</span> chunk = files.chunk[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">let</span> dir = <span class="hljs-string">`<span class="hljs-subst">$&#123;STATIC_TEMPORARY&#125;</span>/<span class="hljs-subst">$&#123;filename&#125;</span>`</span><br>        <span class="hljs-comment">// console.log(filename, hash, chunk)</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (!fs.existsSync(dir)) fs.mkdirSync(dir)<br>            <span class="hljs-keyword">const</span> buffer = fs.readFileSync(chunk.path)<br>            <span class="hljs-keyword">const</span> ws = fs.createWriteStream(<span class="hljs-string">`<span class="hljs-subst">$&#123;dir&#125;</span>/<span class="hljs-subst">$&#123;hash&#125;</span>`</span>)<br>            ws.write(buffer)<br>            ws.close()<br>            res.send(<span class="hljs-string">`<span class="hljs-subst">$&#123;filename&#125;</span>-<span class="hljs-subst">$&#123;hash&#125;</span> 切片上传成功`</span>)<br>        &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>            <span class="hljs-built_in">console</span>.error(error)<br>            res.status(<span class="hljs-number">500</span>).send(<span class="hljs-string">`<span class="hljs-subst">$&#123;filename&#125;</span>-<span class="hljs-subst">$&#123;hash&#125;</span> 切片上传失败`</span>)<br>        &#125;<br>    &#125;)<br>&#125;)<br><span class="hljs-comment">//合并切片接口</span><br>server.get(<span class="hljs-string">&#x27;/merge&#x27;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> &#123; filename &#125; = req.query<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">const</span> bufferList = fs.readdirSync(<span class="hljs-string">`<span class="hljs-subst">$&#123;STATIC_TEMPORARY&#125;</span>/<span class="hljs-subst">$&#123;filename&#125;</span>`</span>).map(<span class="hljs-function">(<span class="hljs-params">hash,index</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">const</span> buffer = fs.readFileSync(<span class="hljs-string">`<span class="hljs-subst">$&#123;STATIC_TEMPORARY&#125;</span>/<span class="hljs-subst">$&#123;filename&#125;</span>/<span class="hljs-subst">$&#123;index&#125;</span>`</span>)<br>            len += buffer.length<br>            <span class="hljs-keyword">return</span> buffer<br>        &#125;);<br>        <span class="hljs-comment">//合并文件</span><br>        <span class="hljs-keyword">const</span> buffer = Buffer.concat(bufferList, len);<br>        <span class="hljs-keyword">const</span> ws = fs.createWriteStream(<span class="hljs-string">`<span class="hljs-subst">$&#123;STATIC_FILES&#125;</span>/<span class="hljs-subst">$&#123;filename&#125;</span>`</span>)<br>        ws.write(buffer);<br>        ws.close();<br>        res.send(<span class="hljs-string">`切片合并完成`</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-built_in">console</span>.error(error);<br>    &#125;<br>&#125;)<br><br>server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;http://localhost:3000/&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h5><p>如果使用腾讯云或阿里云文件上传的服务,它们提供了npm库,例如腾讯云的cos-js-sdk-v5,它自身提供的切片相关的配置</p><h5 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/7053658552472174605#heading-7">前端上传大文件怎么处理</a></p>]]></content>
    
    
    <categories>
      
      <category>项目优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组件库按需加载原理分析&amp;&amp; Vue3中提到的Tree-shaking</title>
    <link href="/2022/03/27/%E7%BB%84%E4%BB%B6%E5%BA%93%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <url>/2022/03/27/%E7%BB%84%E4%BB%B6%E5%BA%93%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>在使用 vant、element-ui、ant-design 等 UI 组件库时候会用到按需加载，通过 <a href="https://github.com/ant-design/babel-plugin-import">babel-plugin-import</a> 插件可以快速配置好自动按需加载组件，还可以通过直接手动引入对应组件和样式文件的方式来实现。同时，在开发中使用 webpack 构建项目时也常使用懒加载技术，本文所述的组件库动态加载和 webpack 构建项目的懒加载是不同的。本文将以 babel-plugin-import 插件为主，讲解组件库按需加载方案的实现原理。</p><hr><h3 id="对比-webpack-懒加载"><a href="#对比-webpack-懒加载" class="headerlink" title="对比 webpack 懒加载"></a>对比 webpack 懒加载</h3><p><strong>组件库按需加载：</strong> 组件库以组件为基本单位产出 js、css、less 文件，借助插件或者部分引入的写法，使得项目代码或 babel 编译后的代码中只包含使用到的组件的 js、css、less 等。<br><img src="/imageO/Webpack1.jpg" alt="组件库"><br><strong>webpack 懒加载：</strong> webpack 将源码中的 import、require 引入的文件编译之后再根据动态加载语法配置（通常以页面路由为基本单位）将较大的代码拆分并构建出较小的 chunk 包，应用在运行时执行到相应业务逻辑时才去加载执行对应 chunk 代码。 webpack 懒加载主要发生在下图的 JS 拆分出不同的 Chunk 这一过程中。<br><img src="/imageO/Webpack2.jpg" alt="组件库"><br>可见，两者的差别主要在于：</p><blockquote><p>两者执行时机不同，组件库按需加载是在源码编写阶段或者 babel 编译 js 阶段，而 webpack 懒加载则是在构建生成打包产物时，组件库按需加载在前，webpack 懒加载在后；</p></blockquote><blockquote><p>两者原理不同，组件库按需加载是在源码阶段就去掉了无关代码，而 webpack 懒加载则是将经过 tree-shaking 优化过后的大文件包进行拆分在适当的运行时进行按需加载。</p></blockquote><h3 id="为何需要组件库按需加载"><a href="#为何需要组件库按需加载" class="headerlink" title="为何需要组件库按需加载"></a>为何需要组件库按需加载</h3><p>组件库按需加载主要目的就是为了减少项目构建打包产物的大小，提高项目线上首屏渲染速度，减少白屏时间，减少流量消耗。<br>一般组件库会提供一种引入全部组件和 css 文件的写法，例如：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> Vant <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vant&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;vant/lib/index.css&#x27;</span>;<br>Vue.use(Vant);<br></code></pre></td></tr></table></figure><p>这种写法经过 webpack 构建之后会将组件库产出的 vant.min.js、index.css 引入并打包至构建产物中，而引入的 vant.min.js 文件是包含组件库全部组件的 js 部分，index.css 包含全部组件的 css 部分。因此，这会导致构建打包产物增大。</p><h3 id="组件库动态加载用法"><a href="#组件库动态加载用法" class="headerlink" title="组件库动态加载用法"></a>组件库动态加载用法</h3><p>Vant 官方文档中推荐使用如下两种方式让 Vant 组件库支持按需加载。</p><h5 id="方式一：手动加载"><a href="#方式一：手动加载" class="headerlink" title="方式一：手动加载"></a>方式一：手动加载</h5><p>手动引入需要使用到的组件以及其对应的样式文件即可，在 webpack 构件时组件库中其他未被引入的文件不会被打包。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> Button <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vant/lib/button&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;vant/lib/button/style&#x27;</span>;<br></code></pre></td></tr></table></figure><h5 id="方式二：自动加载"><a href="#方式二：自动加载" class="headerlink" title="方式二：自动加载"></a>方式二：自动加载</h5><p>安装 babel-plugin-import 插件</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i babel-plugin-<span class="hljs-keyword">import</span> -D<br></code></pre></td></tr></table></figure><p>修改 babel 插件配置</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = &#123;<br>  plugins: [<br>    [<span class="hljs-string">&#x27;import&#x27;</span>, &#123;<br>      libraryName: <span class="hljs-string">&#x27;vant&#x27;</span>,<br>      libraryDirectory: <span class="hljs-string">&#x27;es&#x27;</span>,<br>      style: <span class="hljs-literal">true</span><br>    &#125;, <span class="hljs-string">&#x27;vant&#x27;</span>]<br>  ]<br>&#125;;<br></code></pre></td></tr></table></figure><p>在项目代码中按需引入要用到的组件</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123; Button &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vant&#x27;</span>;<br>Vue.use(Button);<br></code></pre></td></tr></table></figure><h3 id="组件库按需加载的本质"><a href="#组件库按需加载的本质" class="headerlink" title="组件库按需加载的本质"></a>组件库按需加载的本质</h3><p>从上文中手动配置按需加载需要用到的组件中就可以看出，所谓的按需加载就如字面意思一样，指的就是<strong>按需引入需要的组件</strong>，用专业术语来讲就是：在代码中手动引入需要用到的组件。组件其实就是对一堆 js、css 以及 less 等文件的总称，所以上文中需要手动引入组件对应的样式文件 vant/lib/button/style 。<br>即，本质就是对源代码进行如下转换</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123; Button &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vant&#x27;</span>;<br></code></pre></td></tr></table></figure><p>转换为</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;vant/es/button/style&quot;</span>;<br><span class="hljs-keyword">import</span> _Button <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vant/es/button&quot;</span>;<br></code></pre></td></tr></table></figure><p>可以想到，如果每次需要用到新的组件都像这样时都同时手动引入 js、css 或 less 文件岂不是很麻烦，所以为了免去引入写法的繁杂，产生了两种方案：<strong>引入全部组件和使用插件自动引入。使用插件自动引入就是插件帮我们把引入组件的写法进行了转换，最后转换成了上文中手动加载方式的写法。</strong></p><h4 id="babel-plugin-import-插件"><a href="#babel-plugin-import-插件" class="headerlink" title="babel-plugin-import 插件"></a>babel-plugin-import 插件</h4><p>上文已经介绍了使用插件自动按需加载的本质，下面开始进一步地分析该插件底层是如何实现的。</p><h6 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h6><p><a href="https://juejin.cn/post/6968505746757533710#heading-12">组件库按需加载原理分析</a></p><h3 id="Vue3中提到的Tree-shaking"><a href="#Vue3中提到的Tree-shaking" class="headerlink" title="Vue3中提到的Tree-shaking"></a>Vue3中提到的Tree-shaking</h3><p>按照作者的原话解释，Tree-shaking其实就是：<strong>把无用的模块进行“剪枝”，很多没有用到的API就不会打包到最后的包里</strong><br>vue3一个比较大的显著的区别就是，当你用一个bundler的时候，比如webpack或者rollup，webpack和rollup都是有tree shaking功能，但是tree shaking的<strong>前提是所有的东西都必须用ES6 module的import来写</strong></p><p>而vue3 在浏览器里的时候依然会由一个全局的Vue对象，但是当你用了一个bundler时（比如webpack），它就没有default export，你就不能import xxx from vue，然后把vue本身当一个对象去操作。那所有的这些API全部要用import的方式import进来，这样的结果就是使得一些可能不会用到的一些功能就可以被tree shaking掉。比如说 v-model、<code>&lt;transition&gt;</code>这些功能，如果你不用的话，就不会引用到最后的包里。</p><p><strong>Tree-shaking某种程度上来讲，也是通过编译器去实现的（记住这句话）</strong></p><p>之前让大家记住的一句话，为什么尤大说某种程度上来讲，Tree-shaking是通过编译器去实现的<br>其实说白了，Tree-shaking本质并不是Vue3的东西，而是那些打包工具的功能。只是Vue3代码结构调整，当用webpack等打包工具打包项目时，webpack会将那些没用用到的代码不打包到最后的项目中，这样使得项目体积更小<br>主要原理：依赖es6的模块化的语法，将无用的代码(dead-code)进行剔除!</p><p><a href="https://juejin.cn/post/6974778684418818078">看尤老师解释Vue3中提到的Tree-shaking</a></p>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你真的了解垃圾回收机制吗</title>
    <link href="/2022/03/26/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%90%97/"/>
    <url>/2022/03/26/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%90%97/</url>
    
    <content type="html"><![CDATA[<p>本文我们以一些通用的回收算法作为切入，再由 V8 引擎发展至今对该机制的优化为例（为什么以 V8 为例？因为它市场占有率大 😄 ），一步一步深入来助我们了解垃圾回收机制，因为只有真正了解垃圾回收机制，后面才能理解内存泄漏的问题以及手动预防和优化</p><hr><h3 id="GC是什么"><a href="#GC是什么" class="headerlink" title="GC是什么"></a>GC是什么</h3><p>GC 即 Garbage Collection ，<strong>程序工作过程中会产生很多 垃圾，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而 GC 就是负责回收垃圾的</strong>，因为他工作在引擎内部，所以对于我们前端来说，GC 过程是相对比较无感的，这一套引擎执行而对我们又相对无感的操作也就是常说的 垃圾回收机制 了<br>当然也不是所有语言都有 GC，一般的高级语言里面会自带 GC，比如 Java、Python、JavaScript 等，也有无 GC 的语言，比如 C、C++ 等，那这种就需要我们程序员手动管理内存了，相对比较麻烦</p><h3 id="垃圾产生-amp-为何回收"><a href="#垃圾产生-amp-为何回收" class="headerlink" title="垃圾产生&amp;为何回收"></a>垃圾产生&amp;为何回收</h3><p>在Chrome中，V8被限制了内存的使用（64位约1.4G/1464MB ， 32位约0.7G/732MB），为什么要限制呢？</p><p>表层原因：V8最初为浏览器而设计，不太可能遇到用大量内存的场景<br>深层原因：V8的垃圾回收机制的限制（如果清理大量的内存垃圾是很耗时间，这样回引起JavaScript线程暂停执行的时间，那么性能和应用直线下降）</p><p><img src="/imageO/Gc.jpg" alt="回收"><br>没有了引用关系，也就是无用的对象，这个时候假如任由它搁置，一个两个还好，多了的话内存也会受不了，所以就需要被清理（回收）</p><p>用官方一点的话说，程序的运行需要内存，只要程序提出要求，操作系统或者运行时就必须提供内存，那么对于持续运行的服务进程，必须要及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则就会导致进程崩溃</p><h3 id="垃圾回收策略"><a href="#垃圾回收策略" class="headerlink" title="垃圾回收策略"></a>垃圾回收策略</h3><p>在 JavaScript 内存管理中有一个概念叫做 <strong>可达性</strong>，就是那些以某种方式<strong>可访问或者说可用的值</strong>，它们被保证存储在内存中，反之不可访问则需回收<br>我们都可以 Get 到这之中的重点，那就是怎样找出所谓的垃圾？<br>这个流程就涉及到了一些算法策略，有很多种方式，我们简单介绍两个最常见的</p><p>标记清除算法<br>引用计数算法</p><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>标记清除（Mark-Sweep），目前在<strong> JavaScript引擎</strong> 里这种算法是最常用的，到目前为止的大多数浏览器的 JavaScript引擎 都在采用标记清除算法，只是各大浏览器厂商还对此算法进行了优化加工，且不同浏览器的 JavaScript引擎 在运行垃圾回收的频率上有所差异</p><p>就像它的名字一样，此算法分为 标记 和 清除 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁</p><p>你可能会疑惑怎么给变量加标记？其实有很多种办法，比如当变量进入执行环境时，反转某一位（通过一个二进制字符来表示标记），又或者可以维护进入环境变量和离开环境变量这样两个列表，可以自由的把变量从一个列表转移到另一个列表，当前还有很多其他办法。其实，怎样标记对我们来说并不重要，重要的是其策略</p><p>引擎在执行 GC（使用标记清除算法）时，需要从出发点去遍历内存中所有的对象去打标记，而这个出发点有很多，我们称之为一组 根 对象，而所谓的根对象，其实在浏览器环境中包括又不止于<strong> 全局Window对象、文档DOM树 </strong>等</p><blockquote><p>整个标记清除算法大致过程就像下面这样</p></blockquote><ol><li>垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0</li><li>然后从各个根对象开始遍历，把不是垃圾的节点改成1</li><li>清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间</li><li>最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收</li></ol><blockquote><p>优点</p></blockquote><p>标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单</p><blockquote><p>缺点</p></blockquote><p>标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 内存碎片，并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的</p><blockquote><p>问题<br>假设我们新建对象分配内存时需要大小为 size，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于 size 的块才能为其分配</p></blockquote><p>那如何找到合适的块呢？我们可以采取下面三种分配策略</p><ol><li><p><strong>First-fit</strong>，找到大于等于 size 的块立即返回</p></li><li><p><strong>Best-fit</strong>，遍历整个空闲列表，返回大于等于 size 的最小分块</p></li><li><p><strong>Worst-fit</strong>，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 size 大小，并将该部分返回</p></li></ol><p>这三种策略里面 Worst-fit 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 First-fit 和 Best-fit 来说，考虑到分配的速度和效率 First-fit 是更为明智的选择<br>综上所述，标记清除算法或者说策略就有两个很明显的缺点</p><ol><li><strong>内存碎片化</strong>，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块</li><li><strong>分配速度慢</strong>，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢</li></ol><blockquote><p>PS：标记清除算法的缺点补充</p></blockquote><p>归根结底，标记清除算法的缺点在于清除之后剩余的对象位置不变而导致的空闲内存不连续，所以只要解决这一点，两个缺点都可以完美解决了</p><p>而<strong> 标记整理（Mark-Compact）算法</strong> 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）<br><img src="/imageO/Gc1.jpg" alt="移动"></p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>策略<br>引用计数（Reference Counting），这其实是早先的一种垃圾回收算法，它把 对象是否不再需要 简化定义为 对象有没有其他对象引用到它，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了，因为它的问题很多，不过我们还是需要了解一下<br>它的策略是跟踪记录每个变量值被使用的次数</p><ul><li><p>当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1</p></li><li><p>如果同一个值又被赋给另一个变量，那么引用数加 1</p></li><li><p>如果该变量的值被其他的值覆盖了，则引用次数减 1</p></li><li><p>当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存<br>如下例</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()  <span class="hljs-comment">// 此对象的引用计数为 1（a引用）</span><br><span class="hljs-keyword">let</span> b = a   <span class="hljs-comment">// 此对象的引用计数是 2（a,b引用）</span><br>a = <span class="hljs-literal">null</span>    <span class="hljs-comment">// 此对象的引用计数为 1（b引用）</span><br>b = <span class="hljs-literal">null</span>    <span class="hljs-comment">// 此对象的引用计数为 0（无引用）</span><br>...   <span class="hljs-comment">// GC 回收此对象</span><br></code></pre></td></tr></table></figure><p>这种方式是不是很简单？确实很简单，不过在引用计数这种算法出现没多久，就遇到了一个很严重的问题——循环引用，即对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A ，如下面这个例子</p><blockquote><p>优点</p></blockquote><p>引用计数算法的优点我们对比标记清除来看就会清晰很多，首先引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾<br>而标记清除算法需要每隔一段时间进行一次，那在应用程序（JS脚本）运行过程中线程就必须要暂停去执行一段时间的 GC，另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了</p><blockquote><p>缺点</p></blockquote><p><strong>引用计数的缺点想必大家也都很明朗了，首先它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限，还有就是无法解决循环引用无法回收的问题，这也是最严重的</strong></p><h3 id="V8对GC的优化"><a href="#V8对GC的优化" class="headerlink" title="V8对GC的优化"></a>V8对GC的优化</h3><p>我们在上面也说过，现在大多数浏览器都是基于标记清除算法，V8 亦是，当然 V8 肯定也对其进行了一些优化加工处理，那接下来我们主要就来看 V8 中对垃圾回收机制的优化</p><h4 id="1-分代式垃圾回收"><a href="#1-分代式垃圾回收" class="headerlink" title="1. 分代式垃圾回收"></a>1. 分代式垃圾回收</h4><p>试想一下，我们上面所说的垃圾清理算法在每次垃圾回收时都要检查内存中所有的对象，这样的话对于一些大、老、存活时间长的对象来说同新、小、存活时间短的对象一个频率的检查很不好，因为前者需要时间长并且不需要频繁进行清理，后者恰好相反，怎么优化这点呢？？？分代式就来了</p><h4 id="2-新老生代"><a href="#2-新老生代" class="headerlink" title="2.新老生代"></a>2.新老生代</h4><p>V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收<br>新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大<br>V8 整个堆内存的大小就等于新生代加上老生代的内存（如下图）<br><img src="/imageO/Gc2.jpg" alt="新老"><br>对于新老两块内存区域的垃圾回收，V8 采用了两个垃圾回收器来管控，我们暂且将管理新生代的垃圾回收器叫做新生代垃圾回收器，同样的，我们称管理老生代的垃圾回收器叫做老生代垃圾回收器好了</p><h4 id="3-新生代垃圾回收"><a href="#3-新生代垃圾回收" class="headerlink" title="3.新生代垃圾回收"></a>3.新生代垃圾回收</h4><p>新生代对象是通过一个名为 Scavenge 的算法进行垃圾回收，在 Scavenge算法 的具体实现中，主要采用了一种复制式的方法即 Cheney算法 ，我们细细道来<br>Cheney算法 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 使用区，一个是处于闲置状态的空间我们称之为 空闲区，如下图所示<br><img src="/imageO/Gc3.jpg" alt="新老"><br>新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作<br>当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区<br><strong>当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理</strong><br>另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 Scavenge 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配</p><h4 id="4-老生代垃圾回收"><a href="#4-老生代垃圾回收" class="headerlink" title="4. 老生代垃圾回收"></a>4. 老生代垃圾回收</h4><p>相比于新生代，老生代的垃圾回收就比较容易理解了，上面我们说过，对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是上文所说的标记清除算法了<br>首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象<br>清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉<br>前面我们也提过，标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而 V8 中就采用了我们上文中说的标记整理算法来解决这一问题来优化空间</p><h4 id="5-为什么需要分代式？"><a href="#5-为什么需要分代式？" class="headerlink" title="5. 为什么需要分代式？"></a>5. 为什么需要分代式？</h4><p>其实，它并不能说是解决了什么问题，可以说是一个优化点吧<br>分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度提高了垃圾回收机制的效率</p><h4 id="6-并行回收-Parallel"><a href="#6-并行回收-Parallel" class="headerlink" title="6. 并行回收(Parallel)"></a>6. 并行回收(Parallel)</h4><p>在介绍并行之前，我们先要了解一个概念 全停顿（Stop-The-World），我们都知道 JavaScript 是一门单线程的语言，它是运行在主线程上的，那在进行垃圾回收时就会阻塞 JavaScript 脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，我们把这种行为叫做 全停顿<br>比如一次 GC 需要 60ms ，那我们的应用逻辑就得暂停 60ms ，假如一次 GC 的时间过长，对用户来说就可能造成页面卡顿等问题<br>既然存在执行一次 GC 比较耗时的情况，考虑到一个人盖房子难，那两个人、十个人…呢？切换到程序这边，那我们可不可以引入多个辅助线程来同时处理，这样是不是就会加速垃圾回收的执行速度呢？因此 V8 团队引入了并行回收机制<br>所谓并行，也就是同时的意思，它指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作<br><img src="/imageO/Gc4.jpg" alt="新老"><br>简单来说，使用并行回收，假如本来是主线程一个人干活，它一个人需要 3 秒，现在叫上了 2 个辅助线程和主线程一块干活，那三个人一块干一个人干 1 秒就完事了，但是由于多人协同办公，所以需要加上一部分多人协同（同步开销）的时间我们算 0.5 秒好了，也就是说，采用并行策略后，本来要 3 秒的活现在 1.5 秒就可以干完了<br>不过虽然 1.5 秒就可以干完了，时间也大大缩小了，但是这 1.5 秒内，主线程还是需要让出来的，也正是因为主线程还是需要让出来，这个过程内存是静态的，不需要考虑内存中对象的引用关系改变，只需要考虑协同，实现起来也很简单<br>新生代对象空间就采用并行策略，在执行垃圾回收的过程中，会启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，这个过程中由于数据地址会发生改变，所以还需要同步更新引用这些对象的指针，此即并行回收</p><h4 id="7-增量标记与懒性清理"><a href="#7-增量标记与懒性清理" class="headerlink" title="7. 增量标记与懒性清理"></a>7. 增量标记与懒性清理</h4><p>我们上面所说的并行策略虽然可以增加垃圾回收的效率，对于新生代垃圾回收器能够有很好的优化，但是其实它还是一种全停顿式的垃圾回收方式，对于老生代来说，它的内部存放的都是一些比较大的对象，对于这些大的对象 GC 时哪怕我们使用并行策略依然可能会消耗大量时间<br>所以为了减少全停顿的时间，在 2011 年，V8 对老生代的标记进行了优化，从全停顿标记切换到增量标记</p><h5 id="什么是增量"><a href="#什么是增量" class="headerlink" title="什么是增量"></a>什么是增量</h5><p>增量就是将一次 GC 标记的过程，分成了很多小步，每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成一轮 GC 标记（如下图）</p><p>试想一下，将一次完整的 GC 标记分次执行，那在每一小次 GC 标记执行完之后如何暂停下来去执行任务程序，而后又怎么恢复呢？那假如我们在一次完整的 GC 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了又怎么办呢？<br>可以看出增量的实现要比并行复杂一点，V8 对这两个问题对应的解决方案分别是三色标记法与写屏障</p><h5 id="三色标记法-暂停与恢复"><a href="#三色标记法-暂停与恢复" class="headerlink" title="三色标记法(暂停与恢复)"></a>三色标记法(暂停与恢复)</h5><p>如果采用非黑即白的标记策略，那在垃圾回收器执行了一段增量回收后，暂停后启用主线程去执行了应用程序中的一段 JavaScript 代码，随后当垃圾回收器再次被启动，这时候内存中黑白色都有，我们无法得知下一步走到哪里了<br>为了解决这个问题，V8 团队采用了一种特殊方式： 三色标记法<br>三色标记法即使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：白、灰、黑</p><p>白色指的是未被标记的对象<br>灰色指自身被标记，成员变量（该对象的引用对象）未被标记<br>黑色指自身和成员变量皆被标记</p><h5 id="写屏障-增量中修改引用"><a href="#写屏障-增量中修改引用" class="headerlink" title="写屏障(增量中修改引用)"></a>写屏障(增量中修改引用)</h5><h5 id="懒性清理"><a href="#懒性清理" class="headerlink" title="懒性清理"></a>懒性清理</h5><h5 id="增量标记与惰性清理的优缺？"><a href="#增量标记与惰性清理的优缺？" class="headerlink" title="增量标记与惰性清理的优缺？"></a>增量标记与惰性清理的优缺？</h5><h4 id="8-并发回收-Concurrent"><a href="#8-并发回收-Concurrent" class="headerlink" title="8.并发回收(Concurrent)"></a>8.并发回收(Concurrent)</h4><p>前面我们说并行回收依然会阻塞主线程，增量标记同样有增加了总暂停时间、降低应用程序吞吐量两个缺点，那么怎么才能在不阻塞主线程的情况下执行垃圾回收并且与增量相比更高效呢？<br>这就要说到并发回收了，它指的是主线程在执行 JavaScript 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起（如下图）<br><img src="/imageO/Gc5.jpg" alt="新老"></p><h4 id="再说V8中GC优化"><a href="#再说V8中GC优化" class="headerlink" title="再说V8中GC优化"></a>再说V8中GC优化</h4><p>V8 的垃圾回收策略主要基于分代式垃圾回收机制，这我们说过，关于新生代垃圾回收器，我们说使用并行回收可以很好的增加垃圾回收的效率，那老生代垃圾回收器用的哪个策略呢？我上面说了并行回收、增量标记与惰性清理、并发回收这几种回收方式来提高效率、优化体验，看着一个比一个好，那老生代垃圾回收器到底用的哪个策略？难道是并发？？内心独白：” 好像。。貌似。。并发回收效率最高 “<br>其实，这三种方式各有优缺点，所以在老生代垃圾回收器中这几种策略都是融合使用的<br>老生代主要使用并发标记，主线程在开始执行 JavaScript 时，辅助线程也同时执行标记操作（标记操作全都由辅助线程完成）<br>标记完成之后，再执行并行清理操作（主线程在执行清理操作时，多个辅助线程也同时执行清理操作）<br>同时，清理的任务会采用增量的方式分批在各个 JavaScript 任务之间执行</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>那上面就是 V8 引擎为我们的垃圾回收所做的一些主要优化了，虽然引擎有优化，但并不是说我们就可以完全不用关心垃圾回收这块了，我们的代码中依然要主动避免一些不利于引擎做垃圾回收操作，因为不是所有无用对象内存都可以被回收的，那当不再用到的内存，没有及时回收时，我们叫它<strong> 内存泄漏</strong></p><h6 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h6><p><a href="https://juejin.cn/post/6981588276356317214#heading-19">「硬核JS」你真的了解垃圾回收机制吗</a></p>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Js中常用的数据结构与算法（学习）</title>
    <link href="/2022/03/22/js%E7%AE%97%E6%B3%95--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2022/03/22/js%E7%AE%97%E6%B3%95--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>对任何专业技术人员来说，理解数据结构都非常重要。作为软件开发者，我们要能够用编程语言和数据结构来解决问题。编程语言和数据结构是这些问题解决方案中不可或缺的一部分。如果选择了不恰当的数据结构，可能会影响所写程序的性能。因此，了解不同数据结构和它们的适用范围十分重要。</p><hr><p><img src="/imageO/SF.jpg" alt="复杂度"></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ol><li>栈：一种遵从先进后出 (LIFO) 原则的有序集合；新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端为栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。</li><li>队列：与上相反，一种遵循先进先出 (FIFO / First In First Out) 原则的一组有序的项；队列在尾部添加新元素，并从头部移除元素。最新添加的元素必须排在队列的末尾。</li><li>链表：存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的；每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（指针/链接）组成。</li><li>集合：由一组无序且唯一（即不能重复）的项组成；这个数据结构使用了与有限集合相同的数学概念，但应用在计算机科学的数据结构中。</li><li>字典：以 [键，值] 对为数据形态的数据结构，其中键名用来查询特定元素，类似于 Javascript 中的Object。</li><li>散列：根据关键码值（Key value）直接进行访问的数据结构；它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度；这个映射函数叫做散列函数，存放记录的数组叫做散列表。</li><li>树：由 n（n&gt;=1）个有限节点组成一个具有层次关系的集合；把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的，基本呈一对多关系，树也可以看做是图的特殊形式。</li><li>图：图是网络结构的抽象模型；图是一组由边连接的节点（顶点）；任何二元关系都可以用图来表示，常见的比如：道路图、关系图，呈多对多关系。</li></ol><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><ol><li>冒泡排序：比较任何两个相邻的项，如果第一个比第二个大，则交换它们；元素项向上移动至正确的顺序，好似气泡上升至表面一般，因此得名。</li><li>选择排序：每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，以此循环，直至排序完毕。</li><li>插入排序：将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，此算法适用于少量数据的排序，时间复杂度为 O(n^2)。</li><li>归并排序：将原始序列切分成较小的序列，只到每个小序列无法再切分，然后执行合并，即将小序列归并成大的序列，合并过程进行比较排序，只到最后只有一个排序完毕的大序列，时间复杂度为 <strong> O(n log n)。</strong></li><li>快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行上述<strong>递归排序</strong>，以此达到整个数据变成有序序列，时间复杂度为<strong> O(n log n)。</strong></li></ol><h4 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h4><ol><li>顺序搜索：让目标元素与列表中的每一个元素逐个比较，直到找出与给定元素相同的元素为止，缺点是效率低下。</li><li>二分搜索：在一个有序列表，以中间值为基准拆分为两个子列表，拿目标元素与中间值作比较从而再在目标的子列表中递归此方法，直至找到目标元素。</li></ol><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol><li><p>贪心算法：在对问题求解时，不考虑全局，总是做出局部最优解的方法。</p></li><li><p>动态规划：在对问题求解时，由以求出的局部最优解来推导全局最优解。</p></li></ol><p>复杂度概念：一个方法在执行的整个生命周期，所需要占用的资源，主要包括：时间资源、空间资源。</p><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p><strong>1、按照索引查询元素速度快<br>2、按照索引遍历数组方便</strong></p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p><strong>1、数组的大小固定后就无法扩容了<br>2、数组只能存储一种类型的数据<br>3、添加，删除的操作慢，因为要移动其他的元素。</strong><br>适用场景：</p><blockquote><p>频繁查询，对存储空间要求不大，很少增加和删除的情况。</p></blockquote><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>要存储多个元素，数组（或列表）可能是最常用的数据结构。<br>链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。</p><h5 id="链表的优点-添加删除很快"><a href="#链表的优点-添加删除很快" class="headerlink" title="链表的优点(添加删除很快)"></a>链表的优点(添加删除很快)</h5><p>链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；<br>添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>因为含有大量的指针域，占用空间较大；<br>查找元素需要遍历链表来查找，非常耗时。</p><blockquote><p>适用场景：数据量较小，需要频繁增加，删除操作的场景<br><img src="/imageO/Link.png" alt="链表"></p></blockquote><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p><ol><li>每个节点有零个或多个子节点；</li><li>没有父节点的节点称为根节点；</li><li>每一个非根节点有且只有一个父节点；</li><li>除了根节点外，每个子节点可以分为多个不相交的子树；</li></ol><p>在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是<strong>二叉树。</strong></p><p>二叉树是树的特殊一种，具有如下特点：</p><p>1、每个结点最多有两颗子树，结点的度最大为2。<br>2、左子树和右子树是有顺序的，次序不能颠倒。<br>3、即使某结点只有一个子树，也要区分左右子树。</p><p>二叉树是一种比较有用的折中方案，<strong>它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。</strong></p><p>扩展：<br>二叉树有很多扩展的数据结构，包括平衡二叉树、红黑树、B+树等，这些数据结构二叉树的基础上衍生了很多的功能，在实际应用中广泛用到，例如mysql的数据库索引结构用的就是B+树，还有HashMap的底层源码中用到了红黑树。这些二叉树的功能强大，但算法上比较复杂，想学习的话还是需要花时间去深入的。</p><h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><p>散列表，也叫哈希表，是根据关键码和值 <strong>(key和value) </strong>直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。</p><blockquote><p>记录的存储位置=f(key)</p></blockquote><p>这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。<br>哈希表在应用中也是比较常见的，就如Java中有些集合类就是借鉴了哈希原理构造的，例如HashMap，HashTable等，利用hash表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。拉链法是数组结合链表的一种结构，较早前的hashMap底层的存储就是采用这种结构，直到jdk1.8之后才换成了数组加红黑树的结构，其示例图如下：<br><img src="/imageO/hash.jpg" alt="哈希表"><br>从图中可以看出，左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。<br>哈希表的应用场景很多，当然也有很多问题要考虑，比如哈希冲突的问题，如果处理的不好会浪费大量的时间，导致应用崩溃。</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈是一种遵从先进后出 (LIFO) 原则的有序集合；新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端为栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。</p><p>栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，<strong>栈常应用于实现递归功能方面的场景，例如斐波那契数列。</strong></p><p>通俗来讲，一摞叠起来的书或盘子都可以看做一个栈，我们想要拿出最底下的书或盘子，一定要现将上面的移走才可以。</p><p>栈也被用在编程语言的编译器和内存中保存变变量、方法调用。<br>在 Javascript 中我们可以使用数组的原生方法实现一个栈/队列的功能，鉴于学习目的，我们使用类来实现一个栈。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.items = []<br>    &#125;<br><br>    <span class="hljs-comment">// 入栈</span><br>    <span class="hljs-function"><span class="hljs-title">push</span>(<span class="hljs-params">element</span>)</span> &#123;<br>         <span class="hljs-built_in">this</span>.items.push(element)<br>    &#125;<br><br>    <span class="hljs-comment">// 出栈</span><br>    <span class="hljs-function"><span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.pop()<br>    &#125;<br><br>    <span class="hljs-comment">// 末位</span><br>    <span class="hljs-keyword">get</span> <span class="hljs-title">peek</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items[<span class="hljs-built_in">this</span>.items.length - <span class="hljs-number">1</span>]<br>    &#125;<br><br>    <span class="hljs-comment">// 是否为空栈</span><br>    <span class="hljs-keyword">get</span> <span class="hljs-title">isEmpty</span>() &#123;<br>        <span class="hljs-keyword">return</span> !<span class="hljs-built_in">this</span>.items.length<br>    &#125;<br><br>    <span class="hljs-comment">// 尺寸</span><br>    <span class="hljs-keyword">get</span> <span class="hljs-title">size</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length<br>    &#125;<br><br>    <span class="hljs-comment">// 清空栈</span><br>    <span class="hljs-function"><span class="hljs-title">clear</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.items = []<br>    &#125;<br><br>    <span class="hljs-comment">// 打印栈数据</span><br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.items.toString())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用栈类：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 实例化一个栈</span><br><span class="hljs-keyword">const</span> stack = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Stack</span>()<br>console.<span class="hljs-built_in">log</span>(stack.isEmpty) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 添加元素</span><br>stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">5</span>)<br>stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">8</span>)<br><br><span class="hljs-comment">// 读取属性再添加</span><br>console.<span class="hljs-built_in">log</span>(stack.peek) <span class="hljs-comment">// 8</span><br>stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">11</span>)<br>console.<span class="hljs-built_in">log</span>(stack.size) <span class="hljs-comment">// 3</span><br>console.<span class="hljs-built_in">log</span>(stack.isEmpty) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>与栈相反，队列是一种遵循先进先出 (FIFO / First In First Out) 原则的一组有序的项；队列在尾部添加新元素，并从头部移除元素。最新添加的元素必须排在队列的末尾。</p><blockquote><p>使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。<br>在现实中，最常见的例子就是排队，吃饭排队、银行业务排队、公车的前门上后门下机制…，前面的人优先完成自己的事务，完成之后，下一个人才能继续。</p></blockquote><p>在计算机科学中，一个常见的例子就是打印队列。比如说我们需要打印五份文档。我们会打开每个文档，然后点击打印按钮。每个文档都会被发送至打印队列。第一个发送到打印队列的文档会首先被打印，以此类推，直到打印完所有文档。<br>同样的，我们在 Javascript 中实现一个队列类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">items</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.items = items || []<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">enqueue</span>(<span class="hljs-params">element</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.items.push(element)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">dequeue</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.shift()<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">front</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items[<span class="hljs-number">0</span>]<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">clear</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.items = []<br>    &#125;<br><br>    <span class="hljs-keyword">get</span> <span class="hljs-title">size</span>()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length<br>    &#125;<br><br>    <span class="hljs-keyword">get</span> <span class="hljs-title">isEmpty</span>()&#123;<br>        <span class="hljs-keyword">return</span> !<span class="hljs-built_in">this</span>.items.length<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.items.toString())<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用队列类：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><br>const <span class="hljs-built_in">queue</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Queue</span>()<br>console.<span class="hljs-keyword">log</span>(<span class="hljs-built_in">queue</span>.isEmpty) <span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">queue</span>.enqueue(<span class="hljs-string">&#x27;John&#x27;</span>)<br><span class="hljs-built_in">queue</span>.enqueue(<span class="hljs-string">&#x27;Jack&#x27;</span>)<br><span class="hljs-built_in">queue</span>.enqueue(<span class="hljs-string">&#x27;Camila&#x27;</span>)<br>console.<span class="hljs-keyword">log</span>(<span class="hljs-built_in">queue</span>.size) <span class="hljs-comment">// 3</span><br>console.<span class="hljs-keyword">log</span>(<span class="hljs-built_in">queue</span>.isEmpty) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">queue</span>.dequeue()<br><span class="hljs-built_in">queue</span>.dequeue()<br><span class="hljs-built_in">queue</span>.print() <span class="hljs-comment">// &#x27;Camila&#x27;</span><br><br></code></pre></td></tr></table></figure><h5 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h5><p>队列大量应用在计算机科学以及我们的生活中，我们在之前话题中实现的默认队列也有一些修改版本。<br>其中一个修改版就是优先队列。元素的添加和移除是基于优先级的。一个现实的例子就是机场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。在有些国家，老年人和孕妇(或 带小孩的妇女)登机时也享有高于其他乘客的优先级。<br>另一个现实中的例子是医院的(急诊科)候诊室。医生会优先处理病情比较严重的患者。通常，护士会鉴别分类，根据患者病情的严重程度放号。</p><p>实现一个优先队列，有两种选项：<br><strong>设置优先级，然后在正确的位置添加元素；<br>或者用入列操作添加元素，然后按照优先级移除它们。</strong><br>在下面示例中，我们将会在正确的位置添加元素，因此可以对它们使用默认的出列操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityQueue</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.items = []<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">enqueue</span>(<span class="hljs-params">element, priority</span>)</span>&#123;<br>        <span class="hljs-keyword">const</span> queueElement = &#123; element, priority &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isEmpty) &#123;<br>            <span class="hljs-built_in">this</span>.items.push(queueElement)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">const</span> preIndex = <span class="hljs-built_in">this</span>.items.findIndex(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> queueElement.priority &lt; item.priority)<br>            <span class="hljs-keyword">if</span> (preIndex &gt; -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">this</span>.items.splice(preIndex, <span class="hljs-number">0</span>, queueElement)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">this</span>.items.push(queueElement)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">dequeue</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.shift()<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">front</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items[<span class="hljs-number">0</span>]<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">clear</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.items = []<br>    &#125;<br><br>    <span class="hljs-keyword">get</span> <span class="hljs-title">size</span>()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length<br>    &#125;<br><br>    <span class="hljs-keyword">get</span> <span class="hljs-title">isEmpty</span>()&#123;<br>        <span class="hljs-keyword">return</span> !<span class="hljs-built_in">this</span>.items.length<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.items)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优先队列的使用：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>const priorityQueue = new PriorityQueue()<br>priorityQueue<span class="hljs-selector-class">.enqueue</span>(<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-number">2</span>)<br>priorityQueue<span class="hljs-selector-class">.enqueue</span>(<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">1</span>)<br>priorityQueue<span class="hljs-selector-class">.enqueue</span>(<span class="hljs-string">&#x27;Camila&#x27;</span>, <span class="hljs-number">1</span>)<br>priorityQueue<span class="hljs-selector-class">.enqueue</span>(<span class="hljs-string">&#x27;Surmon&#x27;</span>, <span class="hljs-number">3</span>)<br>priorityQueue<span class="hljs-selector-class">.enqueue</span>(<span class="hljs-string">&#x27;skyRover&#x27;</span>, <span class="hljs-number">2</span>)<br>priorityQueue<span class="hljs-selector-class">.enqueue</span>(<span class="hljs-string">&#x27;司马萌&#x27;</span>, <span class="hljs-number">1</span>)<br>priorityQueue<span class="hljs-selector-class">.print</span>()<br><br>console<span class="hljs-selector-class">.log</span>(priorityQueue<span class="hljs-selector-class">.isEmpty</span>, priorityQueue.size) <span class="hljs-comment">// false 6</span><br><br></code></pre></td></tr></table></figure><h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><p>为充分利用向量空间，克服”假溢出”现象的方法是：将向量空间想象为一个首尾相接的圆环，并称这种向量为循环向量。存储在其中的队列称为循环队列（Circular Queue）。这种循环队列可以以单链表、队列的方式来在实际编程应用中来实现。<br>下面我们基于首次实现的队列类，简单实现一个循环引用的示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoopQueue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Queue</span> </span>&#123;<br><br>    constructor(items) &#123;<br>        <span class="hljs-keyword">super</span>(items)<br>    &#125;<br><br>    getIndex(index) &#123;<br>        const length = <span class="hljs-keyword">this</span>.items.length<br>        <span class="hljs-keyword">return</span> index &gt; length ? (index % length) : index<br>    &#125;<br><br>    find(index) &#123;<br>        <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.isEmpty ? <span class="hljs-keyword">this</span>.items[<span class="hljs-keyword">this</span>.getIndex(index)] : <span class="hljs-literal">null</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问一个循环队列：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">const loopQueue = new LoopQueue(<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Surmon&#x27;</span>]</span>)<br>loopQueue<span class="hljs-selector-class">.enqueue</span>(<span class="hljs-string">&#x27;SkyRover&#x27;</span>)<br>loopQueue<span class="hljs-selector-class">.enqueue</span>(<span class="hljs-string">&#x27;Even&#x27;</span>)<br>loopQueue<span class="hljs-selector-class">.enqueue</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>)<br>console<span class="hljs-selector-class">.log</span>(loopQueue<span class="hljs-selector-class">.size</span>, loopQueue.isEmpty) <span class="hljs-comment">// 4 false</span><br><br>console<span class="hljs-selector-class">.log</span>(loopQueue<span class="hljs-selector-class">.find</span>(<span class="hljs-number">26</span>)) <span class="hljs-comment">// &#x27;Evan&#x27;</span><br>console<span class="hljs-selector-class">.log</span>(loopQueue<span class="hljs-selector-class">.find</span>(<span class="hljs-number">87651</span>)) <span class="hljs-comment">// &#x27;Alice&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：</p><ol><li>堆中某个节点的值总是不大于或不小于其父节点的值；</li><li>堆总是一棵完全二叉树。</li></ol><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><p>图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6844903482432962573">在 JavaScript 中学习数据结构与算法</a><br><a href="https://juejin.cn/post/7022226724121214989#heading-8">数据结构：八大数据结构分类</a></p>]]></content>
    
    
    <categories>
      
      <category>js算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js算法学习</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串-回文字符串</title>
    <link href="/2022/03/21/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0(5)%20-%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/03/21/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0(5)%20-%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<hr><h4 id="字符串的一些方法（主要这三种就能解决）"><a href="#字符串的一些方法（主要这三种就能解决）" class="headerlink" title="字符串的一些方法（主要这三种就能解决）"></a>字符串的一些方法（主要这三种就能解决）</h4><p>似乎字符串的一些算法题都是借助于<strong>数组的（reverse）还有用指针(双指针) 还有（正则）</strong></p><h4 id="去除异常的字符，先全部转成小写-先将字符串进行这一步"><a href="#去除异常的字符，先全部转成小写-先将字符串进行这一步" class="headerlink" title="//  去除异常的字符，先全部转成小写  (先将字符串进行这一步)"></a>//  去除异常的字符，先全部转成小写  (先将字符串进行这一步)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = s.toLocaleLowerCase().replace(<span class="hljs-regexp">/[\W_]/ig</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="大小写转化"><a href="#大小写转化" class="headerlink" title="大小写转化"></a>大小写转化</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">str</span>.toUpperCase<br><span class="hljs-built_in">str</span>.toLocaleLowerCase<br></code></pre></td></tr></table></figure><h4 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h4><p>一定要记住reverse是Array原型上的方法，不要搞错</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing">function reverseStr(<span class="hljs-built_in">str</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>.<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-built_in">reverse</span>().<span class="hljs-built_in">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>split()： 方法用于把一个字符串分割成字符串数组。<br>reverse()： 方法用于颠倒数组中元素的顺序。<br>join() ：方法也就是把数组中的所有元素以字符串的形式输出</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">var str = &#x27;<span class="hljs-number">112254</span>,<span class="hljs-number">3344</span>5,<span class="hljs-number">5669</span>9&#x27;;<br>var s=str.split(&#x27;,&#x27;);<br>console.<span class="hljs-built_in">log</span>(s.length);<br>console.<span class="hljs-built_in">log</span>(s[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><h3 id="判断回文字符串"><a href="#判断回文字符串" class="headerlink" title="判断回文字符串"></a>判断回文字符串</h3><p>方法一： 利用Array的reverse方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing">functin isHuiwenStr(<span class="hljs-built_in">str</span>) &#123;<br>    <span class="hljs-keyword">return</span> srt.<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-built_in">reverse</span>().<span class="hljs-built_in">join</span>(<span class="hljs-string">&#x27;&#x27;</span>) === <span class="hljs-built_in">str</span><br>&#125;<br></code></pre></td></tr></table></figure><p>方法二： 回文字符串是对称的</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs glsl">functin isHuiwenStr(str) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">length</span> = str.<span class="hljs-built_in">length</span><br>    <span class="hljs-keyword">const</span> midIndex = Math.<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">length</span> / <span class="hljs-number">2</span>)<br><br>    <span class="hljs-keyword">for</span>(let i = <span class="hljs-number">0</span>; i &lt; midIndex; i++) &#123;<br>        <span class="hljs-keyword">if</span>(str[i] !== str[<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span> - i]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="非空字符串删除一个元素，判断能否成为回文字符串"><a href="#非空字符串删除一个元素，判断能否成为回文字符串" class="headerlink" title="非空字符串删除一个元素，判断能否成为回文字符串"></a>非空字符串删除一个元素，判断能否成为回文字符串</h3><p>描述：给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs processing">function isTransHuiwenStr(<span class="hljs-built_in">str</span>) &#123;<br>    <span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">str</span>.<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">for</span>(let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">str</span>.length; i++) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-built_in">copy</span> = [...arr]<br>        <span class="hljs-built_in">copy</span>.<span class="hljs-built_in">splice</span>(i, <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">copy</span>.<span class="hljs-built_in">reverse</span>().<span class="hljs-built_in">join</span>(<span class="hljs-string">&#x27;&#x27;</span>) === <span class="hljs-built_in">copy</span>.<span class="hljs-built_in">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="验证回文串-leetcode-125"><a href="#验证回文串-leetcode-125" class="headerlink" title="验证回文串(leetcode-125)"></a>验证回文串(leetcode-125)</h3><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。<br>说明：本题中，我们将空字符串定义为有效的回文串。<br>示例 1:<br>输入: “A man, a plan, a canal: Panama”<br>输出: true<br>解释：”amanaplanacanalpanama” 是回文串</p><p>示例 2:<br>输入: “race a car”<br>输出: false<br>解释：”raceacar” 不是回文串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-comment">//  去除异常的字符，先全部转成小写</span><br>  <span class="hljs-keyword">const</span> str = s.toLocaleLowerCase().replace(<span class="hljs-regexp">/[\W_]/ig</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>  <span class="hljs-keyword">const</span> length = str.length;<br>  <span class="hljs-keyword">const</span> midLength = <span class="hljs-built_in">Math</span>.floor(length / <span class="hljs-number">2</span>)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; midLength; i++) &#123;<br>    <span class="hljs-keyword">if</span> (str[i] !== str[length - i - <span class="hljs-number">1</span>]) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/valid-palindrome/">125. 验证回文串</a></p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6972471622724747277">字符串-回文字符串</a></p>]]></content>
    
    
    <categories>
      
      <category>js算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js算法学习</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快排&amp;&amp;排序算法</title>
    <link href="/2022/03/16/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0(4)/"/>
    <url>/2022/03/16/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0(4)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="Js实现冒泡排序"><a href="#Js实现冒泡排序" class="headerlink" title="Js实现冒泡排序"></a>Js实现冒泡排序</h3><p>// 是一种计算机科学领域的较简单的排序算法<br>// 它重复的走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小，首字母）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是该元素列已经排序完成。</p><p>冒泡排序是效率最低的排序算法，由于算法嵌套了两轮循环，所以<strong>时间复杂度委O(n^2)</strong></p><p>最好的情况给出一个已经排序的数组进行冒泡排序，时间复杂度为O(n)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml">// 冒泡排序<br>function bubbleSort(arr) &#123;<br>  let len = arr.length;<br>  // 遍历数组的长度，以确定循环次数<br>  for (let i = 0; i &lt; len;i++) &#123;<br>    // 遍历数组len次，忽略后面的i项<br>    for (let j = 0; j &lt; len - 1 - i; j++) &#123;<br>      // 将每一项与后一项进行对比，不符合要求的就换位<br>      if (arr[j] &gt; arr[j + 1]) &#123;<br>        <span class="hljs-comment">&lt;!-- es6数组解构赋值 --&gt;</span><br>        [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]]<br>      &#125;<br>    &#125;<br>  &#125;<br>  return arr<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现一个快排"><a href="#实现一个快排" class="headerlink" title="实现一个快排"></a>实现一个快排</h3><p>快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行上述递归排序，以此达到整个数据变成有序序列，时间复杂度为 O(n log n)。</p><p>// 1.Quickersort通过数组选取一个元素表示为基准点，把数组中的所有其他元素分为两类-（大于和小于此基准点的数组）<br>// 2.然后把作为这一轮排序结果的两个数组（数组元素都小于基准点的数组和数组元素都大于基准点的数组）再进行相同的排序。即分别再选个基准点，然后基于基准点分为两个数组元素分别小于和大于基准点的数组。<br>// 3.最终，由于最后数组中没有元素或只有一个元素，因此不用再比较了。剩下的值都已经基于基准点拍好序了。<br><strong>（时间复杂度（平均）O(nlogn))</strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">const</span> quickSort1 = arr =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//数组小于等于1时的情况</span><br>    <span class="hljs-keyword">return</span> arr;<br>  &#125;<br>  <span class="hljs-keyword">const</span> midIndex = Math.<span class="hljs-built_in">floor</span>(arr.<span class="hljs-built_in">length</span> / <span class="hljs-number">2</span>)<span class="hljs-comment">//取中间的元素为基准点</span><br>   <span class="hljs-comment">// 使用splice截取中间值，第一个参数为截取的索引，第二个参数为截取的长度；</span><br>    <span class="hljs-comment">// 如果此处使用arrArr=arr[index]; 那么将会出现无限递归的错误；</span><br>    <span class="hljs-comment">// splice影响原数组</span><br>  <span class="hljs-keyword">const</span> arrArr = arr.splice(midIndex, <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">const</span> midIndexVal = arrArr[<span class="hljs-number">0</span>]<br>  <span class="hljs-keyword">const</span> left = []<br>  <span class="hljs-keyword">const</span> right = []<br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] &lt; midIndexVal) &#123;<br>      left.push(arr[i]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      right.push(arr[i])<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> quickSort1(left).concat(midIndexVal, quickSort1(right));<span class="hljs-comment">//重复进行上面的步骤，直到剩下小于等于一个元素。</span><br>&#125;<br></code></pre></td></tr></table></figure><!-- 方法二 --><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs coq">// 快速排序<br>const testQuickSort = arr =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (arr.length &lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr;<br>  &#125;<br>  const mid = arr[<span class="hljs-number">0</span>];// 基准值<br>  const <span class="hljs-built_in">left</span> = []<br>  const <span class="hljs-built_in">right</span> = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] &lt; mid) &#123;<br>      <span class="hljs-built_in">left</span>.push(arr[i])<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">right</span>.push(arr[i])<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> [...testQuickSort(<span class="hljs-built_in">left</span>), mid, ...testQuickSort(<span class="hljs-built_in">right</span>)]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="选择排序-（O-2）"><a href="#选择排序-（O-2）" class="headerlink" title="选择排序 （O^2）"></a>选择排序 （O^2）</h3><p>从上面可以看到，对于具有 n 个记录的无序表遍历 n-1 次，第i 次从无序表中第 i 个记录开始，找出后序关键字中最小的记录，然后放置在第 i 的位置上</p><p>直至到从第n个和第n-1个元素中选出最小的放在第n-1个位置</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-comment">// 选择排序</span><br><span class="hljs-function">function <span class="hljs-title">testSelectSort</span>(<span class="hljs-params">arr</span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> len = arr.length;<br>  <span class="hljs-keyword">let</span> minIndex;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<br>    minIndex = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;<br>      <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;  <span class="hljs-comment">//寻找最小数</span><br>        minIndex = j;  <span class="hljs-comment">//将最小数的索引保存</span><br>      &#125;<br>    &#125;<br>    [<span class="hljs-meta">arr[i</span>], arr[minIndex]] = arr[minIndex], arr[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一次内循环比较N - 1次，然后是N-2次，N-3次，……，最后一次内循环比较1次 共比较的次数是 (N - 1) + (N - 2) + … + 1，求等差数列和，得 (N - 1 + 1)* N / 2 = N^2 / 2，舍去最高项系数，其时间复杂度为 O(N^2)</p><p>从上述也可以看到，选择排序是一种稳定的排序</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>// 插入排序<br>// 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p><p>// 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置</p><p>// 如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> testInsertSort(arr) &#123;<br>  const len = arr.length;<br>  let preIndex, <span class="hljs-keyword">current</span>;<br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>    preIndex = i - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">current</span> = arr[i];<br>    <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; <span class="hljs-keyword">current</span>) &#123;<br>      arr[preIndex + <span class="hljs-number">1</span>] = arr[preIndex];<br>      preIndex<span class="hljs-comment">--;</span><br>    &#125;<br>    arr[preIndex + <span class="hljs-number">1</span>] = <span class="hljs-keyword">current</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">function InsertSort(arr) &#123;<br>  for (let i = 0; i &lt; arr.length; i++) &#123;<br>    for (let j = 0; j &lt; i; j++) &#123;<br>      if (arr<span class="hljs-comment">[j]</span> &gt; arr<span class="hljs-comment">[i]</span>) &#123;<br>        <span class="hljs-comment">[arr<span class="hljs-comment">[i]</span>, arr<span class="hljs-comment">[j]</span>]</span> = <span class="hljs-comment">[arr<span class="hljs-comment">[j]</span>, arr<span class="hljs-comment">[i]</span>]</span><br>      &#125;<br>    &#125;<br>  &#125;<br>  return arr;<br>&#125;<br></code></pre></td></tr></table></figure><p>// 在插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较N- 1次，时间复杂度为O(n)</p><p>// 最坏的情况是待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为O(n^2)</p><p>// 通过上面了解，可以看到插入排序是一种稳定的排序方式</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
    
    
    <categories>
      
      <category>js算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js算法学习</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Js类型转换装箱与拆箱</title>
    <link href="/2022/03/11/Js%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/"/>
    <url>/2022/03/11/Js%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/</url>
    
    <content type="html"><![CDATA[<p>众所周知，JS 是一门弱类型语言。它不需要事先具体声明变量的类型，因为会在程序运行过程中，类型会被自动推断确定。因此，可以用同一个变量保存不同类型的数据：</p><p>var a = 1;<br>a = ‘abc’;<br>a = {<br>  x: 1<br>};</p><hr><h3 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h3><p>a.x 或者 a[‘x’] 中“.”和“[]”操作符是专门用来获取引用类型属性值的。然而在 JS 中基本类型变量也是可以使用“点”的，这给初学者造成一定困惑，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>a.x = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">console</span>.log(a);<span class="hljs-comment">// 1 </span><br> <span class="hljs-built_in">console</span>.log(a.x);<span class="hljs-comment">// undefined  </span><br></code></pre></td></tr></table></figure><p>其实，上述代码运行过程中发生了所谓的“装箱”操作。<br>比如第二行：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a.x</span> = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">var <span class="hljs-keyword">temp</span> = <span class="hljs-built_in">new</span> Number(a)<br><span class="hljs-keyword">temp</span>.x = <span class="hljs-number">2</span><br><span class="hljs-keyword">temp</span> = <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p>因为 2 是基本类型，在取其属性时，先用对应的 Number 构造函数包裹成一个临时对象，然后再对临时对象取属性值操作，随后这个临时对象便销毁。</p><h3 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h3><p><a href="https://juejin.cn/post/6844903838575493127">【JS迷你书】类型转换之拆箱操作</a></p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6844903827347341325">【JS迷你书】类型转换之装箱操作</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整理Ts常见知识（面试题）</title>
    <link href="/2022/03/11/Ts%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/03/11/Ts%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>总结了最近的一些面试题和之前的知识点</p><hr><h3 id="typescript-中-interface-和-type-的区别"><a href="#typescript-中-interface-和-type-的区别" class="headerlink" title="typescript 中 interface 和 type 的区别"></a>typescript 中 interface 和 type 的区别</h3><h4 id="相同点-都可以描述一个对象或者函数-amp-amp-都允许拓展（extends）"><a href="#相同点-都可以描述一个对象或者函数-amp-amp-都允许拓展（extends）" class="headerlink" title="相同点 (都可以描述一个对象或者函数&amp;&amp;都允许拓展（extends）)"></a>相同点 (都可以描述一个对象或者函数&amp;&amp;都允许拓展（extends）)</h4><h5 id="都可以描述一个对象或者函数"><a href="#都可以描述一个对象或者函数" class="headerlink" title="都可以描述一个对象或者函数"></a>都可以描述一个对象或者函数</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span><br><span class="hljs-symbol">interface</span> <span class="hljs-symbol">User</span> &#123;<br>  name: <span class="hljs-built_in">string</span><br>  age: number<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-symbol">SetUser</span> &#123;<br>  (name: <span class="hljs-built_in">string</span>, age: number): <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>type</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">type</span> <span class="hljs-keyword">User</span> <span class="hljs-title">= &#123;</span><br><span class="hljs-title">  name</span>: <span class="hljs-keyword">string</span><br>  age: <span class="hljs-keyword">number</span><br>&#125;;<br><br><span class="hljs-keyword">type</span> SetUser = (name: <span class="hljs-keyword">string</span>, age: <span class="hljs-keyword">number</span>)=&gt; void;<br></code></pre></td></tr></table></figure><h5 id="都允许拓展（extends）"><a href="#都允许拓展（extends）" class="headerlink" title="都允许拓展（extends）"></a>都允许拓展（extends）</h5><p>interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">interface</span><br><span class="hljs-symbol">interface</span> <span class="hljs-symbol">Name</span> &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-symbol">User</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Name</span> &#123;<br>  age: number;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">type</span><br><span class="hljs-symbol">type</span> <span class="hljs-symbol">Name</span> = &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-symbol">User</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Name</span> &#123;<br>  age: number;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">type</span></span><br><span class="hljs-class"><span class="hljs-title">type</span> <span class="hljs-title">Name</span> </span>= &#123;<br>  name: string;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">User</span> </span>= <span class="hljs-type">Name</span> &amp; &#123; age: number  &#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">interface</span></span><br><span class="hljs-class"><span class="hljs-title">interface</span> <span class="hljs-title">Name</span> </span>&#123;<br>  name: string;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">User</span> </span>= <span class="hljs-type">Name</span> &amp; &#123;<br>  age: number;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="不同点-type-可以声明基本类型别名，联合类型，元组等类型-type-语句中还可以使用-typeof-获取实例的-类型进行赋值-interface-能够声明合并"><a href="#不同点-type-可以声明基本类型别名，联合类型，元组等类型-type-语句中还可以使用-typeof-获取实例的-类型进行赋值-interface-能够声明合并" class="headerlink" title="不同点 (type 可以声明基本类型别名，联合类型，元组等类型,type 语句中还可以使用 typeof 获取实例的 类型进行赋值 ,interface 能够声明合并)"></a>不同点 (type 可以声明基本类型别名，联合类型，元组等类型,type 语句中还可以使用 typeof 获取实例的 类型进行赋值 ,interface 能够声明合并)</h4><h5 id="type-可以而-interface-不行"><a href="#type-可以而-interface-不行" class="headerlink" title="type 可以而 interface 不行"></a>type 可以而 interface 不行</h5><p>type 可以声明基本类型别名，联合类型，元组等类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 基本类型别名</span><br><span class="hljs-keyword">type</span> Name = <span class="hljs-keyword">string</span><br><br><span class="hljs-comment">// 联合类型</span><br><span class="hljs-keyword">interface</span> Dog &#123;<br>    wong();<br>&#125;<br><span class="hljs-keyword">interface</span> Cat &#123;<br>    miao();<br>&#125;<br><br><span class="hljs-keyword">type</span> Pet = Dog | Cat<br><br><span class="hljs-comment">// 具体定义数组每个位置的类型</span><br><span class="hljs-keyword">type</span> PetList = [Dog, Pet]<br><br></code></pre></td></tr></table></figure><p>type 语句中还可以使用 typeof 获取实例的 类型进行赋值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 当你想获取一个变量的类型时，使用 typeof</span><br><span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-keyword">type</span> B = <span class="hljs-keyword">typeof</span> div<br></code></pre></td></tr></table></figure><p>其他骚操作</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">StringOrNumber</span> = string | number;  <br><span class="hljs-keyword">type</span> <span class="hljs-type">Text</span> = string | &#123; text: string &#125;;  <br><span class="hljs-keyword">type</span> <span class="hljs-type">NameLookup</span> = <span class="hljs-type">Dictionary</span>&lt;string, <span class="hljs-type">Person</span>&gt;;  <br><span class="hljs-keyword">type</span> <span class="hljs-type">Callback</span>&lt;<span class="hljs-type">T</span>&gt; = (data: <span class="hljs-type">T</span>) =&gt; void;  <br><span class="hljs-keyword">type</span> <span class="hljs-type">Pair</span>&lt;<span class="hljs-type">T</span>&gt; = [<span class="hljs-type">T</span>, <span class="hljs-type">T</span>];  <br><span class="hljs-keyword">type</span> <span class="hljs-type">Coordinates</span> = <span class="hljs-type">Pair</span>&lt;number&gt;;  <br><span class="hljs-keyword">type</span> <span class="hljs-type">Tree</span>&lt;<span class="hljs-type">T</span>&gt; = <span class="hljs-type">T</span> | &#123; left: <span class="hljs-type">Tree</span>&lt;<span class="hljs-type">T</span>&gt;, right: <span class="hljs-type">Tree</span>&lt;<span class="hljs-type">T</span>&gt; &#125;;<br></code></pre></td></tr></table></figure><h5 id="interface-可以而-type-不行"><a href="#interface-可以而-type-不行" class="headerlink" title="interface 可以而 type 不行"></a>interface 可以而 type 不行</h5><p>interface 能够声明合并</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">interface <span class="hljs-keyword">User</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  name</span>: <span class="hljs-keyword">string</span><br>  age: <span class="hljs-keyword">number</span><br>&#125;<br><br>interface <span class="hljs-keyword">User</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  sex</span>: <span class="hljs-keyword">string</span><br>&#125;<br><br>/*<br><span class="hljs-keyword">User</span> <span class="hljs-title">接口为 &#123;</span><br><span class="hljs-title">  name</span>: <span class="hljs-keyword">string</span><br>  age: <span class="hljs-keyword">number</span><br>  sex: <span class="hljs-keyword">string</span><br>&#125;<br>*/<br><br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一般来说，如果不清楚什么时候用interface/type，能用 interface 实现，就用 interface , 如果不能就用 type 。其他更多详情参看 官方规范文档</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6844903749501059085">Typescript 中的 interface 和 type 到底有什么区别</a></p>]]></content>
    
    
    <categories>
      
      <category>TS学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算属性和watch的原理</title>
    <link href="/2022/03/10/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8Ccomputed%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <url>/2022/03/10/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8Ccomputed%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="Watcher是什么？Watcher的种类有哪些？"><a href="#Watcher是什么？Watcher的种类有哪些？" class="headerlink" title="Watcher是什么？Watcher的种类有哪些？"></a>Watcher是什么？Watcher的种类有哪些？</h3><p>大家要注意，这里说的是Watcher，要跟vue里使用的watch属性区分一下哦</p><h4 id="1-什么是Watcher呢？"><a href="#1-什么是Watcher呢？" class="headerlink" title="1.什么是Watcher呢？"></a>1.什么是Watcher呢？</h4><p>举个例子，请看下面代码：</p><p>// 例子代码，与本章代码无关</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span>&gt;&#123;&#123;<span class="hljs-built_in">name</span>&#125;&#125;&lt;/<span class="hljs-keyword">div</span>&gt;<br>aaa<br>data() &#123;<br><span class="hljs-built_in">        return</span> &#123;<br>            <span class="hljs-built_in">name</span>: &#x27;aaa&#x27;<br>        &#125;<br>    &#125;,<br>    computed: &#123;<br>        info () &#123;<br><span class="hljs-built_in">            return</span> this.<span class="hljs-built_in">name</span><br>        &#125;<br>    &#125;,<br>    watch: &#123;<br>        <span class="hljs-built_in">name</span>(newVal) &#123;<br>            console.<span class="hljs-built_in">log</span>(newVal)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>上方代码可知，name变量被三处地方所依赖，分别是html里，computed里，watch里。只要name一改变，html里就会重新渲染，computed里就会重新计算，watch里就会重新执行。那么是谁去通知这三个地方name修改了呢？那就是Watcher了</p><h4 id="2-Watcher的种类有哪些呢？"><a href="#2-Watcher的种类有哪些呢？" class="headerlink" title="2.Watcher的种类有哪些呢？"></a>2.Watcher的种类有哪些呢？</h4><p>上面所说的三处地方就刚刚好代表了三种Watcher，分别是：</p><ol><li>渲染Watcher：变量修改时，负责通知HTML里的重新渲染</li><li>computed Watcher：变量修改时，负责通知computed里依赖此变量的computed属性变量的修改</li><li>user Watcher：变量修改时，负责通知watch属性里所对应的变量函数的执行</li></ol><h3 id="Vue–Observer、Dep、Watcher"><a href="#Vue–Observer、Dep、Watcher" class="headerlink" title="Vue–Observer、Dep、Watcher"></a>Vue–Observer、Dep、Watcher</h3><ol><li><p>Observer 将数据定义为响应式，每个 Observer 实例都有自己的 Dep 来管理依赖。实例化 Wacther 的时候进行求值会触发 getter ，进而执行 dep.depend() 将当前 Wacther 加入 Dep 维护的依赖列表，这就是依赖收集过程</p></li><li><p>数据发生变化触发 setter 执行 dep.notify，Dep 会执行所有依赖的 update 方法并加入异步更新队列，这就是触发依赖过程。<br><a href="https://pengzhenglong.github.io/2022/02/25/Vue--Observer%E3%80%81Dep%E3%80%81Watcher/#Dep-%E3%80%8C%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E3%80%8D">博客</a></p></li></ol><h4 id="4-Watcher为何也要反过来收集Dep？"><a href="#4-Watcher为何也要反过来收集Dep？" class="headerlink" title="4.Watcher为何也要反过来收集Dep？"></a>4.Watcher为何也要反过来收集Dep？</h4><p>上面说到了，dep是name的管家，他的职责是：name更新时，dep会带着主人的命令去通知subs里的Watcher去做该做的事，那么，dep收集Watcher很合理。那为什么watcher也需要反过来收集dep呢？</p><blockquote><p>这是因为computed属性里的变量没有自己的dep，也就是他没有自己的管家，看以下例子：</p></blockquote><p>这里先说一个知识点：如果html里不依赖name这个变量，那么无论name再怎么变，他都不会主动去刷新视图，因为html没引用他（说专业点就是：name的dep里没有渲染Watcher），注意，这里说的是不会主动，但这并不代表他不会被动去更新。什么情况下他会被动去更新呢？那就是computed有依赖他的属性变量。</p><p>// 例子代码，与本章代码无关</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">person</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><span class="xml">computed: &#123;</span><br><span class="xml">    person &#123;</span><br><span class="xml">        return `名称：$&#123;this.name&#125;`</span><br><span class="xml">        &#125;</span><br><span class="xml">    &#125;</span><br></code></pre></td></tr></table></figure><p>这里的person事依赖于name的，但是person是没有自己的dep的（因为他是computed属性变量），而name是有的。好了，继续看，请注意，此例子html里只有person的引用没有name的引用，所以name一改变，按理说虽然person跟着变了，但是html不会重新渲染，因为name虽然有dep，有更新视图的能力，但是奈何人家html不引用他啊！person想要自己去更新视图，但他却没这个能力啊，毕竟他没有dep这个管家！这个时候computed Watcher里收集的name的dep就派上用场了，可以借助这些dep去更新视图，达到更新html里的person的效果。具体会在下面computed里实现。</p><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>计算属性实现原理<br>这里还是按照惯例，将定义的computed属性的每一项使用Watcher类进行实例化，不过这里是按照computed-watcher的形式，来看下如何实例化的：</p><p>这里的变量watcher就是之前computed对应的computed-watcher实例，接下来会执行Watcher类专门为计算属性定义的两个方法，在执行evaluate方法进行求值的过程中又会触发computed内可以访问到的响应式数据的get，它们会将当前的computed-watcher作为依赖收集到自己的dep里，计算完毕之后将dirty置为false，表示已经计算过了。<br>然后执行depend让计算属性内的响应式数据订阅当前的render-watcher，所以computed内的响应式数据会收集computed-watcher和render-watcher两个watcher，当computed内的状态发生变更触发set后，首先通知computed需要进行重新计算，然后通知到视图执行渲染，再渲染中会访问到computed计算后的值，最后渲染到页面。</p><p>Ps: 计算属性内的值须是响应式数据才能触发重新计算。</p><blockquote><p>watch总结：为什么计算属性有缓存功能？因为当计算属性经过计算后，内部的标志位会表明已经计算过了，再次访问时会直接读取计算后的值；为什么计算属性内的响应式数据发生变更后，计算属性会重新计算？因为内部的响应式数据会收集computed-watcher，变更后通知计算属性要进行计算，也会通知页面重新渲染，渲染时会读取到重新计算后的值。</p></blockquote><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844903926819454983#heading-6">Vue原理解析（九）：搞懂computed和watch原理，减少使用场景思考时间</a><br><a href="https://juejin.cn/post/6974293549135167495#heading-24">「Vue源码学习(四)」立志写一篇人人都看的懂的computed，watch原理</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Object.defineProperty和Proxy，Vue3.0为什么采用Proxy？</title>
    <link href="/2022/03/07/defineproPerty&amp;&amp;proxy/"/>
    <url>/2022/03/07/defineproPerty&amp;&amp;proxy/</url>
    
    <content type="html"><![CDATA[<p>Vue3.0 中，响应式数据部分弃用了 Object.defineProperty，使用Proxy来代替它。本文将主要通过以下三个方面来分析为什么 Vue 选择弃用 Object.defineProperty。</p><ol><li>Object.defineProperty 真的无法监测数组下标的变化吗？</li><li>分析 Vue2.x 中对数组 Observe 部分源码。</li><li>对比Object.defineProperty和 Proxy。</li></ol><hr><h3 id="无法监控到数组下标的变化？"><a href="#无法监控到数组下标的变化？" class="headerlink" title="无法监控到数组下标的变化？"></a>无法监控到数组下标的变化？</h3><p>在一些技术博客上，我看到过这样一种说法，认为 Object.defineProperty 有一个缺陷是无法监听数组变化：</p><p>无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。所以 Vue 才设置了 7 个变异数组（push、pop、shift、unshift、splice、sort、reverse）的 hack 方法来解决问题。</p><p>Object.defineProperty的第一个缺陷是无法监听数组变化。然而 Vue 的文档提到了 Vue 是可以检测到数组变化的，但是只有以下八种方法，vm.items[indexOfItem] = newValue 这种是无法检测的。</p><blockquote><p>这种说法是有问题的，事实上，Object.defineProperty 本身是可以监控到数组下标的变化的，只是在 Vue 的实现中，从性能 / 体验的性价比考虑，放弃了这个特性。<br>下面我们通过一个例子来为 Object.defineProperty 正名：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">data, key, value</span>) </span>&#123;<br>  <span class="hljs-built_in">Object</span>.defineProperty(data, key, &#123;<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>     get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineGet</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`get key: <span class="hljs-subst">$&#123;key&#125;</span> value: <span class="hljs-subst">$&#123;value&#125;</span>`</span>)<br>      <span class="hljs-keyword">return</span> value<br>    &#125;,<br>     set: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineSet</span>(<span class="hljs-params">newVal</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`set key: <span class="hljs-subst">$&#123;key&#125;</span> value: <span class="hljs-subst">$&#123;newVal&#125;</span>`</span>)<br>      value = newVal<br>    &#125;<br>  &#125;)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span>(<span class="hljs-params">data</span>) </span>&#123;<br>  <span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>&#123;<br>    defineReactive(data, key, data[key])<br>  &#125;)<br>&#125;<br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>observe(arr)<br></code></pre></td></tr></table></figure><p>上面的代码对数组 arr 的每个属性通过 Object.defineProperty 进行劫持，下面我们对数组 arr 进行操作，看看哪些行为会触发数组的 getter 和 setter 方法。</p><ol><li>通过下标获取某个元素和修改某个元素的值</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">arr</span>[<span class="hljs-number">1</span>]<br><span class="hljs-attribute">6</span> get key: <span class="hljs-number">1</span> value: <span class="hljs-number">2</span><br><span class="hljs-attribute">2</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">1</span>]=<span class="hljs-number">5</span><br><span class="hljs-attribute">10</span> set key: <span class="hljs-number">1</span> value: <span class="hljs-number">5</span><br><span class="hljs-attribute">5</span><br></code></pre></td></tr></table></figure><p>可以看到，通过下标获取某个元素会触发 getter 方法, 设置某个值会触发 setter 方法。</p><p>接下来，我们再试一下数组的一些操作方法，看看是否会触发。</p><ol start="2"><li>数组的 push 方法</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">arr</span>.push(<span class="hljs-number">4</span>)<br><span class="hljs-attribute">4</span><br></code></pre></td></tr></table></figure><p>push 并未触发 setter 和 getter方法，数组的下标可以看做是对象中的 key ，这里 push 之后相当于增加了下索引为 3 的元素，但是并未对新的下标进行 observe ，所以不会触发。<br>3. 数组的 unshift 方法</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">arr</span>.unshift(<span class="hljs-number">0</span>)<br><span class="hljs-attribute">get</span> key: <span class="hljs-number">2</span> value: <span class="hljs-number">3</span><br><span class="hljs-attribute">get</span> key: <span class="hljs-number">1</span> value: <span class="hljs-number">5</span><br><span class="hljs-attribute">set</span> key: <span class="hljs-number">2</span> value: <span class="hljs-number">5</span><br><span class="hljs-attribute">get</span> key: <span class="hljs-number">0</span> value: <span class="hljs-number">1</span><br><span class="hljs-attribute">set</span> key: <span class="hljs-number">1</span> value: <span class="hljs-number">1</span><br><span class="hljs-attribute">set</span> key: <span class="hljs-number">0</span> value: <span class="hljs-number">0</span><br><span class="hljs-attribute">5</span><br></code></pre></td></tr></table></figure><p>我擦，发生了什么？</p><p>unshift 操作会导致原来索引为 0、1、2、3 的值发生变化，这就需要将原来索引为 0、1、2、3 的值取出来，然后重新赋值，所以取值的过程触发了 getter ，赋值时触发了 setter 。</p><p>下面我们尝试通过索引获取一下对应的元素：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">arr</span>[<span class="hljs-number">0</span>]<br> <span class="hljs-attribute">get</span> key: <span class="hljs-number">0</span> value: <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">1</span>]<br> <span class="hljs-attribute">get</span> key: <span class="hljs-number">1</span> value: <span class="hljs-number">1</span><br><span class="hljs-attribute">1</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">2</span>]<br> <span class="hljs-attribute">get</span> key: <span class="hljs-number">2</span> value: <span class="hljs-number">5</span><br><span class="hljs-attribute">5</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">3</span>]<br><span class="hljs-attribute">3</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">4</span>]<br><span class="hljs-attribute">4</span><br></code></pre></td></tr></table></figure><p>只有索引为 0、1、2 的属性才会触发 getter 。</p><p>这里我们可以对比对象来看，arr 数组初始值为 [1, 2, 3]，即只对索引为 0，1，2 执行了 observe 方法，所以无论后来数组的长度发生怎样的变化，依然只有索引为 0、1、2 的元素发生变化才会触发。<strong>其他的新增索引，就相当于对象中新增的属性，需要再手动 observe 才可以。</strong><br>4. 数组的 pop 方法</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs maxima">arr.<span class="hljs-built_in">pop</span>()<br><span class="hljs-number">4</span><br>arr.<span class="hljs-built_in">pop</span>()<br><span class="hljs-number">3</span><br>arr.<span class="hljs-built_in">pop</span>()<br> <span class="hljs-built_in">get</span> <span class="hljs-built_in">key</span>: <span class="hljs-number">2</span> value: <span class="hljs-number">5</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>当移除的元素为引用为 2 的元素时，会触发 getter 。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">arr</span>[<span class="hljs-number">2</span>]<br><span class="hljs-attribute">undefined</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">2</span>]=<span class="hljs-number">3</span><br><span class="hljs-attribute">3</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">2</span>]<br><span class="hljs-attribute">3</span><br></code></pre></td></tr></table></figure><p>删除了索引为 2 的元素后，再去修改或获取它的值时，不会再触发 setter 和 getter 。</p><p>这和对象的处理是同样的，数组的索引被删除后，就相当于对象的属性被删除一样，不会再去触发 observe。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Object.defineProperty 在数组中的表现和在对象中的表现是一致的，数组的索引就可以看做是对象中的 key。</p><ol><li>通过索引访问或设置对应元素的值时，可以触发 getter 和 setter 方法。</li><li>通过 push 或 unshift 会增加索引，对于新增加的属性，需要再手动初始化才能被 observe。</li><li>通过 pop 或 shift 删除元素，会删除并更新索引，也会触发 setter 和 getter 方法。</li></ol><p>所以，Object.defineProperty是有监控数组下标变化的能力的，只是 Vue2.x 放弃了这个特性。</p><h3 id="Vue-对数组的-observe-做了哪些处理？"><a href="#Vue-对数组的-observe-做了哪些处理？" class="headerlink" title="Vue 对数组的 observe 做了哪些处理？"></a>Vue 对数组的 observe 做了哪些处理？</h3><p>Vue 的 Observer 类定义在 core/observer/index.js 中。<br><img src="/imageO/Observer.png" alt="Observer"><br>可以看到，Vue 的 Observer 对数组做了单独的处理。<br>hasProto 判断数组的实例是否有 proto 属性，如果有 proto 属性就会执行 protoAugment 方法，将 arrayMethods 重写到原型上。hasProto 的定义如下：<br><img src="/imageO/Observer1.png" alt="Observer"><br>arrayMethods 是对数组的方法进行重写，定义在 core/observer/array.js 中，下面是这部分源码的分析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * not type checking this file because flow doesn&#x27;t play well with</span><br><span class="hljs-comment"> * dynamically accessing methods on Array prototype</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> &#123; def &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../util/index&#x27;</span><br><span class="hljs-comment">// 复制数组构造函数的原型，Array.prototype 也是一个数组。</span><br><span class="hljs-keyword">const</span> arrayProto = <span class="hljs-built_in">Array</span>.prototype<br><span class="hljs-comment">// 创建对象，对象的 __proto__ 指向 arrayProto，所以 arrayMethods 的 __proto__ 包含数组的所有方法。</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> arrayMethods = <span class="hljs-built_in">Object</span>.create(arrayProto)<br><span class="hljs-comment">// 下面的数组是要进行重写的方法</span><br><span class="hljs-keyword">const</span> methodsToPatch = [<br>  <span class="hljs-string">&#x27;push&#x27;</span>,<br>  <span class="hljs-string">&#x27;pop&#x27;</span>,<br>  <span class="hljs-string">&#x27;shift&#x27;</span>,<br>  <span class="hljs-string">&#x27;unshift&#x27;</span>,<br>  <span class="hljs-string">&#x27;splice&#x27;</span>,<br>  <span class="hljs-string">&#x27;sort&#x27;</span>,<br>  <span class="hljs-string">&#x27;reverse&#x27;</span><br>]<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Intercept mutating methods and emit events</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 遍历 methodsToPatch 数组，对其中的方法进行重写</span><br>methodsToPatch.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>&#123;<br>  <span class="hljs-comment">// cache original method</span><br>  <span class="hljs-keyword">const</span> original = arrayProto[method]<br>  <span class="hljs-comment">// def 方法定义在 lang.js 文件中，是通过 object.defineProperty 对属性进行重新定义。</span><br>  <span class="hljs-comment">// 即在 arrayMethods 中找到我们要重写的方法，对其进行重新定义</span><br>  def(arrayMethods, method, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mutator</span> (<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> result = original.apply(<span class="hljs-built_in">this</span>, args)<br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-built_in">this</span>.__ob__<br>    <span class="hljs-keyword">let</span> inserted<br>    <span class="hljs-keyword">switch</span> (method) &#123;<br>      <span class="hljs-comment">// 上面已经分析过，对于 push，unshift 会新增索引，所以需要手动 observe</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;push&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;unshift&#x27;</span>:<br>        inserted = args<br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-comment">// splice 方法，如果传入了第三个参数，也会有新增索引，所以也需要手动 observe</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;splice&#x27;</span>:<br>        inserted = args.slice(<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>    <span class="hljs-comment">// push，unshift，splice 三个方法触发后，在这里手动 observe，其他方法的变更会在当前的索引上进行更新，所以不需要再执行 ob.observeArray</span><br>    <span class="hljs-keyword">if</span> (inserted) ob.observeArray(inserted)<br>    <span class="hljs-comment">// notify change</span><br>    ob.dep.notify()<br>    <span class="hljs-keyword">return</span> result<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="Object-defineProperty-VS-Proxy-重点"><a href="#Object-defineProperty-VS-Proxy-重点" class="headerlink" title="Object.defineProperty VS Proxy(重点)"></a>Object.defineProperty VS Proxy(重点)</h3><p>上面已经知道 Object.defineProperty 对数组和对象的表现是一致的，那么它和 Proxy 对比存在哪些优缺点呢？</p><ol><li>Object.defineProperty <strong>只能劫持对象的属性，而 Proxy 是直接代理对象。</strong></li></ol><p>由于 Object.defineProperty 只能对属性进行劫持，需要遍历对象的每个属性，如果属性值也是对象，则需要深度遍历。而 Proxy 直接代理对象，不需要遍历操作。</p><ol start="2"><li>Object.defineProperty <strong>对新增属性需要手动进行 Observe。</strong></li></ol><p>由于 Object.defineProperty 劫持的是对象的属性，所以新增属性时，需要重新遍历对象，对其新增属性再使用 Object.defineProperty 进行劫持。</p><p>也正是因为这个原因，使用 Vue 给 data 中的数组或对象新增属性时，需要使用 vm.$set 才能保证新增的属性也是响应式的。</p><p>下面看一下 Vue 的 set 方法是如何实现的，set 方法定义在 core/observer/index.js ，下面是核心代码。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Set a property on an object. Adds the new property and</span><br><span class="hljs-comment"> * triggers change notification if the property doesn&#x27;t</span><br><span class="hljs-comment"> * already exist.</span><br><span class="hljs-comment"> */</span><br>export function <span class="hljs-built_in">set</span> (target: <span class="hljs-keyword">Array</span>&lt;any&gt; | <span class="hljs-keyword">Object</span>, <span class="hljs-built_in">key</span>: any, val: any): any &#123;<br>  <span class="hljs-comment">// 如果 target 是数组，且 key 是有效的数组索引，会调用数组的 splice 方法，</span><br>  <span class="hljs-comment">// 我们上面说过，数组的 splice 方法会被重写，重写的方法中会手动 Observe</span><br>  <span class="hljs-comment">// 所以 vue 的 set 方法，对于数组，就是直接调用重写 splice 方法</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(<span class="hljs-built_in">key</span>)) &#123;<br>    target.length = Math.<span class="hljs-built_in">max</span>(target.length, <span class="hljs-built_in">key</span>)<br>    target.<span class="hljs-built_in">splice</span>(<span class="hljs-built_in">key</span>, <span class="hljs-number">1</span>, val)<br>    <span class="hljs-keyword">return</span> val<br>  &#125;<br>  <span class="hljs-comment">// 对于对象，如果 key 本来就是对象中的属性，直接修改值就可以触发更新</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span> in target &amp;&amp; !(<span class="hljs-built_in">key</span> in <span class="hljs-keyword">Object</span>.prototype)) &#123;<br>    target[<span class="hljs-built_in">key</span>] = val<br>    <span class="hljs-keyword">return</span> val<br>  &#125;<br>  <span class="hljs-comment">// vue 的响应式对象中都会添加了 __ob__ 属性，所以可以根据是否有 __ob__ 属性判断是否为响应式对象</span><br>  <span class="hljs-keyword">const</span> ob = (target: any).__ob__<br>  <span class="hljs-comment">// 如果不是响应式对象，直接赋值</span><br>  <span class="hljs-keyword">if</span> (!ob) &#123;<br>    target[<span class="hljs-built_in">key</span>] = val<br>    <span class="hljs-keyword">return</span> val<br>  &#125;<br>  <span class="hljs-comment">// 调用 defineReactive 给数据添加了 getter 和 setter，</span><br>  <span class="hljs-comment">// 所以 vue 的 set 方法，对于响应式的对象，就会调用 defineReactive 重新定义响应式对象，defineReactive 函数</span><br>  defineReactive(ob.value, <span class="hljs-built_in">key</span>, val)<br>  ob.dep.notify()<br>  <span class="hljs-keyword">return</span> val<br>&#125;<br></code></pre></td></tr></table></figure><p>在 set 方法中，对 target 是数组和对象分别做了处理。target 是数组时，会调用重写过的 splice 方法进行手动 Observe 。</p><p>对于对象，如果 key 本来就是对象的属性，则直接修改值触发更新，否则调用 defineReactive 方法重新定义响应式对象。</p><p>如果采用 proxy 实现，Proxy 通过 set(target, propKey, value, receiver) 拦截对象属性的设置，是可以拦截到对象的新增属性的。<br>不止如此，Proxy 对数组的方法也可以监测到，不需要像上面 vue2.x 源码中那样进行 hack。</p><ol start="3"><li>Proxy支持 13 种拦截操作，这是 defineProperty 所不具有的。</li></ol><p>get(target, propKey, receiver)：拦截对象属性的读取，比如 proxy.foo 和proxy[‘foo’]。<br>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v 或 proxy[‘foo’] = v，返回一个布尔值。<br>has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值。<br>deleteProperty(target, propKey)：拦截 delete proxy[propKey] 的操作，返回一个布尔值。<br>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys() 的返回结果仅包括目标对象自身的可遍历属性。<br>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。<br>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。<br>preventExtensions(target)：拦截 Object.preventExtensions(proxy)，返回一个布尔值。<br>getPrototypeOf(target)：拦截 Object.getPrototypeOf(proxy)，返回一个对象。<br>isExtensible(target)：拦截 Object.isExtensible(proxy)，返回一个布尔值。<br>setPrototypeOf(target, proto)：拦截 Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。<br>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。<br>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</p><ol start="4"><li>新标准性能红利</li></ol><p>Proxy 作为新标准，从长远来看，JS 引擎会继续优化 Proxy，但 getter 和 setter 基本不会再有针对性优化。<br>5. Proxy 兼容性差<br>可以看到，Proxy 对于 IE 浏览器来说简直是灾难。</p><p>并且目前并没有一个完整支持 Proxy 所有拦截方法的 Polyfill 方案，有一个 Google 编写的 proxy-polyfill 也只支持了 get、set、apply、construct 四种拦截，可以支持到 IE9+ 和 Safari 6+。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>Object.defineProperty 并非不能监控数组下标的变化，Vue2.x 中无法通过数组索引来实现响应式数据的自动更新是 Vue 本身的设计导致的，不是 defineProperty 的锅。</li><li>Object.defineProperty 和 Proxy 本质差别是，defineProperty 只能对属性进行劫持，所以出现了需要递归遍历，新增属性需要手动 Observe 的问题。</li><li>Proxy 作为新标准，浏览器厂商势必会对其进行持续优化，但它的兼容性也是块硬伤，并且目前还没有完整的 polyfill 方案。</li></ol><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://mp.weixin.qq.com/s/O8iL4o8oPpqTm4URRveOIA">为什么Vue3.0不再使用defineProperty实现数据监听？</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http1.0，http1.1，http2，http3</title>
    <link href="/2022/03/06/Http/"/>
    <url>/2022/03/06/Http/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="http1-0"><a href="#http1-0" class="headerlink" title="http1.0"></a>http1.0</h3><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上,是一种<strong>无状态、无连接</strong>的应用层协议，几年后被HTTP1.1代替并广泛使用</p><h3 id="http1-1"><a href="#http1-1" class="headerlink" title="http1.1"></a>http1.1</h3><p>http1.1基于文本解析,把所有请求和响应作为纯文本<br>http1.1加入了缓存处理（强缓存和协商缓存）<br>http1.1拥有长连接，并支持请求管道化（pipelining），<br>http1.1流控制基于tcp连接。当连接建立时，两端通过系统默认机制建立缓冲区。并通过ack报文来通知对方接收窗口大小，因为http1.1 依靠传输层来避免流溢出，每个tcp连接需要一个独立的流控制机制</p><h4 id="缓存处理（强缓存和协商缓存）"><a href="#缓存处理（强缓存和协商缓存）" class="headerlink" title="缓存处理（强缓存和协商缓存）"></a>缓存处理（强缓存和协商缓存）</h4><p>浏览器缓存能优化性能，而浏览器缓存分为强缓存和协商缓存，都是从客户端读取缓存<br>强缓存</p><ol><li>强缓存不发送请求，直接读取资源，可以获得返回200的状态码</li><li>利用http头中的Expires和Cache-Control两个字段来控制，都用来表示资源的缓存时间，Expires能设置失效时间，而Cache-Control能做到更多选项更细致，如果同时设置的话，其优先级高于Expires</li></ol><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><ol><li>通过服务器来确定缓存资源是否可用，通过request header判断是否命中请求，命中后返回304状态码，并返回新的request header通知客户端从缓存里取</li><li>普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存</li><li>如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求，回到1</li></ol><h3 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h3><ol><li>http2相比于http1.1，<strong>性能</strong>大幅度提升</li><li>http2通过一个连接来<strong>多路复用</strong></li><li>http2拥有<strong>头部压缩</strong></li><li>http2拥有<strong>新的二进制格式</strong>，使用二进制框架层把所有消息封装成二进制，且仍然保持http语法</li><li>http2允许客户端和服务器端实现他们自己的流控制机制，而不是依赖传输层,两端在传输层交换可用的缓冲区大小，来让他们在多路复用流上设置自己的接收窗口</li><li>http2让服务器可以将响应主动<strong>“推送”</strong>到客户端缓存中</li></ol><h4 id="htpp2头部压缩"><a href="#htpp2头部压缩" class="headerlink" title="htpp2头部压缩"></a>htpp2头部压缩</h4><p>http2头部压缩又称为HAPCK，设计简单而灵活，是因为HPACK格式有意地简单且不灵活能降低由于实现错误而导致的互操作性或安全问题的风险<br>http1.1没有头部压缩，随着请求增加，冗余头部字段会不必要地占用带宽，从而显着增加延迟，而头部压缩可消除冗余报头字段，限制已知安全攻击的漏洞，并且在受限环境中使用有限的内存要求</p><p>http2多路复用</p><p>http 性能优化的关键并不在于高带宽，而是低延迟</p><p>tcp 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度,这种调谐则被称为 tcp 慢启动,由于这种原因，让原本就具有突发性和短时性的 http 连接变的十分低效</p><p>http/2 通过让所有数据流共用同一个连接，可以更有效地使用 tcp 连接，让高带宽也能真正的服务于 http 的性能提升。而http1.1存在低性能的线头阻塞，一旦有一个请求超时，便会出现阻塞等待的情况</p><h3 id="http3"><a href="#http3" class="headerlink" title="http3"></a>http3</h3><p>之前说了http2，那么http3就是为了解决http2相关问题而诞生，它基于一个新的传输层协议QUIC，而http3就是建立一个在<strong>QUIC</strong>上运行的HTTP新规范，而http3之前的版本都是基于TCP，QUIC就是为了替代TCP，解决TCP的一些缺陷<br>tcp</p><p>不支持流级复用，TCP会将所有对象序列化在同一个流中，因此，它不知道TCP段的对象级分区，无法在同一个流中复用数据包<br>会产生冗余通信，tco三次连接握手会有冗余的消息交换序列<br>可能会间歇性地挂起数据传输，tcp中有个因为序列顺序处理丢失的问题的缺陷称为行头阻塞</p><h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><p>同样拥有头部压缩，并优化了对乱序发送的支持，也优化了压缩率<br>放弃tcp，通过udp建立，提高了连接建立的速度，降低了延迟<br>tcp本身是无法解决队头拥塞，quic则解决了这个问题<br>Connection ID使得http3支持连接迁移以及NAT的重绑定</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://juejin.cn/post/7001510315514937375">一文总结http1.0，http1.1，http2，http3，面试强心剂</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片格式&amp;&amp;各自优缺点和使用场景</title>
    <link href="/2022/03/04/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F--%E5%90%84%E8%87%AA%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/2022/03/04/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F--%E5%90%84%E8%87%AA%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="前置知识：二进制位数与色彩的关系"><a href="#前置知识：二进制位数与色彩的关系" class="headerlink" title="前置知识：二进制位数与色彩的关系"></a>前置知识：二进制位数与色彩的关系</h3><p>　　在计算机中，像素用二进制数来表示。不同的图片格式中像素与二进制位数之间的对应关系是不同的，<br>　　一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越清晰，文件体积相应也会越大</p><h3 id="JPG-JPEG"><a href="#JPG-JPEG" class="headerlink" title="JPG / JPEG"></a>JPG / JPEG</h3><p>　　优点<br>　　　　①：体积小<br>　　　　②：加载快<br>　　　　③：支持颜色种类多<br>　　 缺点<br>　　　　①：有损压缩<br>　　　　②：不支持透明</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>　　JPG 适用于呈现色彩丰富的图片，在日常开发中，JPG 图片经常作为大的背景图、轮播图或 Banner 图出现</p><h4 id="注：JPEG和JPG指代同一种图片格式，前者是后者的全称，后者是简称"><a href="#注：JPEG和JPG指代同一种图片格式，前者是后者的全称，后者是简称" class="headerlink" title="注：JPEG和JPG指代同一种图片格式，前者是后者的全称，后者是简称"></a>注：JPEG和JPG指代同一种图片格式，前者是后者的全称，后者是简称</h4><h3 id="PNG-8-PNG-24"><a href="#PNG-8-PNG-24" class="headerlink" title="PNG-8 / PNG-24"></a>PNG-8 / PNG-24</h3><p>　　优点<br>　　　　①：支持透明，弥补了JPG的不足<br>　　　　 ②：无损压缩，图片质量更高<br>　　缺点<br>　　　　①：什么都好，就是体积太大</p><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>　主要用它来呈现小的 Logo 和需要透明效果的图片（比如透明背景图，透明Logo图）</p><h4 id="注：PNG-8和PNG-24区别在于支持色彩多少的不同。前者最多支持256种颜色，后者支持1600万种颜色"><a href="#注：PNG-8和PNG-24区别在于支持色彩多少的不同。前者最多支持256种颜色，后者支持1600万种颜色" class="headerlink" title="注：PNG-8和PNG-24区别在于支持色彩多少的不同。前者最多支持256种颜色，后者支持1600万种颜色"></a>注：PNG-8和PNG-24区别在于支持色彩多少的不同。前者最多支持256种颜色，后者支持1600万种颜色</h4><h3 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h3><p>　　优点<br>　　　　①：体积小<br>　　　　②：支持透明<br>　　　　③：支持动图<br>　缺点<br>　　　①：最多只支持256种颜色，成像效果较差</p><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>主要用于需要有动画效果的图片</p><h3 id="SVG（矢量图形）"><a href="#SVG（矢量图形）" class="headerlink" title="SVG（矢量图形）"></a>SVG（矢量图形）</h3><p>　　优点<br>　　　　①：即使无限放大，图片依然不失真<br>　　　　②：相对于JPG和PNG，体积更小<br>　　缺点<br>　　　　①：对性能有一定影响</p><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>　　SVG 是文本文件，我们既可以像写代码一样定义 SVG，把它写在 HTML 里、成为 DOM 的一部分，<br>　　也可以把对图形的描述写入以 .svg 为后缀的独立文件（SVG 文件在使用上与普通图片文件无异）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span>   <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;50&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>　将 SVG 写入独立文件后引入 HTML</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;文件名.svg&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="HTML-5-Canvas-vs-SVG"><a href="#HTML-5-Canvas-vs-SVG" class="headerlink" title="HTML 5 Canvas vs. SVG"></a>HTML 5 Canvas vs. SVG</h3><p>Canvas 和 SVG 都允许您在浏览器中创建图形，但是它们在根本上是不同的。</p><h4 id="Canvas-与-SVG-的比较"><a href="#Canvas-与-SVG-的比较" class="headerlink" title="Canvas 与 SVG 的比较"></a>Canvas 与 SVG 的比较</h4><p>下表列出了 canvas 与 SVG 之间的一些不同之处。</p><h4 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h4><p>依赖分辨率<br>不支持事件处理器<br>弱的文本渲染能力<br>能够以 .png 或 .jpg 格式保存结果图像<br>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</p><h4 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h4><p>不依赖分辨率<br>支持事件处理器<br>最适合带有大型渲染区域的应用程序（比如谷歌地图）<br>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）<br>不适合游戏应用</p><h3 id="补充——Base64"><a href="#补充——Base64" class="headerlink" title="补充——Base64"></a>补充——Base64</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>　　雪碧图（又被称为CSS Sprites、CSS 精灵、图像精灵）<br>　　 是一种将小图标和背景图像合并到一张图片上，然后利用 CSS 的背景定位来显示其中每一部分的技术，从而减少http请求</p><h4 id="Base64严格意义上来说并不是一种图片格式，而是作为小图标解决方案而存在的，可以理解为是雪碧图的一种补充"><a href="#Base64严格意义上来说并不是一种图片格式，而是作为小图标解决方案而存在的，可以理解为是雪碧图的一种补充" class="headerlink" title="Base64严格意义上来说并不是一种图片格式，而是作为小图标解决方案而存在的，可以理解为是雪碧图的一种补充"></a>Base64严格意义上来说并不是一种图片格式，而是作为小图标解决方案而存在的，可以理解为是雪碧图的一种补充</h4><p>　　Base64 通过对图片进行编码，可以直接将编码结果写入 HTML 或者 CSS，从而减少 HTTP 请求的次数<br>　　比如现在有一个放大镜图标</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">　　 图片路径是：&lt;https:<span class="hljs-regexp">//u</span>ser-gold-cdn.xitu.io<span class="hljs-regexp">/2018/</span><span class="hljs-number">9</span><span class="hljs-regexp">/15/</span><span class="hljs-number">165</span>db7e94699824b?w=<span class="hljs-number">22</span>&amp;h=<span class="hljs-number">22</span>&amp;f=png&amp;s=<span class="hljs-number">3680</span>&gt;<br></code></pre></td></tr></table></figure><p>　   按照一贯思路，我们加载图片需要把图片链接写入 img 标签，然后向服务器发送请求</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;img src=&quot;https://user-gold-cdn.xitu.io/<span class="hljs-number">2018</span>/<span class="hljs-number">9</span>/<span class="hljs-number">15</span>/<span class="hljs-number">165</span>db7e94699824b?w=<span class="hljs-number">22</span><span class="hljs-variable">&amp;h</span>=<span class="hljs-number">22</span><span class="hljs-variable">&amp;f</span>=png<span class="hljs-variable">&amp;s</span>=<span class="hljs-number">3680</span>&quot;&gt;</span><br></code></pre></td></tr></table></figure><p>　 但如果我们对这个图片进行 Base64 编码，会得到一个下图所示的字符串：</p><p> 　　原来浏览器是可以理解这个字符串的，它自动将这个字符串解码为一张图片，而不需再去发送 HTTP 请求</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.cnblogs.com/tu-0718/p/10091432.html">前端常用图片格式优缺点及使用场景简述</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>前端基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CommonJS和ES6模块</title>
    <link href="/2022/03/01/CommonJS%E5%92%8CES6%E6%A8%A1%E5%9D%97/"/>
    <url>/2022/03/01/CommonJS%E5%92%8CES6%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="一、CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用"><a href="#一、CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用" class="headerlink" title="一、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用"></a>一、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</h3><h4 id="commonjs的用法，我们一起来看一下"><a href="#commonjs的用法，我们一起来看一下" class="headerlink" title="commonjs的用法，我们一起来看一下"></a>commonjs的用法，我们一起来看一下</h4><p>1.首先创建一个lib.js的文件</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> lib.js<br>const counter = <span class="hljs-number">3</span>;<br>const incCounter = <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>  counter++<br>&#125;<br><br><span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = &#123;<br>  counter,<br>  incCounter<br>&#125;<br><br></code></pre></td></tr></table></figure><p>2.再次创建一个main.js,使用commonjs的方式导入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">var</span> lib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./lib&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(lib)<br><span class="hljs-built_in">console</span>.log(lib.counter);  <span class="hljs-comment">// 3</span><br>lib.incCounter();<br><span class="hljs-built_in">console</span>.log(lib.counter); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><blockquote><p>lib.js模块加载以后，它的内部变化就影响不到输出的lib.counter了。这是因为mod.counter是一个原始类型的值，会被缓存；</p></blockquote><h4 id="esmodule的用法，我们一起来看一下"><a href="#esmodule的用法，我们一起来看一下" class="headerlink" title="esmodule的用法，我们一起来看一下"></a>esmodule的用法，我们一起来看一下</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// lib.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> counter = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incCounter</span> (<span class="hljs-params"></span>) </span>&#123;<br>  counter++;<br>&#125;<br><br><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; counter, incCounter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./util.mjs&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(counter);  <span class="hljs-comment">//3</span><br>incCounter()<br><span class="hljs-built_in">console</span>.log(counter)  <span class="hljs-comment">//4</span><br><br></code></pre></td></tr></table></figure><blockquote><p>ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。</p></blockquote><h5 id="补充：通过esmodule导入的变量是不能重新赋值修改的"><a href="#补充：通过esmodule导入的变量是不能重新赋值修改的" class="headerlink" title="补充：通过esmodule导入的变量是不能重新赋值修改的"></a>补充：通过esmodule导入的变量是不能重新赋值修改的</h5><h3 id="二、CommonJS-模块是运行时加载，ES6-模块是编译时输出接口"><a href="#二、CommonJS-模块是运行时加载，ES6-模块是编译时输出接口" class="headerlink" title="二、CommonJS 模块是运行时加载，ES6 模块是编译时输出接口"></a>二、CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// CommonJS模块</span><br><span class="hljs-keyword">let</span> &#123; stat, exists, readFile &#125; = require(&#x27;fs&#x27;);<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">let</span> _fs = require(&#x27;fs&#x27;);<br><span class="hljs-keyword">let</span> stat =<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_fs</span>.</span></span>stat;<br><span class="hljs-keyword">let</span> exists = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_fs</span>.</span></span>exists;<br><span class="hljs-keyword">let</span> readfile =<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_fs</span>.</span></span>readfile;<br></code></pre></td></tr></table></figure><p>上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。因此commonjs属于再运行时才会加载模块的方式。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> &#123; stat, <span class="hljs-keyword">exists</span>, readFile &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;<br></code></pre></td></tr></table></figure><p>上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高;</p><h3 id="三、CommonJS-模块的require-是同步加载模块，ES6-模块的import命令是异步加载，有一个独立的模块依赖的解析阶段"><a href="#三、CommonJS-模块的require-是同步加载模块，ES6-模块的import命令是异步加载，有一个独立的模块依赖的解析阶段" class="headerlink" title="三、CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段"></a>三、CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段</h3><blockquote><p>同步加载：所谓同步加载就是加载资源或者模块的过程会阻塞后续代码的执行；<br>异步加载：不会阻塞后续代码的执行；</p></blockquote><p>我们来看一个案例,创建如下的目录；</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">| <span class="hljs-comment">-- a.js</span><br>| <span class="hljs-comment">-- index.js</span><br>| <span class="hljs-comment">-- c.js</span><br></code></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> a.js<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a.js文件的执行&#x27;</span>);<br>const importFun = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./c&#x27;</span>).c);<br>&#125;<br><br>importFun()<br><br><span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = &#123;<br>  importFun<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">const</span> A = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;index.js的执行&#x27;</span>);<br><br><span class="hljs-comment">// c.js</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;c.js的运行&#x27;</span>);<br><br><span class="hljs-keyword">const</span> c = <span class="hljs-number">3</span><br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  c<br>&#125;<br><br></code></pre></td></tr></table></figure><p>执行命令 node index.js</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> a.js文件的执行<br><span class="hljs-regexp">//</span> c.js的运行<br><span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br><span class="hljs-regexp">//</span> index.js的执行<br></code></pre></td></tr></table></figure><p>我们会发现,require的内容会阻塞后续代码的执行。因为c.js先打印出来，然后在是index.js的打印，所以说require()是同步加载的；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// a.js</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a.js文件的执行&#x27;</span>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> importFun = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./c.js&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">&#123;c&#125;</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(c)<br>  &#125;)<br>&#125;<br><br>importFun()<br><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> &#123;importFun&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;index.js的执行&#x27;</span>);<br><br><span class="hljs-comment">// c.js</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;c.js的运行&#x27;</span>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> c = <span class="hljs-number">3</span><br><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 结果<br><span class="hljs-regexp">//</span> a.js文件的执行<br><span class="hljs-regexp">//</span> index.js的执行<br><span class="hljs-regexp">//</span> c.js的运行<br><span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>可以看的出来:import()是异步加载资源的，因为c.js是在index.js的后面打印出来的，并不会阻塞后续代码的执行；</p><h3 id="总结：以上便是commonjs和esmodule的几个区别"><a href="#总结：以上便是commonjs和esmodule的几个区别" class="headerlink" title="总结：以上便是commonjs和esmodule的几个区别"></a>总结：以上便是commonjs和esmodule的几个区别</h3><p>1: CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用<br>2: CommonJS 模块是运行时加载，ES6 模块是编译时输出接口<br>3: CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段</p><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>鉴于浏览器支持度的问题，如果要使用 ES6 的语法，一般都会借助 Babel，可对于 import 和 export 而言，只借助 Babel 就可以吗？</p><p>让我们看看 Babel 是怎么编译 import 和 export 语法的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// ES6</span><br><span class="hljs-keyword">var</span> firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<br><span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<br><span class="hljs-keyword">var</span> year = <span class="hljs-number">1958</span>;<br><br><span class="hljs-keyword">export</span> &#123;firstName, lastName, year&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Babel 编译后</span><br><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">exports</span>, <span class="hljs-string">&quot;__esModule&quot;</span>, &#123;<br>  value: <span class="hljs-literal">true</span><br>&#125;);<br><span class="hljs-keyword">var</span> firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<br><span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<br><span class="hljs-keyword">var</span> year = <span class="hljs-number">1958</span>;<br><br><span class="hljs-built_in">exports</span>.firstName = firstName;<br><span class="hljs-built_in">exports</span>.lastName = lastName;<br><span class="hljs-built_in">exports</span>.year = year;<br></code></pre></td></tr></table></figure><p>是不是感觉有那么一点奇怪？编译后的语法更像是 CommonJS 规范，再看 import 的编译结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES6</span><br><span class="hljs-keyword">import</span> &#123;firstName, lastName, year&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./profile&#x27;</span>;<br>复制代码<br><span class="hljs-comment">// Babel 编译后</span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">var</span> _profile = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./profile&#x27;</span>);<br></code></pre></td></tr></table></figure><p>你会发现 Babel 只是把 ES6 模块语法转为 CommonJS 模块语法，然而<strong>浏览器是不支持这种模块语法的，所以直接跑在浏览器会报错的，如果想要在浏览器中运行，还是需要使用打包工具将代码打包。</strong></p><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>Babel 将 ES6 模块转为 CommonJS 后， webpack 又是怎么做的打包的呢？它该如何将这些文件打包在一起，从而能保证正确的处理依赖，以及能在浏览器中运行呢？</p><p>首先为什么浏览器中不支持 CommonJS 语法呢？</p><p>这是因为浏览器环境中并没有 module、 exports、 require 等环境变量。</p><p>换句话说，webpack 打包后的文件之所以在浏览器中能运行，就是靠模拟了这些变量的行为。</p><p>那怎么模拟呢？</p><p>我们以 CommonJS 项目中的 square.js 为例，它依赖了 multiply 模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;加载了 square 模块&#x27;</span>)<br><br><span class="hljs-keyword">var</span> multiply = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./multiply.js&#x27;</span>);<br><br><span class="hljs-keyword">var</span> square = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) </span>&#123;&amp;emsp;<br>    <span class="hljs-keyword">return</span> multiply.multiply(num, num);<br>&#125;;<br><br><span class="hljs-built_in">module</span>.exports.square = square;<br></code></pre></td></tr></table></figure><p>webpack 会将其包裹一层，注入这些变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;加载了 square 模块&#x27;</span>);<br><br>    <span class="hljs-keyword">var</span> multiply = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./multiply&quot;</span>);<br>    <span class="hljs-built_in">module</span>.exports = &#123;<br>        square: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> multiply.multiply(num, num);<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>那 webpack 又会将 CommonJS 项目的代码打包成什么样呢？我写了一个精简的例子，你可以直接复制到浏览器中查看效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 自执行函数</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">modules</span>) </span>&#123;<br><br>    <span class="hljs-comment">// 用于储存已经加载过的模块</span><br>    <span class="hljs-keyword">var</span> installedModules = &#123;&#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">require</span>(<span class="hljs-params">moduleName</span>) </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (installedModules[moduleName]) &#123;<br>            <span class="hljs-keyword">return</span> installedModules[moduleName].exports;<br>        &#125;<br><br>        <span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = installedModules[moduleName] = &#123;<br>            <span class="hljs-built_in">exports</span>: &#123;&#125;<br>        &#125;;<br><br>        modules[moduleName](<span class="hljs-built_in">module</span>, <span class="hljs-built_in">module</span>.exports, <span class="hljs-built_in">require</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports;<br>    &#125;<br><br>    <span class="hljs-comment">// 加载主模块</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;main&quot;</span>);<br><br>&#125;)(&#123;<br>    <span class="hljs-string">&quot;main&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) </span>&#123;<br><br>        <span class="hljs-keyword">var</span> addModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./add&quot;</span>);<br>        <span class="hljs-built_in">console</span>.log(addModule.add(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br><br>        <span class="hljs-keyword">var</span> squareModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./square&quot;</span>);<br>        <span class="hljs-built_in">console</span>.log(squareModule.square(<span class="hljs-number">3</span>));<br><br>    &#125;,<br>    <span class="hljs-string">&quot;./add&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;加载了 add 模块&#x27;</span>);<br><br>        <span class="hljs-built_in">module</span>.exports = &#123;<br>            add: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>                <span class="hljs-keyword">return</span> x + y;<br>            &#125;<br>        &#125;;<br>    &#125;,<br>    <span class="hljs-string">&quot;./square&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;加载了 square 模块&#x27;</span>);<br><br>        <span class="hljs-keyword">var</span> multiply = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./multiply&quot;</span>);<br>        <span class="hljs-built_in">module</span>.exports = &#123;<br>            square: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) </span>&#123;<br>                <span class="hljs-keyword">return</span> multiply.multiply(num, num);<br>            &#125;<br>        &#125;;<br>    &#125;,<br><br>    <span class="hljs-string">&quot;./multiply&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;加载了 multiply 模块&#x27;</span>);<br><br>        <span class="hljs-built_in">module</span>.exports = &#123;<br>            multiply: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>                <span class="hljs-keyword">return</span> x * y;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">最终的执行结果为：<br><br>加载了 <span class="hljs-built_in">add</span> 模块<br><span class="hljs-number">2</span><br>加载了 square 模块<br>加载了 <span class="hljs-built_in">multiply</span> 模块<br><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://juejin.cn/post/7048139060983889950#heading-1">CommonJS和ES6模块有什么区别!</a><br><a href="https://juejin.cn/post/6844903712553435149#heading-11">ES6 系列之模块加载方案</a></p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node相关&amp;&amp;Koa与Express的区别</title>
    <link href="/2022/03/01/Koa%E4%B8%8EExpress%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/03/01/Koa%E4%B8%8EExpress%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="node有哪些相关的文件路径？"><a href="#node有哪些相关的文件路径？" class="headerlink" title="node有哪些相关的文件路径？"></a>node有哪些相关的文件路径？</h3><p>答案是：Node 中的文件路径有 __dirname,__filename, process.cwd(), ./ 或者 ../下面用一个例子来介绍这几种文件路径的区别</p><p>__dirname: 总是返回被执行的 js 所在文件夹的绝对路径<br>__filename: 总是返回被执行的 js 的绝对路径<br>process.cwd(): 总是返回运行 node 命令时所在的文件夹的绝对路径</p><h3 id="node的http模块创建服务与Express或Koa框架有何不同"><a href="#node的http模块创建服务与Express或Koa框架有何不同" class="headerlink" title="node的http模块创建服务与Express或Koa框架有何不同?"></a>node的http模块创建服务与Express或Koa框架有何不同?</h3><p>答案是：express是一个服务端框架,框架简单封装了node的http模块,express支持node原生的写法,express不仅封装好服务器，还封装了中间件、路由等特征，方便开发web服务器，</p><blockquote><p>换句话说express = http模块 + 中间件 + 路由</p></blockquote><h3 id="Express和Koa框架中间件有什么不同？"><a href="#Express和Koa框架中间件有什么不同？" class="headerlink" title="Express和Koa框架中间件有什么不同？"></a>Express和Koa框架中间件有什么不同？</h3><p>答案：中间件： app.use方法就是往中间件队列中塞入新的中间件，express中间件处理方式是线性的，next过后继续寻找下一个中间件，当然如果没有调用next()的话，就不会调用下一个函数了，调用就会被终止</p><h5 id="express-中间件：是通过-next-的机制，即上一个中间件会通过-next-触发下一个中间件"><a href="#express-中间件：是通过-next-的机制，即上一个中间件会通过-next-触发下一个中间件" class="headerlink" title="express 中间件：是通过 next 的机制，即上一个中间件会通过 next 触发下一个中间件"></a>express 中间件：是通过 next 的机制，即上一个中间件会通过 next 触发下一个中间件</h5><h5 id="koa2-中间件：是通过-async-await-实现的，中间件执行顺序是“洋葱圈”模型（推荐）"><a href="#koa2-中间件：是通过-async-await-实现的，中间件执行顺序是“洋葱圈”模型（推荐）" class="headerlink" title="koa2 中间件：是通过 async await 实现的，中间件执行顺序是“洋葱圈”模型（推荐）"></a>koa2 中间件：是通过 async await 实现的，中间件执行顺序是“洋葱圈”模型（推荐）</h5><p>洋葱模型其实就是中间件处理的流程，中间件生命周期大致有：</p><p><strong>前期处理,交给并等待其它中间件处理,后期处理</strong></p><p><img src="/imageO/YC.jpg" alt="洋葱模型"><br>先回顾一下，Koa2.js 中下面代码打印输出顺序为：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa()<br><br>app.use(<span class="hljs-keyword">async</span> (cxt, next) =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;middleware_01 start&#x27;</span>)<br>  <span class="hljs-keyword">await</span> next()<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;middleware_01 end&#x27;</span>)<br>&#125;)<br><br>app.use(<span class="hljs-keyword">async</span> (cxt, next) =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;middleware_02 start&#x27;</span>)<br>  <span class="hljs-keyword">await</span> next()<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;middleware_02 end&#x27;</span>)<br>&#125;)<br><br>app.use(<span class="hljs-keyword">async</span> (cxt, next) =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;middleware_03 start&#x27;</span>)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;middleware_03 end&#x27;</span>)<br>&#125;)<br><br>app.listen(<span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">// 浏览器访问：<span class="hljs-keyword">http</span>://localhost:<span class="hljs-number">3000</span><br>// 输出顺序为：<br>middleware_01 <span class="hljs-built_in">start</span><br>middleware_02 <span class="hljs-built_in">start</span><br>middleware_03 <span class="hljs-built_in">start</span><br>middleware_03 <span class="hljs-keyword">end</span><br>middleware_02 <span class="hljs-keyword">end</span><br>middleware_01 <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/6844904031152783374">掘金</a></p><h3 id="Koa与Express的区别"><a href="#Koa与Express的区别" class="headerlink" title="Koa与Express的区别"></a>Koa与Express的区别</h3><h4 id="Koa"><a href="#Koa" class="headerlink" title="Koa"></a>Koa</h4><ul><li>基于node的一个web开发框架，利用co作为底层运行框架，利用Generator的特性，实现“无回调”的异步处理；</li><li>ES7;</li><li>更小、更富有表现力、更健壮的基石；</li><li>利用async函数、Koa丢弃回调函数，增强错误处理；</li><li>很小的体积，因为没有捆绑任何中间件；</li><li>类似堆栈的方式组织和执行；</li><li>低级中间件层中提供高级“语法糖”，提高了互操性、稳健性；</li></ul><p>可以看到要从洋葱中心点穿过去，就必须先一层层向内穿入洋葱表皮进入中心点，然后再从中心点一层层向外穿出表皮，这里有个特点：进入时穿入了多少层表皮，出去时就必须穿出多少层表皮。先穿入表皮，后穿出表皮，符合我们所说的<strong>栈列表，先进后出的原则</strong>。</p><h4 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h4><ul><li>Node的基础框架，基础Connect中间件，自身封装了路由、视图处理等功能；</li><li>线性逻辑，路由和中间件完美融合，清晰明了；</li><li>弊端是callback回调方式，不可组合、异常不可捕获；</li><li>ES5;</li><li>connect的执行流程： connect的中间件模型是线性的，即一个一个往下执行；</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><h5 id="Handler的处理"><a href="#Handler的处理" class="headerlink" title="Handler的处理"></a>Handler的处理</h5><p>Express普通回调函数，在同一线程上完成当前进程的所有Http请求；<br>Koa利用Generator Function作为响应器，co作为底层运行框架，利用Generator特性，实现“协程响应”；</p><h5 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h5><p>Express的路由是自身集成的；<br>Koa的需要引入中间件Koa-router；</p><h5 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h5><p>koa采用new Koa()<br>express采用传统的函数形式function；</p><h5 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h5><p>Koa没有回调<br>express有回调；</p><h5 id="Http-Request"><a href="#Http-Request" class="headerlink" title="Http Request"></a>Http Request</h5><p>koa1使用this取代Express的req、res；</p><h5 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h5><p>Koa新增了一个Context对象，用来代替Express的Request和Response，作为请求的上下文对象。<br>还有Node原生提供的req、res、socket等对象；</p><h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><p>Express的生命周期不确定：express内部执行异步函数，不能确定什么时候执行完；<br>Koa确定：koa是基于await/async，在执行下一步操作的时候，必须等待前端await执行完；</p><h5 id="异步流程"><a href="#异步流程" class="headerlink" title="异步流程"></a>异步流程</h5><p> Express采用callback来处理异步(ES5)；<br> Koa1采用generator(ES6)；<br> Koa2采用async/await(ES7)；</p><h5 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h5><p> Express使用callback捕获异常，深层次的异常捕获不了；<br> Koa使用try catch，很好的解决异常捕获；</p><h5 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h5><h6 id="koa2的中间件"><a href="#koa2的中间件" class="headerlink" title="koa2的中间件"></a>koa2的中间件</h6><p>   1、通过async await实现的，中间件执行的顺序是“洋葱圈”模型。<br>   2、中间件之间通过next函数联系，当一个中间件调用next()后，会将控制权交给下一个中间件，直到下一个中间件不再执行next()后，会沿路返回，将控制权交给前一个中间件。</p><h6 id="Express中间件"><a href="#Express中间件" class="headerlink" title="Express中间件"></a>Express中间件</h6><p>  1、一个接一个顺序执行，response响应写在最后一个中间件中。<br>  2、特点：<br>   a.app.use用来注册中间件；<br>   b.遇到http请求，根据path和method判断触发哪些中间件；<br>   c.实现next机制，即上一个中间件会通过next触发下一个中间件；</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://juejin.cn/post/6844904196265754638#comment">面试官问你关于node的那些事（基础篇）</a><br><a href="https://juejin.cn/post/6875152985949732872">前端面试—Koa与Express的区别</a></p>]]></content>
    
    
    <categories>
      
      <category>Node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Js数组基本问题</title>
    <link href="/2022/02/28/Js%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/02/28/Js%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>总结了最近的一些面试题和之前的知识点</p><hr><h3 id="JS判断数组中是否包含某个值"><a href="#JS判断数组中是否包含某个值" class="headerlink" title="JS判断数组中是否包含某个值"></a>JS判断数组中是否包含某个值</h3><h4 id="方法一：array-indexOf"><a href="#方法一：array-indexOf" class="headerlink" title="方法一：array.indexOf"></a>方法一：array.indexOf</h4><p>此方法判断数组中是否存在某个值，如果存在，则返回数组元素的下标，否则返回-1。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-attribute">var</span> index=arr.indexOf(<span class="hljs-number">3</span>);<br><span class="hljs-attribute">console</span>.log(index);<br></code></pre></td></tr></table></figure><h4 id="方法二：array-includes-searcElement-fromIndex"><a href="#方法二：array-includes-searcElement-fromIndex" class="headerlink" title="方法二：array.includes(searcElement[,fromIndex])"></a>方法二：array.includes(searcElement[,fromIndex])</h4><p>此方法判断数组中是否存在某个值，如果存在返回true，否则返回false</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-attribute">if</span>(arr.includes(<span class="hljs-number">3</span>))<br>    <span class="hljs-attribute">console</span>.log(<span class="hljs-string">&quot;存在&quot;</span>);<br><span class="hljs-attribute">else</span><br>    <span class="hljs-attribute">console</span>.log(<span class="hljs-string">&quot;不存在&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="方法三：array-find-callback-thisArg"><a href="#方法三：array-find-callback-thisArg" class="headerlink" title="方法三：array.find(callback[,thisArg])"></a>方法三：array.find(callback[,thisArg])</h4><p>返回数组中满足条件的第一个元素的值，如果没有，返回undefined</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-keyword">var</span> result = arr.find(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> item &gt; <span class="hljs-number">3</span><br>&#125;);<br>console.log(result);<br></code></pre></td></tr></table></figure><p>如果元素是对象：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">var</span> items=[<br>    &#123;<span class="hljs-attribute">id:</span><span class="hljs-string">1,name</span>:<span class="hljs-string">&#x27;yxy&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attribute">id:</span><span class="hljs-string">2,name</span>:<span class="hljs-string">&#x27;whc&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attribute">id:</span><span class="hljs-string">3,name</span>:<span class="hljs-string">&#x27;hzj&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attribute">id:</span><span class="hljs-string">4,name</span>:<span class="hljs-string">&#x27;fyq&#x27;</span>&#125;<br>];<br><span class="hljs-keyword">var</span> result = items.find(item=&gt;&#123;<br>    <span class="hljs-keyword">return</span> item.id == <span class="hljs-number">3</span>;<br>&#125;);<br><span class="hljs-built_in">console</span>.log(result);<br></code></pre></td></tr></table></figure><h4 id="方法四：array-findeIndex-callback-thisArg"><a href="#方法四：array-findeIndex-callback-thisArg" class="headerlink" title="方法四：array.findeIndex(callback[,thisArg])"></a>方法四：array.findeIndex(callback[,thisArg])</h4><p>返回数组中满足条件的第一个元素的下标，如果没有找到，返回**-1**</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-keyword">var</span> result = arr.findIndex(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> item &gt; <span class="hljs-number">3</span><br>&#125;);<br>console.log(result);<br></code></pre></td></tr></table></figure><h4 id="方法五：当然不能忘了养大我们的for循环和if"><a href="#方法五：当然不能忘了养大我们的for循环和if" class="headerlink" title="方法五：当然不能忘了养大我们的for循环和if"></a>方法五：当然不能忘了养大我们的for循环和if</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-built_in">var</span> k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">var</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-built_in">length</span>;i++)&#123;<br>    <span class="hljs-keyword">if</span>(arr[i]==<span class="hljs-number">3</span>)<br>        k=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(k)<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;存在&quot;</span>);<br><span class="hljs-keyword">else</span><br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;不存在&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="js获取数组中的最大值"><a href="#js获取数组中的最大值" class="headerlink" title="js获取数组中的最大值"></a>js获取数组中的最大值</h3><ol><li>es6拓展运算符</li></ol><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">Math.<span class="hljs-keyword">max</span>(<span class="hljs-params">...</span>arr)<br></code></pre></td></tr></table></figure><ol start="2"><li>es5 apply(与方法1原理相同)</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>,arr)<br></code></pre></td></tr></table></figure><ol start="3"><li>for循环</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> <span class="hljs-built_in">max</span> = arr[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-built_in">max</span> = <span class="hljs-built_in">max</span> &lt; arr[i+<span class="hljs-number">1</span>] ? arr[i+<span class="hljs-number">1</span>] : <span class="hljs-built_in">max</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>数组sort()</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">arr.sort(<span class="hljs-function"><span class="hljs-params">(num1, num2)</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> num1 - num2 &lt; <span class="hljs-number">0</span><br>&#125;)<br>arr[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><ol start="5"><li>数组reduce</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">arr</span>.reduce((num<span class="hljs-number">1</span>, num<span class="hljs-number">2</span>) =&gt; &#123;<br>    <span class="hljs-attribute">return</span> num<span class="hljs-number">1</span> &gt; num<span class="hljs-number">2</span> ? num<span class="hljs-number">1</span> : num<span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="js获取最大值和最小值"><a href="#js获取最大值和最小值" class="headerlink" title="js获取最大值和最小值"></a>js获取最大值和最小值</h3><ol><li>排序法</li><li>假设法  （for 循环前后逐一对比）</li><li>Math max() min()</li><li>ES</li></ol><h3 id="JS求数组的交集、并集、差集"><a href="#JS求数组的交集、并集、差集" class="headerlink" title="JS求数组的交集、并集、差集"></a>JS求数组的交集、并集、差集</h3><p>现有两个数组</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span> = [<span class="hljs-number">101</span>,<span class="hljs-number">201</span>,<span class="hljs-number">601</span>]<br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span> = [<span class="hljs-number">201</span>,<span class="hljs-number">301</span>,<span class="hljs-number">801</span>]<br></code></pre></td></tr></table></figure><h4 id="求交集（交集元素由既属于集合a又属于集合b的元素组成）"><a href="#求交集（交集元素由既属于集合a又属于集合b的元素组成）" class="headerlink" title="求交集（交集元素由既属于集合a又属于集合b的元素组成）"></a>求交集（交集元素由既属于集合a又属于集合b的元素组成）</h4><ol><li>方法1  filter  includes()</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let intersection = <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.filter</span>(v =&gt; <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.includes</span>(v)) <span class="hljs-comment">// [201]</span><br></code></pre></td></tr></table></figure><ol start="2"><li>方法2  filter  indexOf()</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> intersection = a.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>&#123; <span class="hljs-keyword">return</span> b.indexOf(v) &gt; -<span class="hljs-number">1</span> &#125;) <span class="hljs-comment">//[201]</span><br></code></pre></td></tr></table></figure><ol start="3"><li>方法3  filter Set() set.has</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> intersection = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>from(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Set(<span class="hljs-params">a</span>.<span class="hljs-params">filter</span>(<span class="hljs-params">v</span>=&gt; <span class="hljs-params">new</span> Set(<span class="hljs-params">b</span>)</span>.has(v))))  <span class="hljs-comment">//[201]</span><br><br></code></pre></td></tr></table></figure><ol start="4"><li>方法4  </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> intersection = a.filter(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(b).has(v))  <span class="hljs-comment">// [201]</span><br></code></pre></td></tr></table></figure><h4 id="2-求并集-并集元素由集合a和集合b中所有元素去重组成"><a href="#2-求并集-并集元素由集合a和集合b中所有元素去重组成" class="headerlink" title="2.求并集 (并集元素由集合a和集合b中所有元素去重组成)"></a>2.求并集 (并集元素由集合a和集合b中所有元素去重组成)</h4><ol><li>方法1  filter  includes()</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let union = <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.concat</span>(<span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.filter</span>(v=&gt; &#123;<br>   return !<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.includes</span>(v)<br> &#125;<br>)) <span class="hljs-comment">// [101, 201, 601, 301, 801]</span><br></code></pre></td></tr></table></figure><ol start="2"><li>方法2  Array.from()  Set()  concat() (最简单)</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> union = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>from(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Set(<span class="hljs-params">a</span>.<span class="hljs-params">concat</span>(<span class="hljs-params">b</span>)</span>)) <span class="hljs-comment">// [101, 201, 601, 301, 801]</span><br></code></pre></td></tr></table></figure><ol start="3"><li>方法3    concat()  filter()  indexOf()</li></ol><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">let <span class="hljs-built_in">union</span> = <span class="hljs-keyword">a</span>.concat(b.<span class="hljs-built_in">filter</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-title">v</span>) &#123;</span><br>    <span class="hljs-literal">return</span> <span class="hljs-keyword">a</span>.indexOf(v) === <span class="hljs-number">-1</span><br>&#125;))<span class="hljs-comment"> // [101, 201, 601, 301, 801]</span><br></code></pre></td></tr></table></figure><h4 id="3-求差集-差集元素由集合a和集合b的并集减去集合a和集合b的交集"><a href="#3-求差集-差集元素由集合a和集合b的并集减去集合a和集合b的交集" class="headerlink" title="3.求差集 (差集元素由集合a和集合b的并集减去集合a和集合b的交集)"></a>3.求差集 (差集元素由集合a和集合b的并集减去集合a和集合b的交集)</h4><ol><li>方法1  (写法最优。indexOf有个对NaN返回-1的问题)</li></ol><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">let <span class="hljs-built_in">difference</span> = <span class="hljs-keyword">a</span>.concat(b).<span class="hljs-built_in">filter</span>(v =&gt; !<span class="hljs-keyword">a</span>.includes(v) || !b.includes(v))) <span class="hljs-comment"> // [101, 601, 301, 801]</span><br></code></pre></td></tr></table></figure><ol start="2"><li>方法2</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> difference = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>from(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Set(<span class="hljs-params">a</span>.<span class="hljs-params">concat</span>(<span class="hljs-params">b</span>)</span>.filter(<br> <span class="hljs-function"> <span class="hljs-params">v</span> =&gt;</span> !<span class="hljs-keyword">new</span> <span class="hljs-constructor">Set(<span class="hljs-params">a</span>)</span>.has(v)<span class="hljs-operator"> || </span>!<span class="hljs-keyword">new</span> <span class="hljs-constructor">Set(<span class="hljs-params">b</span>)</span>.has(v)<br>))) <span class="hljs-comment">// [101, 601, 301, 801]</span><br></code></pre></td></tr></table></figure><ol start="3"><li>方法3</li></ol><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">let <span class="hljs-built_in">difference</span> = <span class="hljs-keyword">a</span>.<span class="hljs-built_in">filter</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-title">v</span>) &#123;</span><br>    <span class="hljs-literal">return</span> b.indexOf(v) === <span class="hljs-number">-1</span><br>&#125;).concat(b.<span class="hljs-built_in">filter</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-title">v</span>) &#123;</span><br>    <span class="hljs-literal">return</span> <span class="hljs-keyword">a</span>.indexOf(v) === <span class="hljs-number">-1</span><br>&#125;))<span class="hljs-comment"> // [101, 601, 301, 801]</span><br></code></pre></td></tr></table></figure><h3 id="JS如何实现数组扁平化？"><a href="#JS如何实现数组扁平化？" class="headerlink" title="JS如何实现数组扁平化？"></a>JS如何实现数组扁平化？</h3><h4 id="ES6的flat"><a href="#ES6的flat" class="headerlink" title="ES6的flat"></a>ES6的flat</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ary = arr<span class="hljs-selector-class">.flat</span>(Infinity)<br>console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-attr">[1, [2, 3, [4, 5]</span>]]<span class="hljs-selector-class">.flat</span>(Infinity))<br></code></pre></td></tr></table></figure><p>Array.protype.flat()用于将数组“拉平”，变成一维数组，返回一个新数组。flat()默认只会拉平一层，flat（n）拉平n层，Infinity无限次。好用归好用，但效率我们就心里明白，这也是我们面试官最不想听到的答案了。</p><h4 id="正则处理"><a href="#正则处理" class="headerlink" title="正则处理"></a>正则处理</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>第一种处理<br>ary = str.replace(<span class="hljs-regexp">/(\[|\])/g</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br><br><span class="hljs-regexp">//</span>第二种处理<br>str = str.replace(<span class="hljs-regexp">/(\[|\]))/g</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>str = <span class="hljs-string">&#x27;[&#x27;</span> + str + <span class="hljs-string">&#x27;]&#x27;</span>;<br>ary = JSON.parse(str);<br></code></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-keyword">let</span> arr = <span class="hljs-literal">[<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]</span>]];<br><br> <span class="hljs-keyword">function</span> flattern(arr,result =<span class="hljs-literal">[]</span>) &#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">arr</span>[<span class="hljs-params">i</span>])</span>) &#123;<br>                flattern(arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, result)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result.push(arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)<br>            &#125;<br>        &#125;<br>        return result;<br>    &#125;<br>console.log(flattern(arr));<br></code></pre></td></tr></table></figure><p>这也是我当时面试想到最简单的解决方案，思路很简单，通过遍历最外层数组的每一个元素，看看是否还是数组，如果是的话，继续递归执行，不是的话，放到最后的结果数组当中</p><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prev, next</span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> prev.concat(<span class="hljs-built_in">Array</span>.isArray(next) ? flatten(next) : next)<br>    &#125;, [])<br>&#125;<br><span class="hljs-built_in">console</span>.log(flatten(arr))<br><br><span class="hljs-comment">//reduce搭配扩展运算符</span><br><span class="hljs-keyword">const</span> flatten = <span class="hljs-function">(<span class="hljs-params">array</span>) =&gt;</span> array.reduce(<span class="hljs-function">(<span class="hljs-params">acc,cur</span>)=&gt;</span><br>    (<span class="hljs-built_in">Array</span>.isArray(cur)?[...acc,...flatten(cur)]:[...acc,cur]),[])<br></code></pre></td></tr></table></figure><p>提到数组的方法，就会联想到非常常用的2个高阶函数map和reduce。其实思路上和上面递归的很相似。</p><h4 id="ES6扩展运算符"><a href="#ES6扩展运算符" class="headerlink" title="ES6扩展运算符"></a>ES6扩展运算符</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>],<span class="hljs-number">8</span>],<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,[<span class="hljs-number">11</span>,[<span class="hljs-number">12</span>,<span class="hljs-number">13</span>]]];<br><span class="hljs-keyword">const</span> flatten = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">while</span>(arr.some(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span><span class="hljs-built_in">Array</span>.isArray(item)))&#123;<br>        arr=[].concat(...arr);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-built_in">console</span>.log(flatten(arr)); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]</span><br></code></pre></td></tr></table></figure><p>由于扩展运算符一次只能展开一层数组</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">var arr = <span class="hljs-comment">[1, <span class="hljs-comment">[2, <span class="hljs-comment">[3, 4]</span>]</span>]</span>;<br>console.log(<span class="hljs-comment">[]</span>.concat(...arr)); // <span class="hljs-comment">[1, 2, <span class="hljs-comment">[3, 4]</span>]</span><br></code></pre></td></tr></table></figure><p>因此考虑只要数组中还有数组，就使用扩展运算符展开一次。</p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl">function flatten(arr)&#123;<br><br>    //arr.join(<span class="hljs-string">&#x27;,&#x27;</span>).<span class="hljs-keyword">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>);  <span class="hljs-keyword">join</span>也可以实现  <br>    <span class="hljs-keyword">return</span> arr.toString().<span class="hljs-keyword">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>).map(function(item)&#123;<br>        <span class="hljs-keyword">return</span> +item;  <span class="hljs-regexp">//</span>+将字符转换为数字<br> &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果数组的元素都是数字，可以考虑使用 toString 方法，因为：toString会将数组中的数以逗号形式结合起来。toString之后再split转成数组，并将其转换回数字。所以这种场景只适用于数组内全部是数字的情况，因为中间是全部转换为字符串了。</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6978115075672375326">🔥🔥JS如何实现数组扁平化？不同的方法有什么区别？</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中父子组件生命周期执行顺</title>
    <link href="/2022/02/28/Vue%E4%B8%AD%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E9%A1%BA/"/>
    <url>/2022/02/28/Vue%E4%B8%AD%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E9%A1%BA/</url>
    
    <content type="html"><![CDATA[<p>问题背景</p><p>在单一组件中，钩子的执行顺序是beforeCreate-&gt; created -&gt; mounted-&gt;… -&gt;destroyed，但当父子组件嵌套时，父组件和子组件各拥有各自独立的钩子函数，这些父子组件的这些钩子是如何交融执行，且执行顺序又是怎样的呢?</p><hr><h3 id="父子组件生命周期执行顺序"><a href="#父子组件生命周期执行顺序" class="headerlink" title="父子组件生命周期执行顺序"></a>父子组件生命周期执行顺序</h3><p>组件，分别在他们的钩子函数中打印日志，观察执行顺序。得到的结果如图所示，父组件先创建，然后子组件创建；子组件先挂载，然后父组件挂载。</p><p>父beforeCreate-&gt; 父create -&gt; 子beforeCreate-&gt; 子created -&gt; 子mounted -&gt; 父mounted</p><blockquote><p>子组件挂载完成后，父组件还未挂载。所以组件数据回显的时候，在父组件mounted中获取api的数据，子组件的mounted是拿不到的。子组件挂载完成后，父组件还未挂载。所以组件数据回显的时候，在父组件mounted中获取api的数据，子组件的mounted是拿不到的。</p></blockquote><h4 id="仔细看看父子组件生命周期钩子的执行顺序，会发现created这个钩子是按照从外内顺序执行，所以父子组件传递接口数据的解决方案是"><a href="#仔细看看父子组件生命周期钩子的执行顺序，会发现created这个钩子是按照从外内顺序执行，所以父子组件传递接口数据的解决方案是" class="headerlink" title="仔细看看父子组件生命周期钩子的执行顺序，会发现created这个钩子是按照从外内顺序执行，所以父子组件传递接口数据的解决方案是"></a>仔细看看父子组件生命周期钩子的执行顺序，会发现created这个钩子是按照从外内顺序执行，所以父子组件传递接口数据的解决方案是</h4><p>在created中发起请求获取数据，依次在子组件的created或者mounted中会接收到这个数据。</p><h3 id="父子组件生命周期执行顺序-1"><a href="#父子组件生命周期执行顺序-1" class="headerlink" title="父子组件生命周期执行顺序"></a>父子组件生命周期执行顺序</h3><p>加载渲染过程</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">父<span class="hljs-function"><span class="hljs-title">beforeCreate</span>-&gt;</span>父<span class="hljs-function"><span class="hljs-title">created</span>-&gt;</span>父<span class="hljs-function"><span class="hljs-title">beforeMount</span>-&gt;</span>子<span class="hljs-function"><span class="hljs-title">beforeCreate</span>-&gt;</span>子<span class="hljs-function"><span class="hljs-title">created</span>-&gt;</span>子<span class="hljs-function"><span class="hljs-title">beforeMount</span>-&gt;</span>子<span class="hljs-function"><span class="hljs-title">mounted</span>-&gt;</span>父mounted<br></code></pre></td></tr></table></figure><h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">父<span class="hljs-function"><span class="hljs-title">beforeUpdate</span>-&gt;</span>子<span class="hljs-function"><span class="hljs-title">beforeUpdate</span>-&gt;</span>子<span class="hljs-function"><span class="hljs-title">updated</span>-&gt;</span>父updated<br></code></pre></td></tr></table></figure><h3 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">父<span class="hljs-function"><span class="hljs-title">beforeDestroy</span>-&gt;</span>子<span class="hljs-function"><span class="hljs-title">beforeDestroy</span>-&gt;</span>子<span class="hljs-function"><span class="hljs-title">destroyed</span>-&gt;</span>父destroyed<br></code></pre></td></tr></table></figure><h3 id="注意-在父组件传递接口的数据给子组件时，一定要在子组件标签上加上v-if-”传递的接口数据”"><a href="#注意-在父组件传递接口的数据给子组件时，一定要在子组件标签上加上v-if-”传递的接口数据”" class="headerlink" title="注意 在父组件传递接口的数据给子组件时，一定要在子组件标签上加上v-if=”传递的接口数据”"></a>注意 在父组件传递接口的数据给子组件时，一定要在子组件标签上加上v-if=”传递的接口数据”</h3><p>在父组件的created中发请求获取数据，通过prop传递给子组件。子组件在created或者mounted中拿父组件传递过来的数据  这样处理是有问题的。</p><p>在父组件调用接口传递数据给子组件时，接口响应显然是异步的。这会导致无论你在父组件哪个钩子发请求，在子组件哪个钩子接收数据。都是取不到的。当子组件的mounted都执行完之后，此时可能父组件的请求才返回数据。会导致，从父组件传递给子组件的数据是undefined。</p><h4 id="解决方法1-v-if"><a href="#解决方法1-v-if" class="headerlink" title="解决方法1:v-if"></a>解决方法1:v-if</h4><p>在渲染子组件的时候加上一个条件,data1是父组件调用接口返回的数据。当有数据的时候在去渲染子组件。这样就会形成天然的阻塞。在父组件的created中的请求返回数据后，才会执行子组件的created，mounted。最后执行父组件的mounted。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">children</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;data1&quot;</span> <span class="hljs-attr">:data</span>=<span class="hljs-string">&quot;data1&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">children</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="在子组件中-watch-监听，父组件获取到值，这个值就会变化，自然是可以监听到的"><a href="#在子组件中-watch-监听，父组件获取到值，这个值就会变化，自然是可以监听到的" class="headerlink" title="在子组件中 watch 监听，父组件获取到值，这个值就会变化，自然是可以监听到的"></a>在子组件中 watch 监听，父组件获取到值，这个值就会变化，自然是可以监听到的</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe">watch:<span class="hljs-type"></span>&#123;<br>    data:<span class="hljs-type"></span>&#123;<br>      deep:<span class="hljs-type">true</span>,<br>      handler:<span class="hljs-type">function</span>(<span class="hljs-keyword">new</span><span class="hljs-type">Val</span>,oldVal) &#123;<br>        <span class="hljs-built_in">this</span>.$nextTick(() =&gt; &#123;<br>          <span class="hljs-built_in">this</span>.data = <span class="hljs-keyword">new</span><span class="hljs-type">Val</span><br><span class="hljs-type"></span>          <span class="hljs-built_in">this</span>.data = <span class="hljs-keyword">new</span><span class="hljs-type">Val</span>.url ? <span class="hljs-keyword">new</span><span class="hljs-type">Val</span>.url : <span class="hljs-type"></span>&#x27;<span class="hljs-string">&#x27;</span><br><span class="hljs-string">        &#125;)</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>从父组件点击调用接口并显示子组件，子组件拿到数据并监听在watch中调用方法并显示</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844904113914773518#comment">Vue中父子组件生命周期执行顺序回顾</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS项目优化问题（项目面试题）</title>
    <link href="/2022/02/26/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/"/>
    <url>/2022/02/26/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>总结了最近的一些面试题和之前的知识点</p><hr><h3 id="前端性能优化建议"><a href="#前端性能优化建议" class="headerlink" title="前端性能优化建议"></a>前端性能优化建议</h3><ol><li>减少 HTTP 请求</li><li>使用 HTTP2</li><li>静态资源使用 CDN</li><li>将 CSS 放在文件头部，JavaScript 文件放在底部（CSS 执行会阻塞渲染，阻止 JS 执行;<br>JS 加载和执行会阻塞 HTML 解析，阻止 CSSOM 构建）</li><li>图片优化</li><li>减少重绘重排</li><li>CSS 选择器优先级<br><a href="https://pengzhenglong.github.io/2022/03/28/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">博客</a></li></ol><h3 id="防止表单重复提交的解决方案"><a href="#防止表单重复提交的解决方案" class="headerlink" title="防止表单重复提交的解决方案"></a>防止表单重复提交的解决方案</h3><p>用户在操作表单Post数据时往往会出现表单数据重复提交的问题，尤其在Web开发中此类问题比较常见。刷新页面，后退操作以前的页面，单机多次按钮都会导致数据重复提交。此类问题是因为浏览器重复提交HTTP请求导致。</p><h4 id="1、-在数据库添加唯一字段"><a href="#1、-在数据库添加唯一字段" class="headerlink" title="1、 在数据库添加唯一字段"></a>1、 在数据库添加唯一字段</h4><p>在数据库建表的时候在ID字段添加主键约束，账号，名称的信息添加唯一性约束。确保数据库只可以添加一条数据。<br>此方法从根本上的防止了数据重复提交。</p><h4 id="2、-用js为添加按钮禁用"><a href="#2、-用js为添加按钮禁用" class="headerlink" title="2、 用js为添加按钮禁用"></a>2、 用js为添加按钮禁用</h4><p>当用户提交表单之后，可以使用js将提交按钮隐藏（disable属性），防止用户多次点击按钮提交数据。<br>注意：如果客户端禁用了js，则此方法无效。</p><h4 id="3、-使用Post-Redirect-Get"><a href="#3、-使用Post-Redirect-Get" class="headerlink" title="3、 使用Post/Redirect/Get"></a>3、 使用Post/Redirect/Get</h4><p>Post/Redirect/Get简称PRG，是一种可以防止表单数据重复提交的一种Web设计模式，像用户刷新提交响应页面等比较典型的重复提交表单数据的问题可以使用PRG模式来避免。例如：当用户提交成功之后，执行客户端重定向，跳转到提交成功页面。<br>注意：PRG设计模式并不适用所有的重复提交情况，比如：</p><p>1）由于服务器响应缓慢，用户刷新提交POST请求造成的重复提交。</p><p>2）用户点击后退按钮，返回到数据提交界面，导致的数据重复提交。</p><p>3）用户多次点击提交按钮，导致的数据重复提交。</p><p>4）用户恶意避开客户端预防多次提交手段，进行重复数据提交。</p><h4 id="4、-使用Session设置令牌"><a href="#4、-使用Session设置令牌" class="headerlink" title="4、 使用Session设置令牌"></a>4、 使用Session设置令牌</h4><p>客户端请求页面时，服务器为每次产生的Form表单分配唯一的随机标识号，并且在Form的一个隐藏字段中设置这个标识号，同时在当前用户的Session中保存这个标识号。当提交表单时，服务器比较hidden和session中的标识号是否相同，相同则继续，处理完后清空Session，否则服务器忽略请求。</p><p>注意：恶意用户可利用这一性质，不断重复访问页面，以致Session中保存的标识号不断增多，最终严重消耗服务器内存。可以采用在Session中记录用户发帖的时间，然后通过一个时间间隔来限制用户连续发帖的数量来解决这一问题。</p><h5 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h5><p><a href="https://juejin.cn/post/6968747879682801672">防止表单重复提交的解决方案整理</a></p><h3 id="渲染十万条数据解决方案"><a href="#渲染十万条数据解决方案" class="headerlink" title="渲染十万条数据解决方案"></a>渲染十万条数据解决方案</h3><p>虚拟列表是最主流的解决方案，不渲染所有的数据，只渲染可视区域中的数据。当用户滑（滚）动时，通过监听 scroll 来判断是上滑还是下拉，从而更新数据。同理 IntersectionObserver 和 getBoundingClientRect 都能实现</p><p>延迟渲染，也叫懒加载。顾名思义，最开始不渲染所有数据，只渲染可视区域中的数据（同虚拟列表一致）。当滚动到页面底部时，添加数据（concat），视图渲染新增DOM</p><p>时间分片主要是分批渲染DOM，使用 requestAnimationFrame 来让动画更加流畅</p><h4 id="虚拟列表（也叫按需渲染或可视区域渲染）"><a href="#虚拟列表（也叫按需渲染或可视区域渲染）" class="headerlink" title="虚拟列表（也叫按需渲染或可视区域渲染）"></a>虚拟列表（也叫按需渲染或可视区域渲染）</h4><h5 id="什么是虚拟列表"><a href="#什么是虚拟列表" class="headerlink" title="什么是虚拟列表"></a>什么是虚拟列表</h5><p>虚拟列表是按需显示的一种实现，即<strong>只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术</strong>，是对长列表渲染的优化手段<br>说的明白一点，就是展示可视区域中的内容，当你向上向下滚动时，通过 DOM API 替换可视区域中的数据，做到动态加载十万条数据</p><h5 id="两种解决思路"><a href="#两种解决思路" class="headerlink" title="两种解决思路"></a>两种解决思路</h5><p>关于无限滚动，早期通过监听 scroll 事件，这是最常见的解决方案。可去 图片懒加载 中查看，简单来说，就是通过子项的 offsetTop（偏移高度）与 innerHeight（视窗高度）+ scrollTop（滚动高度）做对比来实现，当偏移高度 &lt; 视窗高度+滚动高度时，说明已经滚到下方，就可展示图片<br>在 图片懒加载 中我们也提及 IntersectionObserver（交叉观察者）API，以此来解决 scroll 所不具备的效果，即  IntersectionObserver API 是异步的，不随目标元素的滚动同步触发，性能消耗小。当然还可以通过 getBoundingClientRect 来实现，getBoundingClientRect 方法返回元素的大小机器相对于视窗的位置</p><h6 id="scroll-解决方案"><a href="#scroll-解决方案" class="headerlink" title="scroll 解决方案"></a>scroll 解决方案</h6><p>先说 <strong>scroll 解决方案，简单来说，就是对其传来的数据进行分割展示，用到 slice 方法，它会返回一个新的数组</strong><br>我们假设单个列表高度为 30px，一页展示的列表数量为 const count = Math.ceil(列表高度 / 30)，展示的数据就是 visibleData = data.slice(start, start + count)（start 一开始为0）<br>当滚动时，动态修改 start 和 visibleData，虚拟列表scroll无virtual-list-phantom</p><p>这种方法的精髓在于设置开始渲染的点和展示的数据，当他滚动时动态修改，但是因为<strong>scroll 会频繁触发，当渲染的数据变多后会有性能问题</strong></p><h6 id="IntersectionObserver-解决方案"><a href="#IntersectionObserver-解决方案" class="headerlink" title="IntersectionObserver 解决方案"></a>IntersectionObserver 解决方案</h6><p>通过 IntersectionObserver 的特性，当目标对象中的 entry.isIntersecting 为 true 或者 intersectionRatio &gt; 0 （元素与祖先元素交叉、可见）时，说明本来不可见的元素浮现在视图中，表示它向上或向下滑动，我们动态设置视图中的顶部和底部 id 即可对其判断。当下滑时 entry.traget.id === ‘bottom’，我们修改 start 和 end；同理，当上滑时entry.traget.id === ‘top 时，我们也一样修改 start 和 end</p><h4 id="延迟渲染（即懒渲染）"><a href="#延迟渲染（即懒渲染）" class="headerlink" title="延迟渲染（即懒渲染）"></a>延迟渲染（即懒渲染）</h4><h5 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h5><p>不多介绍，一句话解释：最开始不渲染所有数据，只展示视图上可见的数据，当滚动到页面底部时，加载更多数据<br>实现原理：<strong>通过监听父级元素的 scroll 事件</strong>，当然也可以通过 IntersectionObserver 或 getBoundingClientRect 等 API 实现<br>但 scroll 事件会频繁触发，所以需要手写节流；滚动元素内有大量 DOM ，容易造成卡顿，建议使用 IntersectionObserver</p><h4 id="时间分片"><a href="#时间分片" class="headerlink" title="时间分片"></a>时间分片</h4><p>对于大量数据渲染时，JS 运算并不是性能的瓶颈，性能的瓶颈主要在于渲染阶段。也就是说 JS 执行是很快的，页面卡顿是因为同时渲染大量 DOM 所引起的，可采用分批渲染的方式来解决</p><p>我的理解是，<strong>通过递归来渲染DOM，刚开始可以是20个，20个渲染完后再渲染剩下的，循环如此</strong>，将其全部渲染完。又因为浏览器的渲染机制是“宏任务—微任务—GUI渲染—宏任务…”。遂第一个 loop 执行后，先等页面渲染完，再执行下一轮的<strong>setTimeout（宏任务）</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>渲染十万条数据有三种解决方案，为虚拟列表、懒加载、时间分片。最优选是虚拟列表，DOM 树上只挂载有限的DOM；懒加载和时间分片的缺点在于插入大量的DOM，占内存运行时会造成卡顿<br>无论是虚拟列表还是懒加载，传统的做法是 scroll + 节流，这种做法的优势是老 API，兼容性刚刚的，缺点是，滑多了还是会引起性能问题，当然 IntersectionObserver 也是一样的，无非是换了个 API 做“元素是否出现在视图”判断，最好的方案是用 IntersectionObserver（交叉观察器），异步加载、性能消耗小</p><p><a href="https://juejin.cn/post/7065218958663614500#heading-3">面试题：渲染十万条数据解决方案</a></p><h3 id="实现图片懒加载-Lazyload"><a href="#实现图片懒加载-Lazyload" class="headerlink" title="实现图片懒加载(Lazyload)"></a>实现图片懒加载(Lazyload)</h3><p>懒加载的意义（为什么要使用懒加载）<br>对页面加载速度影响最大的就是图片，一张普通的图片可以达到几M的大小，而代码也许就只有几十KB。当页面图片很多时，页面的加载速度缓慢，几S钟内页面没有加载完成，也许会失去很多的用户。<br>所以，对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样子对于页面加载性能上会有很大的提升，也提高了用户体验。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>将页面中的img标签src<strong>指向一张小图片或者字符串，然后定义data-src（这个属性可以自定义命名，我才用data-src）属性指向真实的图片</strong>。src指向一张默认的图片，否则当src为空时也会向服务器发送一次请求。可以指向loading的地址。</p><p>注：图片要指定宽高</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;default.jpg&quot;</span> <span class="hljs-attribute">data-src</span>=<span class="hljs-string">&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot;</span> /&gt;复制代码当载入页面时，先把可视区域内的img标签的<br></code></pre></td></tr></table></figure><p>data-src属性值负给src，然后监听滚动事件，把用户即将看到的图片加载。这样便实现了懒加载。<br>JavaScript</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> num = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;img&#x27;</span>).length;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> img = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&quot;img&quot;</span>);</span><br><span class="javascript">    <span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>; <span class="hljs-comment">//存储图片加载到的位置，避免每次都从第一张图片开始遍历</span></span><br><br><span class="javascript">    lazyload(); <span class="hljs-comment">//页面载入完毕加载可是区域内的图片</span></span><br><br><span class="javascript">    <span class="hljs-built_in">window</span>.onscroll = lazyload;</span><br><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyload</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">//监听页面滚动事件</span></span><br><span class="javascript">        <span class="hljs-keyword">var</span> seeHeight = <span class="hljs-built_in">document</span>.documentElement.clientHeight; <span class="hljs-comment">//可见区域高度</span></span><br><span class="javascript">        <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-built_in">document</span>.documentElement.scrollTop || <span class="hljs-built_in">document</span>.body.scrollTop; <span class="hljs-comment">//滚动条距离顶部高度</span></span><br><span class="javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = n; i &lt; num; i++) &#123;</span><br>            if (img[i].offsetTop &lt; seeHeight + scrollTop) &#123;<br><span class="javascript">                <span class="hljs-keyword">if</span> (img[i].getAttribute(<span class="hljs-string">&quot;src&quot;</span>) == <span class="hljs-string">&quot;default.jpg&quot;</span>) &#123;</span><br><span class="javascript">                    img[i].src = img[i].getAttribute(<span class="hljs-string">&quot;data-src&quot;</span>);</span><br>                &#125;<br>                n = i + 1;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="使用节流函数进行性能优化"><a href="#使用节流函数进行性能优化" class="headerlink" title="使用节流函数进行性能优化"></a>使用节流函数进行性能优化</h4><p>如果直接将函数绑定在scroll事件上，当页面滚动时，函数会被高频触发，这非常影响浏览器的性能。</p><p>我想实现限制触发频率，来优化性能。</p><p>节流函数：只允许一个函数在N秒内执行一次。<br><a href="https://juejin.cn/post/6844903455048335368">实现图片懒加载(Lazyload)</a></p><h3 id="图片预加载"><a href="#图片预加载" class="headerlink" title="图片预加载"></a>图片预加载</h3><p>预加载</p><h4 id="1-什么是预加载"><a href="#1-什么是预加载" class="headerlink" title="1.什么是预加载"></a>1.什么是预加载</h4><p>资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能在将来会被使用到。预加载简单来说就是将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。</p><h4 id="2-为什么要用预加载"><a href="#2-为什么要用预加载" class="headerlink" title="2.为什么要用预加载"></a>2.为什么要用预加载</h4><p>在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，直到所有内容加载完毕。</p><h4 id="3-实现预加载的几种办法-使用HTML标签-display-none-使用Image对象"><a href="#3-实现预加载的几种办法-使用HTML标签-display-none-使用Image对象" class="headerlink" title="3.实现预加载的几种办法(使用HTML标签:display:none,使用Image对象)"></a>3.实现预加载的几种办法(使用HTML标签:display:none,使用Image对象)</h4><h5 id="使用HTML标签"><a href="#使用HTML标签" class="headerlink" title="使用HTML标签"></a>使用HTML标签</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;http://pic26.nipic.com/20121213/6168183 0044449030002.jpg&quot;</span> <span class="hljs-attribute">style</span>=<span class="hljs-string">&quot;display:none&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h5 id="使用Image对象"><a href="#使用Image对象" class="headerlink" title="使用Image对象"></a>使用Image对象</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">&lt;script src=<span class="hljs-string">&quot;./myPreload.js&quot;</span>&gt;&lt;/script&gt;<br><span class="hljs-comment">//myPreload.js文件</span><br>var image= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>()<br>image.src=<span class="hljs-string">&quot;http://pic26.nipic.com/20121213/6168183 004444903000 2.jpg&quot;</span><br></code></pre></td></tr></table></figure><p>这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p><h6 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h6><p><a href="https://juejin.cn/post/6844903614138286094#heading-5">懒加载和预加载</a></p><h3 id="判断图片是否加载完成的六种方式"><a href="#判断图片是否加载完成的六种方式" class="headerlink" title="判断图片是否加载完成的六种方式"></a>判断图片是否加载完成的六种方式</h3><p>一、load事件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>img - load event<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;img1&quot;</span><span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://pic1.win4000.com/wallpaper/f/51c3bb99a21ea.jpg&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">        img1.onload =<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">            p1.innerHTML =<span class="hljs-string">&#x27;loaded&#x27;</span></span><br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试，所有浏览器都显示出了“loaded”，说明所有浏览器都支持img的load事件<br>二、img的complete属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>img - complete attribute<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;img1&quot;</span><span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://pic1.win4000.com/wallpaper/f/51c3bb99a21ea.jpg&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">functionimgLoad</span>(<span class="hljs-params">img, callback</span>)</span> &#123;</span><br><span class="javascript">            vartimer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br>                if(img.complete) &#123;<br>                    callback(img)<br><span class="javascript">                    <span class="hljs-built_in">clearInterval</span>(timer)</span><br>                &#125;<br>            &#125;, 50)<br>        &#125;<br><span class="javascript">        imgLoad(img1,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">            p1.innerHTML(<span class="hljs-string">&#x27;加载完毕&#x27;</span>)</span><br>        &#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>轮询不断监测img的complete属性，如果为true则表明图片已经加载完毕，停止轮询。该属性所有浏览器都支持。<br><a href="https://www.cnblogs.com/zhusf/p/10607957.html">参考文章</a></p><h3 id="原生JS实现轮播图-方法总结"><a href="#原生JS实现轮播图-方法总结" class="headerlink" title="原生JS实现轮播图 方法总结"></a>原生JS实现轮播图 方法总结</h3><ol><li><p>方法一：<br>利用绝对定位absolute偏移量的改变来实现<br>具有往左往右滑动的效果</p></li><li><p>方法二：<br>利用 display/opacity/visibility状态切换来实现<br>没有往左往右滑动的效果</p></li><li><p>方法三<br>旋转木马轮播图<br>存储每个图片的位置信息（absolute位置信息+z-index属性+opacity透明度 等等）到一个数组。对数组进行pop push shift unshift等操作再引用到DOM元素上，产生轮播效果。<br><a href="https://juejin.cn/post/6850418121606594568">参考</a></p></li></ol><h3 id="实现一个div元素的拖拽-（addEventListen-removeEventListen"><a href="#实现一个div元素的拖拽-（addEventListen-removeEventListen" class="headerlink" title="实现一个div元素的拖拽  （addEventListen/removeEventListen)"></a>实现一个div元素的拖拽  （addEventListen/removeEventListen)</h3><p>1.js 如何实现拖动滑块( <strong>mousedown，mousemove，mouseup</strong>)<br>实现拖动滑块，先分析，滑块可以拖动应该改变滑块在页面中的坐标，那就采用定位拿到元素的 top 和 left 对它们进行赋值，接下来就是准备事件，既然是鼠标拖动应该具备 mousedown，mousemove，mouseup 三种事件，通过 mousedown 鼠标按下事件选中滑块，mousemove 事件拖动滑块，在拖动滑块的时候获取鼠标在可视窗口的坐标赋值给滑块的 top 和 left<br><a href="https://juejin.cn/post/7001022287981838350">参考</a></p><p>2.实现思路：<br>鼠标按下开始拖拽<br>记录摁下鼠标时的鼠标位置以及元素位置<br>拖动鼠标记下当前鼠标的位置<br>鼠标当前位置-摁下时鼠标位置= 鼠标移动距离<br>元素位置= 鼠标移动距离+鼠标摁下时元素的位置<br><a href="https://www.cnblogs.com/yinping/p/10697083.html">参考</a></p><h3 id="白屏合理性优化-（骨架屏-loading）"><a href="#白屏合理性优化-（骨架屏-loading）" class="headerlink" title="白屏合理性优化  （骨架屏,loading）"></a>白屏合理性优化  （骨架屏,loading）</h3><p>4.路由懒加载<br>9.骨架屏<br>骨架屏就是在进入项目的FP阶段，给它来一个类似轮廓的东西，当我们的页面加载完成之后就消失，这个也很好做的，很多ui库都有这个东西，可以参考一下<br>10.loading<br>首页加一个loading或许是最原始的方法了，在index.html里加一个loadingcss效果，当页面加载完成消失</p><p><a href="https://juejin.cn/post/6995455015972241444#heading-9">Vue首屏加载白屏问题及解决方案</a></p><h3 id="按需引入组件库-element-ui"><a href="#按需引入组件库-element-ui" class="headerlink" title="按需引入组件库 element-ui"></a>按需引入组件库 element-ui</h3><p>参考 element-ui 的导出方案，组件库导出的组件依赖，要提供每个组件单独打包的依赖文件。<br>全量导出 index.js 文件无需改动，在 index.js 同级目录增加新文件 base.js，用于导出基础组件。<br><a href="https://juejin.cn/post/6844904147049775118">将Vue组件库更换为按需加载</a></p><ol><li>支持bable的自动引入</li></ol><h4 id="2-支持tree-shaking"><a href="#2-支持tree-shaking" class="headerlink" title="2. 支持tree-shaking"></a>2. 支持tree-shaking</h4><h3 id="如何中断已经发出去的请求"><a href="#如何中断已经发出去的请求" class="headerlink" title="如何中断已经发出去的请求"></a>如何中断已经发出去的请求</h3><ol><li>调用 XMLHttpRequest 对象上的 abort 方法来取消请求</li><li>CancelToken<br><a href="https://pengzhenglong.github.io/2022/03/08/%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%B9%B6%E5%8F%91/#%E5%89%8D%E7%AB%AF%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86">博客</a></li></ol><h3 id="多个Promise顺序执行的解决思路"><a href="#多个Promise顺序执行的解决思路" class="headerlink" title="多个Promise顺序执行的解决思路"></a>多个Promise顺序执行的解决思路</h3><h4 id="1-使用回调函数解决"><a href="#1-使用回调函数解决" class="headerlink" title="1. 使用回调函数解决"></a>1. 使用回调函数解决</h4><h4 id="2-使用promise-then链式调用"><a href="#2-使用promise-then链式调用" class="headerlink" title="2. 使用promise/then链式调用"></a>2. 使用promise/then链式调用</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>.resolve().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> a())<br>.<span class="hljs-keyword">then</span>(res =&gt; <span class="hljs-built_in">console</span>.log(res))<br>.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> b())<br>.<span class="hljs-keyword">then</span>(res =&gt; <span class="hljs-built_in">console</span>.log(res))<br>.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> c())<br>.<span class="hljs-keyword">then</span>(res =&gt; <span class="hljs-built_in">console</span>.log(res))<br>.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>))<br></code></pre></td></tr></table></figure><h4 id="3-使用async-await解决-for-of"><a href="#3-使用async-await解决-for-of" class="headerlink" title="3. 使用async/await解决  (for  of)"></a>3. 使用async/await解决  (for  of)</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">async <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span><span class="hljs-params">(a, b, c)</span> &#123;</span><br> const <span class="hljs-keyword">args</span> = [].slice.<span class="hljs-keyword">call</span>(arguments, <span class="hljs-number">0</span>)<br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item of <span class="hljs-keyword">args</span>) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">res</span> = await item()<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">res</span>)<br> &#125;<br> console.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>)<br>&#125;<br><span class="hljs-built_in">log</span>(<span class="hljs-keyword">a</span>, <span class="hljs-keyword">b</span>, <span class="hljs-keyword">c</span>)<br></code></pre></td></tr></table></figure><h3 id="大文件上传处理"><a href="#大文件上传处理" class="headerlink" title="大文件上传处理"></a>大文件上传处理</h3><ol><li>对文件做切片,即将一个请求拆分成多个请求，每个请求的时间就会缩短，且如果某个请求失败，只需要重新发送这一次请求即可，无需从头开始</li></ol><p>步骤1-切片,合并切片<br><strong>在JavaScript中，文件FIle对象是Blob对象的子类，Blob对象包含一个重要的方法slice通过这个方法</strong></p><p>步骤2-并发控制<br><strong>结合Promise.race和异步函数实现,多个请求同时并发的数量,防止浏览器内存溢出</strong><br>步骤3-断点续传<br><strong>在单个请求失败后,触发catch的方法的时候,讲当前请求放到失败列表中,在本轮请求完成后,重复对失败请求做处理</strong><br>2. 通知服务器合并切片,在上传完切片后,前端通知服务器做合并切片操作<br>3. 控制多个请求的并发量,防止多个请求同时发送,造成浏览器内存溢出,导致页面卡死<br>4. 做断点续传,当多个请求中有请求发送失败,例如出现网络故障、页面关闭等,我们得对失败的请求做处理,让它们重复发送<br><a href="https://pengzhenglong.github.io/2022/03/08/%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%B9%B6%E5%8F%91/#%E5%89%8D%E7%AB%AF%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86">博客</a></p><h4 id="了解Ts，Ts的好处是？"><a href="#了解Ts，Ts的好处是？" class="headerlink" title="了解Ts，Ts的好处是？"></a>了解Ts，Ts的好处是？</h4><h5 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h5><p>静态类型化是一种功能，可以在开发人员编写脚本是检测错误，有了这项功能，就会允许开发人员编写更健壮的代码并对其进行维护，以便使得代码质量更好、更清晰。<br>(从代码可知变量num是number类型，如果我们给num赋予其他类型的值就会报错。)</p><h5 id="大型项目的优势"><a href="#大型项目的优势" class="headerlink" title="大型项目的优势"></a>大型项目的优势</h5><p>对于大型项目的开发，有时为了优化改进项目，对代码进行小小更改。这些小小的变化可能会产生严重的、意想不到的后果，因此有必要撤销这些变化。使用TypeScript工具来进行重构更变的容易、快捷。</p><h5 id="更好的协作"><a href="#更好的协作" class="headerlink" title="更好的协作"></a>更好的协作</h5><p>对于大型项目的开发一般会有很多开发人员一起开发，此时乱码和错误的机也会增加。类型安全是一种在编码期间检测错误的功能，而不是在编译项目时检测错误。这为开发团队创建了一个更高效的编码和调试过程。</p><h4 id="typescript-中-interface-和-type-的区别"><a href="#typescript-中-interface-和-type-的区别" class="headerlink" title="typescript 中 interface 和 type 的区别"></a>typescript 中 interface 和 type 的区别</h4><blockquote><p>相同点 (都可以描述一个对象或者函数&amp;&amp;都允许拓展（extends）)</p></blockquote><p>不同点 (<br>  type可以interface不可以：：</p><blockquote><p>type 可以声明基本类型别名，联合类型，元组等类型,type 语句中还可以使用 typeof 获取实例的 类型进行赋值 ,</p></blockquote><p>interface可以type不可以：</p><blockquote><p>interface 能够声明合并)<br><a href="https://juejin.cn/post/6844903749501059085">参考</a><br>一般来说，如果不清楚什么时候用interface/type，能用 interface 实现，就用 interface , 如果不能就用 type</p></blockquote><h4 id="如何让localStorage支持过期时间设置"><a href="#如何让localStorage支持过期时间设置" class="headerlink" title="如何让localStorage支持过期时间设置?"></a>如何让localStorage支持过期时间设置?</h4><p>聊到 localStorage 想必熟悉前端的朋友都不会陌生, 我们可以使用它提供的<strong>getItem, setItem, removeItem, clear</strong> 这几个 API 轻松的对存储在浏览器本地的数据进行<strong>「读,写, 删」操作, 但是相比于 cookie, localStorage 唯一美中不足的就是「不能设置每一个键的过期时间」</strong>。</p><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>在实际的应用场景中, 我们往往需要让 localStorage 设置的某个 「key」 能在指定时间内自动失效, 所以基于这种场景, 我们如何去解决呢?</p><ol><li>初级写法 （维护成本极高, 且不利于工程化复用）</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&#x27;dooring&#x27;</span>, <span class="hljs-string">&#x27;1.0.0&#x27;</span>)<br><span class="hljs-regexp">//</span> 设置一小时的有效期<br>const expire = <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&#x27;dooring&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;, expire)<br></code></pre></td></tr></table></figure><ol start="2"><li>中级解法<br>前端工程师在有一定的工作经验之后, 往往会去考虑工程化和复用性的问题, 并对数据结构有了一定的了解, 所以可能会有接下来的解法:</li></ol><p>基本思路：<br>（1）封装函数在保存数据时，指定有效时间，把数据和这个有效时间一起保存起来。<br>（2）封装函数在获取数据时，不着急直接给出结果，而是检查之前保存的有效时间是否过期，如果在就返回数据，否则就删除数据，并返回false。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// key: 属性名</span><br><span class="hljs-comment">// value: 要保存的值</span><br><span class="hljs-comment">// availabletime: 有效时间，毫秒为单位</span><br>const setItem =<span class="hljs-function"> (<span class="hljs-params">key</span>, <span class="hljs-params">value</span>,<span class="hljs-params">availabletime</span> = 1000*60*60*24) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 最晚这时间点</span><br>    const t = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>.get<span class="hljs-constructor">Time()</span> + availabletime;<br>    localStorage.set<span class="hljs-constructor">Item(<span class="hljs-params">key</span>, JSON.<span class="hljs-params">stringify</span>(&#123; <span class="hljs-params">data</span>: <span class="hljs-params">value</span>, <span class="hljs-params">time</span>: <span class="hljs-params">t</span> &#125;)</span>);<br>&#125;<br><br><span class="hljs-comment">// 获取数据</span><br>const getItem =<span class="hljs-function"> (<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 去初始值</span><br>    const localData = localStorage.get<span class="hljs-constructor">Item(<span class="hljs-params">key</span>)</span>;<br>    const localDataObj = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span>parse(localData);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Date</span>.</span></span>now<span class="hljs-literal">()</span> &gt; localDataObj.time) &#123;<br>        <span class="hljs-comment">// console.log(&quot;数据已过期&quot;);</span><br>        <span class="hljs-comment">//删除</span><br>        localStorage.remove<span class="hljs-constructor">Item(<span class="hljs-params">key</span>)</span>;<br>        return <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 返回真正的数据</span><br>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span>parse(localDataObj.data);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>重写 set(存入) 方法：<br>首先有三个参数 key、value、expired ，分别对应 键、值、过期时间，<br>过期时间的单位可以自由发挥，小时、分钟、天都可以，<br>注意点：存储的值可能是数组/对象，不能直接存储，需要转换 JSON.stringify，<br>这个时间如何设置呢？在这个值存入的时候在键(key)的基础上扩展一个字段，如：key+’expires’，而它的值为当前 时间戳 + expired过期时间<br><a href="https://juejin.cn/post/7083869252586831880">掘金</a></p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue--Observer、Dep、Watcher</title>
    <link href="/2022/02/25/Vue--Observer%E3%80%81Dep%E3%80%81Watcher/"/>
    <url>/2022/02/25/Vue--Observer%E3%80%81Dep%E3%80%81Watcher/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="Vue-初始化"><a href="#Vue-初始化" class="headerlink" title="Vue 初始化"></a>Vue 初始化</h3><p>我觉得搞清楚这些，首先要知道 vue 初始化的过程。我们从 new Vue() 开始，构造函数会执行 this._init，在_init 中会进行合并配置、初始化生命周期、事件、渲染等，最后执行 vm.$mount 进行挂载。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> src<span class="hljs-regexp">/core/i</span>nstance/index.js<br><span class="hljs-keyword">function</span> Vue (options) &#123;<br>    <span class="hljs-regexp">//</span> ...<br>    this._init(options)<br>&#125;<br><br><span class="hljs-regexp">//</span> src<span class="hljs-regexp">/core/i</span>nstance/init.js<br>Vue.prototype._init = <span class="hljs-keyword">function</span> (options?: Object) &#123;<br>    <span class="hljs-regexp">//</span> 合并配置<br>    <span class="hljs-regexp">//</span> ...<br>    <br>    <span class="hljs-regexp">//</span> 一系列初始化<br>    <span class="hljs-regexp">//</span> ...<br>    initState(vm)<br>    <span class="hljs-regexp">//</span> ...<br>    <br>    <span class="hljs-keyword">if</span> (vm.<span class="hljs-variable">$options</span>.el) &#123;<br>      vm.<span class="hljs-variable">$mount</span>(vm.<span class="hljs-variable">$options</span>.el)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里主要来看 <strong>initState(vm)</strong>，响应式的核心均在于此，会进行<strong>props、data、computed、watch</strong>  的初始化操作。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> src<span class="hljs-regexp">/core/i</span>nstance/state.js<br>export <span class="hljs-keyword">function</span> initState (vm: Component) &#123;<br>    vm._watchers = []<br>    const opts = vm.<span class="hljs-variable">$options</span><br>    <span class="hljs-keyword">if</span> (opts.props) initProps(vm, opts.props) <span class="hljs-regexp">//</span> 初始化 props<br>    <span class="hljs-regexp">//</span> ...<br>    <span class="hljs-keyword">if</span> (opts.data) &#123;<br>        initData(vm) <span class="hljs-regexp">//</span> 初始化 data<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        observe(vm._data = &#123;&#125;, true <span class="hljs-regexp">/* asRootData */</span>)<br>    &#125;<br>    <span class="hljs-regexp">//</span> ...<br>&#125;<br></code></pre></td></tr></table></figure><p>了解了初始化过程，接下来就引出 Observer。</p><h3 id="Obserber-「数据的观察者」"><a href="#Obserber-「数据的观察者」" class="headerlink" title="Obserber 「数据的观察者」"></a>Obserber 「数据的观察者」</h3><p>在上面的 initData 中会执行 observe 方法进而实例化 Observer。Observer 的实例化过程就是递归地把 data 对象和子对象添加 <strong>ob</strong> 属性同时通过我们熟知的 defindReactive 为属性定义 getter/setter。</p><p>那么 Observer 顾名思义是观察者，观察的就是 data，它通过数据劫持使 data 的读写都处于它的监管之下。那么在观察到数据发生变化时会做出怎样的操作呢？</p><p>来到 defindReactive 的核心代码，会看到 getter 里的 dep.depend() 和 setter 里的 dep.notify()，这就是依赖收集和触发更新的起点。这里的 dep 是 defindReactive 内定义的一个常量，getter/setter 函数内持有对它的闭包引用，Dep 就是引出的下一个概念。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// src/core/observer/index.js</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep()<br><span class="hljs-comment">// ...</span><br>Object.defineProperty(obj, key, &#123;<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>    <span class="hljs-keyword">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveGetter</span> <span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        dep.depend()<br>        <span class="hljs-comment">//...</span><br>    &#125;,<br>    <span class="hljs-keyword">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveSetter</span> <span class="hljs-params">(newVal)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        dep.notify()<br>    &#125;,<br></code></pre></td></tr></table></figure><h3 id="Dep-「依赖管理」"><a href="#Dep-「依赖管理」" class="headerlink" title="Dep 「依赖管理」"></a>Dep 「依赖管理」</h3><p>先看下 Dep 类的定义</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs perl">// src/core/observer/dep.js<br>export default class Dep &#123;<br>    constructor () &#123;<br>        this.id = uid++<br>        this.subs = []<br>    &#125;<br><br>    addSub (<span class="hljs-function"><span class="hljs-keyword">sub</span>: <span class="hljs-title">Watcher</span>) </span>&#123;&#125;<br><br>    removeSub (<span class="hljs-function"><span class="hljs-keyword">sub</span>: <span class="hljs-title">Watcher</span>) </span>&#123;&#125;<br><br>    depend () &#123;&#125;<br>    <br>    notify () &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 Dep 有一个实例属性 subs 数组，实例方法 addSub/removeSub 添加和删除数组中的某项。由此可以确定 dep 实例并非依赖而是依赖的管理者，subs 数组即为依赖(订阅者)列表，它们就是接下来登场的 Watcher</p><h3 id="Watcher-「订阅者」"><a href="#Watcher-「订阅者」" class="headerlink" title="Watcher 「订阅者」"></a>Watcher 「订阅者」</h3><p>从上面知道 Observer Dep 都已经在 initState 中实例化了，响应式数据和依赖管理都准备好了，接下来就需要 Wacther 来订阅了。那么 Wacther 什么时候实例化呢，回到开头的初始化过程最后 vm.$mount 挂载，在这之后会执行 mountComponent 方法，Watcher 就是在这里实例化的（暂不关注 computed watcher 和 watch 选项的 watcher）。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> src<span class="hljs-regexp">/core/i</span>nstance/lifecycle.js<br>export <span class="hljs-keyword">function</span> mountComponent () &#123;<br>    <span class="hljs-regexp">//</span> ...<br>    new Watcher(vm, updateComponent, noop, &#123;<br>        <span class="hljs-regexp">//</span> ...<br>    &#125;, true <span class="hljs-regexp">/* isRenderWatcher */</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>Watcher 的定义如下，实例化时会执行 get 方法对传入的 updateComponent 进行求值，updateComponent 也就是 _render 函数，执行_render 函数会读取 data 数据从而触发 getter 进行依赖收集。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> src<span class="hljs-regexp">/core/</span>observer/watcher.js<br>export default class Watcher &#123;<br>    <br>    <span class="hljs-regexp">//</span> 对 getter 求值，进行依赖收集<br>    get () &#123;&#125;<br>    <br>    <span class="hljs-regexp">//</span> 触发更新<br>    update() &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，我们可以总结一下三者的关系：</p><ol><li><p>Observer 将数据定义为响应式，每个 Observer 实例都有自己的 Dep 来管理依赖。实例化 Wacther 的时候进行求值会触发 getter ，进而执行 dep.depend() 将当前 Wacther 加入 Dep 维护的依赖列表，这就是依赖收集过程。</p></li><li><p>数据发生变化触发 setter 执行 dep.notify，Dep 会执行所有依赖的 update 方法并加入异步更新队列，这就是触发依赖过程。<br><img src="/imageO/Dep.jpg" alt="dep"></p></li></ol><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844904128028622861">Observer、Dep、Watcher 傻傻搞不清楚</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整理一些最近遇到的问题-2022春招</title>
    <link href="/2022/02/22/%5B%E9%A1%B9%E7%9B%AE%5D%E6%95%B4%E7%90%86%E4%B8%80%E4%BA%9B%E6%9C%80%E8%BF%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98-2022%E6%98%A5%E6%8B%9B/"/>
    <url>/2022/02/22/%5B%E9%A1%B9%E7%9B%AE%5D%E6%95%B4%E7%90%86%E4%B8%80%E4%BA%9B%E6%9C%80%E8%BF%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98-2022%E6%98%A5%E6%8B%9B/</url>
    
    <content type="html"><![CDATA[<p>总结了最近的一些面试题和之前的知识点</p><hr><h2 id="面试问到较重要的（需掌握）"><a href="#面试问到较重要的（需掌握）" class="headerlink" title="面试问到较重要的（需掌握）"></a>面试问到较重要的（需掌握）</h2><h4 id="讲讲Dom渲染性能消耗"><a href="#讲讲Dom渲染性能消耗" class="headerlink" title="讲讲Dom渲染性能消耗 ()"></a>讲讲Dom渲染性能消耗 ()</h4><h5 id="回流重绘"><a href="#回流重绘" class="headerlink" title="回流重绘"></a>回流重绘</h5><p><strong>URL从输入到页面展示的过程 （获取到HTTP响应报文  HtmlDom树 CSSdom树  JSdom树  ）<br>重绘是一个非常昂贵的操作。</strong>浏览器完成一个dom操作，大多时间都是花费在重绘上面的。**<br>回流（重绘）</p><p>全局范围就是<strong>从根节点 html 开始对整个渲染树进行重新布局</strong>，例如当我们改变了窗口尺寸或方向或者是<strong>修改了根元素的尺寸或者字体大小等</strong>；而局部布局可以是对渲染树的某部分或某一个渲染对象进行重新布局。</p><p>所谓重排，实际上是根据渲染树中每个渲染对象的信息，计算出各自渲染对象的几何信息（DOM对象的位置和尺寸大小），并将其安置在界面中的正确位置。</p><h5 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h5><h6 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h6><p>避免使用table布局。<br>避免设置多层内联样式。<br>将动画效果应用到position属性为absolute或fixed的元素上。</p><h6 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h6><p><strong>避免频繁操作样式，最好一次性重写style属性</strong>，或者将样式列表定义为class并一次性更改class属性。<br>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。<br><strong>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</strong><br>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。<br>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。<br><a href="https://pengzhenglong.github.io/2022/02/15/CSS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%EF%BC%9F%EF%BC%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B%EF%BC%89">博客</a><br>js 操作 Dom 很耗性能，其实是在说很耗浏览器性能，具体和 js计算 性能没多大的关系，优化方案<br>DOM操作的背后，隐藏这不止止是文中所描述的这些代价。为了给用户更好的浏览体验，可以有以下优化的方案：<br><strong>减少DOM操作如果在一个局部方法中需要多次访问同一个dom，则先暂存它的引用</strong><br>采用更高效的API或者更高效的写法<br>1）用querySelectorAll()替代getElementByXX()。<br>2）开启动画的GPU加速，把渲染计算交给GPU<br>3）用事件委托来减少事件处理器的数量。<br>4）<strong>使用react、vue等页面框架来编写View页面。react采用虚拟dom，尽可能的讲多次重排浓缩成一次。</strong><br>CSS及动画处理<br>1）<strong>用更高效的css3效果，通过类名控制动画，尽量避免直接操作DOM属性；</strong><br>2）<strong>在动画的元素多嵌套一层div，尽量用绝对定位或者固定定位使其脱离文档流，再进行动画处理；</strong><br>3）尽量在滚动的时候，停止动画；<br>4）动画实现的速度选择。以1px移动最为平滑，但是reflow就会果与频繁，建议以3px移动则会好很多。<br><a href="https://zhuanlan.zhihu.com/p/86153264">知乎</a></p><h4 id="计算属性的原理"><a href="#计算属性的原理" class="headerlink" title="计算属性的原理"></a>计算属性的原理</h4><p><a href="https://pengzhenglong.github.io/2022/03/10/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8Ccomputed%E7%9A%84%E5%8E%9F%E7%90%86/">博客：</a></p><h3 id="Js-动画与-CSS-动画区别及相应实现（JS动画重绘回流，性能影响）"><a href="#Js-动画与-CSS-动画区别及相应实现（JS动画重绘回流，性能影响）" class="headerlink" title="Js 动画与 CSS 动画区别及相应实现（JS动画重绘回流，性能影响）"></a>Js 动画与 CSS 动画区别及相应实现（JS动画重绘回流，性能影响）</h3><p>区别：<br>（1）transform仅描述元素的静态样式，常常配合transition和animation使用<br>（2）<strong>transition通常和hover等事件配合使用，animation是自发的，立即播放</strong><br>（3）animation可设置循环次数<br>（4）<strong>transition只能设置头尾,animation可设置每一帧的样式和时间</strong><br>（5）<strong>transition可与js配合使用，js设定要变化的样式，transition负责动画效果</strong></p><p>CSS3 的动画的优点<br>在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化,代码相对简单</p><p>缺点(在动画控制上不够灵活,兼容性不好)</p><p>Js动画<br>JavaScript 的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。对于一些复杂控制的动画，使用 javascript 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧<br>如果动画相较复杂，我们可以采用 JS + canvas 去尝试，能不能实现最后再考虑纯 JS 实现<br><a href="https://pengzhenglong.github.io/2022/02/15/CSS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#Js-%E5%8A%A8%E7%94%BB%E4%B8%8E-CSS-%E5%8A%A8%E7%94%BB%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%AE%9E%E7%8E%B0">博客</a></p><h3 id="css预处理-sass-less-stylus-有什么区别-哪个更好用"><a href="#css预处理-sass-less-stylus-有什么区别-哪个更好用" class="headerlink" title="css预处理  sass  less  stylus 有什么区别  哪个更好用"></a>css预处理  sass  less  stylus 有什么区别  哪个更好用</h3><h4 id="下面从特性上比较三者异同"><a href="#下面从特性上比较三者异同" class="headerlink" title="下面从特性上比较三者异同"></a>下面从特性上比较三者异同</h4><ol><li>变量：<br>Sass声明变量必须是 <strong>『$』开头，后面紧跟变量名和变量值</strong>，而且变量名和变量值需要使用冒号：分隔开。<br>Less 声明变量用 <strong>『@』开头，其余等同 Sass。</strong><br>Stylus 中声明变量没有任何限定，结尾的分号可有可无，但变量名和变量值之间必须要有『等号』。但需要注意的是，如果用“@”符号来声明变量，Stylus会进行编译，但不会赋值给变量。就是说，Stylus 不要使用『@』声明变量。Stylus 调用变量的方法和Less、Sass完全相同。</li><li>作用域：<br>css 预编译器把变量赋予作用域，也就是存在生命周期。就像 js 一样，它会先从局部作用域查找变量，依次向上级作用域查找。<br>Sass：<strong>三者最差，不存在全局变量的概念。也就是说在 Sass 中定义了相同名字的变量时你就要小心蛋疼了。</strong></li></ol><p><strong>Less：我认为跟 JS 一样，逐级查找，向上冒泡。<br>Stylus：完全等同 Less。Stylus 和 Sass 则更倾向于指令式。</strong></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>个人认为：<br>Sass和Less语法严谨、Stylus相对自由。因为<strong>Less长得更像 css，所以它可能学习起来更容易。</strong><br>Sass 和 Compass、Stylus 和 Nib 都是好基友。<br><strong>Sass 和 Stylus 都具有类语言的逻辑方式处理：条件、循环等，而 Less 需要通过When等关键词模拟这些功能</strong>，这方面 Less 比不上 Sass 和 Stylus。<br>Less 在丰富性以及特色上都不及 Sass 和 Stylus，若不是因为 Bootstrap 引入了 Less，可能它不会像现在这样被广泛应用（个人愚见）。<br>身边有几个朋友在 css 预编译器的选择上犹豫不决，其实我认为选择什么无所谓，关键在于你的熟练程度以及团队合作方面的有利性。<br>当然，在大致学习、使用和研究了这三种 css 预编译器之后，我想我会选择 Stylus，它的语法自由度很高，而且写出来的代码非常简洁，这点十分吸引我。</p><h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><h4 id="TCP-和-UDP-应用场景"><a href="#TCP-和-UDP-应用场景" class="headerlink" title="TCP 和 UDP 应用场景"></a>TCP 和 UDP 应用场景</h4><p>传送门 ☞<a href="https://juejin.cn/post/6992743999756845087"># 深度剖析TCP与UDP的区别</a><br><a href="https://pengzhenglong.github.io/2021/07/09/TCP%E5%8D%8F%E8%AE%AE/">博客</a></p><h3 id="请求头信息"><a href="#请求头信息" class="headerlink" title="请求头信息"></a>请求头信息</h3><h3 id="路由页面跳转后状态保存"><a href="#路由页面跳转后状态保存" class="headerlink" title="路由页面跳转后状态保存"></a>路由页面跳转后状态保存</h3><p>需求场景<br>首页搜索内容，点击跳转至详情页，页面后退返回主页，保留搜索结果。</p><p> 这里介绍两种比较容易实现的解决方案</p><h4 id="方案一：将搜索参数存储在路由参数（route-query）中，加载页面时根据参数搜索"><a href="#方案一：将搜索参数存储在路由参数（route-query）中，加载页面时根据参数搜索" class="headerlink" title="方案一：将搜索参数存储在路由参数（route.query）中，加载页面时根据参数搜索"></a>方案一：将搜索参数存储在路由参数（route.query）中，加载页面时根据参数搜索</h4><p>优点：刷新不影响；实现简单<br>缺点：参数只能是基础类型、长度受限；路径看起来比较难看；只对浏览器返回有效，手动跳转回首页不行</p><h4 id="方案二：使用路由守卫钩子，在离开页面前本地存储页面参数（vuex、Local-Storage-等等）"><a href="#方案二：使用路由守卫钩子，在离开页面前本地存储页面参数（vuex、Local-Storage-等等）" class="headerlink" title="方案二：使用路由守卫钩子，在离开页面前本地存储页面参数（vuex、Local Storage 等等）"></a>方案二：使用路由守卫钩子，在离开页面前本地存储页面参数（vuex、Local Storage 等等）</h4><p>优点：参数类型长度都比较自由；路径看起来清爽美观；对任意方式返回主页都有效<br>缺点：需要额外进行数据存储操作，如果使用store模式或vuex则刷新页面失效<br>参考<br><a href="https://juejin.cn/post/6987953448419328036#heading-2">前端 Vue路由返回恢复页面状态的实现方案</a></p><h3 id="keep-alive-组件有什么作用？"><a href="#keep-alive-组件有什么作用？" class="headerlink" title="keep-alive 组件有什么作用？"></a>keep-alive 组件有什么作用？</h3><p><a href="https://www.zoo.team/article/lru-keep-alive">参考文章</a></p><h3 id="浏览器兼容性问题"><a href="#浏览器兼容性问题" class="headerlink" title="浏览器兼容性问题"></a>浏览器兼容性问题</h3><blockquote><p>虽然面试官的问题十分的笼统，浏览器的兼容性无非还是样式兼容性（css），交互兼容性（javascript），浏览器 hack 三个方面。</p></blockquote><p>一、了解浏览器<br>主流浏览器 有五个：IE(Trident内核)、Firefox(火狐：Gecko内核)、Safari(苹果：webkit内核)、Google Chrome(谷歌：Blink内核)、Opera(欧朋：Blink内核)<br>四大内核：Trident(IE内核)、Gecko(Firefox内核)、webkit内核、Blink(Chrome内核)<br>1、什么是兼容问题？</p><p>答：<strong>同样的代码，在不同的浏览器上显示的页面效果不一样</strong></p><p>2、不一样的原因是什么？</p><p>答：浏览器各浏览器使用了不同的内核，并且它们处理同一件事情的时候思路不同。</p><h4 id="样式兼容性（css）方面"><a href="#样式兼容性（css）方面" class="headerlink" title="样式兼容性（css）方面"></a>样式兼容性（css）方面</h4><ol><li>因为历史原因，不同的浏览器样式存在差异，可以通过 Normalize.css 抹平差异，也可以定制自己的 reset.css，例如通过通配符选择器，全局重置样式<br>1、不要使用*{} 类似的通配符<br>这种方法虽然写起来简单，但是渲染起来，浏览器引擎要遍历所有的标签，很影响效率。为了对浏览器友好，可以把自己经常用的标签进行重置操作。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123; <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>; &#125;<br></code></pre></td></tr></table></figure><p>2、<strong>addEventListener 与 attachEvent</strong> 区别<br>attachEvent ——兼容：IE7、IE8；不兼容firefox、chrome、IE9、IE10、IE11、safari、opera。addEventListener——兼容：firefox、chrome、IE、safari、opera；不兼容IE7、IE8解决方案：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> add<span class="hljs-constructor">Event(<span class="hljs-params">elm</span>, <span class="hljs-params">evType</span>, <span class="hljs-params">fn</span>, <span class="hljs-params">useCapture</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (elm.addEventListener) &#123; <span class="hljs-comment">// W3C标准</span><br>    elm.add<span class="hljs-constructor">EventListener(<span class="hljs-params">evType</span>, <span class="hljs-params">fn</span>, <span class="hljs-params">useCapture</span>)</span>;<br>    return <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (elm.attachEvent) &#123; <span class="hljs-comment">// IE</span><br>    var r = elm.attach<span class="hljs-constructor">Event(&#x27;<span class="hljs-params">on</span>&#x27; + <span class="hljs-params">evType</span>, <span class="hljs-params">fn</span>)</span>; <span class="hljs-comment">// IE5+</span><br>    return r;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    elm<span class="hljs-literal">[&#x27;<span class="hljs-identifier">on</span>&#x27; + <span class="hljs-identifier">evType</span>]</span> = fn; <span class="hljs-comment">// DOM事件</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/6972937716660961317#heading-31">浏览器的兼容问题及解决方案整理（建议收藏）</a><br><a href="https://juejin.cn/post/6844903633708908557">如何机智地回答浏览器兼容性问题</a></p><h3 id="JS垃圾回收机制-（GC）"><a href="#JS垃圾回收机制-（GC）" class="headerlink" title="JS垃圾回收机制 （GC）"></a>JS垃圾回收机制 （GC）</h3><p><a href="https://pengzhenglong.github.io/2022/03/26/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%90%97/">博客</a></p><h3 id="前端性能优化建议"><a href="#前端性能优化建议" class="headerlink" title="前端性能优化建议"></a>前端性能优化建议</h3><ol><li>减少 HTTP 请求</li><li>使用 HTTP2</li><li>静态资源使用 CDN</li><li>将 CSS 放在文件头部，JavaScript 文件放在底部（CSS 执行会阻塞渲染，阻止 JS 执行;<br>JS 加载和执行会阻塞 HTML 解析，阻止 CSSOM 构建）</li><li>图片优化</li><li>减少重绘重排</li><li>CSS 选择器优先级<br><a href="https://pengzhenglong.github.io/2022/03/28/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">博客</a></li></ol><h3 id="使用es5实现一个继承-原型继承-构造函数继承-组合继承-组合继承"><a href="#使用es5实现一个继承-原型继承-构造函数继承-组合继承-组合继承" class="headerlink" title="使用es5实现一个继承 (原型继承,构造函数继承,组合继承,组合继承)"></a>使用es5实现一个继承 (原型继承,构造函数继承,组合继承,组合继承)</h3><h4 id="创建子类Child，使用原型和构造函数的方式继承父类People的方法，并调用say函数说出姓名和年龄-es5方法"><a href="#创建子类Child，使用原型和构造函数的方式继承父类People的方法，并调用say函数说出姓名和年龄-es5方法" class="headerlink" title="创建子类Child，使用原型和构造函数的方式继承父类People的方法，并调用say函数说出姓名和年龄(es5方法)"></a>创建子类Child，使用原型和构造函数的方式继承父类People的方法，并调用say函数说出姓名和年龄(es5方法)</h4><p>父类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">People</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>     <span class="hljs-built_in">this</span>.name=name;<br>     <span class="hljs-built_in">this</span>.age=age;<br>     <span class="hljs-built_in">this</span>.say=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我的名字是:&quot;</span>+<span class="hljs-built_in">this</span>.name+<span class="hljs-string">&quot;我今年&quot;</span>+<span class="hljs-built_in">this</span>.age+<span class="hljs-string">&quot;岁！&quot;</span>);<br>     &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>原型继承：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Child(<span class="hljs-params">name</span>, <span class="hljs-params">age</span>)</span>&#123;<br>    this.name = name;<br>    this.age = age;<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype = <span class="hljs-keyword">new</span> <span class="hljs-constructor">People()</span>;<br>var child = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Child(&#x27;Rainy&#x27;, 20)</span>;<br>child.say<span class="hljs-literal">()</span><br></code></pre></td></tr></table></figure><p>构造函数继承：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span><span class="hljs-params">(name, age)</span></span>&#123;<br>    People.call(<span class="hljs-keyword">this</span>)<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&#x27;Rainy&#x27;</span>, <span class="hljs-number">20</span>);<br>child.say()<br></code></pre></td></tr></table></figure><p>组合继承：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Child(<span class="hljs-params">name</span>, <span class="hljs-params">age</span>)</span>&#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">People</span>.</span></span>call(this);<br>    this.name = name;<br>    this.age = age;<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">People</span>.</span></span>prototype;<br>var child = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Child(&#x27;Rainy&#x27;, 20)</span>;<br>child.say<span class="hljs-literal">()</span><br></code></pre></td></tr></table></figure><p>组合继承优化：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Child(<span class="hljs-params">name</span>, <span class="hljs-params">age</span>)</span>&#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">People</span>.</span></span>call(this);<br>    this.name = name;<br>    this.age = age;<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>create(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">People</span>.</span></span>prototype);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype.constructor = Child;<br>var child = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Child(&#x27;Rainy&#x27;, 20)</span>;<br>child.say<span class="hljs-literal">()</span><br></code></pre></td></tr></table></figure><h6 id="es6-class继承"><a href="#es6-class继承" class="headerlink" title="es6  class继承"></a>es6  class继承</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.x = x<br>        <span class="hljs-built_in">this</span>.y = y<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x + <span class="hljs-string">&#x27;&#x27;</span> + <span class="hljs-built_in">this</span>.y<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y, color</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(x, y) <span class="hljs-comment">//调用父类的constructor(x, y)</span><br>        <span class="hljs-built_in">this</span>.color = color<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.color + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">super</span>.toString() <span class="hljs-comment">// 调用父类的toString()</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> colorPoint = <span class="hljs-keyword">new</span> ColorPoint(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(colorPoint.toString())  <span class="hljs-comment">// red 12</span><br><br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/ctt08225/article/details/88255411">参考连接</a></p><h2 id="个人简历项目（要熟悉）"><a href="#个人简历项目（要熟悉）" class="headerlink" title="个人简历项目（要熟悉）"></a>个人简历项目（要熟悉）</h2><h3 id="项目上的难点，（说一下）（图片上传那-大文件怎么上传-js怎么压缩一张图片）（图片么转换为base64-图片怎么转化为base64的过程-裁剪这一块怎么弄的，FileReader-怎么裁剪的-怎么压缩一张图片）"><a href="#项目上的难点，（说一下）（图片上传那-大文件怎么上传-js怎么压缩一张图片）（图片么转换为base64-图片怎么转化为base64的过程-裁剪这一块怎么弄的，FileReader-怎么裁剪的-怎么压缩一张图片）" class="headerlink" title="项目上的难点，（说一下）（图片上传那+大文件怎么上传+js怎么压缩一张图片）（图片么转换为base64+图片怎么转化为base64的过程+裁剪这一块怎么弄的，FileReader+怎么裁剪的+怎么压缩一张图片）"></a>项目上的难点，（说一下）（图片上传那+大文件怎么上传+js怎么压缩一张图片）（图片么转换为base64+图片怎么转化为base64的过程+裁剪这一块怎么弄的，FileReader+怎么裁剪的+怎么压缩一张图片）</h3><h4 id="预览图片"><a href="#预览图片" class="headerlink" title="预览图片"></a>预览图片</h4><h5 id="1-使用-URL-createObjectURL-预览"><a href="#1-使用-URL-createObjectURL-预览" class="headerlink" title="1. 使用 URL.createObjectURL 预览"></a>1. 使用 URL.createObjectURL 预览</h5><p> URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的 URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。用法用下：</p><p><strong>objectURL = URL.createObjectURL(object);</strong></p><p>其中，<strong>object 参数指 用于创建 URL 的 File 对象、Blob 对象或者 MediaSource 对象。</strong></p><h5 id="2-使用-FileReader-预览"><a href="#2-使用-FileReader-预览" class="headerlink" title="2. 使用 FileReader 预览"></a>2. 使用 FileReader 预览</h5><p>FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。同理的，我们也可以通过<strong>input.files[0] 获取到当前选中的图片的 File 对象</strong>。</p><blockquote><p>特别注意，FileReader 和 是异步读取文件或数据的！</p></blockquote><h5 id="两种方法的对比"><a href="#两种方法的对比" class="headerlink" title="两种方法的对比"></a>两种方法的对比</h5><p>我个人更加倾向于使用 URL.createObjectURL() 。<strong>主要原先它的 API 简洁，同步读取，并且他返回的是一个 URL ，比 FileReaer 返回的base64 更加精简。</strong>兼容性上，两者都差不多，都是在 WD 的阶段。性能上的对比, 在 chrome 上, 选择了一张 2M 的图片, URL.createObjectURL() 用时是 0 , 而 FileReader 用时 20ms 左右。 0 感觉不太合理，虽然这个方法立刻就会返回一个 URL ，但是我猜测实际上这个 URL 指定的内容还没有生成好，应该是异步生成的，然后才渲染出来的。所以并没有很好的办法来对比他们的性能。</p><p><a href="https://juejin.cn/post/6844903982574338061#heading-3">掘金</a></p><h3 id="图片上传压缩canvas"><a href="#图片上传压缩canvas" class="headerlink" title="图片上传压缩canvas"></a>图片上传压缩canvas</h3><h4 id="1-用户通过input框选择图片"><a href="#1-用户通过input框选择图片" class="headerlink" title="1. 用户通过input框选择图片"></a>1. 用户通过input框选择图片</h4><p> let file = e.target.files[0]</p><h4 id="2-将-file文件流通过FileReader转化成base64-（能够预览）"><a href="#2-将-file文件流通过FileReader转化成base64-（能够预览）" class="headerlink" title="2. 将_file文件流通过FileReader转化成base64  （能够预览）"></a>2. 将_file文件流通过FileReader转化成base64  （能够预览）</h4><p><strong>FileReade就是这个对象是用来读取File对象或Blob对象的</strong></p><h5 id="FileReader的钩子与方法：-（onload-readAsDataURL）"><a href="#FileReader的钩子与方法：-（onload-readAsDataURL）" class="headerlink" title="FileReader的钩子与方法： （onload/readAsDataURL）"></a>FileReader的钩子与方法： <strong>（onload/readAsDataURL）</strong></h5><p>FileReader.onload:处理load事件。即该钩子在读取操作完成时触发，通过该钩子函数可以完成例如<strong>读取完图片后进行预览的操作，或读取完图片后对图片内容进行二次处理等操作。</strong></p><p>FileReader.readAsDataURL：读取方法，<strong>并且读取完成后，result属性将返回 Data URL 格式（Base64 编码）的字符串</strong>，代表图片内容。</p><h4 id="3-将图片绘制到canvas画布上"><a href="#3-将图片绘制到canvas画布上" class="headerlink" title="3. 将图片绘制到canvas画布上"></a>3. 将图片绘制到canvas画布上</h4><p>可以理解为一个标签，可以通过这个标签上的属性来绘制图片并且可以实现压缩效果。</p><p>canvas.getContext(‘2d’): 获得渲染上下文和它的2d绘画功能,返回ctx对象</p><p><strong>ctx.drawImage(img,x,y,width,height):<strong>绘制图像 | x，y对应的是坐标轴，width、height绘制的图片大小  (这个方法是</strong>CanvasRenderingContext2D</strong>上的绘制图片的方法)</p><h4 id="4-使用canvas画布的能力进行图片压缩-Canvas-toDataURL-mimeType-quailty-核心"><a href="#4-使用canvas画布的能力进行图片压缩-Canvas-toDataURL-mimeType-quailty-核心" class="headerlink" title="4. 使用canvas画布的能力进行图片压缩    Canvas.toDataURL(mimeType,quailty) (核心)"></a>4. 使用canvas画布的能力进行图片压缩    Canvas.toDataURL(mimeType,quailty) (核心)</h4><p>Canvas.toDataURL()方法可以将<strong>canvas画布上的信息转换为base64(DataURL)格式</strong>的图像信息，纯字符的图片表示形式。该方法接收2个参数：</p><p>mimeType(可选)：String；表示需要转换的图像的mimeType类型。默认值是<strong>image/png</strong>，还可以是image/jpeg，甚至image/webp（前提浏览器支持）等。</p><p>quailty(可选)：Number；quality表示转换的图片质量。范围是0到1。此参数要想有效，图片的mimeType需要是image/jpeg或者image/webp，其他mimeType值无效。<strong>默认压缩质量是0.92</strong>。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const canvas = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">canvas</span>&#x27;)</span>; <br>const quality = <span class="hljs-number">0.2</span>; <span class="hljs-comment">//设置压缩比例</span><br>canvas.<span class="hljs-keyword">to</span><span class="hljs-constructor">DataURL(<span class="hljs-params">file</span>.<span class="hljs-params">type</span>, <span class="hljs-params">quality</span>)</span><br></code></pre></td></tr></table></figure><p>本文中设置了压缩质量为0.2，需要注意的是不是说压缩质量<strong>设置为0.2实际压缩效果就为5倍压缩</strong>（在本文中，压缩质量设置成了0.2但<strong>实际压缩效果确实7-9倍</strong>），简单的说，当到达了这一步以后，其实图片已经完成了压缩，我们已经可以<strong>直接拿着返回的base64(DataURL)格式的数据</strong>去渲染图片，但是，如果你的目的是将图片先进行压缩，压缩后再上传给服务器，并且服务器只接受二进制的图片信息的话，那就得好好考虑怎么将base64转换成二进制Blob对象了</p><p>当quality在0.2~0.5之间，图片质量变化并不大，quality的值越小，压缩效率越可观（也就是在0.2左右时，压缩图片可以最大化，同时并不对图片质量造成太大影响）<br><a href="https://juejin.cn/post/6940430496128040967#comment">参考</a><br>DataURL带来的便利原因就是一个：<strong>它不需要发起http请求</strong>；而它的缺点归纳起来就是两个：<strong>体积比原有还要大、不会被缓存。</strong></p><h5 id="解决小体积图片压缩问题"><a href="#解决小体积图片压缩问题" class="headerlink" title="解决小体积图片压缩问题"></a><strong>解决小体积图片压缩问题</strong></h5><p>经过多组测试发现，使用canvas压缩体积的时候，<strong>文件体积过小反而会出现越压缩体积越大</strong>的情况</p><p><strong>设置一个体积阀门，小于这个体积的图片我们不做限制</strong>。毕竟我们的初心就是为了压缩大体积文件<br>在上述代码的基础上添加 minSize，当小于300kb的时候不进行canvas压缩</p><p>每 <strong><code>3*8bit</code> 的字节转换为 4*6bit 的字节，剩下的两位用 00 补齐</strong>，所以Base64 编码后的数据比编码之前<strong>大 1/3</strong></p><h4 id="5-将压缩后的Base64-DataURL-格式的数据转换成Blob对象进行上传"><a href="#5-将压缩后的Base64-DataURL-格式的数据转换成Blob对象进行上传" class="headerlink" title="5. 将压缩后的Base64(DataURL)格式的数据转换成Blob对象进行上传"></a>5. 将压缩后的Base64(DataURL)格式的数据转换成Blob对象进行上传</h4><p>3.<strong>atob</strong>  <strong>数据解码</strong></p><p>对经过 base-64 编码的字符串进行解码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> encodedData = <span class="hljs-built_in">window</span>.btoa(<span class="hljs-string">&quot;Hello, world&quot;</span>); <span class="hljs-comment">// 编码  SGVsbG8sIHdvcmxk</span><br><span class="hljs-keyword">let</span> decodedData = <span class="hljs-built_in">window</span>.atob(encodedData);    <span class="hljs-comment">// 解码  Hello, world</span><br></code></pre></td></tr></table></figure><p>4.<strong>ArrayBuffer</strong> 类数组对象  <strong>Array</strong></p><p>ArrayBuffer对象代表储存二进制数据的一段内存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> buf = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><p>上面代码生成了一段 8 字节的内存区域，每个字节的值默认都是 0。(看不太懂，不着急👇接着往下看)<br>5.File 构造函数 MDN-File<br><a href="https://juejin.cn/post/7069269252867358733#heading-9">canvas还能这么用？🤨 图片压缩70% | base64转换原理</a></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php">export <span class="hljs-keyword">const</span> dataURItoBlob = (dataURI: <span class="hljs-keyword">string</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">binary</span> = atob(dataURI.split(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">array</span>: number[] = [];<br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">binary</span>.length; i++) &#123;<br>    <span class="hljs-keyword">array</span>.push(<span class="hljs-keyword">binary</span>.charCodeAt(i));<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Blob([<span class="hljs-keyword">new</span> Uint8Array(<span class="hljs-keyword">array</span>)], &#123; type: <span class="hljs-string">&quot;image/jpeg&quot;</span> &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="为何使用DataURL–想做图片预览，而图片预览是通过FileReader对象实现的-（FileReader-readAsDataURL-）"><a href="#为何使用DataURL–想做图片预览，而图片预览是通过FileReader对象实现的-（FileReader-readAsDataURL-）" class="headerlink" title="为何使用DataURL–想做图片预览，而图片预览是通过FileReader对象实现的  （FileReader.readAsDataURL()）"></a>为何使用DataURL–想做图片预览，而图片预览是通过FileReader对象实现的  （FileReader.readAsDataURL()）</h4><p><a href="https://juejin.cn/post/6844903495703904263#heading-11">前端图片压缩上传（压缩篇）：可能是最适合小白的前端图片压缩文章了！</a></p><h4 id="拓展问题：这个图片压缩的原理是啥？这个压缩影响图片质量么"><a href="#拓展问题：这个图片压缩的原理是啥？这个压缩影响图片质量么" class="headerlink" title="拓展问题：这个图片压缩的原理是啥？这个压缩影响图片质量么"></a>拓展问题：这个图片压缩的原理是啥？这个压缩影响图片质量么</h4><p>图片压缩原理，简单来说，<strong>通过算法减少一张图片上的颜色差异，牺牲图片画质。比如紧挨着的颜色相近的四个像素的颜色信息压缩前大概占16个字节，压缩后变成一个颜色就能减少近4倍。quality用来控制色差的力度，值越小力度越大，颜色相差较大的两个像素也会被处理，自然被压缩后文件就越小，画质就越烂，</strong>所以是会影响图片质量的，官方文档中也有说到。</p><h3 id="封装公共方法拖拽事件函数，使用节流优化。（mousedown，mousemove，mouseup）"><a href="#封装公共方法拖拽事件函数，使用节流优化。（mousedown，mousemove，mouseup）" class="headerlink" title="封装公共方法拖拽事件函数，使用节流优化。（mousedown，mousemove，mouseup）"></a>封装公共方法拖拽事件函数，使用节流优化。（mousedown，mousemove，mouseup）</h3><p>（横向的scroll电脑上是要靠鼠标拖动scroll  bar 才能移动的，而这个函数就能够实现拖动里面的内容滑动，效果和手机端一样），这样实现的效果，拖动元素时不会出现一卡一卡的效果，比较流畅，并且每秒触发的事件会很少性能上会有很大的提升<br>鼠标按下开始拖拽</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">记录摁下鼠标时的鼠标位置以及元素位置</span><br><span class="hljs-attr">拖动鼠标记下当前鼠标的位置</span><br><span class="hljs-attr">鼠标当前位置-摁下时鼠标位置</span>=<span class="hljs-string"> 鼠标移动距离</span><br><span class="hljs-string">元素位置= 鼠标移动距离+鼠标摁下时元素的位置</span><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">（<span class="hljs-keyword">event</span>.clientX、<span class="hljs-keyword">event</span>.clientY，<span class="hljs-keyword">event</span>.offsetX、<span class="hljs-keyword">event</span>.offsetY）<br><br><span class="hljs-keyword">event</span>.clientX、<span class="hljs-keyword">event</span>.clientY<br></code></pre></td></tr></table></figure><p>鼠标相对于浏览器窗口可视区域的X，Y坐标（窗口坐标），可视区域不包括工具栏和滚动条。IE事件和标准事件都定义了这2个属性event.pageX、event.pageY</p><p>类似于event.clientX、event.clientY，但它们使用的是文档坐标而非窗口坐标。这2个属性不是标准属性，但得到了广泛支持。IE事件中没有这2个属性。event.offsetX、event.offsetY<br>鼠标相对于事件源元素（srcElement）的X,Y坐标，只有IE事件有这2个属性，标准事件没有对应的属性。<br>event.screenX、event.screenY<br>鼠标相对于用户显示器屏幕左上角的X,Y坐标。标准事件和IE事件都定义了这2个属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> node1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;div1&quot;</span>);<span class="hljs-comment">//获取节点</span><br>drag(node1);<span class="hljs-comment">//调用方法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drag</span>(<span class="hljs-params">node</span>)</span>&#123;<br>    <span class="hljs-comment">//1、添加mousedown，记录相对距离</span><br>    node.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> e = ev || <span class="hljs-built_in">window</span>.event;<span class="hljs-comment">//兼容事件对象</span><br>        <span class="hljs-keyword">var</span> offsetX = e.clientX - node.offsetLeft;<span class="hljs-comment">//鼠标点击相对当前div的距离</span><br>        <span class="hljs-keyword">var</span> offsetY = e.clientY - node.offsetTop;<br><br>        <span class="hljs-comment">//2、mousemove，保持相对距离跟随鼠标移动</span><br>        <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>&#123;<br>            <span class="hljs-keyword">var</span> e = ev || <span class="hljs-built_in">window</span>.event;<br><br>            node.style.left = e.clientX - offsetX + <span class="hljs-string">&#x27;px&#x27;</span>;<span class="hljs-comment">//鼠标位置减去相对距离即为新的位置</span><br>            node.style.top = e.clientY - offsetY + <span class="hljs-string">&#x27;px&#x27;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//3、取消拖拽</span><br>    <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-literal">null</span>;<span class="hljs-comment">//取消移动事件</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/6844904116804681742">参考文章</a><br><a href="https://blog.csdn.net/HRM2454/article/details/109060637">参考文章</a></p><p> <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> slide = <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> isDown = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">let</span> startX: <span class="hljs-built_in">any</span>;<br>  <span class="hljs-keyword">let</span> scrollLeft: <span class="hljs-built_in">any</span>;<br>  <span class="hljs-keyword">const</span> slider = value;<br>  slider.addEventListener(<span class="hljs-string">&quot;mousedown&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>    isDown = <span class="hljs-literal">true</span>;<br>    slider.classList.add(<span class="hljs-string">&quot;active&quot;</span>);<br>    startX = e.pageX - slider.offsetLeft;<br>    scrollLeft = slider.scrollLeft;<br>  &#125;);<br>  slider.addEventListener(<span class="hljs-string">&quot;mouseleave&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    isDown = <span class="hljs-literal">false</span>;<br>    slider.classList.remove(<span class="hljs-string">&quot;active&quot;</span>);<br>  &#125;);<br>  slider.addEventListener(<span class="hljs-string">&quot;mouseup&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    isDown = <span class="hljs-literal">false</span>;<br>    slider.classList.remove(<span class="hljs-string">&quot;active&quot;</span>);<br>  &#125;);<br>  slider.addEventListener(<span class="hljs-string">&quot;mousemove&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isDown) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    e.preventDefault();<br>    <span class="hljs-keyword">const</span> x = e.pageX - slider.offsetLeft;<br>    <span class="hljs-keyword">const</span> walk = (x - startX) * <span class="hljs-number">3</span>;<br>    slider.scrollLeft = scrollLeft - walk;<br>    <span class="hljs-comment">// console.log(walk);</span><br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure></p><h3 id="实现移动端与网页端的适配，解决本地，测试，生产环境样式不一致的问题。-可能有缓存，打包版本的-x-不同的版本-排查错误的能力"><a href="#实现移动端与网页端的适配，解决本地，测试，生产环境样式不一致的问题。-可能有缓存，打包版本的-x-不同的版本-排查错误的能力" class="headerlink" title="实现移动端与网页端的适配，解决本地，测试，生产环境样式不一致的问题。 (  可能有缓存，打包版本的 ?x 不同的版本)  排查错误的能力"></a>实现移动端与网页端的适配，解决本地，测试，生产环境样式不一致的问题。 (  可能有缓存，打包版本的 ?x 不同的版本)  排查错误的能力</h3><p>（rem  /媒体查询  css3 的media   /flex 布局   dialog弹框的形式打开的） webkit<br>问题   苹果浏览器   scrollbar  高度修改不了  （苹果safari13的官方文档 默认修改不了）<br>img 网站中样式污染了 max-width 100% 导致图片不能正常展开 ，设置后覆盖样式就可以了,和网站中的类名一样也会有样式污染</p><h3 id="与后端加购信息对接，实现插件与网站的信息交互。-（dispatchEvent）"><a href="#与后端加购信息对接，实现插件与网站的信息交互。-（dispatchEvent）" class="headerlink" title="与后端加购信息对接，实现插件与网站的信息交互。 （dispatchEvent）"></a>与后端加购信息对接，实现插件与网站的信息交互。 （dispatchEvent）</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">    <span class="hljs-comment">// 这里通知外部，定制完成，已经加购</span><br>    const eventAwesome = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CustomEvent(<span class="hljs-string">&quot;customeFinished&quot;</span>, &#123;&#125;)</span>;<br>    window.dispatch<span class="hljs-constructor">Event(<span class="hljs-params">eventAwesome</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="了解Ts，Ts的好处是？"><a href="#了解Ts，Ts的好处是？" class="headerlink" title="了解Ts，Ts的好处是？"></a>了解Ts，Ts的好处是？</h3><h5 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h5><p>静态类型化是一种功能，可以在开发人员编写脚本是检测错误，有了这项功能，就会允许开发人员编写更健壮的代码并对其进行维护，以便使得代码质量更好、更清晰。<br>(从代码可知变量num是number类型，如果我们给num赋予其他类型的值就会报错。)</p><h5 id="大型项目的优势"><a href="#大型项目的优势" class="headerlink" title="大型项目的优势"></a>大型项目的优势</h5><p>对于大型项目的开发，有时为了优化改进项目，对代码进行小小更改。这些小小的变化可能会产生严重的、意想不到的后果，因此有必要撤销这些变化。使用TypeScript工具来进行重构更变的容易、快捷。</p><h5 id="更好的协作"><a href="#更好的协作" class="headerlink" title="更好的协作"></a>更好的协作</h5><p>对于大型项目的开发一般会有很多开发人员一起开发，此时乱码和错误的机也会增加。类型安全是一种在编码期间检测错误的功能，而不是在编译项目时检测错误。这为开发团队创建了一个更高效的编码和调试过程。</p><h4 id="typescript-中-interface-和-type-的区别"><a href="#typescript-中-interface-和-type-的区别" class="headerlink" title="typescript 中 interface 和 type 的区别"></a>typescript 中 interface 和 type 的区别</h4><blockquote><p>相同点 (都可以描述一个对象或者函数&amp;&amp;都允许拓展（extends）)</p></blockquote><p>不同点 (<br>  type可以interface不可以：：</p><blockquote><p>type 可以声明基本类型别名，联合类型，元组等类型,type 语句中还可以使用 typeof 获取实例的 类型进行赋值 ,</p></blockquote><p>interface可以type不可以：</p><blockquote><p>interface 能够声明合并)<br><a href="https://juejin.cn/post/6844903749501059085">参考</a><br>一般来说，如果不清楚什么时候用interface/type，能用 interface 实现，就用 interface , 如果不能就用 type</p></blockquote><h3 id="说一下前端登录的流程-JWT鉴权"><a href="#说一下前端登录的流程-JWT鉴权" class="headerlink" title="说一下前端登录的流程?  JWT鉴权"></a>说一下前端登录的流程?  JWT鉴权</h3><p>初次登录的时候，前端调后调的登录接口，发送用户名和密码，后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token，和一个用户信息的值，前端拿到token，将token储存到Vuex中，然后从Vuex中把token的值存入浏览器Cookies中。</p><p>把用户信息存到Vuex然后再存储到LocalStrobe中,然后跳转到下一个页面，<strong>根据后端接口的要求，只要不登录就不能访问的页面需要在前端每次跳转页面师判断Cookies中是否有token，没有就跳转到登录页，有就跳转到相应的页面</strong>,</p><p>我们应该再每次发送post/get请求的时候应该加入token，常用方法再项目utils/service.js中<strong>添加全局拦截器，将token的值放入请求头中 后端判断请求头中有无token，有token，就拿到token并验证token是否过期，在这里过期会返回无效的token，然后有个跳回登录页面重新登录并且清除本地用户的信息</strong></p><h4 id="token过期了怎么处理"><a href="#token过期了怎么处理" class="headerlink" title="token过期了怎么处理"></a>token过期了怎么处理</h4><p><strong>没有绝对的安全, 所谓的安全处理, 就是提高攻击者攻击的难度, 对他造成了一定的麻烦</strong>, 我们这个网站就是安全的! 网站安全性就是高的! 所以: token 必须要有过期时间! 每隔一段时间, 必须有一个新的token, 旧的token失效。<br>token的过期问题</p><p>你登陆成功之后，接口会返回一个token值，这个值在后续请求时带上（就像是开门钥匙）。<br>但是，这个值<strong>一般会有有效期（具体是多长，是由后端决定）</strong>，token失效，再去发请求时，就会报401错误。</p><h5 id="token"><a href="#token" class="headerlink" title="token"></a>token</h5><p>作用：在访问一些接口时，需要传入token，就是它。<br>有效期：2小时。</p><h5 id="refresh-token"><a href="#refresh-token" class="headerlink" title="refresh_token"></a>refresh_token</h5><p>作用: <strong>当token的有效期过了之后，可以使用它去请求一个特殊接口（这个接口也是后端指定的，明确需要传入refresh_token），并返回一个新的token回来（有效期还是2小时），以替换过期的那个token</strong>。<br>有效期：14天。（最理想的情况下，一次登陆可以持续14天。）</p><h5 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h5><p>对于 某次请求A 的响应，如果是401错误</p><ol><li><p>有refresh_token，用refresh_token去请求回新的token</p><ol><li>新token请求成功  （更新本地token，再发一次请求A）</li><li>新token请求失败（清空vuex中的token，携带请求地址，跳转到登陆页）</li></ol></li><li><p>没有refresh_token<br>（清空vuex中的token，携带请求地址，跳转到登陆页）</p></li></ol><p>对于一个请求的响应 401, 要这么处理, 对于十个请求的响应 401, 也要这么处理,<br><strong>我们可以统一将这个token过期处理放在响应拦截器中</strong><br>请求拦截器: 所有的请求, 在真正被发送出去之前, 都会先经过请求拦截器 (可以携带token)<br>响应拦截器: 所有的响应, 在真正被(.then.catch await)处理之前, 都会先经过响应拦截器, 可以在这个响应拦截器中统一对响应做判断<br><a href="https://juejin.cn/post/7076022961316036638#heading-7">掘金</a></p><h3 id="登录权限怎么处理-（动态路由）Vue实现动态路由（和面试官吹项目亮点）"><a href="#登录权限怎么处理-（动态路由）Vue实现动态路由（和面试官吹项目亮点）" class="headerlink" title="登录权限怎么处理 （动态路由）Vue实现动态路由（和面试官吹项目亮点）"></a>登录权限怎么处理 （动态路由）Vue实现动态路由（和面试官吹项目亮点）</h3><h4 id="登录逻辑"><a href="#登录逻辑" class="headerlink" title="登录逻辑"></a>登录逻辑</h4><p>每个系统都有自己的登录登出逻辑，而我们前端所要做的其实是请求后台，<strong>拿到登录权限，带上登录权限，获取用户信息和菜单信息</strong>。 在vue项目开发当中，我们一般都是在全局路由钩子做这一系列判断。</p><h4 id="菜单权限"><a href="#菜单权限" class="headerlink" title="菜单权限"></a>菜单权限</h4><p><strong>通过带有 token 请求头的请求方法，后端可以判断到是哪一个用户，前端也可以通过获取权限接口获得该用户的权限列表，根据权限列表做一份路由映射表</strong>，如果后端返回的数据结构与前端的路由设置的数据结构不同，此时还需编写此映射路由的业务功能函数。</p><p>如果该<strong>用户拥有此路由权限，则通过在全局路由监控中 router.beforeEach 进行 router 中的 addRoutes 方法将有权限的路由配置添加到路由当中</strong>，侧边栏也可根据路由列表中的 <strong>meta 字段中关键字的判断进行相应的渲染</strong>。如果权限的颗粒度小到一个按钮，则<strong>可根据后端返回的权限列表映射出的权限参数，通过v-if 进行判断该功能组件是否渲染</strong>。在路由管理中通过 router.beforeEach 钩子中判断当前的路由权限是否为空，是的话则可执行获取权限路由的接口：</p><p>以前的菜单路由是直接写死在前端，但是当我们直接访问这个路由时，用户还是可以进入到这个功能页面；后来直接改成<strong>动态添加路由的方式router.addRoutes。</strong></p><p><strong>一个是操作权限，一个是路由访问权限（这里指前端路由）</strong><br>1.后端返回一个json格式的路由表<br>2.因为后端传回来的是都是字符串格式的，但前端这里需要的是一个组件对象，<strong>写个方法遍历一下，将字符串转换为组件对象</strong><br>3.利用vue-router的<strong>beforeEach、addRoutes、vuex</strong>来配合上边两步实现效果<br>4.左侧菜单拦截根据拿到转换好的路由列表进行展示<strong>拦截路由 -&gt; 后端取到路由 -&gt; 保存路由到vuex</strong>（用户登录进来只会从后端取一次，其余都从本地取，所以用户，只有退出在登录路由才会更新）</p><p>前端有一份动态路由表，等到用户登录拿到用户的角色之后根据当前登录用户的角色去筛选出可以访问的路由，形成一份定制路由表，然后动态挂载路由。，这样做的好处就是，前端每开发一个页面不需要让后端再去配一下路由和权限了，从而避免被后端支配。</p><p>然而，路由表又是跟角色挂钩。考虑一种情况，项目上线之后，管理员添加了一个新角色，并且要给这个角色分配菜单。<br><strong>如果采用将路由表放在前端的话那么每个路由的可访问角色都是写死的，要给新添加的角色分配菜单，只能改前端代码，显然不是很合适</strong>。<br>所以我才用了后者，就是<strong>把路由信息放在后端，后端将路由信息和角色关联起来，用户登录之后请求对应的接口拿到属于这个用户的路由信息</strong>（也就是菜单），</p><p><strong>然后前端对返回的数据格式化，转换成符合vue-router的路由格式，然后动态挂载。</strong>将路由信息放在后端，这样就可以对路由进行配置了，比如说超级管理员今天很不高兴，不想让某个角色下的用户访问某个路由，直接在该路由下剔除这个角色就可以了</p><p><a href="https://juejin.cn/post/6981031288803164173#comment">Vue后台管理系统怎么做权限验证和动态路由，谁来做？</a></p><h6 id="什么是-Token（令牌）"><a href="#什么是-Token（令牌）" class="headerlink" title="什么是 Token（令牌）"></a>什么是 Token（令牌）</h6><p>Acesss Token</p><p>访问资源接口（API）时所需要的资源凭证</p><blockquote><p>简单 token 的组成： uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</p></blockquote><h6 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h6><p>服务端无状态化、可扩展性好，支持移动端设备，安全，支持跨程序调用，每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里</p><h5 id="说一下前端权限管理怎么实现"><a href="#说一下前端权限管理怎么实现" class="headerlink" title="说一下前端权限管理怎么实现"></a>说一下前端权限管理怎么实现</h5><p><a href="https://blog.csdn.net/weixin_40599109/article/details/113728974">参考文章</a></p><h3 id="Vue3-Composition-API-和-script-setup-（toRefs设置响应式）"><a href="#Vue3-Composition-API-和-script-setup-（toRefs设置响应式）" class="headerlink" title="Vue3 Composition API 和 script setup （toRefs设置响应式）"></a>Vue3 Composition API 和 script setup （toRefs设置响应式）</h3><p><a href="https://pengzhenglong.github.io/2022/01/10/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#Vue3">博客</a></p><h3 id="使用mongodb的优势"><a href="#使用mongodb的优势" class="headerlink" title="使用mongodb的优势"></a>使用mongodb的优势</h3><p>为什么使用mongodb   好处(连接mongose)</p><blockquote><p>学习成本较低，非常简单</p></blockquote><p><strong>在需求不明确/需求变化频繁（表结构不明确）的情况下，使用MongoDB的开发和维护成本最低（MongoDB语法简单，修改表结构简单）。</strong><br>部署简单<br>应该不需要事务/不存在大量的复杂事务逻辑操作，不需要复杂的锁<br><strong>逻辑比较单一、简单，不存在数据结构化查询（表之间join）的情况</strong></p><p>模式自由</p><blockquote><p>面向集合存储，易存储对象类型的数据</p></blockquote><p>为什所谓“面向集合”（Collenction-Oriented），意思是数据被分组存储在数据集中，被称为一个集合（Collenction)。每个集合在数据库中都有一个唯一的标识名，并且可以包含无限数目的文档。集合的概念类似关系型数据库（RDBMS）里的表（table），不同的是它不需要定义任何模式（schema)。</p><h3 id="使用组件库遇到的问题（难点）项目中用的两个库的有遇到什么难点"><a href="#使用组件库遇到的问题（难点）项目中用的两个库的有遇到什么难点" class="headerlink" title="使用组件库遇到的问题（难点）项目中用的两个库的有遇到什么难点"></a>使用组件库遇到的问题（难点）项目中用的两个库的有遇到什么难点</h3><h4 id="面试问你用组件库有什么体会，面试官主要想听到的是啥-用组件库有遇到什么问题难点-好几次面试"><a href="#面试问你用组件库有什么体会，面试官主要想听到的是啥-用组件库有遇到什么问题难点-好几次面试" class="headerlink" title="面试问你用组件库有什么体会，面试官主要想听到的是啥(用组件库有遇到什么问题难点 -好几次面试)"></a>面试问你用组件库有什么体会，面试官主要想听到的是啥(用组件库有遇到什么问题难点 -好几次面试)</h4><p>能复用通用 –ElementUi 的tab是三个都渲染了(为了高度和宽度一样)</p><ol><li><strong>性能问题（按需引入） tree shaking  打包体积</strong><br>开发中有没有遇见过数据修改了页面不刷新的情况 （$set()）</li><li><strong>从业务组件（对功能组件的具体实现）和功能组件（不涉及业务逻辑，比如下拉框，列表）两方面来说</strong><br>定向了什么业务，然后  ，你的功能组件，入参怎么设计的，有什么抽象的属性，使用于什么…</li></ol><blockquote><p>开发中项目有什么优化的点（项目中引用轻量级的库）</p></blockquote><h2 id="面试（记录）"><a href="#面试（记录）" class="headerlink" title="面试（记录）"></a>面试（记录）</h2><h3 id="同花顺一面（凉经）-2022-3-7-10-00-1h5min"><a href="#同花顺一面（凉经）-2022-3-7-10-00-1h5min" class="headerlink" title="同花顺一面（凉经） 2022.3.7 10:00  1h5min"></a>同花顺一面（凉经） 2022.3.7 10:00  1h5min</h3><h4 id="HTML-语义化"><a href="#HTML-语义化" class="headerlink" title="HTML 语义化"></a>HTML 语义化</h4><p>概念：HTML5的语义化指的是合理正确的使用语义化的标签来创建页面结构。【正确的标签做正确的事】<br>语义化标签：header nav main article section aside footer<br>语义化的优点:<br>在没CSS样式的情况下，页面整体也会呈现很好的结构效果<br>代码结构清晰，易于阅读，<br>利于开发和维护 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。<br>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重</p><h4 id="说一下跨域，如何解决跨域"><a href="#说一下跨域，如何解决跨域" class="headerlink" title="说一下跨域，如何解决跨域"></a>说一下跨域，如何解决跨域</h4><p><a href="https://pengzhenglong.github.io/2022/01/07/%E8%AE%A1%E7%BD%91+%E6%B5%8F%E8%A7%88%E5%99%A8+http+%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%EF%BC%9F">博客</a></p><h4 id="讲讲Dom渲染性能消耗-没理解–讲了diff算法去了"><a href="#讲讲Dom渲染性能消耗-没理解–讲了diff算法去了" class="headerlink" title="讲讲Dom渲染性能消耗 (没理解–讲了diff算法去了)"></a>讲讲Dom渲染性能消耗 (没理解–讲了diff算法去了)</h4><h4 id="v-if-v-show"><a href="#v-if-v-show" class="headerlink" title="v-if  v-show"></a>v-if  v-show</h4><h4 id="数组的key的作用"><a href="#数组的key的作用" class="headerlink" title="数组的key的作用"></a>数组的key的作用</h4><p><a href="https://pengzhenglong.github.io/2022/01/10/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#Vue%E4%B8%AD%E7%9A%84key%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E2%BD%A4%EF%BC%9F">博客</a></p><h4 id="vue-data为什么不是一个对象"><a href="#vue-data为什么不是一个对象" class="headerlink" title="vue  data为什么不是一个对象"></a>vue  data为什么不是一个对象</h4><p><a href="https://pengzhenglong.github.io/2022/01/10/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#%E4%B8%BA%E4%BB%80%E4%B9%88vue%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84data%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F">博客</a></p><h4 id="计算属性的原理-1"><a href="#计算属性的原理-1" class="headerlink" title="计算属性的原理"></a>计算属性的原理</h4><h4 id="双向数据绑定原理-defineProperty-proxy"><a href="#双向数据绑定原理-defineProperty-proxy" class="headerlink" title="双向数据绑定原理  defineProperty  proxy"></a>双向数据绑定原理  defineProperty  proxy</h4><p><a href="https://pengzhenglong.github.io/2022/01/10/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#Vue%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">博客</a><br><a href="https://pengzhenglong.github.io/2022/03/07/defineproPerty&&proxy/">Object.defineProperty和Proxy，Vue3.0为什么采用Proxy？</a></p><h4 id="vue3有了解吗-为什么可以监听数组"><a href="#vue3有了解吗-为什么可以监听数组" class="headerlink" title="vue3有了解吗  为什么可以监听数组"></a>vue3有了解吗  为什么可以监听数组</h4><blockquote><p>这种说法是有问题的，事实上，Object.defineProperty 本身是可以监控到数组下标的变化的，只是在 Vue 的实现中，从性能 / 体验的性价比考虑，放弃了这个特性。</p></blockquote><p>可以看到，Vue 的 Observer 对数组做了单独的处理。<br>hasProto 判断数组的实例是否有 proto 属性，如果有 proto 属性就会执行 protoAugment 方法，将 arrayMethods 重写到原型上</p><h5 id="Object-defineProperty-VS-Proxy-重点"><a href="#Object-defineProperty-VS-Proxy-重点" class="headerlink" title="Object.defineProperty VS Proxy(重点)"></a>Object.defineProperty VS Proxy(重点)</h5><p>Object.defineProperty 只能劫持对象的属性，而 Proxy 是直接代理对象。<br>由于 Object.defineProperty 只能对属性进行劫持，需要遍历对象的每个属性，如果属性值也是对象，则需要深度遍历。而 Proxy 直接代理对象，不需要遍历操作。</p><p>Object.defineProperty 对新增属性需要手动进行 Observe。<br>由于 Object.defineProperty 劫持的是对象的属性，所以新增属性时，需要重新遍历对象，对其新增属性再使用 Object.defineProperty 进行劫持。</p><p>也正是因为这个原因，使用 Vue 给 data 中的数组或对象新增属性时，需要使用 vm.$set 才能保证新增的属性也是响应式的。<br><a href="https://pengzhenglong.github.io/2022/01/10/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#defineProperty-%E5%92%8C-Proxy-%E7%9A%84%E5%8C%BA%E5%88%AB">博客</a></p><h4 id="defineProperty-proxy的区别-源码"><a href="#defineProperty-proxy的区别-源码" class="headerlink" title="defineProperty  proxy的区别 源码"></a>defineProperty  proxy的区别 源码</h4><h4 id="react-–不了解"><a href="#react-–不了解" class="headerlink" title="react  –不了解"></a>react  –不了解</h4><h4 id="选择器-权重"><a href="#选择器-权重" class="headerlink" title="选择器  权重"></a>选择器  权重</h4><p><a href="https://pengzhenglong.github.io/2022/02/15/CSS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#css%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7">博客</a></p><h4 id="动画了解吗"><a href="#动画了解吗" class="headerlink" title="动画了解吗"></a>动画了解吗</h4><h5 id="js动画了解吗-css动画-canvas"><a href="#js动画了解吗-css动画-canvas" class="headerlink" title="js动画了解吗  css动画  canvas"></a>js动画了解吗  css动画  canvas</h5><h5 id="Js-动画与-CSS-动画区别及相应实现（JS动画重绘回流，性能影响）-1"><a href="#Js-动画与-CSS-动画区别及相应实现（JS动画重绘回流，性能影响）-1" class="headerlink" title="Js 动画与 CSS 动画区别及相应实现（JS动画重绘回流，性能影响）"></a>Js 动画与 CSS 动画区别及相应实现（JS动画重绘回流，性能影响）</h5><h4 id="给一张图片用canvas怎么画出来-（api）"><a href="#给一张图片用canvas怎么画出来-（api）" class="headerlink" title="给一张图片用canvas怎么画出来  （api）"></a>给一张图片用canvas怎么画出来  （api）</h4><p>drawImage()向画布上绘制图像、画布或视频。</p><h4 id="css预处理-sass-less-stylus-有什么区别-哪个更好用-1"><a href="#css预处理-sass-less-stylus-有什么区别-哪个更好用-1" class="headerlink" title="css预处理  sass  less  stylus 有什么区别  哪个更好用"></a>css预处理  sass  less  stylus 有什么区别  哪个更好用</h4><h4 id="es6新特性-let-const-模板字符串-扩展运算符-箭头函数-promise-async-await"><a href="#es6新特性-let-const-模板字符串-扩展运算符-箭头函数-promise-async-await" class="headerlink" title="es6新特性   let  const  模板字符串  扩展运算符  箭头函数  promise  async  await"></a>es6新特性   let  const  模板字符串  扩展运算符  箭头函数  promise  async  await</h4><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>在代码块内，使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区</p><h4 id="promise-讲讲-async-await"><a href="#promise-讲讲-async-await" class="headerlink" title="promise  讲讲  async   await"></a>promise  讲讲  async   await</h4><p><a href="https://pengzhenglong.github.io/2022/01/05/JS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F">博客</a></p><h4 id="浏览器事件循环机制"><a href="#浏览器事件循环机制" class="headerlink" title="浏览器事件循环机制"></a>浏览器事件循环机制</h4><p><a href="https://pengzhenglong.github.io/2022/01/05/JS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/#EventLoop-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">博客</a></p><h4 id="闭包讲讲-闭包优化-使用场景-防抖节流"><a href="#闭包讲讲-闭包优化-使用场景-防抖节流" class="headerlink" title="闭包讲讲   闭包优化 使用场景 (防抖节流)"></a>闭包讲讲   闭包优化 使用场景 (防抖节流)</h4><p><a href="https://pengzhenglong.github.io/2022/01/05/JS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/#%E9%97%AD%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%EF%BC%9F">博客</a><br><a href="https://pengzhenglong.github.io/2022/01/05/JS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/#%E9%98%B2%E6%8A%96-amp-amp-%E8%8A%82%E6%B5%81">防抖节流</a></p><h4 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制  *"></a>垃圾回收机制  *</h4><p><a href="https://pengzhenglong.github.io/2022/01/05/JS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/#JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">博客</a></p><h4 id="基本数据类型-BigInt讲讲（项目中有用过吗）-Symbol"><a href="#基本数据类型-BigInt讲讲（项目中有用过吗）-Symbol" class="headerlink" title="基本数据类型   BigInt讲讲（项目中有用过吗）  Symbol"></a>基本数据类型   BigInt讲讲（项目中有用过吗）  Symbol</h4><p><a href="https://pengzhenglong.github.io/2022/01/05/JS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/#js%E7%A7%8D8%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">博客</a></p><h4 id="深拷贝-浅拷贝"><a href="#深拷贝-浅拷贝" class="headerlink" title="深拷贝 浅拷贝"></a>深拷贝 浅拷贝</h4><p><a href="https://pengzhenglong.github.io/2022/01/05/JS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D">博客</a></p><h4 id="网站性能优化-实习时给公司维护的网站-懒加载-（src先设置为字符串或者指向一张小图片，data-src后改变图片路径src）"><a href="#网站性能优化-实习时给公司维护的网站-懒加载-（src先设置为字符串或者指向一张小图片，data-src后改变图片路径src）" class="headerlink" title="网站性能优化(实习时给公司维护的网站)  懒加载 （src先设置为字符串或者指向一张小图片，data-src后改变图片路径src）"></a>网站性能优化(实习时给公司维护的网站)  懒加载 （src先设置为字符串或者指向一张小图片，data-src后改变图片路径src）</h4><p>预加载：</p><ol><li>使用html标签，设置为dispaly:none</li><li>使用Image对象<br><a href="https://pengzhenglong.github.io/2022/01/05/JS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/#%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD">博客</a></li></ol><h4 id="pc端和移动端-适配-媒体查询"><a href="#pc端和移动端-适配-媒体查询" class="headerlink" title="pc端和移动端 适配  媒体查询"></a>pc端和移动端 适配  媒体查询</h4><h5 id="判断屏幕宽度（现在有一个折叠屏宽度怎么区分呢）他说要怎么区分，我答的是如何适配（好像不是）"><a href="#判断屏幕宽度（现在有一个折叠屏宽度怎么区分呢）他说要怎么区分，我答的是如何适配（好像不是）" class="headerlink" title="判断屏幕宽度（现在有一个折叠屏宽度怎么区分呢）他说要怎么区分，我答的是如何适配（好像不是）"></a>判断屏幕宽度（现在有一个折叠屏宽度怎么区分呢）他说要怎么区分，我答的是如何适配（好像不是）</h5><h4 id="单位-px-em-rem-vh-vw"><a href="#单位-px-em-rem-vh-vw" class="headerlink" title="单位  px  em  rem  vh  vw"></a>单位  px  em  rem  vh  vw</h4><h4 id="浏览器输入url发生了什么-tcp连接3次握手，四次挥手（详细讲讲）"><a href="#浏览器输入url发生了什么-tcp连接3次握手，四次挥手（详细讲讲）" class="headerlink" title="浏览器输入url发生了什么  tcp连接3次握手，四次挥手（详细讲讲）"></a>浏览器输入url发生了什么  tcp连接3次握手，四次挥手（详细讲讲）</h4><p><a href="https://pengzhenglong.github.io/2021/05/27/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%BF%87%E7%A8%8B%E9%9D%A2%E8%AF%95/#URL%E7%9A%84%E8%BE%93%E5%85%A5%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E4%BA%8B%E4%BB%B6">博客</a></p><h4 id="tcp与udp的区别-再讲一下两个主要的区别"><a href="#tcp与udp的区别-再讲一下两个主要的区别" class="headerlink" title="tcp与udp的区别   (再讲一下两个主要的区别)"></a>tcp与udp的区别   (再讲一下两个主要的区别)</h4><h4 id="我们现在视频传输的协议是？-答的是https-百度是udp"><a href="#我们现在视频传输的协议是？-答的是https-百度是udp" class="headerlink" title="我们现在视频传输的协议是？  答的是https    百度是udp"></a>我们现在视频传输的协议是？  答的是https    百度是udp</h4><h4 id="Https和Http的区别"><a href="#Https和Http的区别" class="headerlink" title="Https和Http的区别"></a>Https和Http的区别</h4><ol><li>最简单的，HTTP 在地址栏上的协议是以 http:// 开头，而 HTTPS 在地址栏上的协议是以 https:// 开头</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>pengzhenglong.github.io/<br>https:<span class="hljs-regexp">//</span>pengzhenglong.github.io/<br></code></pre></td></tr></table></figure><ol start="2"><li><p>HTTP 是未经安全加密的协议，它的传输过程容易被攻击者监听、数据容易被窃取、发送方和接收方容易被伪造；而 HTTPS 是安全的协议，它通过 密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法 能够解决上面这些问题。</p></li><li><p>HTTP 的默认端口是 80，而 HTTPS 的默认端口是 443。<br><a href="https://pengzhenglong.github.io/2022/01/07/%E8%AE%A1%E7%BD%91+%E6%B5%8F%E8%A7%88%E5%99%A8+http+%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/#1-http-%E5%92%8C-https-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">博客</a></p></li></ol><h4 id="项目中用的两个库的有遇到什么难点"><a href="#项目中用的两个库的有遇到什么难点" class="headerlink" title="项目中用的两个库的有遇到什么难点"></a>项目中用的两个库的有遇到什么难点</h4><h4 id="typescript-中-interface-和-type-的区别-1"><a href="#typescript-中-interface-和-type-的区别-1" class="headerlink" title="typescript 中 interface 和 type 的区别"></a>typescript 中 interface 和 type 的区别</h4><h4 id="开始做题（一个数如何转换为千分位（1756346-gt-1-756-346），手撕防抖节流）-没时间了讲讲思路"><a href="#开始做题（一个数如何转换为千分位（1756346-gt-1-756-346），手撕防抖节流）-没时间了讲讲思路" class="headerlink" title="开始做题（一个数如何转换为千分位（1756346-&gt; 1,756,346），手撕防抖节流）(没时间了讲讲思路)"></a>开始做题（一个数如何转换为千分位（1756346-&gt; 1,756,346），手撕防抖节流）(没时间了讲讲思路)</h4><h5 id="千分位分割"><a href="#千分位分割" class="headerlink" title="千分位分割"></a>千分位分割</h5><p>方法一：Number.prototype.toLocaleString()<br>返回这个数字在特定语言环境下的表示字符串。<br>该方法的详细介绍请看mdn developer.mozilla.org / zh - CN / docs /…</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> <span class="hljs-built_in">num</span> = <span class="hljs-number">123456789</span>;<br><span class="hljs-built_in">num</span>.toLocaleString()// <span class="hljs-string">&quot;123,456,789&quot;</span><br></code></pre></td></tr></table></figure><p>该方法的很方便，但是兼容性不是很好</p><p>方法二: 通过正则匹配</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-string">&#x27;12345678&#x27;</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/(?=\B(\d&#123;3&#125;)+$)/g</span><br><span class="hljs-built_in">console</span>.log(num.replace(reg, <span class="hljs-string">&quot;,&quot;</span>)) <span class="hljs-comment">//12,345,678</span><br></code></pre></td></tr></table></figure><p>方法三: 自定义方法分隔</p><p>实现思路：</p><p>将用户传入的数字转为字符串。<br>使用字符串的split方法将其分隔成数组，然后在使用reverse方法进行反转数组。<br>通过用户传入的分割位数来确定需要将数值分为几组。<br>定义一个新数组用来存放添加分隔符的数组。<br>通过分组数来循环确定分隔符的位置。<br>传入的分割位数刚好将数组分组，可能分割符出现在第一位，这时我们需要删除该分隔符，然后反转该添加完分隔符的数组，最后通过join方法转为字符串。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">num, sep, size</span>) </span>&#123;<br>  num += <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">let</span> numArr = num.split(<span class="hljs-string">&quot;&quot;</span>).reverse();<br>  <span class="hljs-keyword">let</span> group = <span class="hljs-built_in">parseInt</span>(numArr.length / <span class="hljs-built_in">size</span>);<br>  <span class="hljs-keyword">let</span> resArr = []<br>  <span class="hljs-comment">// 设置一个变量来控制数组分割的起始和终止</span><br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (group) &#123;<br>    <span class="hljs-comment">// 确定分隔符的位置</span><br>    resArr = [...resArr, ...numArr.slice(<span class="hljs-built_in">size</span> * i, <span class="hljs-built_in">size</span> * (i + <span class="hljs-number">1</span>)), sep]<br>    group--;<br>    i++;<br>  &#125;<br>  <span class="hljs-comment">// 表示参与分割的数组元素个数</span><br>  <span class="hljs-keyword">const</span> restIndex = resArr.length - <span class="hljs-built_in">parseInt</span>(numArr.length / <span class="hljs-built_in">size</span>);<br><br>  <span class="hljs-comment">// 将没参与分组的元素添加到已经添加分隔符的数组中</span><br>  resArr = [...resArr, ...numArr.slice(restIndex)]<br>  <span class="hljs-comment">// 将分隔好的数组反转，并转为字符串。</span><br>  <span class="hljs-keyword">let</span> strNum = resArr.reverse().join(<span class="hljs-string">&#x27;&#x27;</span>)<br>  <span class="hljs-keyword">if</span> (strNum[<span class="hljs-number">0</span>] === sep) &#123;<br>    strNum = strNum.slice(<span class="hljs-number">1</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> strNum;<br>&#125;<br><span class="hljs-built_in">console</span>.log(fn(<span class="hljs-number">12345678</span>, <span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">//12,345,678</span><br></code></pre></td></tr></table></figure><h5 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!-- 防抖 --&gt;<br><span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">debounce</span> (<span class="hljs-params">fn,delay</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span>  timer  = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timer)<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      fn.apply(<span class="hljs-built_in">this</span>)<br>    &#125;,delay)<br>  &#125;<br>&#125;<br>&lt;!-- 节流 --&gt;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn,delay</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span>  flag= <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(flag) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>         fn.call(<span class="hljs-built_in">this</span>)<br>         flag= <span class="hljs-literal">true</span>;<br>      &#125;,delay);<br>    &#125;<br>    flag= <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://pengzhenglong.github.io/2021/05/16/JS&%E9%98%B2%E6%8A%96&%E8%8A%82%E6%B5%81/">博客：防抖节流</a><br><a href="https://juejin.cn/post/7042192025868828702#heading-2">防抖</a></p><h4 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h4><blockquote><p>不要停留在使用层，多看看源码，要理解，http,tcp知识不熟练，沟通能力，表达</p></blockquote><h3 id="金桔科技（2022-3-8-53min-业务场景题偏多）"><a href="#金桔科技（2022-3-8-53min-业务场景题偏多）" class="headerlink" title="金桔科技（2022.3.8 53min  业务场景题偏多）"></a>金桔科技（2022.3.8 53min  业务场景题偏多）</h3><h5 id="登录权限怎么处理-（动态路由）"><a href="#登录权限怎么处理-（动态路由）" class="headerlink" title="登录权限怎么处理 （动态路由）"></a>登录权限怎么处理 （动态路由）</h5><h5 id="说一下前端登录的流程"><a href="#说一下前端登录的流程" class="headerlink" title="说一下前端登录的流程?"></a>说一下前端登录的流程?</h5><h6 id="什么是-Token（令牌）-1"><a href="#什么是-Token（令牌）-1" class="headerlink" title="什么是 Token（令牌）"></a>什么是 Token（令牌）</h6><h5 id="说一下前端权限管理怎么实现-1"><a href="#说一下前端权限管理怎么实现-1" class="headerlink" title="说一下前端权限管理怎么实现"></a>说一下前端权限管理怎么实现</h5><p><a href="https://blog.csdn.net/weixin_40599109/article/details/113728974">参考文章</a></p><p>全局引入，按需引入组件<br>1.项目中引入了第三方组件，该组件要升级了怎么处理，升级了要怎么检查（有什么好的替代方案)</p><h3 id="杭州后起智能科技（2022-3-8-20min）"><a href="#杭州后起智能科技（2022-3-8-20min）" class="headerlink" title="杭州后起智能科技（2022.3.8 20min）"></a>杭州后起智能科技（2022.3.8 20min）</h3><ol><li>有100个请求，一次发10个，允许最大容错3个超过3个就抛出异常   怎么处理</li></ol><h5 id="2-keep-alive-原理"><a href="#2-keep-alive-原理" class="headerlink" title="2. keep-alive  原理"></a>2. keep-alive  原理</h5><h3 id="优倍快一面深圳（5-8k）"><a href="#优倍快一面深圳（5-8k）" class="headerlink" title="优倍快一面深圳（5-8k）"></a>优倍快一面深圳（5-8k）</h3><p>（听不清，有点像一直念题目）<br>项目上的难点，（说一下）（图片上传那+大文件怎么上传+js怎么压缩一张图片）（图片为什么转换为base64+图片怎么转化为base64的过程+裁剪这一块怎么弄的，FileReader+怎么裁剪的+怎么压缩一张图片）</p><p>canvas了解吗  (drawImg  api 绘画图片)<br>js大文件上传（切片上传 - 并发控制-断点续传）<br><a href="https://pengzhenglong.github.io/2022/03/08/%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%B9%B6%E5%8F%91/">博客</a><br>Ts访问修饰符<br>class<br>interface  和type<br>promise  /generotor /await  (await后面接受的是什么 )<br>第一行是await   第二行是promise.then,执行顺序是</p><blockquote><p>正常情况下，async中的await命令是一个Promise对象，返回该对象的结果。<br>但如果不是Promise对象的话，就会直接返回对应的值，相当于Promise.resolve()<br>如果在async函数中抛出了错误，则终止错误结果，不会继续向下执行。</p></blockquote><p>then方法为什么可以链式调用</p><blockquote><p>Promise可以链式调用，不过promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用, 它并不像一般我们任务的链式调用一样return this。<br>父子组件的生命周期<br>data为什么是函数而不是对象<br>v-if  v-show  都会触发重绘回流<br>keep-alive  原理</p></blockquote><p>vue数据双向绑定（对数组也是这样的吗）怎么重写数组的方法</p><h6 id="实现一个轮播组件（使用display-none-这样能加动画吗）"><a href="#实现一个轮播组件（使用display-none-这样能加动画吗）" class="headerlink" title="实现一个轮播组件（使用display:none 这样能加动画吗）"></a>实现一个轮播组件（使用display:none 这样能加动画吗）</h6><p>方法一：<br>利用绝对定位absolute偏移量的改变来实现<br>具有往左往右滑动的效果演示代码：</p><p>方法二：<br>利用 display/opacity/visibility状态切换来实现<br>没有往左往右滑动的效果演示代码：</p><p>方法三<br>旋转木马轮播图<br>存储每个图片的位置信息（absolute位置信息+z-index属性+opacity透明度 等等）到一个数组。对数组进行pop push shift unshift等操作再引用到DOM元素上，产生轮播效果。<br><a href="https://juejin.cn/post/6850418121606594568">掘金</a></p><p>使用es5实现一个继承<br>原型链是什么<br>懒加载和预加载（怎么判断一张图片是否加载成功）（load  complete）</p><p>实现一个div元素的拖拽   (（addEventListen/removeEventListen)mousedown，mousemove，mouseup)<br><a href="https://pengzhenglong.github.io/2022/02/26/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAdiv%E5%85%83%E7%B4%A0%E7%9A%84%E6%8B%96%E6%8B%BD-%EF%BC%88addEventListen-removeEventListen">博客</a><br>防抖节流（没怎么讲清楚）</p><p>实现一个三角形  (采用相邻边框连接处均分的原理)</p><p>怎么求多个数组之间的交集  （暴力解法/set）</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">如何求出两个数组的交集和差集？<br>let intersection = <span class="hljs-keyword">a</span>.<span class="hljs-built_in">filter</span>(v =&gt; b.includes(v))<br>let <span class="hljs-built_in">difference</span> = <span class="hljs-keyword">a</span>.concat(b).<span class="hljs-built_in">filter</span>(v =&gt; !<span class="hljs-keyword">a</span>.includes(v) || !b.includes(v))<br></code></pre></td></tr></table></figure><p>set有什么特性</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">Set</span>类似于数组，但是它里面每一项的值是唯一的，没有重复的值，<span class="hljs-keyword">Set</span>是一个构造函数，用来生成<span class="hljs-keyword">set</span>的数据结构<br><span class="hljs-keyword">Set</span>中两个对象永远是不相等的，即使键和值都是一样的<br></code></pre></td></tr></table></figure><blockquote><p>总结：讲的磕磕盼盼的，不清楚（表达能力不行）</p></blockquote><h3 id="优倍快二面"><a href="#优倍快二面" class="headerlink" title="优倍快二面"></a>优倍快二面</h3><p>W3C标准及规范(简历上写了）<br><a href="https://blog.csdn.net/weixin_39407291/article/details/90172851">参考</a><br>为什么要遵循规范</p><blockquote><p>答案这一个就够了：利人利己，便于维护！如果你写的代码不符合“规范”，查找代码的错误时或者后期的维护会让你痛恨自己当初怎么会写出那么乱的代码。<br>react  和vue的区别<br>什么是好的网页(往用户体验来说)<br>mysql了解吗<br>(迅速结束了，两面反问都没有,体验很差)</p></blockquote><h3 id="沃太能源-苏州-（一面3-16-20：00-–25分钟）"><a href="#沃太能源-苏州-（一面3-16-20：00-–25分钟）" class="headerlink" title="沃太能源(苏州)（一面3.16   20：00  –25分钟）"></a>沃太能源(苏州)（一面3.16   20：00  –25分钟）</h3><h4 id="面试问你用组件库有什么体会，面试官主要想听到的是啥-用组件库有遇到什么问题难点-好几次面试-1"><a href="#面试问你用组件库有什么体会，面试官主要想听到的是啥-用组件库有遇到什么问题难点-好几次面试-1" class="headerlink" title="面试问你用组件库有什么体会，面试官主要想听到的是啥(用组件库有遇到什么问题难点 -好几次面试)"></a>面试问你用组件库有什么体会，面试官主要想听到的是啥(用组件库有遇到什么问题难点 -好几次面试)</h4><blockquote></blockquote><p>401（没有权限访问） 403 状态码（服务端拒绝访问）   同步请求，异步请求</p><h3 id="浙江木链（3-16-一面电话）女面试官—40分钟）已凉"><a href="#浙江木链（3-16-一面电话）女面试官—40分钟）已凉" class="headerlink" title="浙江木链（3.16 一面电话）女面试官—40分钟）已凉"></a>浙江木链（3.16 一面电话）女面试官—40分钟）已凉</h3><ol><li>两栏布局<br>（1. flex  2.左边浮动 width :200px，右边margin-left :200px  width:auto   ）</li><li>BFC解决什么问题</li><li>margin塌陷   ()</li><li>C3动画  transition  animation</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">区别：<br>（<span class="hljs-number">1</span>）<span class="hljs-attribute">transform</span>仅描述元素的静态样式，常常配合<span class="hljs-attribute">transition</span>和<span class="hljs-attribute">animation</span>使用<br>（<span class="hljs-number">2</span>）<span class="hljs-attribute">transition</span>通常和hover等事件配合使用，<span class="hljs-attribute">animation</span>是自发的，立即播放<br>（<span class="hljs-number">3</span>）<span class="hljs-attribute">animation</span>可设置循环次数<br>（<span class="hljs-number">4</span>）<span class="hljs-attribute">animation</span>可设置每一帧的样式和时间，<span class="hljs-attribute">transition</span>只能设置头尾<br>（<span class="hljs-number">5</span>）<span class="hljs-attribute">transition</span>可与js配合使用，js设定要变化的样式，<span class="hljs-attribute">transition</span>负责动画效果<br></code></pre></td></tr></table></figure><ol start="5"><li>使用过css预处理嘛</li><li>判断js数据类型<br>toString判断的原理</li><li>讲一下原型链</li><li>数组常用的方法  find  filter(返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组。)  every  some</li><li>判断一个数组中有符合我需求的元素用哪个比较合适<br>indexof    find(返回数组中满足条件的第一个元素的值，如果没有，返回undefined)</li></ol><blockquote><p>返回一个布尔值   includes  some every<br><a href="https://pengzhenglong.github.io/2022/02/28/Js%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/#JS%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%80%BC">博客</a></p></blockquote><ol start="10"><li>遍历一个对象<br>for  of   Object.key  Object.value  Object.entries</li><li>工作中遍历对象都用for  in 嘛，遍历用的比较多的方法是</li><li>promise  promise.all</li><li>async  await</li><li>js事件循环 evenLoop</li><li>$nextTick是宏任务还是微任务</li><li>生命周期  还有父子组件的生命周期  执行</li><li>vue3   ref  refs  reactive  toref()  简单讲讲</li></ol><h5 id="既用到扩展运算符取到数据有让他是响应式的-toRefs"><a href="#既用到扩展运算符取到数据有让他是响应式的-toRefs" class="headerlink" title="既用到扩展运算符取到数据有让他是响应式的  (toRefs)"></a>既用到扩展运算符取到数据有让他是响应式的  (toRefs)</h5><h6 id="注意reactive封装的响应式对象，不要通过解构的方式return，这是不具有响应式的。可以通过-toRefs-处理，然后再解构返回，这样才具有响应式"><a href="#注意reactive封装的响应式对象，不要通过解构的方式return，这是不具有响应式的。可以通过-toRefs-处理，然后再解构返回，这样才具有响应式" class="headerlink" title="注意reactive封装的响应式对象，不要通过解构的方式return，这是不具有响应式的。可以通过 toRefs 处理，然后再解构返回，这样才具有响应式"></a>注意reactive封装的响应式对象，不要通过解构的方式return，这是不具有响应式的。可以通过 toRefs 处理，然后再解构返回，这样才具有响应式</h6><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> <span class="hljs-keyword">state</span> = reactive(&#123;...&#125;);<br>return &#123;...<span class="hljs-keyword">state</span>&#125;; // 这种方式将丢失响应式，是一种错误的方式<br>return <span class="hljs-keyword">to</span>Refs(<span class="hljs-keyword">state</span>); // works<br></code></pre></td></tr></table></figure><ol><li>vue2 组件传值<br>那组件调用特别深，用什么传值方式<br>Provide  inject  $listeners $attars</li><li>vuex  mutation为什么不可以包含异步回调，action 为什么可以<br><a href="https://pengzhenglong.github.io/2022/01/10/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#vuex-mutation%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%EF%BC%8Caction-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5">博客</a></li><li>简历中项目经历（拿错简历了哈哈哈）<br>有封装过功能模块吗</li><li>有什么遇到项目中遇到的棘手的问题</li><li>开发中项目有什么优化的点（项目中引用轻量级的库）</li><li>反问</li></ol><h3 id="北京梧桐花开一面（2022-3-20-20min"><a href="#北京梧桐花开一面（2022-3-20-20min" class="headerlink" title="北京梧桐花开一面（2022.3.20 20min)"></a>北京梧桐花开一面（2022.3.20 20min)</h3><ol><li>定制插件项目（简历上的讲一下）</li><li>双向数据绑定</li><li>生命周期（父子组件生命周期）</li><li>做过手机端的vue吗（如何适配手机端– 媒体查询-rem）</li></ol><h4 id="5-了解Ts，Ts的好处是？"><a href="#5-了解Ts，Ts的好处是？" class="headerlink" title="5. 了解Ts，Ts的好处是？"></a>5. 了解Ts，Ts的好处是？</h4><h4 id="6-使用mongodb的优势"><a href="#6-使用mongodb的优势" class="headerlink" title="6. 使用mongodb的优势"></a>6. 使用mongodb的优势</h4><h4 id="使用组件库遇到的问题（难点）"><a href="#使用组件库遇到的问题（难点）" class="headerlink" title="使用组件库遇到的问题（难点）"></a>使用组件库遇到的问题（难点）</h4><h3 id="3-26日后面试问题"><a href="#3-26日后面试问题" class="headerlink" title="3.26日后面试问题"></a>3.26日后面试问题</h3><h4 id="行内元素-块级元素"><a href="#行内元素-块级元素" class="headerlink" title="行内元素 块级元素"></a>行内元素 块级元素</h4><p>块级元素：div、p、ol、ul、dl、li、table、td、th、tr、dd、dt、caption、h、<br>行内元素：i、img、input、select、label、textarea、button、b、span、a、u、em、</p><p>块级元素的特点<br><strong>1、高度，行高以及外边距和内边距都可控制。</strong><br>2、总是在新行上开始，占据一整行。<br>3、它可以容纳内联元素和其他块元素。<br>4、宽度始终是与浏览器宽度一样，与内容无关。</p><p>行内元素的特点<br>1、行内元素只能容纳文本或者其他行内元素。<br><strong>2、宽度只与内容有关。</strong><br>3、和其他元素都在一行上。<br>4、高，行高及外边距和内边距部分可改变。</p><p>区别<br>1、行内元素会在一条直线上分列，都是统一行的，程度偏向分列。<br>块级元素各盘踞一行，垂直偏向分列；块级元素重新行开端停止接着一个断行。<br>2、行内元素不可以包括块级元素，只能包容文本或许其余行内元素。<br>块级元素能够包括行内元素和块级元素，还能够包容内联元素和其余元素；。</p><blockquote><p>3、行内元素与块级元素属性的分歧，主要在盒模子属性上。<br>行内元素设置width无效，height无效（能够设置line-height），margin、padding设置上下有效。</p></blockquote><h5 id="切换-display-inline-block、inline和block"><a href="#切换-display-inline-block、inline和block" class="headerlink" title="切换  display:inline-block、inline和block"></a>切换  display:inline-block、inline和block</h5><h5 id="link标签和import标签的区别"><a href="#link标签和import标签的区别" class="headerlink" title="link标签和import标签的区别"></a>link标签和import标签的区别</h5><h4 id="实现一个下拉刷新的组件"><a href="#实现一个下拉刷新的组件" class="headerlink" title="实现一个下拉刷新的组件"></a>实现一个下拉刷新的组件</h4><p>其实技术点也没什么难的，主要使用H5的touch事件：</p><p>touchstart: 手指触屏触发的事件，主要工作是在触发时获取鼠标点击的Y坐标，event.touches[0].pageY。<br>touchmove: 手指滑动触发的事件, 主要工作是在触发时获取移动的Y坐标减去开始时的Y坐标，得出移动的距离，然后利用transform改变容器的位置。<br>touchend: 手指松开触发的事件，主要工作是释放鼠标让div恢复原来位置。</p><p><a href="https://juejin.cn/post/6883373475843538951#comment">手把手教学：Vue下拉刷新、上拉加载组件插件（超详细）</a></p><h4 id="深浅拷贝（如何实现）"><a href="#深浅拷贝（如何实现）" class="headerlink" title="深浅拷贝（如何实现）"></a>深浅拷贝（如何实现）</h4><p><a href="https://pengzhenglong.github.io/2022/01/05/JS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D">博客</a></p><h5 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h5><ol><li>Object.assign()</li><li>Array.prototype.concat()</li><li>Array.prototype.slice()</li><li>展开运算符…</li><li>函数库lodash的_.clone方法</li></ol><h5 id="深拷贝的实现方式"><a href="#深拷贝的实现方式" class="headerlink" title="深拷贝的实现方式"></a>深拷贝的实现方式</h5><ol><li>JSON.parse()</li><li>JSON.stringify()</li><li>函数库lodash的_.cloneDeep方法</li><li>jQuery.extend()方法</li><li>手写递归方法<br>参考<br><a href="https://juejin.cn/post/6844904197595332622#heading-3">掘金</a></li></ol><h4 id="路由页面跳转后状态保存-1"><a href="#路由页面跳转后状态保存-1" class="headerlink" title="路由页面跳转后状态保存"></a>路由页面跳转后状态保存</h4><p>需求场景<br>首页搜索内容，点击跳转至详情页，页面后退返回主页，保留搜索结果。</p><h5 id="这里介绍两种比较容易实现的解决方案"><a href="#这里介绍两种比较容易实现的解决方案" class="headerlink" title="这里介绍两种比较容易实现的解决方案"></a>这里介绍两种比较容易实现的解决方案</h5><h6 id="方案一：将搜索参数存储在路由参数（route-query）中，加载页面时根据参数搜索-1"><a href="#方案一：将搜索参数存储在路由参数（route-query）中，加载页面时根据参数搜索-1" class="headerlink" title="方案一：将搜索参数存储在路由参数（route.query）中，加载页面时根据参数搜索"></a>方案一：将搜索参数存储在路由参数（route.query）中，加载页面时根据参数搜索</h6><p>优点：刷新不影响；实现简单<br>缺点：参数只能是基础类型、长度受限；路径看起来比较难看；只对浏览器返回有效，手动跳转回首页不行</p><h6 id="方案二：使用路由守卫钩子，在离开页面前本地存储页面参数（vuex、Local-Storage-等等）-1"><a href="#方案二：使用路由守卫钩子，在离开页面前本地存储页面参数（vuex、Local-Storage-等等）-1" class="headerlink" title="方案二：使用路由守卫钩子，在离开页面前本地存储页面参数（vuex、Local Storage 等等）"></a>方案二：使用路由守卫钩子，在离开页面前本地存储页面参数（vuex、Local Storage 等等）</h6><p>优点：参数类型长度都比较自由；路径看起来清爽美观；对任意方式返回主页都有效<br>缺点：需要额外进行数据存储操作，如果使用store模式或vuex则刷新页面失效<br>参考<br><a href="https://juejin.cn/post/6987953448419328036#heading-2">前端 Vue路由返回恢复页面状态的实现方案</a></p><h4 id="按需引入组件库"><a href="#按需引入组件库" class="headerlink" title="按需引入组件库"></a>按需引入组件库</h4><h4 id="浏览器兼容性问题-1"><a href="#浏览器兼容性问题-1" class="headerlink" title="浏览器兼容性问题"></a>浏览器兼容性问题</h4><h4 id="垃圾回收机制-1"><a href="#垃圾回收机制-1" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h4><p><a href="https://pengzhenglong.github.io/2022/03/26/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%90%97/">博客</a></p><h4 id="前端性能优化建议-1"><a href="#前端性能优化建议-1" class="headerlink" title="前端性能优化建议"></a>前端性能优化建议</h4><p><a href="https://pengzhenglong.github.io/2022/03/28/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">前端性能优化建议:博客</a></p><h3 id="深圳小雨伞-（2022-4-8）-1h"><a href="#深圳小雨伞-（2022-4-8）-1h" class="headerlink" title="深圳小雨伞  （2022.4.8） 1h"></a>深圳小雨伞  （2022.4.8） 1h</h3><p>一面<br>没有让自我介绍<br>1.聊毕设 （node  express做的后台 为什么用express）为什么不用koa  洋葱模型是什么<br>2.async  await (原理)<br>3. promise  （做了个题目）<br>4. JS执行机制  Event Loop   UI渲染（训练如何回答 ）<br>5. Set Map 数据结构  WeakMap  (何时用这个)<br>6. 垃圾回收机制 V8 （）变量怎么标记的，所有变量都这样标记的？<br>7.Tcp三次握手  （第三次不发Ack包会发生什么）<br>8.HTTP队头阻塞<br>9.HTTP2.0/1.0   优点（队头怎么压缩的 ，多路复用（限制6Tcp连接个，其他的是什么状态））<br>10.HTTPS加密过程 （越详细越好）<br>10.网路协议分层 （每一层都有什么）（HTTPS在哪一层加密）<br>11. 居中实现（越多越好，说了5种左右，还问有没有，问我了解table布局嘛）<br>（整个过程，会听你讲然后从你说的（说我打断一下），反问）</p><h5 id="反问：技术栈，有什么建议-：问的偏基础，刚毕业，基础打扎实点，讲的过于表面（手写promise一遍）（框架都是基于底层的，vue-react问都没问，侧重基础就好了）"><a href="#反问：技术栈，有什么建议-：问的偏基础，刚毕业，基础打扎实点，讲的过于表面（手写promise一遍）（框架都是基于底层的，vue-react问都没问，侧重基础就好了）" class="headerlink" title="反问：技术栈，有什么建议 ：问的偏基础，刚毕业，基础打扎实点，讲的过于表面（手写promise一遍）（框架都是基于底层的，vue /react问都没问，侧重基础就好了）"></a>反问：技术栈，有什么建议 ：问的偏基础，刚毕业，基础打扎实点，讲的过于表面（手写promise一遍）（框架都是基于底层的，vue /react问都没问，侧重基础就好了）</h5>]]></content>
    
    
    <categories>
      
      <category>项目优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue diff算法</title>
    <link href="/2022/02/20/Vue--diff%E7%AE%97%E6%B3%95/"/>
    <url>/2022/02/20/Vue--diff%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="1-当数据发生变化时，vue是怎么更新节点的？"><a href="#1-当数据发生变化时，vue是怎么更新节点的？" class="headerlink" title="1. 当数据发生变化时，vue是怎么更新节点的？"></a>1. 当数据发生变化时，vue是怎么更新节点的？</h3><p>要知道渲染真实DOM的开销是很大的，比如有时候我们修改了某个数据，如果直接渲染到真实dom上会引起整个dom树的重绘和重排，有没有可能我们只更新我们修改的那一小块dom而不要更新整个dom呢？diff算法能够帮助我们。</p><p>我们先根据真实DOM生成一颗<strong>virtual DOM</strong>，当virtual DOM某个节点的数据改变后会生成一个新的<strong>Vnode</strong>，然后<strong>Vnode和oldVnode</strong>作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使oldVnode的值为Vnode。</p><p>diff的过程就是调用名为<strong>patch的函数</strong>，比较新旧节点，一边比较一边给真实的DOM打补丁。</p><h3 id="2-virtual-DOM和真实DOM的区别？"><a href="#2-virtual-DOM和真实DOM的区别？" class="headerlink" title="2. virtual DOM和真实DOM的区别？"></a>2. virtual DOM和真实DOM的区别？</h3><p>virtual DOM是将真实的DOM的数据抽取出来，以对象的形式模拟树形结构。比如dom是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对应的virtual DOM（伪代码）：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">var</span> Vnode = &#123;<br>    <span class="hljs-built_in">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>    children: <span class="hljs-meta">[</span><br>        &#123; <span class="hljs-built_in">tag</span>: <span class="hljs-string">&#x27;p&#x27;</span>, text: <span class="hljs-string">&#x27;123&#x27;</span> &#125;<br>    <span class="hljs-meta">]</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>（温馨提示：<strong>VNode和oldVNode都是对象</strong>，一定要记住）</p><h3 id="3-diff的比较方式？"><a href="#3-diff的比较方式？" class="headerlink" title="3. diff的比较方式？"></a>3. diff的比较方式？</h3><p>在采取diff算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>456<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面的代码会分别比较同一层的两个div以及第二层的p和span，但是不会拿div和span作比较。在别处看到的一张很形象的图：<br><img src="/imageO/Dom.jpg" alt="如图"></p><h3 id="diff流程图"><a href="#diff流程图" class="headerlink" title="diff流程图"></a>diff流程图</h3><p>当数据发生改变时，set方法会让调用 <strong> Dep.notify  </strong>通知所有订阅者Watcher，订阅者就会调用<strong>patch</strong>给真实的DOM打补丁，更新相应的视图。</p><p><img src="/imageO/Patch.jpg" alt="Patch"></p><h3 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h3><h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><p>来看看patch是怎么打补丁的（代码只保留核心部分）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> patch (oldVnode, vnode) &#123;<br>    <span class="hljs-comment">// some code</span><br>    <span class="hljs-keyword">if</span> (same<span class="hljs-constructor">Vnode(<span class="hljs-params">oldVnode</span>, <span class="hljs-params">vnode</span>)</span>) &#123;<br>     patch<span class="hljs-constructor">Vnode(<span class="hljs-params">oldVnode</span>, <span class="hljs-params">vnode</span>)</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>     const oEl = oldVnode.el <span class="hljs-comment">// 当前oldVnode对应的真实元素节点</span><br>     <span class="hljs-keyword">let</span> parentEle = api.parent<span class="hljs-constructor">Node(<span class="hljs-params">oEl</span>)</span>  <span class="hljs-comment">// 父元素</span><br>     create<span class="hljs-constructor">Ele(<span class="hljs-params">vnode</span>)</span>  <span class="hljs-comment">// 根据Vnode生成新元素</span><br>     <span class="hljs-keyword">if</span> (parentEle !== null) &#123;<br>            api.insert<span class="hljs-constructor">Before(<span class="hljs-params">parentEle</span>, <span class="hljs-params">vnode</span>.<span class="hljs-params">el</span>, <span class="hljs-params">api</span>.<span class="hljs-params">nextSibling</span>(<span class="hljs-params">oEl</span>)</span>) <span class="hljs-comment">// 将新元素添加进父元素</span><br>            api.remove<span class="hljs-constructor">Child(<span class="hljs-params">parentEle</span>, <span class="hljs-params">oldVnode</span>.<span class="hljs-params">el</span>)</span>  <span class="hljs-comment">// 移除以前的旧元素节点</span><br>            oldVnode = null<br>     &#125;<br>    &#125;<br>    <span class="hljs-comment">// some code </span><br>    return vnode<br>&#125;<br></code></pre></td></tr></table></figure><p>patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点</p><h5 id="判断两节点是否值得比较，值得比较则执行patchVnode"><a href="#判断两节点是否值得比较，值得比较则执行patchVnode" class="headerlink" title="判断两节点是否值得比较，值得比较则执行patchVnode"></a>判断两节点是否值得比较，值得比较则执行patchVnode</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> sameVnode (a, b) &#123;<br>  return (<br>    a.key<span class="hljs-operator"> === </span>b.key<span class="hljs-operator"> &amp;&amp;  </span><span class="hljs-comment">// key值</span><br>    a.tag<span class="hljs-operator"> === </span>b.tag<span class="hljs-operator"> &amp;&amp;  </span><span class="hljs-comment">// 标签名</span><br>    a.isComment<span class="hljs-operator"> === </span>b.isComment<span class="hljs-operator"> &amp;&amp;  </span><span class="hljs-comment">// 是否为注释节点</span><br>    <span class="hljs-comment">// 是否都定义了data，data包含一些具体信息，例如onclick , style</span><br>    is<span class="hljs-constructor">Def(<span class="hljs-params">a</span>.<span class="hljs-params">data</span>)</span><span class="hljs-operator"> === </span>is<span class="hljs-constructor">Def(<span class="hljs-params">b</span>.<span class="hljs-params">data</span>)</span><span class="hljs-operator"> &amp;&amp;  </span><br>    same<span class="hljs-constructor">InputType(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span> <span class="hljs-comment">// 当标签是&lt;input&gt;的时候，type必须相同</span><br>  )<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="不值得比较则用Vnode替换oldVnode"><a href="#不值得比较则用Vnode替换oldVnode" class="headerlink" title="不值得比较则用Vnode替换oldVnode"></a>不值得比较则用Vnode替换oldVnode</h5><p>如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。<br>虽然这两个节点不一样但是他们的子节点一样怎么办？别忘了，diff可是逐层比较的，如果第一层不一样那么就不会继续深入比较第二层了。（我在想这算是一个缺点吗？相同子节点不能重复利用了…）</p><h4 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h4><p>当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法。那么这个方法做了什么呢？</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">patchVnode (oldVnode, vnode) &#123;<br>    const el = vnode.el = oldVnode.el<br>    <span class="hljs-keyword">let</span> i, oldCh = oldVnode.children, ch = vnode.children<br>    <span class="hljs-keyword">if</span> (oldVnode<span class="hljs-operator"> === </span>vnode) return<br>    <span class="hljs-keyword">if</span> (oldVnode.text !== null<span class="hljs-operator"> &amp;&amp; </span>vnode.text !== null<span class="hljs-operator"> &amp;&amp; </span>oldVnode.text !== vnode.text) &#123;<br>        api.set<span class="hljs-constructor">TextContent(<span class="hljs-params">el</span>, <span class="hljs-params">vnode</span>.<span class="hljs-params">text</span>)</span><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        update<span class="hljs-constructor">Ele(<span class="hljs-params">el</span>, <span class="hljs-params">vnode</span>, <span class="hljs-params">oldVnode</span>)</span><br>     <span class="hljs-keyword">if</span> (oldCh<span class="hljs-operator"> &amp;&amp; </span>ch<span class="hljs-operator"> &amp;&amp; </span>oldCh !== ch) &#123;<br>            update<span class="hljs-constructor">Children(<span class="hljs-params">el</span>, <span class="hljs-params">oldCh</span>, <span class="hljs-params">ch</span>)</span><br>     &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch)&#123;<br>            create<span class="hljs-constructor">Ele(<span class="hljs-params">vnode</span>)</span> <span class="hljs-comment">//create el&#x27;s children dom</span><br>     &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldCh)&#123;<br>            api.remove<span class="hljs-constructor">Children(<span class="hljs-params">el</span>)</span><br>     &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="这个函数做了以下事情"><a href="#这个函数做了以下事情" class="headerlink" title="这个函数做了以下事情"></a>这个函数做了以下事情</h5><ol><li>找到对应的真实dom，称为el</li><li>判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return</li><li>如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。</li><li>如果oldVnode有子节点而Vnode没有，则删除el的子节点</li><li>如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el</li><li>如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要</li></ol><p>其他几个点都很好理解，我们详细来讲一下updateChildren</p><h4 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h4><p>代码量很大，不方便一行一行的讲解，所以下面结合一些示例图来描述一下。<br>先说一下这个函数做了什么</p><ol><li>将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来</li><li>oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。</li></ol><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844903607913938951#heading-2">详解vue的diff算法</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue Vue2与Vue3的v-model</title>
    <link href="/2022/02/18/Vue--v-model/"/>
    <url>/2022/02/18/Vue--v-model/</url>
    
    <content type="html"><![CDATA[<p>v-model 是 Vue 中使用频率特别高的一个指令，而 Vue3 中的 v-model 有了很大的变化，本文将详细讲述一下 Vue2 和 Vue3 中的 v-model 的区别。</p><hr><h3 id="Vue2-中的-v-model"><a href="#Vue2-中的-v-model" class="headerlink" title="Vue2 中的 v-model"></a>Vue2 中的 v-model</h3><p>如果对 Vue2 中的语法很熟悉，这部分可以不看。<br>首先来回顾一下 Vue2 中的 v-model，它主要用于表单元素和自定义组件上。v-model本质上是一个语法糖，会对用户的输入做一些特殊处理以达到更新数据，而所谓的处理其实就是给使用的元素默认绑定属性和事件。</p><p>当 v-model 使用在表单元素上时，会根据元素的不同而采用不同的处理：</p><ol><li>当<code>&lt;input type=&quot;text&quot;&gt;</code>文本 和 <code>&lt;textarea&gt;</code>上使用时，会默认给元素绑定名为 value 的<strong> prop </strong> 和名为 <strong> input </strong>的事件；</li><li>当<code>&lt;input type=&quot;checkbox&quot;&gt;</code>复选框 和 <code>&lt;input type=&quot;radio&quot;&gt;</code>单选框 上使用时，会默认绑定名为<strong> checked 的 prop 和名为 change  </strong> 的事件；</li><li>当 <code>&lt;select&gt;</code>选择框 上使用时，则绑定名为 value 的 prop 和名为   <strong> change</strong> 的事件。</li></ol><p>这些是 Vue 默认帮我们处理的，可以直接使用。但是你也会发现一些第三方组件也可以使用 v-model ，比如 Element 中的 Input 组件。这是因为这些组件自己实现了 v-model，原理其实就是上面说到的绑定属性和事件。<br>我们可以尝试实现一下 v-model，来开发一个简单的输入组件，就叫 MyInput 吧：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- MyInput 组件代码 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;value&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;input&#x27;,$event.target.value)&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>  props: &#123;<br><span class="javascript">    value: <span class="hljs-built_in">String</span>,  <span class="hljs-comment">// 默认接收一个名为 value 的 prop</span></span><br>  &#125;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>上面代码就实现了组件的 v-model 功能，当在这个组件上使用 v-model 时：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">my</span>-input v-model=<span class="hljs-string">&quot;msg&quot;</span>&gt;&lt;/<span class="hljs-keyword">my</span>-input&gt;<br></code></pre></td></tr></table></figure><p>其实就等同于：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;my-input :<span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;msg&quot;</span> @<span class="hljs-attribute">input</span>=<span class="hljs-string">&quot;msg = <span class="hljs-variable">$event</span>&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>Vue 还提供了 model 选项，用于将属性或事件名称改为其他名称，比如上面的 MyInput 组件，我们改一下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    &lt;input<br>      type=&quot;text&quot;<br>      :value=&quot;title&quot;<br>      @input=&quot;$emit(&#x27;change&#x27;, $event.target.value)&quot;<br>    /&gt;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>  model: &#123;<br><span class="javascript">    prop: <span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-comment">// 将默认的 prop 名 value 改为 title</span></span><br><span class="javascript">    event: <span class="hljs-string">&quot;change&quot;</span>, <span class="hljs-comment">// 将默认的事件名 input 改为 change</span></span><br>  &#125;,<br>  props: &#123;<br><span class="javascript">    title: <span class="hljs-built_in">String</span>, <span class="hljs-comment">// 注意 template 代码中也要修改为 title</span></span><br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此时使用组件：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;my-<span class="hljs-keyword">input</span> v-model=<span class="hljs-string">&quot;msg&quot;</span>&gt;&lt;/my-<span class="hljs-keyword">input</span>&gt;<br><br><span class="hljs-comment">// 等同于</span><br>&lt;my-<span class="hljs-keyword">input</span> :<span class="hljs-keyword">title</span>=<span class="hljs-string">&quot;msg&quot;</span> @change=<span class="hljs-string">&quot;msg = $event&quot;</span>&gt;&lt;/my-<span class="hljs-keyword">input</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="使用-sync-修饰符"><a href="#使用-sync-修饰符" class="headerlink" title="使用 .sync 修饰符"></a>使用 .sync 修饰符</h3><p>Vue 提供一个 .sync 的修饰符，效果跟 v-model 一样，也是便于子组件数据更改后自动更新父组件相关数据。实现 .sync 的方式与实现 v-model 异曲同工，区别就是抛出的事件名需要是 update:myPropName 的结构。<br>还是拿上面的 MyInput 说明，我们还是传入一个 title 的 prop，同时组件内部抛出 update:title 事件，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// MyInput 组件中，修改抛出的事件名为 update:title</span><br> &lt;input type=<span class="hljs-string">&quot;text&quot;</span> :value=<span class="hljs-string">&quot;title&quot;</span> <span class="hljs-meta">@input</span>=<span class="hljs-string">&quot;<span class="hljs-subst">$emit</span>(&#x27;update:title&#x27;, <span class="hljs-subst">$event</span>.target.value)&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>此时如果使用这个组件，正常应该是这样：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">&lt;my-input <span class="hljs-symbol">:title=<span class="hljs-string">&quot;msg&quot;</span></span> <span class="hljs-variable">@update</span><span class="hljs-symbol">:title=<span class="hljs-string">&quot;msg = $event&quot;</span>&gt;&lt;/my-input&gt;</span><br></code></pre></td></tr></table></figure><p>但此时可以使用 .sync 修饰符来简化：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">&lt;my-<span class="hljs-meta">input</span> :<span class="hljs-meta">title</span>.sync=<span class="hljs-string">&quot;msg&quot;</span>&gt;&lt;/my-<span class="hljs-meta">input</span>&gt;<br></code></pre></td></tr></table></figure><p>可以看到 .sync 和 v-model 所能达到的效果是一样的，用什么就看你什么场景，一般表单组件上都是用 v-model。</p><h3 id="Vue3-中的-v-model"><a href="#Vue3-中的-v-model" class="headerlink" title="Vue3 中的 v-model"></a>Vue3 中的 v-model</h3><p>上面说了那么多，为的就是接下来区别出 Vue3 中 v-model 带来的变化，主要变化有以下几处：</p><h4 id="修改默认-prop-名和事件名"><a href="#修改默认-prop-名和事件名" class="headerlink" title="修改默认 prop 名和事件名"></a>修改默认 prop 名和事件名</h4><p>当用在自定义组件上时，v-model 默认绑定的 prop 名从 value 变为 modelValue，而事件名也从默认的input 改为 update:modelValue 。在 Vue3 中编写上面那个 MyInput 组件时，就需要这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- MyInput 组件代码 Vue3 版 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    &lt;input<br>      type=&quot;text&quot;<br>      :value=&quot;modelValue&quot;<br>      @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;  // 事件名改为 update:modelValue<br>    /&gt;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>  props: &#123;<br><span class="javascript">    modelValue: <span class="hljs-built_in">String</span>, <span class="hljs-comment">// 默认 prop 从 value 改为 modelValue</span></span><br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>使用组件时：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;my-<span class="hljs-keyword">input</span> v-model=<span class="hljs-string">&quot;msg&quot;</span>&gt;&lt;/my-<span class="hljs-keyword">input</span>&gt;<br><br><span class="hljs-comment">// 等同于</span><br>&lt;my-<span class="hljs-keyword">input</span> :modelValue=<span class="hljs-string">&quot;msg&quot;</span> @<span class="hljs-keyword">update</span>:modelValue=<span class="hljs-string">&quot;msg = $event&quot;</span>&gt;&lt;/my-<span class="hljs-keyword">input</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="废除-model-选项和-sync-修饰符"><a href="#废除-model-选项和-sync-修饰符" class="headerlink" title="废除 model 选项和 .sync 修饰符"></a>废除 model 选项和 .sync 修饰符</h4><p>Vue3 中移除了 model 选项，这样就不可以在组件内修改默认 prop 名了。现在有一种更简单的方式，就是直接在 v-model 后面传递要修改的 prop 名：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-comment">// 要修改默认 prop 名，只需在 v-model 后面接上 :propName，例如修改为 title</span><br>&lt;my-<span class="hljs-keyword">input</span> v-model:<span class="hljs-keyword">title</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;&lt;/my-<span class="hljs-keyword">input</span>&gt;<br><br><span class="hljs-comment">// 等同于</span><br>&lt;my-<span class="hljs-keyword">input</span> :<span class="hljs-keyword">title</span>=<span class="hljs-string">&quot;msg&quot;</span> @update:<span class="hljs-keyword">title</span>=<span class="hljs-string">&quot;msg = $event&quot;</span>&gt;&lt;/my-<span class="hljs-keyword">input</span>&gt;<br></code></pre></td></tr></table></figure><p>注意组件内部也要修改 props：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    &lt;input<br>      type=&quot;text&quot;<br>      :value=&quot;title&quot;<br>      @input=&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;<br>    /&gt;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-comment">// 此时这里不需要 model 选项来修改了</span></span><br>  props: &#123;<br><span class="javascript">    title: <span class="hljs-built_in">String</span>, <span class="hljs-comment">// 修改为 title，注意 template 中也要修改</span></span><br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>同时，.sync 修饰符也被移除了，如果你尝试使用它，会报这样的错误：</p><blockquote><p>‘.sync’ modifier on ‘v-bind’ directive is deprecated. Use ‘v-model:propName’ instead</p></blockquote><p>错误提示中说明了，可以使用 v-model:propName 的方式来替代 .sync，因为本质上效果是一样的。</p><h4 id="使用多个-v-model"><a href="#使用多个-v-model" class="headerlink" title="使用多个 v-model"></a>使用多个 v-model</h4><p>Vue3 中支持使用多个 v-model，属于新增功能，我很喜欢这个功能，使得组件数据更新更灵活。例如有这样一个表单子组件，用户输入的多个数据都需要更新到父组件中显示，可以这样写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  表单子组件 Form --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form&quot;</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;name&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;update:name&#x27;,$event.target.value)&quot;</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;address&quot;</span>&gt;</span>地址<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;address&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;update:address&#x27;,$event.target.value)&quot;</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>  props:&#123;<br><span class="javascript">    name: <span class="hljs-built_in">String</span>,</span><br><span class="javascript">    address: <span class="hljs-built_in">String</span></span><br>  &#125;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>父组件使用这个组件时：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">child-component</span> <span class="hljs-attr">v-model:name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">v-model:address</span>=<span class="hljs-string">&quot;address&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-component</span>&gt;</span></span><br><span class="xml">    </span><br><span class="xml">// 将用户输入数据更新到父组件中显示</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">name</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">address</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="自定义-v-model-修饰符"><a href="#自定义-v-model-修饰符" class="headerlink" title="自定义 v-model 修饰符"></a>自定义 v-model 修饰符</h4><p>在 Vue2 中的 v-model 上，我们用过 .trim、.lazy 和 .number这三个内置修饰符，而 Vue3 则在这个基础上增加了自定义修饰符，即开发者可以自定义修饰符，以按需处理绑定值。<br>当我们在 v-model 后面加上自定义修饰符后，会通过名为 modelModifiers 的 prop 传递给子组件，子组件拿到这个修饰符名后，根据条件修改绑定值。我们来看一个例子，自定义一个修饰符 capitalize，用于将输入字符串的首字母大写。<br>假设自定义组件还是叫 MyInput，使用 v-model 时加上自定义修饰符 capitalize：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">my</span>-input v-model.capitalize=<span class="hljs-string">&quot;msg&quot;</span>&gt;&lt;/<span class="hljs-keyword">my</span>-input&gt;<br></code></pre></td></tr></table></figure><p>由于不是内置修饰符，所以需要我们自己在组件内部处理修饰符逻辑，编写组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- MyInput 组件 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;modelValue&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;emitValue&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>  props: &#123;<br><span class="javascript">    modelValue: <span class="hljs-built_in">String</span>,</span><br><span class="javascript">    modelModifiers: &#123;  <span class="hljs-comment">// 自定义修饰符会默认传入这个 prop 中</span></span><br><span class="javascript">      type: <span class="hljs-built_in">Object</span>,</span><br><span class="javascript">      <span class="hljs-keyword">default</span>: <span class="hljs-function">() =&gt;</span> (&#123;&#125;),</span><br>    &#125;,<br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-comment">// 当组件 v-model 后面加上了自定义修饰符，组件内部会在 modelModifiers 上获取到修饰符状态</span></span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.modelModifiers); <span class="hljs-comment">// &#123;capitalize: true&#125;</span></span><br>  &#125;,<br>  methods: &#123;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">emitValue</span>(<span class="hljs-params">e</span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> value = e.target.value;</span><br><span class="javascript">      <span class="hljs-comment">// 如果使用了自定义修饰符，即状态为 true，就处理值</span></span><br><span class="javascript">      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.modelModifiers.capitalize) &#123;</span><br>        value = value.charAt(0).toUpperCase() + value.slice(1);<br>      &#125;<br><span class="javascript">      <span class="hljs-comment">// emit value</span></span><br><span class="javascript">      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&quot;update:modelValue&quot;</span>, value);</span><br>    &#125;,<br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样就完成了一个将输入字符串首字母大写的v-model修饰符。</p><p>如果是 v-model 带上了参数，同时使用了自定义修饰符，比如这样：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">&lt;my-<span class="hljs-built_in">input</span> v-<span class="hljs-keyword">mode</span><span class="hljs-variable">l:title</span>.capitalize=<span class="hljs-string">&quot;msg&quot;</span>&gt;&lt;/my-<span class="hljs-built_in">input</span>&gt;<br></code></pre></td></tr></table></figure><p>那么传入组件内部的 prop 就不再是 modelModifiers 了，而是 titleModifiers。它的格式是 arg + ‘Modifiers’。此时这个组件应该这样写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- MyInput 组件 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;title&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;emitValue&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>  props: &#123;<br><span class="javascript">    title: <span class="hljs-built_in">String</span>,  <span class="hljs-comment">// modelValue -&gt; title</span></span><br><span class="javascript">    titleModifiers: &#123;  <span class="hljs-comment">// modelModifiers -&gt; titleModifiers</span></span><br><span class="javascript">      type: <span class="hljs-built_in">Object</span>,</span><br><span class="javascript">      <span class="hljs-keyword">default</span>: <span class="hljs-function">() =&gt;</span> (&#123;&#125;),</span><br>    &#125;,<br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.titleModifiers); <span class="hljs-comment">// &#123;capitalize: true&#125;</span></span><br>  &#125;,<br>  methods: &#123;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">emitValue</span>(<span class="hljs-params">e</span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> value = e.target.value;</span><br><br><span class="javascript">      <span class="hljs-comment">// 如果使用了自定义修饰符，就处理值</span></span><br><span class="javascript">      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.titleModifiers.capitalize) &#123;</span><br>        value = value.charAt(0).toUpperCase() + value.slice(1);<br>      &#125;<br><span class="javascript">      <span class="hljs-comment">// emit value</span></span><br><span class="javascript">      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&quot;update:title&quot;</span>, value);</span><br>    &#125;,<br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6970210247726071845">v-model 在 Vue2 和 Vue3 中的区别</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端两种路由实现和使用场景--Hash模式&amp;&amp;History模式</title>
    <link href="/2022/02/17/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2022/02/17/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h3><p>路由这个概念最先是后端出现的，简单来说路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能。</p><h3 id="前端路由的诞生"><a href="#前端路由的诞生" class="headerlink" title="前端路由的诞生"></a>前端路由的诞生</h3><p>前端路由的出现要从 ajax 开始，有了 Ajax 后，用户交互就不用每次都刷新页面，体验带来了极大的提升。随着技术的发展，简单的异步已经不能满足需求，所以异步的更高级体验出现了——SPA(单页应用)。<br>SPA 的出现大大提高了 WEB 应用的交互体验。在与用户的交互过程中，不再需要重新刷新页面，获取数据也是通过 Ajax 异步获取，页面显示变的更加流畅。<br>但由于 SPA 中用户的交互是通过 JS 改变 HTML 内容来实现的，页面本身的 url 并没有变化，这导致了两个问题：</p><ul><li>SPA 无法记住用户的操作记录，无论是刷新、前进还是后退，都无法展示用户真实的期望内容。</li><li>SPA 中虽然由于业务的不同会有多种页面展示形式，但只有一个 url，对 SEO 不友好，不方便搜索引擎进行收录。</li></ul><p>前端路由就是为了解决上述问题而出现的。</p><h3 id="什么是前端路由"><a href="#什么是前端路由" class="headerlink" title="什么是前端路由"></a>什么是前端路由</h3><p>简单的说，就是在保证只有一个 HTML 页面，且与用户交互时不刷新和跳转页面的同时，为 SPA 中的每个视图展示形式匹配一个特殊的 url。在刷新、前进、后退和SEO时均通过这个特殊的 url 来实现。<br>为实现这一目标，我们需要做到以下二点：</p><ul><li>改变 url 且不让浏览器像服务器发送请求。</li><li>可以监听到 url 的变化</li></ul><p>接下来要介绍的 hash 模式和 history 模式，就是实现了上面的功能。</p><h3 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a>Hash模式</h3><p>原理</p><ul><li>早期的前端路由的实现就是基于location.hash来实现的，location.hash的值就是URL中#后面的内容 其实现原理就是监听#后面的内容来发起Ajax请求来进行局部更新，而不需要刷新整个页面。</li><li>使用hashchange事件来监听 URL 的变化，以下这几种情况改变 URL 都会触发 hashchange 事件：浏览器前进后退改变 URL、a标签改变 URL、window.location改变URL。</li></ul><p>使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//html</span><br>&lt;ul id=<span class="hljs-string">&quot;menu&quot;</span>&gt;<br>  &lt;li&gt;<br>    &lt;a href=<span class="hljs-string">&quot;#index&quot;</span>&gt;首页&lt;/a&gt;<br>  &lt;/li&gt;<br>  &lt;li&gt;<br>    &lt;a href=<span class="hljs-string">&quot;#news&quot;</span>&gt;资讯&lt;/a&gt;<br>  &lt;/li&gt;<br>  &lt;li&gt;<br>    &lt;a href=<span class="hljs-string">&quot;#user&quot;</span>&gt;个人中心&lt;/a&gt;<br>  &lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;div id=<span class="hljs-string">&quot;app&quot;</span>&gt;&lt;/div&gt;<br><br><span class="hljs-comment">//js</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hashChange</span>(<span class="hljs-params">e</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> app = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;app&#x27;</span>)<br>    <span class="hljs-keyword">switch</span> (location.hash) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#index&#x27;</span>:<br>        app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;这是首页内容&lt;/h1&gt;&#x27;</span><br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#news&#x27;</span>:<br>        app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;这是新闻内容&lt;/h1&gt;&#x27;</span><br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#user&#x27;</span>:<br>        app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;这是个人中心内容&lt;/h1&gt;&#x27;</span><br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-keyword">default</span>:<br>        app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;404&lt;/h1&gt;&#x27;</span><br>    &#125;<br>&#125;<br><span class="hljs-built_in">window</span>.onhashchange = hashChange<br>hashChange()<br></code></pre></td></tr></table></figure><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>兼容低版本浏览器，Angular1.x和Vue默认使用的就是hash路由</li><li>只有#符号之前的内容才会包含在请求中被发送到后端，也就是说就算后端没有对路由全覆盖，但是不会返回404错误<br>hash值的改变，都会在浏览器的访问历史中增加一个记录，所以可以通过浏览器的回退、前进按钮控制hash的切换 会覆盖锚点定位元素的功能</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>不太美观，#后面传输的数据复杂的话会出现问题</li></ul><h3 id="History模式"><a href="#History模式" class="headerlink" title="History模式"></a>History模式</h3><p>原理</p><ul><li>history 提供了 pushState 和 replaceState 两个方法来记录路由状态，这两个方法改变 URL 不会引起页面刷新</li><li>history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过pushState/replaceState或a标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState/replaceState的调用和a标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。</li><li>pushState(state, title, url) 和 replaceState(state, title, url)都可以接受三个相同的参数。<br>使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//html</span><br>&lt;ul id=<span class="hljs-string">&quot;menu&quot;</span>&gt;<br>  &lt;li&gt;<br>    &lt;a href=<span class="hljs-string">&quot;/index&quot;</span>&gt;首页&lt;/a&gt;<br>  &lt;/li&gt;<br>  &lt;li&gt;<br>    &lt;a href=<span class="hljs-string">&quot;/news&quot;</span>&gt;资讯&lt;/a&gt;<br>  &lt;/li&gt;<br>  &lt;li&gt;<br>    &lt;a href=<span class="hljs-string">&quot;/user&quot;</span>&gt;个人中心&lt;/a&gt;<br>  &lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;div id=<span class="hljs-string">&quot;app&quot;</span>&gt;&lt;/div&gt;<br><br><span class="hljs-comment">//js</span><br><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#menu&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(e.target.nodeName ===<span class="hljs-string">&#x27;A&#x27;</span>)&#123;<br>    e.preventDefault()<br>    <span class="hljs-keyword">let</span> path = e.target.getAttribute(<span class="hljs-string">&#x27;href&#x27;</span>)  <span class="hljs-comment">//获取超链接的href，改为pushState跳转，不刷新页面</span><br>    <span class="hljs-built_in">window</span>.history.pushState(&#123;&#125;,<span class="hljs-string">&#x27;&#x27;</span>,path)  <span class="hljs-comment">//修改浏览器中显示的url地址</span><br>    render(path)  <span class="hljs-comment">//根据path，更改页面内容</span><br>  &#125;<br>&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">path</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> app = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;app&#x27;</span>)<br>  <span class="hljs-keyword">switch</span> (path) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/index&#x27;</span>:<br>      app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;这是首页内容&lt;/h1&gt;&#x27;</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/news&#x27;</span>:<br>      app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;这是新闻内容&lt;/h1&gt;&#x27;</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/user&#x27;</span>:<br>      app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;这是个人中心内容&lt;/h1&gt;&#x27;</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">default</span>:<br>      app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;404&lt;/h1&gt;&#x27;</span><br>  &#125;<br>&#125;<br><span class="hljs-built_in">window</span>.onpopstate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  render(location.pathname)<br>&#125;<br>render(<span class="hljs-string">&#x27;/index&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>使用简单，比较美观</li><li>pushState()设置新的URL可以是任意与当前URL同源的URL，而hash只能改变#后面的内容，因此只能设置与当前URL同文档的URL</li><li>pushState()设置的URL与当前URL一模一样时也会被添加到历史记录栈中，而hash#后面的内容必须被修改才会被添加到新的记录栈中</li><li>pushState()可以通过stateObject参数添加任意类型的数据到记录中，而hash只能添加短字符串</li><li>pushState()可额外设置title属性供后续使用</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>前端的URL必须和向发送请求后端URL保持一致，否则会报404错误</li><li>由于History API的缘故，低版本浏览器有兼容行问题</li></ul><h3 id="两种不同使用场景"><a href="#两种不同使用场景" class="headerlink" title="两种不同使用场景"></a>两种不同使用场景</h3><ul><li>从上文可见，hash模式下url会带有#，当你希望url更优雅时，可以使用history模式。</li><li>当使用history模式时，需要注意在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</li><li>当需要兼容低版本的浏览器时，建议使用hash模式。</li><li>当需要添加任意类型数据到记录时，可以使用history模式。</li></ul><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844904054087221256#comment">前端两种路由实现和使用场景</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 面试题总结</title>
    <link href="/2022/02/15/%5B%E6%80%BB%E7%BB%93%5DCSS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2022/02/15/%5B%E6%80%BB%E7%BB%93%5DCSS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>总结了最近的一些面试题和之前的知识点</p><hr><h2 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问"></a>面试常问</h2><h3 id="flex中的缩写代表什么"><a href="#flex中的缩写代表什么" class="headerlink" title="flex中的缩写代表什么"></a>flex中的缩写代表什么</h3><p>flex是<strong>flex-grow,flex-shrink和flex-basis</strong>的缩写，flex属性值可以只指定一个属性的值，而另外的属性值采用各自在flex属性中的的初始值，但是有一点要注意的是：flex属性中flex-grow和flex-basis的初始值和它们原始的默认值不同，至于为什么不同，mdn中有明确的说过这样的设计是为了让「flex」缩写在最常见的情景下比较好用。<br><strong>flex:1—-(flex-grow:0;flex-shrink:1;flex-basis:auto)</strong></p><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><p>一般常见的几种居中的方法有：</p><h4 id="对于宽高固定的元素"><a href="#对于宽高固定的元素" class="headerlink" title="对于宽高固定的元素"></a>对于宽高固定的元素</h4><p>（1）我们可以利用<strong>margin:0 auto</strong>来实现元素的水平居中。</p><p>（2）利用<strong>绝对定位，设置四个方向的值都为0，并将margin设置为auto</strong>，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。</p><p>（3）利用<strong>绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值</strong>来调整元素的中心点到页面的中心。</p><h4 id="对于宽高不定的元素，下面两种方法，可以实现元素的垂直和水平的居中"><a href="#对于宽高不定的元素，下面两种方法，可以实现元素的垂直和水平的居中" class="headerlink" title="对于宽高不定的元素，下面两种方法，可以实现元素的垂直和水平的居中"></a>对于宽高不定的元素，下面两种方法，可以实现元素的垂直和水平的居中</h4><p>（4）利用<strong>绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate</strong>来调整元素的中心点到页面的中心。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">parentElement&#123;<br>       <span class="hljs-attribute">position</span>:relative;<br>   &#125;<br>childElement&#123;<br>       <span class="hljs-attribute">position</span>: absolute;<br>       <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>       <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>（5）使用<strong>flex布局</strong>，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。</p><p>(6) <strong>gird布局</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">place-<span class="hljs-keyword">items</span>:center<br></code></pre></td></tr></table></figure><p>CSS 中的 place-items 是一个简写属性 ，它允许你在相关的布局（如 Grid 或 Flexbox）中可以同时沿着块级和内联方向对齐元素 (例如：align-items 和 justify-items 属性) 。如果未提供第二个值，则第一个值作为第二个值的默认值。<br>(7)文本水平居中：text-algin: center</p><h3 id="CSS3-高斯模糊-filter-blur"><a href="#CSS3-高斯模糊-filter-blur" class="headerlink" title="CSS3    高斯模糊  filter  blur"></a>CSS3    高斯模糊  filter  blur</h3><h3 id="canvas和svg-使用场景及二者的区别"><a href="#canvas和svg-使用场景及二者的区别" class="headerlink" title="canvas和svg | 使用场景及二者的区别"></a>canvas和svg | 使用场景及二者的区别</h3><p>canvas是H5中新增的标签，官方解释说canvas是<strong>一块画布</strong>，可以在网页中绘制图像<br>svg即<strong>可缩放矢量图形，什么是矢量图形呢，也就是放大或者缩小不会失真的图形</strong>。 svg绘图时，每个图形都是以DOM节点的形式插入到页面中的，我们可以通过js来直接操作这些图形</p><h4 id="canvas和svg的区别"><a href="#canvas和svg的区别" class="headerlink" title="canvas和svg的区别"></a>canvas和svg的区别</h4><p>canvas绘画出来的图形一般成为<strong>位图，也就是放大缩小的情况下会出现失真的情况</strong>，svg绘制的图形是<strong>矢量图，不存在失真的情况</strong></p><p>canvas绘制的图形<strong>不会出现在DOM结构中，svg绘制的会存在于DOM结构</strong></p><p>canvas<strong>类似于动画，每次图形的改变都是先清除原来的图形，然后把新的图形画上去</strong>，svg则是可以直接通过js来进行某些操作</p><p>canvas依赖于分辨率，svg不依赖分辨率</p><p>canvas最适合图像密集型的游戏，其中的许多对象会被频繁重绘，svg不适合游戏应用</p><h4 id="图片格式-各自优缺点和使用场景"><a href="#图片格式-各自优缺点和使用场景" class="headerlink" title="图片格式,各自优缺点和使用场景"></a>图片格式,各自优缺点和使用场景</h4><p><a href="https://pengzhenglong.github.io/2022/03/04/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F--%E5%90%84%E8%87%AA%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/">图片格式&amp;&amp;各自优缺点和使用场景 _</a></p><h3 id="link标签和import标签的区别"><a href="#link标签和import标签的区别" class="headerlink" title="link标签和import标签的区别"></a>link标签和import标签的区别</h3><ol><li>link是属于html标签，而@import是css提供的</li><li>页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载</li><li>link是html标签，因此没有兼容性，而@import只有IE5以上才能识别</li><li>link方式样式的权重高于@import</li><li>使⽤dom控制样式时的差别。当使⽤javascript控制dom去改变样式的时候，只能使⽤link标签，因为@import不是 dom可以控制的。</li></ol><h3 id="css-两栏布局的实现？"><a href="#css-两栏布局的实现？" class="headerlink" title="css 两栏布局的实现？"></a>css 两栏布局的实现？</h3><h4 id="两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式"><a href="#两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式" class="headerlink" title="两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式"></a>两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式</h4><p>回答：<br>两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。<br>以左边宽度固定为 200px 为例<br>-（1）利用<strong>浮动</strong>，将<strong>左边元素宽度设置为 200px，并且设置向左浮动</strong>。将右边元素的 <strong>margin-left 设置为 200px，宽度设置为 auto（默认为 auto，撑满整个父元素）</strong>。<br>-（2）第二种是利用<strong>flex</strong> 布局，将左边元素的放大和缩小比例设置为 0，<strong>基础大小设置为 200px</strong>。将右边的元素的<strong>放大比例设置为 1</strong>，缩小比例设置为 1，基础大小设置为 auto。<br>-（3）第三种是利用<strong>绝对定位布局</strong>的方式，将父级元素设置相对定位。<strong>左边元素设置为 absolute 定位，并且宽度设置为 200px。将右边元素的 margin-left 的值设置为 200px。</strong><br>-（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为 200px，右边元素设置为绝对定位，左边定位为 200px，其余方向定位为 0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs css"><br><span class="hljs-comment">/*以左边宽度固定为200px为例*/</span><br><br><span class="hljs-comment">/*（1）利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br> <span class="hljs-attribute">float</span>: left;<br><br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br><br> <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br> <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br><br> <span class="hljs-attribute">width</span>: auto;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br> <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-comment">/*（2）第二种是利用flex布局，将左边元素的放大和缩小比例设置为0，基础大小设置为200px。将右边的元素的放大比例设置为1，缩小比例设置为1，基础大小设置为auto。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br> <span class="hljs-attribute">display</span>: flex;<br><br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br> <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">0</span>;<br> <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">0</span>;<br> <span class="hljs-attribute">flex-basis</span>: <span class="hljs-number">200px</span>;<br><br> <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br> <span class="hljs-attribute">flex</span>: auto;<br> <span class="hljs-comment">/*11auto*/</span><br><br> <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-comment">/*（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为absolute定位，并且宽度设置为</span><br><span class="hljs-comment">200px。将右边元素的margin-left的值设置为200px。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br> <span class="hljs-attribute">position</span>: relative;<br><br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br> <span class="hljs-attribute">position</span>: absolute;<br><br> <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br> <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br> <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br> <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-comment">/*（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br> <span class="hljs-attribute">position</span>: relative;<br><br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br> <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br> <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br> <span class="hljs-attribute">position</span>: absolute;<br><br> <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br> <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br> <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br> <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br><br> <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="css实现两栏固定中间自适应（和三栏布局一样）"><a href="#css实现两栏固定中间自适应（和三栏布局一样）" class="headerlink" title="css实现两栏固定中间自适应（和三栏布局一样）"></a>css实现两栏固定中间自适应（和三栏布局一样）</h3><p>1、利用<strong>绝对定位和margin</strong><br>2、利用<strong>浮动和margin–注意：中间一栏必须放到最后。</strong><br>3、CSS3 <strong>flex</strong></p><p><a href="https://pengzhenglong.github.io/2021/07/06/Css%E5%B8%83%E5%B1%80/#2%E3%80%81%E5%88%A9%E7%94%A8%E6%B5%AE%E5%8A%A8%E5%92%8Cmargin">博客：css实现两栏固定中间自适应</a></p><h3 id="css-三栏布局的实现？"><a href="#css-三栏布局的实现？" class="headerlink" title="css 三栏布局的实现？"></a>css 三栏布局的实现？</h3><h4 id="三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式"><a href="#三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式" class="headerlink" title="三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式"></a>三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式</h4><p>这里以左边宽度固定为100px，右边宽度固定为200px为例<br>（1）利用<strong>绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</strong></p><p>（2）利用<strong>flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto。</strong></p><p>（3）利用<strong>浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意：中间一栏必须放到最后。</strong></p><p>（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置margin负值将其移动到上一行，再利用相对定位，定位到两边。圣杯布局中间列的宽度不能小于两边任意列的宽度，而双飞翼布局则不存在这个问题。</p><p>（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的margin值来实现的，而不是通过父元素的padding来实现的。本质上来说，也是通过浮动和外边距负值来实现的。<br><a href="http://cavszhouyou.top/Demo-Display/ThreeColumnLayout/index.html">三栏布局demo</a></p><p>相关资料：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*这里以左边宽度固定为100px，右边宽度固定为200px为例。*/</span><br><br><span class="hljs-comment">/*（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br> <span class="hljs-attribute">position</span>: relative;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br> <span class="hljs-attribute">position</span>: absolute;<br><br> <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br> <span class="hljs-attribute">position</span>: absolute;<br> <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br> <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br><br> <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br> <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-comment">/*（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br> <span class="hljs-attribute">display</span>: flex;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br> <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br> <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br> <span class="hljs-attribute">flex</span>: auto;<br> <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-comment">/*（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br> <span class="hljs-attribute">float</span>: left;<br> <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br> <span class="hljs-attribute">float</span>: right;<br> <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-comment">/*（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br> <span class="hljs-attribute">position</span>: relative;<br> <span class="hljs-attribute">left</span>: -<span class="hljs-number">100px</span>;<br><br> <span class="hljs-attribute">float</span>: left;<br> <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br> <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br> <span class="hljs-attribute">position</span>: relative;<br> <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br><br> <span class="hljs-attribute">float</span>: right;<br> <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br> <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br> <span class="hljs-attribute">float</span>: left;<br><br> <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-comment">/*（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元</span><br><span class="hljs-comment">素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。*/</span><br><br><span class="hljs-selector-class">.outer</span> &#123;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br> <span class="hljs-attribute">float</span>: left;<br> <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br> <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br> <span class="hljs-attribute">float</span>: left;<br> <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br> <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.wrapper</span> &#123;<br> <span class="hljs-attribute">float</span>: left;<br><br> <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br> <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="transition（过渡）和animation（动画）的区别"><a href="#transition（过渡）和animation（动画）的区别" class="headerlink" title="transition（过渡）和animation（动画）的区别"></a>transition（过渡）和animation（动画）的区别</h3><p>Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，<br>(1)<strong>transition需要触发一个事件才能改变属性</strong>，而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from …. to，而animation<strong>可以一帧一帧</strong>的。<br> (2)transition通常和<strong>hover</strong>等事件配合使用，animation是自发的，立即播放<br>（3）animation可设置循环次数<br>（4）animation可设置每一帧的样式和时间，transition只能设置头尾<br>（5）transition可与js配合使用，js设定要变化的样式，transition负责动画效果</p><h3 id="Js-动画与-CSS-动画区别及相应实现-（JS动画重绘回流，性能影响）"><a href="#Js-动画与-CSS-动画区别及相应实现-（JS动画重绘回流，性能影响）" class="headerlink" title="Js 动画与 CSS 动画区别及相应实现 （JS动画重绘回流，性能影响）"></a>Js 动画与 CSS 动画区别及相应实现 （JS动画重绘回流，性能影响）</h3><p>CSS3 的动画的优点<br><strong>在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化,代码相对简单</strong><br><strong>缺点(在动画控制上不够灵活,兼容性不好)</strong></p><p>Js动画<br>JavaScript 的动画正好弥补了这两个缺点，<strong>控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大</strong>。对于一些复杂控制的动画，使用 javascript 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧<br>如果动画相较复杂，我们可以采用 JS + canvas 去尝试，能不能实现最后再考虑纯 JS 实现<br><a href="https://pengzhenglong.github.io/2022/02/15/CSS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#Js-%E5%8A%A8%E7%94%BB%E4%B8%8E-CSS-%E5%8A%A8%E7%94%BB%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%AE%9E%E7%8E%B0">博客</a></p><h3 id="什么是重绘和回流？（浏览器绘制过程）注意：回流一定会触发重绘，而重绘不一定会回流"><a href="#什么是重绘和回流？（浏览器绘制过程）注意：回流一定会触发重绘，而重绘不一定会回流" class="headerlink" title="什么是重绘和回流？（浏览器绘制过程）注意：回流一定会触发重绘，而重绘不一定会回流"></a>什么是重绘和回流？（浏览器绘制过程）注意：回流一定会触发重绘，而重绘不一定会回流</h3><h4 id="什么是回流？"><a href="#什么是回流？" class="headerlink" title="什么是回流？"></a>什么是回流？</h4><p>当一个元素自身的宽高，布局，显示或隐藏，或元素内部的文字结构发生变化，导致需要重新构建页面的时候，就产生了回流</p><h4 id="什么是重绘？"><a href="#什么是重绘？" class="headerlink" title="什么是重绘？"></a>什么是重绘？</h4><p>当一个元素自身的宽高，布局，及显示或隐藏没有改变，而只是改变了元素的外观风格的时候，就产生了重绘</p><h4 id="什么时候会进行回流？"><a href="#什么时候会进行回流？" class="headerlink" title="什么时候会进行回流？"></a>什么时候会进行回流？</h4><ol><li>添加或者删除可见的DOM元素的时候</li><li>元素的位置发生改变</li><li>元素的尺寸发生改变</li><li>内容改变</li><li>页面第一次渲染的时候</li></ol><p>列举一些相关的CSS样式：width、height、line-height、padding、margin、diaplay、border、top、position、float、font-size、overflow等</p><h4 id="什么时候会进行重绘？"><a href="#什么时候会进行重绘？" class="headerlink" title="什么时候会进行重绘？"></a>什么时候会进行重绘？</h4><p>列举一些相关的CSS样式：color、background、background-size、visibility、box-shadow</p><h4 id="如何进行性能优化？"><a href="#如何进行性能优化？" class="headerlink" title="如何进行性能优化？"></a>如何进行性能优化？</h4><ol><li>用<strong>transform 代替 top，left ，margin-top， margin-left… 这些位移属性</strong></li><li>不要使用 js 代码对dom 元素设置多条样式，选择用一个 className 代替之</li><li>不要在循环内获取dom 的样式例如：offsetWidth, offsetHeight, clientWidth, clientHeight等。浏览器有一个回流的缓冲机制，获取这些属性时会产生回流</li><li>避免设置多层内联样式，写个外部类这样只回流一次</li><li>让多次回流的元素脱离文档流比如动画，使用 position 属性的 fixed 值或 absolute 值</li><li>一起变化（同时修改所有需要变化的属性）</li></ol><h4 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h4><p>CSS</p><p>避免使用table布局。<br>尽可能在DOM树的最末端改变class。<br>避免设置多层内联样式。<br>将动画效果应用到position属性为absolute或fixed的元素上。<br>避免使用CSS表达式（例如：calc()）。</p><p>JavaScript</p><p><strong>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性</strong>。<br>避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。<br>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。<br><strong>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</strong><br>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</p><p><a href="https://pengzhenglong.github.io/2021/07/24/%E9%87%8D%E7%BB%98%E5%9B%9E%E6%B5%81/">博客：浏览器的回流与重绘</a></p><h3 id="Flex-–请解释一下-CSS3-的-Flex-box（弹性盒布局模型），以及适用场景？"><a href="#Flex-–请解释一下-CSS3-的-Flex-box（弹性盒布局模型），以及适用场景？" class="headerlink" title="Flex –请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？"></a>Flex –请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？</h3><ol><li>flex布局是CSS3新增的一种布局方式，我们<strong>可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目</strong>。</li><li>一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。</li><li>我们可以使用<strong>flex-direction</strong>来指定主轴的方向。（默认是x轴为主轴）（row 行  column列）</li><li>我们可以使用<strong>justify-content</strong>来指定元素在主轴上的排列方式，使用<strong>align-items</strong>来指定元素在交叉轴上的排列方式。</li><li>还可以使用<strong>flex-wrap</strong>来规定当一行排列不下时的换行方式。</li><li>对于容器中的项目，我们可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例。</li><li>还可以使用flex-shrink /flex-grow来指定当排列空间不足时，项目的缩小比例。</li></ol><p><a href="https://pengzhenglong.github.io/2021/04/14/CSS3flex%E5%B8%83%E5%B1%80/">博客：Flex布局</a></p><h3 id="css选择器优先级"><a href="#css选择器优先级" class="headerlink" title="css选择器优先级"></a>css选择器优先级</h3><p>!important &gt; inline &gt; id &gt; class &gt; tag &gt; *&gt; inherit &gt; default</p><blockquote><p>总结排序：!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性  同一级别</p></blockquote><p>!important：大于其他<br>行内：1000<br>id选择器：100<br>类，伪类和属性选择器，如.content：10<br>类型选择器和伪元素选择器：1<br>tag  标签选择器 如（body  div  p li）<br>全局选择器(如：*号)<br>通配符、子选择器、相邻选择器：0</p><blockquote><p>同级别的后写的优先级高。</p></blockquote><p>相同class样式，css中后写的优先级高，和html中的class名字前后无关</p><h3 id="CSS-中哪些属性是可以继承的"><a href="#CSS-中哪些属性是可以继承的" class="headerlink" title="CSS 中哪些属性是可以继承的"></a>CSS 中哪些属性是可以继承的</h3><p>前面通过一段代码来简单看了一下关于继承的一个概念。哪些 CSS 这些属性都可以被继承呢？这里总结出了一下常见被继承的 CSS 属性。</p><p><strong>字体属性：font、font-family、font-size、font-style、font-variant、font-weight</strong><br>字母间距属性：letter-spancing<br>可见性属性：visibility<br><strong>文字展示属性：line-height、text-align、text-indent、text-transform</strong><br>字间距属性：word-spacing</p><h4 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h4><p>id选择器&gt;class选择器&gt;标签选择器</p><h4 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h4><ol><li>后代选择器：在某个元素的后面(都会作用)</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*body  p&#123;        background: red;    &#125;*/</span>例：<span class="hljs-selector-tag">body</span>后的所有<span class="hljs-selector-tag">p</span>标签背景都会变为红色<br></code></pre></td></tr></table></figure><ol start="2"><li>子选择器：(就作用一代)</li></ol> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*body&gt;p&#123;       background:blue;   &#125;*/</span>例：<span class="hljs-selector-tag">body</span>后面的第一代<span class="hljs-selector-tag">p</span>标签才有效果，其他嵌套的没有<br></code></pre></td></tr></table></figure><ol start="3"><li>相邻兄弟选择器：只有一个，相邻(向下)</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*.active+p&#123;        background:blue;    &#125;*/</span>例：类active标签的向下的一个P标签才会作用<br></code></pre></td></tr></table></figure><ol start="4"><li>通用兄弟选择器</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">当前选中元素的向下的所有兄弟元素 */    <span class="hljs-selector-class">.active</span> ~ <span class="hljs-selector-tag">p</span> &#123;      <span class="hljs-attribute">background</span>: tomato;    &#125;例：类active后面向下的所有<span class="hljs-selector-tag">P</span>标签都会作用<br></code></pre></td></tr></table></figure><h4 id="结构伪类选择器-避免使用，class-id选择器"><a href="#结构伪类选择器-避免使用，class-id选择器" class="headerlink" title="结构伪类选择器(避免使用，class,id选择器)"></a>结构伪类选择器(避免使用，class,id选择器)</h4><blockquote><p>带冒号都是伪类选择器<br>1 ul li:first-child</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*ul的第一个子元素*/</span><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first</span>-child &#123;  <span class="hljs-attribute">background</span>: tomato;&#125;<br><span class="hljs-comment">/*ul的最后一个元素*/</span><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span> &#123;  <span class="hljs-attribute">background</span>: turquoise;&#125;<br></code></pre></td></tr></table></figure><p>2 p:nth-child(1) (nth父元素)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*选中p1: 定位到父元素，选择当前的第一个元素 选择当前p元素的父级元素，选择父级元素的第一个,并且是当前元素才生效*/</span>    <br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>)&#123;      <span class="hljs-attribute">background</span>: violet;  &#125;*/<br></code></pre></td></tr></table></figure><p>3 p:nth-of-type(1)<br>4 a:hover(鼠标悬浮的颜色 (重要))<br>a:hover {  background: yellow;}</p><h4 id="属性选择器-重要"><a href="#属性选择器-重要" class="headerlink" title="属性选择器(重要)"></a>属性选择器(重要)</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs css"><br><span class="hljs-comment">/*属性名， 属性名= 属性值（正则）</span><br><span class="hljs-comment">=绝对等于</span><br><span class="hljs-comment">*=包含这个元素</span><br><span class="hljs-comment">^= 以这个开头</span><br><span class="hljs-comment">$= 以这个结尾</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    /*存在id属性的元素   a[]&#123;&#125;*/</span><br>    <span class="hljs-comment">/*a[id]&#123;</span><br><span class="hljs-comment">    background: yellow;</span><br><span class="hljs-comment">&#125;*/</span><br>    <span class="hljs-comment">/*id=first的元素*/</span><br>    <span class="hljs-comment">/*a[id=first]&#123;</span><br><span class="hljs-comment">    background: violet;</span><br><span class="hljs-comment">&#125;*/</span><br>    <span class="hljs-comment">/*class 中有links的元素*/</span><br>    <span class="hljs-comment">/*a[class*=&quot;links&quot;]&#123;</span><br><span class="hljs-comment">    background: yellow;</span><br><span class="hljs-comment">&#125;*/</span><br>    <span class="hljs-comment">/*选中href中以http开头的元素*/</span><br>    <span class="hljs-comment">/*a[href^=http]&#123;</span><br><span class="hljs-comment">background: yellow;</span><br><span class="hljs-comment">&#125;*/</span><br>    <span class="hljs-comment">/*选中href中以doc结尾的元素*/</span><br>    <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href$=<span class="hljs-string">&#x27;doc&#x27;</span>]</span> &#123;<br>      <span class="hljs-attribute">background</span>: yellow;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><h4 id="html第一行！doctype是做什么用的"><a href="#html第一行！doctype是做什么用的" class="headerlink" title="html第一行！doctype是做什么用的"></a>html第一行！doctype是做什么用的</h4><p>告诉浏览器用什么样的模式来解析文档。如html5则为声明为html5文档<br>DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。</p><h4 id="HTML5-新特性、语义化"><a href="#HTML5-新特性、语义化" class="headerlink" title="HTML5 新特性、语义化"></a>HTML5 新特性、语义化</h4><ol><li>概念：HTML5的语义化指的是合理正确的使用语义化的标签来创建页面结构。【正确的标签做正确的事】</li><li>语义化标签：header nav main article section aside footer</li><li>语义化的优点:<br>在没CSS样式的情况下，页面整体也会呈现很好的结构效果<br>代码结构清晰，易于阅读，<br>利于开发和维护 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。<br>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重</li></ol><h4 id="src和href的区别？-src相当于同步执行，href相当于并行处理"><a href="#src和href的区别？-src相当于同步执行，href相当于并行处理" class="headerlink" title="src和href的区别？(src相当于同步执行，href相当于并行处理)"></a>src和href的区别？(src相当于同步执行，href相当于并行处理)</h4><ol><li>src是指向外部资源的位置，指向的内容会嵌⼊到⽂档中当前标签所在的位置，在请求src资源时会将其指向的资源<br>下载并应⽤到⽂档内，如js脚本，img图⽚和frame等元素。<strong>当浏览器解析到该元素时，会暂停其他资源的下载和处理，知道将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在底部⽽不是头部。</strong></li><li>href是指向⽹络资源所在位置（的超链接），⽤来建⽴和当前元素或⽂档之间的连接，<strong>当浏览器识别到它他指向的<br>⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。</strong></li></ol><h4 id="前端需要注意哪些-SEO-？"><a href="#前端需要注意哪些-SEO-？" class="headerlink" title="前端需要注意哪些 SEO ？"></a>前端需要注意哪些 SEO ？</h4><p> （1）合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可。<br>（2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。<br> （3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被抓取。<br> （4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容<br> （5）少用 iframe：搜索引擎不会抓取 iframe 中的内容<br> （6）非装饰性图片必须加 alt<br> （7）提高网站速度：网站速度是搜索引擎排序的一个重要指标</p><h4 id="行内元素-块级元素"><a href="#行内元素-块级元素" class="headerlink" title="行内元素 块级元素"></a>行内元素 块级元素</h4><p>块级元素：div、p、ol、ul、dl、li、table、td、th、tr、dd、dt、caption、h、<br>行内元素：i、img、input、select、label、textarea、button、b、span、a、u、em、</p><p>块级元素的特点<br><strong>1、高度，行高以及外边距和内边距都可控制。</strong><br>2、总是在新行上开始，占据一整行。<br>3、它可以容纳内联元素和其他块元素。<br>4、宽度始终是与浏览器宽度一样，与内容无关。</p><p>行内元素的特点<br>1、行内元素只能容纳文本或者其他行内元素。<br><strong>2、宽度只与内容有关。</strong><br>3、和其他元素都在一行上。<br>4、高，行高及外边距和内边距部分可改变。</p><p>区别<br>1、行内元素会在一条直线上分列，都是统一行的，程度偏向分列。<br>块级元素各盘踞一行，垂直偏向分列；块级元素重新行开端停止接着一个断行。<br>2、行内元素不可以包括块级元素，只能包容文本或许其余行内元素。<br>块级元素能够包括行内元素和块级元素，还能够包容内联元素和其余元素；。</p><blockquote><p>3、行内元素与块级元素属性的分歧，主要在盒模子属性上。<br>行内元素设置width无效，height无效（能够设置line-height），margin、padding设置上下有效。</p></blockquote><h5 id="切换-display-inline-block、inline和block"><a href="#切换-display-inline-block、inline和block" class="headerlink" title="切换  display:inline-block、inline和block"></a>切换  display:inline-block、inline和block</h5><h2 id="不常问（已掌握）"><a href="#不常问（已掌握）" class="headerlink" title="不常问（已掌握）"></a>不常问（已掌握）</h2><h3 id="介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？"><a href="#介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？" class="headerlink" title="介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？"></a>介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？</h3><p>（1）有两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box）<br>(2) 盒模型：由四个属性组成的外边距(margin)、内边距(padding)、边界(border)、内容区(width和height);</p><h4 id="IE盒模型和W3C标准盒模型的区别"><a href="#IE盒模型和W3C标准盒模型的区别" class="headerlink" title="IE盒模型和W3C标准盒模型的区别"></a>IE盒模型和W3C标准盒模型的区别</h4><p>（1）W3C标准盒模型：属性width，height只包含内容content，不包含border和padding<br>（2）IE盒模型：属性width，height包含content、border和padding，指的是content+padding+border。</p><h4 id="CSS-如何设置这两种模型？"><a href="#CSS-如何设置这两种模型？" class="headerlink" title="CSS 如何设置这两种模型？"></a>CSS 如何设置这两种模型？</h4><p>box-sizing : content-box  //标准(W3C)盒子模型<br>box-sizing : border-box   //IE盒子模型</p><h3 id="为什么要清除浮动？怎么清除浮动？"><a href="#为什么要清除浮动？怎么清除浮动？" class="headerlink" title="为什么要清除浮动？怎么清除浮动？"></a>为什么要清除浮动？怎么清除浮动？</h3><h4 id="产生原因：子盒子浮动导致的父盒子内高度为-0-，父级盒子不能被撑开，发生高度塌陷的情况"><a href="#产生原因：子盒子浮动导致的父盒子内高度为-0-，父级盒子不能被撑开，发生高度塌陷的情况" class="headerlink" title="产生原因：子盒子浮动导致的父盒子内高度为 0 ，父级盒子不能被撑开，发生高度塌陷的情况"></a>产生原因：子盒子浮动导致的父盒子内高度为 0 ，父级盒子不能被撑开，发生高度塌陷的情况</h4><h4 id="带来的负作用"><a href="#带来的负作用" class="headerlink" title="带来的负作用"></a>带来的负作用</h4><ol><li>背景不能显示</li><li>边框不能撑开</li><li>margin和padding值不能正确显示</li></ol><h4 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h4><ol><li>给父盒子设置合适的高度</li><li>给父盒子添加样式 overflow：hidden/auto;（这个属性相当于触发BFC，让父级紧贴内容，包括使用了浮动的盒子）（为了去除兼容性问题，会添加zoom:1;）</li><li>在父盒子里面的子盒子后面添加一个子盒子，如div，添加样式 .clear{clear:both;}；</li><li>采用伪元素，给父元素追加::after，给父元素添加一个类.clearfix{content:””;clear:both;}</li></ol><h3 id="BFC-IFC-（块级格式化上下文-行级格式化上下文）"><a href="#BFC-IFC-（块级格式化上下文-行级格式化上下文）" class="headerlink" title="BFC/IFC  （块级格式化上下文/行级格式化上下文）"></a>BFC/IFC  （块级格式化上下文/行级格式化上下文）</h3><p>BFC指的是<strong>块级格式化上下文</strong>，</p><ol><li>一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。</li><li>一个BFC就像是一个隔离区域，和其他区域互不影响。</li><li>一般来说根元素是一个BFC区域，浮动和绝对定位的元素也会形成BFC，display属性的值为inline-block、flex这些属性时也会创建BFC。</li><li>还有就是元素的overflow的值不为visible时都会创建BFC。</li></ol><h5 id="BFC的应用-overflow-hidden"><a href="#BFC的应用-overflow-hidden" class="headerlink" title="BFC的应用 (overflow:hidden)"></a>BFC的应用 (overflow:hidden)</h5><p>清除浮动：父元素设置overflow: hidden触发BFC实现清除浮动，防止父元素高度塌陷，后面的元素被覆盖，实现文字环绕等等。<br>消除相邻元素垂直方向的边距重叠：第二个子元素套一层，并设置overflow: hidden，构建BFC使其不影响外部元素。<br>消除父子元素边距重叠，父元素设置overflow: hidden</p><h5 id="触发BFC的方式"><a href="#触发BFC的方式" class="headerlink" title="触发BFC的方式"></a>触发BFC的方式</h5><p>float 不为 none，浮动元素所在的区域就是一个 BFC 区域。<br>position 的值不是 static 或 relative 的元素所在的区域就是一个 BFC 区域<br>display为 table-cell 的表格单元格元素所在的区域也是一个 BFC 区域<br>overflow 不为 visible 的元素所在的区域也是一个 BFC 区域</p><h4 id="margin重叠-及防止方法-overflow-hidden"><a href="#margin重叠-及防止方法-overflow-hidden" class="headerlink" title="margin重叠 及防止方法(overflow:hidden)"></a>margin重叠 及防止方法(overflow:hidden)</h4><p>防止外边距重叠解决方案：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">外层元素<span class="hljs-attribute">padding</span>代替<br>外层元素 <span class="hljs-attribute">overflow</span>:hidden;<br><br>内层元素绝对定位 postion:absolute:<br>内层元素 加float:left;或<span class="hljs-attribute">display</span>:inline-block;<br>内层元素<span class="hljs-attribute">padding</span>:<span class="hljs-number">1px</span>;<br>内层元素透明边框 <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid transparent;<br></code></pre></td></tr></table></figure><h4 id="●-双边距重叠问题（外边距折叠）"><a href="#●-双边距重叠问题（外边距折叠）" class="headerlink" title="● 双边距重叠问题（外边距折叠）"></a>● 双边距重叠问题（外边距折叠）</h4><p>水平排放的盒子，水平间距是两个margin的累加<br>参考回答：<br>多个相邻（兄弟或者父子关系）普通流的块元素垂直方向marigin会重叠<br>折叠的结果为：<br><strong>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。<br>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。<br>如果它们相等，则仅为其中一个<br>两个外边距一正一负时，折叠结果是两者的相加的和。</strong></p><h4 id="IFC指的是行级格式化上下文，它有这样的一些布局规则"><a href="#IFC指的是行级格式化上下文，它有这样的一些布局规则" class="headerlink" title="IFC指的是行级格式化上下文，它有这样的一些布局规则"></a>IFC指的是<strong>行级格式化上下文</strong>，它有这样的一些布局规则</h4><p>（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。<br>（2）当一行不够的时候会自动切换到下一行。<br>（3）行级上下文的高度由内部最高的内联盒子的高度决定。</p><p><a href="https://pengzhenglong.github.io/2021/05/10/BFC/">博客：BFC–块级格式化上下文</a></p><h3 id="css布局"><a href="#css布局" class="headerlink" title="css布局"></a>css布局</h3><p>六种布局方式总结：圣杯布局、双飞翼布局、Flex布局、绝对定位布局、表格布局、网格布局。</p><ol><li>圣杯布局是指布局从上到下分为header、container、footer，然后container部分定为三栏布局。这种布局方式同样分为header、container、footer。圣杯布局的缺陷在于 center 是在 container 的padding中的，因此宽度小的时候会出现混乱。</li><li>双飞翼布局给center 部分包裹了一个 main 通过设置margin主动地把页面撑开。</li><li>Flex布局是由CSS3提供的一种方便的布局方式。</li><li>绝对定位布局是给container 设置position: relative和overflow: hidden，因为绝对定位的元素的参照物为第一个postion不为static的祖先元素。 left 向左浮动，right 向右浮动。center 使用绝对定位，通过设置left和right并把两边撑开。 center 设置top: 0和bottom: 0使其高度撑开。</li><li>表格布局的好处是能使三栏的高度统一。</li><li>网格布局可能是最强大的布局方式了，使用起来极其方便，但目前而言，兼容性并不好。网格布局，可以将页面分割成多个区域，或者用来定义内部元素的大小，位置，图层关系。</li></ol><h3 id="用纯-CSS-创建一个三角形的原理是什么？"><a href="#用纯-CSS-创建一个三角形的原理是什么？" class="headerlink" title="用纯 CSS 创建一个三角形的原理是什么？"></a>用纯 CSS 创建一个三角形的原理是什么？</h3><p>采用的是相邻边框连接处的均分原理。<br> 将元素的宽高设为0，只设置<br> border，把任意三条边隐藏掉（颜色设为transparent），剩下的就是一个三角形。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs maxima"> #<span class="hljs-built_in">demo</span> &#123;<br> <span class="hljs-built_in">width</span>: <span class="hljs-number">0</span>;<br> <span class="hljs-built_in">height</span>: <span class="hljs-number">0</span>;<br> <span class="hljs-built_in">border</span>-<span class="hljs-built_in">width</span>: 20px;<br> <span class="hljs-built_in">border</span>-<span class="hljs-built_in">style</span>: solid;<br> <span class="hljs-built_in">border</span>-<span class="hljs-built_in">color</span>: <span class="hljs-built_in">transparent</span> <span class="hljs-built_in">transparent</span> red <span class="hljs-built_in">transparent</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://pengzhenglong.github.io/2021/06/27/CSS%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2%E2%80%94border%E6%B3%95/">博客：CSS绘制三角形—border法</a></p><h3 id="meta-viewport-移动端适配"><a href="#meta-viewport-移动端适配" class="headerlink" title="meta viewport 移动端适配"></a>meta viewport 移动端适配</h3><p>meta viewport 有六个属性：<br>设置 viewport 的宽度：width<br>设置 viewport 的高度：height<br>设置页面的初始缩放值：initial-scale<br>允许用户最小缩放值：maximum-scale<br>允许用户最大缩放值: minimum-scale<br>是否允许用户进行缩放：user-scalable</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>不允许用户手指放大缩小页面，页面比例始终为 <span class="hljs-number">1</span>:<span class="hljs-number">1</span><br>&lt;meta name=<span class="hljs-string">&quot;viewport&quot;</span> content=<span class="hljs-string">&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>3 个 viewport：<br>1）layout viewport：浏览器会默认将 viewport 设置成一个比可视区域更宽的值，这就是 layout viewport，其宽度通过 document.documentElement.clientWidth 来获取；<br>2）visual viewport：跟浏览器可视区域大小相同的值，其宽度通过 document.documentElement.innerWidth 来获取；<br>3）idea viewport：完美适配移动端的 viewport，无论在何种分辨率的屏幕下，针对 idea viewport 而设计的网站，不需要缩放和横向滚动条就可以完美呈现给用户。</p><h3 id="画一条0-5px的线"><a href="#画一条0-5px的线" class="headerlink" title="画一条0.5px的线"></a>画一条0.5px的线</h3><p>1.采用meta viewport的方式</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix">&lt;meta <span class="hljs-attr">name=&quot;viewport&quot;</span> <span class="hljs-attr">content=&quot;width=device-width,</span> <span class="hljs-attr">initial-scale=0.5,</span> <span class="hljs-attr">minimum-scale=0.5,</span> <span class="hljs-attr">maximum-scale=0.5&quot;/&gt;</span><br></code></pre></td></tr></table></figure><p>这样子就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px<br>要记得viewport只针对于移动端，只在移动端上才能看到效果<br>2.采用transform: scale()的方式</p><p>transform: scale(0.5,0.5);<br>3.采用border-image的方式</p><h3 id="怎么让文本不自动换行？怎么让超过文本部分变成省略号？"><a href="#怎么让文本不自动换行？怎么让超过文本部分变成省略号？" class="headerlink" title="怎么让文本不自动换行？怎么让超过文本部分变成省略号？"></a>怎么让文本不自动换行？怎么让超过文本部分变成省略号？</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">white-space</span>:nowrap;<br><span class="hljs-attribute">overflow</span>:hidden;<br><span class="hljs-attribute">text-overflow</span>:ellipsis;<br></code></pre></td></tr></table></figure><h3 id="before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个元素的作用"><a href="#before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个元素的作用" class="headerlink" title="::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个元素的作用"></a>::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个元素的作用</h3><p>单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）<br>伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after、before等。<br>css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。</p><h3 id="绝对定位–position-的值-relative-和-absolute-定位原点是？"><a href="#绝对定位–position-的值-relative-和-absolute-定位原点是？" class="headerlink" title="绝对定位–position 的值 relative 和 absolute 定位原点是？"></a>绝对定位–position 的值 relative 和 absolute 定位原点是？</h3><p> 绝对定位是相对于元素 <strong>最近的已定位的父亲元素</strong> 来定位的（<strong>拥有定位的祖先元素：position的值不为static的元素</strong>）。如果元素没有已定位的父亲元素，那么<strong>它的位置则是相对于最初的包含块（body）</strong>，这点在做轮播时非常重要。</p><ol><li>absolute生成绝对定位的元素，相对于值不为static的第一个父元素的padding box进行定位，也可以理解为离自己这一级元素最近的一级5. 5.</li><li>fixed（老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。relative生成相对定位的元素，相对于其元素本身所在正常位置进行定位。</li><li>static默认值。<strong>没有定位，</strong>元素出现在正常的流中（忽略top,bottom,left,right,z-index声明）。</li><li>inherit规定从父元素继承position属性的值。</li><li>position设置为absolute或者relative的父元素的padding box的左上角为原点的。</li></ol><h4 id="答：relative定位的元素，是相对于元素本身的正常位置来进行定位的"><a href="#答：relative定位的元素，是相对于元素本身的正常位置来进行定位的" class="headerlink" title="答：relative定位的元素，是相对于元素本身的正常位置来进行定位的"></a>答：relative定位的元素，是相对于元素本身的正常位置来进行定位的</h4><p>absolute定位的元素，是相对于它的第一个position值不为static的祖先元素的padding box来进行定位的。这句话我们可以这样来理解，我们首先需要找到绝对定位元素的一个position的值不为static的祖先元素，然后相对于这个祖先元素的padding box来定位，也就是说在计算定位距离的时候，padding的值也要算进去。</p><h3 id="em-px-rem区别"><a href="#em-px-rem区别" class="headerlink" title="em\px\rem区别"></a>em\px\rem区别</h3><p>px：绝对单位，⻚⾯按精确像素展示。<br>em：<strong>相对单位</strong>，基准点为⽗节点字体的⼤⼩，如果⾃身定义了font-size按⾃身来计算（浏览器默认字体是 16px），整个⻚⾯内1em不是⼀个固定的值。<br>rem：<strong>相对单位</strong>，可理解为”root em”, 相对根节点html的字体⼤⼩来计算，CSS3新加属性<br>rem优缺点<br><a href="https://pengzhenglong.github.io/2021/06/16/Css%E5%8D%95%E4%BD%8Dpx%EF%BC%8Crem%EF%BC%8Cem%EF%BC%8Cvw%EF%BC%8Cvh%E7%9A%84%E5%8C%BA%E5%88%AB/">博客：</a></p><h5 id="优点：在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持rem了，兼容性也非常的好"><a href="#优点：在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持rem了，兼容性也非常的好" class="headerlink" title="优点：在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持rem了，兼容性也非常的好"></a>优点：在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持rem了，兼容性也非常的好</h5><h5 id="缺点：（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。（2）使用iframe引用也会出现问题。（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题"><a href="#缺点：（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。（2）使用iframe引用也会出现问题。（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题" class="headerlink" title="缺点：（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。（2）使用iframe引用也会出现问题。（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题"></a>缺点：（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。（2）使用iframe引用也会出现问题。（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题</h5><h3 id="CSS-哪些可以隐藏⻚⾯元素？"><a href="#CSS-哪些可以隐藏⻚⾯元素？" class="headerlink" title="CSS 哪些可以隐藏⻚⾯元素？"></a>CSS 哪些可以隐藏⻚⾯元素？</h3><p>display:none; visibility:hidden; opacity: 0; 等等</p><ol><li>opacity:0 ：本质上是将元素的透明度将为0，就看起来隐藏了，但是依然占据空间且可以交互</li><li>visibility:hidden : 与上⼀个⽅法类似的效果，占据空间，但是不可以交互了</li><li>overflow:hidden : 这个只隐藏元素溢出的部分，但是占据空间且不可交互</li><li>display:none : 这个是彻底隐藏了元素，元素从⽂档流中消失，既不占据空间也不交互，也不影响布局</li><li>z-index:-9999 : 原理是将层级放到底部，这样就被覆盖了，看起来隐藏了</li><li>transform: scale(0,0) : 平⾯变换，将元素缩放为0，但是依然占据空间，但不可交互</li></ol><h4 id="display-none与visible-hidden的区别"><a href="#display-none与visible-hidden的区别" class="headerlink" title="display:none与visible:hidden的区别"></a>display:none与visible:hidden的区别</h4><p>一般在面试中问display:none和visibility:hidden两者区别，面试者都能回答出：两者都是隐藏元素，前者不会占据空间，后者隐藏了依然占据空间。</p><p> visibility:隐藏对应的元素但不挤占该元素原来的空间。<br> display:隐藏对应的元素并且挤占该元素原来的空间。</p><p>两者区别：</p><ol><li>visibility具有继承性，给父元素设置visibility:hidden;子元素也会继承这个属性。但是如果重新给子元素设置visibility: visible,则子元素又会显示出来。这个和display: none有着质的区别</li><li>visibility: hidden不会影响计数器的计数，如图所示，visibility: hidden虽然让一个元素不见了，但是其计数器仍在运行。这和display: none完全不一样</li><li>visibility用来设置元素的可见状态。</li><li>display:none是会有回流，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”。</li><li>visibility: hidden; 不会有回流，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在，也即是说它仍具有高度、宽度等属性值。</li></ol><h3 id="●-display：table和本身的table有什么区别"><a href="#●-display：table和本身的table有什么区别" class="headerlink" title="● display：table和本身的table有什么区别"></a>● display：table和本身的table有什么区别</h3><p>参考回答：<br>Display:table和本身table是相对应的，区别在于，display：table的css声明能够让一个html元素和它的子节点像table元素一样，使用基于表格的css布局，是我们能够轻松定义一个单元格的边界，背景等样式，而不会产生因为使用了table那样的制表标签导致的语义化问题。<br>之所以现在逐渐淘汰了table系表格元素，是因为用div+css编写出来的文件比用table边写出来的文件小，而且table必须在页面完全加载后才显示，div则是逐行显示，table的嵌套性太多，没有div简洁</p><h3 id="●-z-index的定位方法"><a href="#●-z-index的定位方法" class="headerlink" title="● z-index的定位方法"></a>● z-index的定位方法</h3><p>参考回答：<br>z-index属性设置元素的堆叠顺序，拥有更好堆叠顺序的元素会处于较低顺序元素之前，z-index可以为负，且z-index只能在定位元素上奏效，该属性设置一个定位元素沿z轴的位置，如果为正数，离用户越近，为负数，离用户越远，它的属性值有auto，默认，堆叠顺序与父元素相等，number，inherit，从父元素继承z-index属性的值</p><h3 id="●-对CSS的新属性有了解过的吗？"><a href="#●-对CSS的新属性有了解过的吗？" class="headerlink" title="● 对CSS的新属性有了解过的吗？"></a>● 对CSS的新属性有了解过的吗？</h3><p>CSS3的新特性中，在布局方面新增了flex布局，在选择器方面新增了例如first-of-type,nth-child等选择器，在盒模型方面添加了box-sizing来改变盒模型，在动画方面增加了animation，2d变换，3d变换等，在颜色方面添加透明，rbga等，在字体方面允许嵌入字体和设置字体阴影，最后还有媒体查询等</p><h3 id="●-line-height和height的区别"><a href="#●-line-height和height的区别" class="headerlink" title="● line-height和height的区别"></a>● line-height和height的区别</h3><p>line-height一般是指布局里面一段文字上下行之间的高度，是针对字体来设置的，height一般是指容器的整体高度</p><h3 id="●-设置一个元素的背景颜色，背景颜色会填充哪些区域？"><a href="#●-设置一个元素的背景颜色，背景颜色会填充哪些区域？" class="headerlink" title="● 设置一个元素的背景颜色，背景颜色会填充哪些区域？"></a>● 设置一个元素的背景颜色，背景颜色会填充哪些区域？</h3><p>background-color设置的背景颜色会填充元素的content、padding、border区域，</p><h3 id="●-inline-block、inline和block的区别；为什么img是inline还可以设置宽高"><a href="#●-inline-block、inline和block的区别；为什么img是inline还可以设置宽高" class="headerlink" title="● inline-block、inline和block的区别；为什么img是inline还可以设置宽高"></a>● inline-block、inline和block的区别；为什么img是inline还可以设置宽高</h3><ol><li>Block是块级元素，其前后都会有换行符，能设置宽度，高度，margin/padding水平垂直方向都有效。</li><li>Inline：设置width和height无效，margin在竖直方向上无效，padding在水平方向垂直方向都有效，前后无换行符</li><li>Inline-block：能设置宽度高度，margin/padding水平垂直方向 都有效，前后无换行符</li><li>在 CSS 中，可替换元素（replaced element）的展示效果不是由 CSS 来控制的。这些元素是一种外部对象，它们外观的渲染，是独立于 CSS 的。</li><li>替换元素<br>简单来讲，它们的内容不受当前文档的样式的影响。CSS 能够影响可替换元素的位置，但不会影响到可替换元素自身的内容。例如<code>&lt;iframe&gt;</code>元素，可能具备本身的样式表，但它们不会继承父文档的样式。<br>典型的可替换元素有：浏览器<code>&lt;iframe&gt;&lt;video&gt;&lt;embed&gt;&lt;img&gt;</code><br>有些元素仅在特定状况下被做为可替换元素处理，例如：<code>&lt;input&gt;</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>前端基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础面试题(一)- 0.1+0.2为什么不等于0.3&amp;&amp;typeof NaN ||null&amp;&amp;setTimeout输出--同步与异步</title>
    <link href="/2022/02/13/JS%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98(%E4%B8%80)/"/>
    <url>/2022/02/13/JS%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="介绍-js-的基本数据类型"><a href="#介绍-js-的基本数据类型" class="headerlink" title="介绍 js 的基本数据类型"></a>介绍 js 的基本数据类型</h3><p>js 一共有六种基本数据类型，分别是 <code>Undefined、Null、Boolean、Number、String</code>，还有在 ES6 中新增的<strong> Symbol </strong> 和 ES10 中新增的<strong> BigInt </strong> 类型。</p><blockquote><p>Symbol 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。<br>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number (2^53 -1)  能够表示的安全整数范围。</p></blockquote><h3 id="typeof-NaN-的结果是什么？"><a href="#typeof-NaN-的结果是什么？" class="headerlink" title="typeof NaN 的结果是什么？"></a>typeof NaN 的结果是什么？</h3><p>NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出<br>数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">typeof NaN; <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;number&quot;</span><br></code></pre></td></tr></table></figure><p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN<br>为 true。</p><h3 id="null是对象吗？为什么？"><a href="#null是对象吗？为什么？" class="headerlink" title="null是对象吗？为什么？"></a>null是对象吗？为什么？</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">typeof 运算符对基本数据类型的运算：<br>typeof <span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;string&#x27;</span><br>typeof NaN <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;number&#x27;</span><br>typeof <span class="hljs-number">1</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;number&#x27;</span><br>typeof true <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;boolean&#x27;</span><br>typeof undefined <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;undefined&#x27;</span><br>typeof Symbol() <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;symbol&#x27;</span><br>typeof null <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;object&#x27;</span><br></code></pre></td></tr></table></figure><p>结论: null不是对象。</p><p>解释: 虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。</p><h3 id="JavaScript-有几种类型的值？你能画一下他们的内存图吗？"><a href="#JavaScript-有几种类型的值？你能画一下他们的内存图吗？" class="headerlink" title="JavaScript 有几种类型的值？你能画一下他们的内存图吗？"></a>JavaScript 有几种类型的值？你能画一下他们的内存图吗？</h3><p>涉及知识点：</p><ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><ol><li><p>两种类型的区别是：存储位置不同。</p></li><li><p>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</p></li><li><p>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在<br>栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实<br>体。</p></li></ol><h4 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。<br><br>基本数据类型....（参考<span class="hljs-number">1</span>）<br><br>复杂数据类型指的是   <span class="hljs-built_in">Object</span>   类型，所有其他的如 <span class="hljs-built_in">Array</span>、<span class="hljs-built_in">Date</span> 等数据类型都可以理解为 <span class="hljs-built_in">Object</span> 类型的子类。<br><br>两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中<br>保存对应的指针来获取堆中的值。<br></code></pre></td></tr></table></figure><h3 id="0-1-0-2为什么不等于0-3？"><a href="#0-1-0-2为什么不等于0-3？" class="headerlink" title="0.1+0.2为什么不等于0.3？"></a>0.1+0.2为什么不等于0.3？</h3><p>当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。</p><p>对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。<br>(toPrecision vs toFixed  –toPrecision 是处理精度，精度是从左至右第一个不为0的数开始数起。<br>–toFixed 是小数点后指定位数取整，从小数点开始数起。)</p><p>我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以<br>使用 es6 的 Number.EPSILON</p><h3 id="setTimeout输出值的时候，如何实现i按序输出？"><a href="#setTimeout输出值的时候，如何实现i按序输出？" class="headerlink" title="setTimeout输出值的时候，如何实现i按序输出？"></a>setTimeout输出值的时候，如何实现i按序输出？</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br>//<span class="hljs-number">55555</span><br></code></pre></td></tr></table></figure><p>这道题挺经典的，输出结果是什么呢？结果是1000毫秒之后，输出5个5（隔一秒输出在1000上乘个i就行）<br><strong>原因是，for循环在主线程内，setTimeout是异步方法，在任务队列里面，只有主线程执行完后，任务队列才执行，此时i的值已经是5，所以得到结果是5个5</strong></p><p>那么怎么解决呢？其实思路很容易，只要每次循环把当前的i值传入setTimeout内即可</p><h4 id="方法1：使用let"><a href="#方法1：使用let" class="headerlink" title="方法1：使用let"></a>方法1：使用let</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br>//<span class="hljs-number">01234</span><br></code></pre></td></tr></table></figure><p>使用let 相当于每次循环的时候都新建了1个i并为其赋值</p><p>这是因为第一个代码块中setTimeout 的 console.log(i); 的i是 var 定义的，所以是函数级的作用域，不属于 for 循环体，属于 全局变量。等到 for 循环结束，i 已经等于 5 了，这个时候再执行 setTimeout 的五个回调函数（参考上面对事件机制的阐述），里面的 console.log(i); 的 i 去向上找作用域，只能找到 全局作用下 的 i，即 5。所以输出都是 5。</p><p>而let是代码块的作用域，即是局部变量，所以每一次 for 循环，console.log(i); 都引用到 for 代码块作用域下的i，因为这样被引用，所以 for 循环结束后，这些作用域在 setTimeout 未执行前都不会被释放。</p><h4 id="方法2：定义函数并传值"><a href="#方法2：定义函数并传值" class="headerlink" title="方法2：定义函数并传值"></a>方法2：定义函数并传值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params">i</span>) </span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(i)<br>        &#125;, <span class="hljs-number">1000</span>);        <br>    &#125;<br>    a(i)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法3：IIFE（立即执行函数）"><a href="#方法3：IIFE（立即执行函数）" class="headerlink" title="方法3：IIFE（立即执行函数）"></a>方法3：IIFE（立即执行函数）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    ~<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) </span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(i)<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;(i)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>MDN<br>IIFE（立即调用函数表达式）<br>IIFE（ 立即调用函数表达式）是一个在定义时就会立即执行的  JavaScript 函数。</p></blockquote><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name">function</span> () &#123;<br>    statements<br>&#125;)()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这是一个被称为 自执行匿名函数 的设计模式，主要包含两部分。第一部分是包围在 圆括号运算符 () 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。</p><p>第二部分再一次使用 () 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。</p><h4 id="方法4：使用闭包"><a href="#方法4：使用闭包" class="headerlink" title="方法4：使用闭包"></a>方法4：使用闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<br>        (<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span><br>            () =&gt; <span class="hljs-built_in">console</span>.log(i)<br>        )(i), <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法5：setTimeout第三个参数传入i-是的，你没看错，setTimeout还有第三个参数"><a href="#方法5：setTimeout第三个参数传入i-是的，你没看错，setTimeout还有第三个参数" class="headerlink" title="方法5：setTimeout第三个参数传入i(是的，你没看错，setTimeout还有第三个参数)"></a>方法5：setTimeout第三个参数传入i(是的，你没看错，setTimeout还有第三个参数)</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">for</span> (var i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">(i)</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(i),<span class="hljs-number">1000</span>,i);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6844903700356399112#heading-7">0.1+0.2 !== 0.3？</a><br><a href="https://github.com/camsong/blog/issues/9">JavaScript 浮点数陷阱及解法</a><br><a href="https://segmentfault.com/a/1190000014045184">经典面试题 for循环内setTimeout顺序输出的解法</a></p>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 3--Teleport and  Suspense</title>
    <link href="/2022/02/05/Vue3Study(3)--Teleport%20and%20%20Suspense/"/>
    <url>/2022/02/05/Vue3Study(3)--Teleport%20and%20%20Suspense/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="1、teleport是什么"><a href="#1、teleport是什么" class="headerlink" title="1、teleport是什么"></a>1、teleport是什么</h3><p>teleport，字面意思就是<strong>远距离传送</strong>，我们可以把它理解为传送门的意思。</p><p>大家都知道，传送门的意思就是从一个地方传送到了另外一个地方。而 vue3 为什么要用 teleport 来表达呢？</p><p>其实，有一个非常常见的需求就是，我们经常要通过点击一个按钮，来实现模态框的效果。而在 vue3 之前，我们基本上控制它都是点击后<strong>上下会形成一个父子组件</strong>的关系，这样子感觉独立性就没有那么强了。<br><img src="/imageO/teleport.jpg" alt="模拟框"><br>因此， vue3 为了解决该问题，就用了 teleport 来解决。 teleport 就仿佛一个传送门，像上图这样，比如我们点击了打开按钮，那么点击完了之后，使用传送门瞬间移动到另外一个地方（模态框 Model ）。再点击关闭按钮，传送门模态框 Modal 就消失了。</p><p>通过这样的解释，相信大家对 teleport 有了一个基础的认识。</p><h4 id="1-2、实现模态框功能"><a href="#1-2、实现模态框功能" class="headerlink" title="1.2、实现模态框功能"></a>1.2、实现模态框功能</h4><p>接下来我们就来用这个功能，实现一个模态框，控制组件的显示和隐藏。</p><h5 id="（1）设置锚点"><a href="#（1）设置锚点" class="headerlink" title="（1）设置锚点"></a>（1）设置锚点</h5><p>我们现在 vue3 项目下的 /public/index.html 设置一个锚点，来放置组件的内容。具体代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span><br>    &lt;strong<br>      &gt;We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work<br>      properly without JavaScript enabled. Please enable it to<br>      continue.&lt;/strong<br>    &gt;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;modal&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- built files will be auto injected --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="（2）定义子组件"><a href="#（2）定义子组件" class="headerlink" title="（2）定义子组件"></a>（2）定义子组件</h5><p>接下来我们在 /src/components 下定义一个子组件，命名为 Modal.vue 。具体代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;#modal&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isOpen&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span> this is a modal<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;buttonClick&quot;</span>&gt;</span>Close<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">teleport</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>  <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> &#123; defineComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineComponent(&#123;</span><br>  props: &#123;<br><span class="javascript">    isOpen: <span class="hljs-built_in">Boolean</span>,</span><br>  &#125;,<br>  emits: &#123;<br><span class="javascript">    <span class="hljs-string">&quot;close-modal&quot;</span>: <span class="hljs-literal">null</span>,</span><br>  &#125;,<br><span class="javascript">     <span class="hljs-comment">//props对应props的内容</span></span><br><span class="javascript">    <span class="hljs-comment">//context名字可以自定义，只要上下对应即可，用来触发emit的内容</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">props, context</span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">const</span> buttonClick = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">      context.emit(<span class="hljs-string">&quot;close-modal&quot;</span>);</span><br>    &#125;;<br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br>      buttonClick,<br>    &#125;;<br>  &#125;,<br>&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>#center &#123;<br><span class="css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="css">  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid black;</span><br><span class="css">  <span class="hljs-attribute">background</span>: white;</span><br><span class="css">  <span class="hljs-attribute">position</span>: fixed;</span><br><span class="css">  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;</span><br><span class="css">  <span class="hljs-attribute">right</span>: <span class="hljs-number">50%</span>;</span><br><span class="css">  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;</span><br><span class="css">  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>;</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="（3）定义父组件"><a href="#（3）定义父组件" class="headerlink" title="（3）定义父组件"></a>（3）定义父组件</h5><p>之后我们再来定义一个父组件，命名为 index.vue 。具体代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn1&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;openModal&quot;</span>&gt;</span>打开模态框<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modal</span> <span class="hljs-attr">:isOpen</span>=<span class="hljs-string">&quot;modalIsOpen&quot;</span> @<span class="hljs-attr">close-modal</span>=<span class="hljs-string">&quot;onModalClose&quot;</span>&gt;</span><br>      My Modal!!!<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">modal</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> &#123; ref, defineComponent&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="javascript"><span class="hljs-keyword">import</span> Modal <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Modal.vue&#x27;</span></span><br><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineComponent(&#123;</span><br><span class="javascript">  name: <span class="hljs-string">&#x27;App&#x27;</span>,</span><br>  components: &#123;<br>    Modal<br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-comment">//添加响应式对象控制是否显示</span></span><br><span class="javascript">    <span class="hljs-keyword">const</span> modalIsOpen = ref(<span class="hljs-literal">false</span>)</span><br><span class="javascript">    <span class="hljs-comment">//打开模态框事件</span></span><br><span class="javascript">    <span class="hljs-keyword">const</span> openModal = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">      modalIsOpen.value = <span class="hljs-literal">true</span></span><br>    &#125;<br><span class="javascript">    <span class="hljs-comment">//关闭模态框事件</span></span><br><span class="javascript">    <span class="hljs-keyword">const</span> onModalClose = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">      modalIsOpen.value = <span class="hljs-literal">false</span></span><br>    &#125;<br>   <br><span class="javascript">    <span class="hljs-keyword">return</span>&#123;</span><br>      modalIsOpen,<br>      openModal,<br>      onModalClose<br>    &#125;<br>  &#125;<br>&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/imageO/teleport1.jpg" alt="运行效果"><br>大家可以看到，通过 teleport 的方式，现在的模态框成功显示在 id 为 app 的 div 同一层下，达到了相互独立，而不再是父子层级的结果。</p><p>在上面的案例中，我们学习到了通过使用 vue3 新推出的 teleport 特性，将组件渲染到另外一个 DOM 节点的方法，这样使得组件之间的独立性更强。</p><h3 id="2-用Suspense发起一个异步请求"><a href="#2-用Suspense发起一个异步请求" class="headerlink" title="2.用Suspense发起一个异步请求"></a>2.用Suspense发起一个异步请求</h3><h4 id="1、Suspense是什么"><a href="#1、Suspense是什么" class="headerlink" title="1、Suspense是什么"></a>1、Suspense是什么</h4><p>我们都知道，在<strong> web</strong> 世界中，经常遇到很多的异步请求困境。在发起异步请求时，我们往往需要去判断这些异步请求的状态，然后呢，根据这些请求来展示不同的界面。</p><p>那现在呢， <strong>vue3</strong> 推出了一个新的内置组件<strong> Suspense </strong> ， Suspense 是一个特殊的组件，它会有<strong>两个 template slot</strong> ，刚开始会渲染<strong> fallback</strong> 内容，直到达到某个条件以后，才会渲染正式的内容，也就是<strong> default </strong>的内容。这样呢，进行异步内容的渲染就会变得特别简单。</p><p>同时值得注意的是，如果使用 Suspense ，要返回一个 promise 而不是一个对象。</p><h4 id="2、用Suspense发起一个异步请求"><a href="#2、用Suspense发起一个异步请求" class="headerlink" title="2、用Suspense发起一个异步请求"></a>2、用Suspense发起一个异步请求</h4><p>接下来我们使用 Suspense 来发起一个异步请求。</p><p>首先我们在项目下定义一个子组件，命名为 AsyncShow.vue ，具体代码如下：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">result</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>  <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span></span><br><span class="xml">import &#123; defineComponent &#125; from &quot;vue&quot;;</span><br><span class="xml">export default defineComponent(&#123;</span><br><span class="xml">  setup() &#123;</span><br><span class="xml">    return new Promise((resolve) =&gt; &#123;</span><br><span class="xml">      setTimeout(() =&gt; &#123;</span><br><span class="xml">        return resolve(&#123;</span><br><span class="xml">          result: 42,</span><br><span class="xml">        &#125;);</span><br><span class="xml">      &#125;, 3000);</span><br><span class="xml">    &#125;);</span><br><span class="xml">  &#125;,</span><br><span class="xml">&#125;);</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>之后在项目下再定义一个父组件，命名为 DogShow.vue ，具体代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">async-show</span> /&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Loading !...<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> &#123; defineComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="javascript"><span class="hljs-keyword">import</span> AsyncShow <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/AsyncShow.vue&#x27;</span></span><br><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineComponent(&#123;</span><br><span class="javascript">  name: <span class="hljs-string">&#x27;App&#x27;</span>,</span><br>  components: &#123;<br>    AsyncShow,<br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;</span><br>    <br>  &#125;<br>&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最终浏览器的显示效果为：3秒后loading…变为42<br>大家可以看到，通过 Suspense ，可以很轻易的发起一个异步请求。刚开始是fallback状态，之后达到 3s 的时间之后，切换到default的状态，显示出对应的异步请求内容。</p><h4 id="3、用Suspense发起多个异步请求"><a href="#3、用Suspense发起多个异步请求" class="headerlink" title="3、用Suspense发起多个异步请求"></a>3、用Suspense发起多个异步请求</h4><p>我们不满足于现状，且互联网千奇百怪的，我们总不能一直只发送一个异步请求吧！所以，接下来我们就来实现发起多个异步请求的效果。</p><p>首先我们用一个免费的在线API ，来发起一个请求。接下来我们在项目的 components 文件下，再定义一个子组件，命名为 DogShow.vue ，具体代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;result &amp;&amp; result.message&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span></span><br><span class="javascript"><span class="hljs-keyword">import</span> &#123; defineComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineComponent(&#123;</span><br><span class="javascript">  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">const</span> rawData = <span class="hljs-keyword">await</span> axios.get(<span class="hljs-string">&#x27;https://dog.ceo/api/breeds/image/random&#x27;</span>)</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br>      result: rawData.data<br>    &#125;<br>  &#125;<br>&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p>接下来我们再把以上子组件的内容添加到父组件中，具体代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">async-show</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dog-show</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Loading !...<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> AsyncShow <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/AsyncShow.vue&#x27;</span></span><br><span class="javascript"><span class="hljs-keyword">import</span> DogShow <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/DogShow.vue&#x27;</span></span><br><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&#x27;App&#x27;</span>,</span><br>  components: &#123;<br>    AsyncShow,<br>    DogShow<br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;</span><br>    <br>  &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>大家可以看到，我们同时发起了两个异步请求，并且在Suspense中的default插槽里面同时使用。同样的，浏览器会先显示fallback的内容，之后等到时机到了，就显示我们请求的内容。</p><p>依据这样的例子，显示更多的请求也同样有效。这样对比起来，发送多个异步请求是不是就方便了许多。</p><h4 id="2-1、如何抓取错误"><a href="#2-1、如何抓取错误" class="headerlink" title="2.1、如何抓取错误"></a>2.1、如何抓取错误</h4><p>学完上面的内容，相信大家对Suspense的用法已经有所了解。那么，网络请求千奇百怪的，总不能每次都能够很顺畅的发起请求对吧。所以呢，我们来需要再来学习一下，当网络请求失败时，如何抓取Supsense包裹下的错误。</p><p>这个时候我们可以使用一个钩子函数，这个函数叫做 onErrorCaptured ，接下来我们来看下怎么抓取。</p><p>我们将父组件 index.vue 进行改造，具体代码如下：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">error</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">async-show</span> /&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dog-show</span> /&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Loading !...<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span></span><br><span class="xml">import &#123; onErrorCaptured &#125; from &#x27;vue&#x27;</span><br><span class="xml">import AsyncShow from &#x27;./components/AsyncShow.vue&#x27;</span><br><span class="xml">import DogShow from &#x27;./components/DogShow.vue&#x27;</span><br><br><span class="xml">export default &#123;</span><br><span class="xml">  name: &#x27;App&#x27;,</span><br><span class="xml">  components: &#123;</span><br><span class="xml">    AsyncShow,</span><br><span class="xml">    DogShow</span><br><span class="xml">  &#125;,</span><br><span class="xml">  setup() &#123;</span><br><span class="xml">    const error = ref(null)</span><br><span class="xml">    onErrorCaptured((e: any) =&gt; &#123;</span><br><span class="xml">      error.value = e</span><br><span class="xml">      return true</span><br><span class="xml">    &#125;)</span><br><span class="xml">    return&#123;</span><br><span class="xml">        error</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>此时我们再将 DogShow.vue 的接口进行修改，让其变成一个无效的API。代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> rawData = <span class="hljs-keyword">await</span> axios.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;https://dog.ceo/api/breeds/image&#x27;</span>)<br></code></pre></td></tr></table></figure><p>接下来我们就来看一下浏览器的运行效果：<br><img src="/imageO/Error.jpg" alt="error"><br>大家可以看到，修改成无效的 API 后，狗狗的图片也不显示了，最后最上方就是通过<strong> onErrorCaptured </strong> 这个生命周期捕捉到的错误，清晰明了。</p><h5 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6977869719546101796#heading-1">vue3的传送门teleport究竟有多神奇？suspense发起异步请求有多简约？</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 3--reactive, ref,toRef,toRefs用法和区别</title>
    <link href="/2022/01/30/Vue3Study(3)--ref+reactive+toRef+toRefs/"/>
    <url>/2022/01/30/Vue3Study(3)--ref+reactive+toRef+toRefs/</url>
    
    <content type="html"><![CDATA[<p>Vue3的CompositionAPI 创建响应式对象的方式：</p><ul><li>reactive</li><li>ref</li><li>toRef</li><li>toRefs</li></ul><hr><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><p>reactive 方法 根据传入的<strong>对象</strong> ，创建返回一个<strong>深度响应式对象</strong>。<strong>响应式对象</strong>看起来和传入的对象一样，但是，响应式对象属性值改动，不管层级有多深，都会触发响应式。新增和删除属性也会触发响应式。</p><p><img src="/imageO/reactive.jpg" alt="示例"></p><blockquote><p>重点：</p></blockquote><ul><li><p><strong>reactive 只能 给对象添加响应式</strong>，对于值类型，比如<code>String，Number，Boolean，Symbol</code>无能为力。</p></li><li><p>不能通过 …state 方式结构，这样会丢失响应式。下面这种方式是错误的</p></li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">//注意这里不能通过 ...<span class="hljs-keyword">state</span> 方式结构，这样会丢失响应式。<br> return &#123;<br>     ...<span class="hljs-keyword">state</span>  <br> &#125;<br></code></pre></td></tr></table></figure><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>上面我们提到 reactive 只能给对象，数组 添加响应式，如果想给值类型(String，Number，Boolean，Symbol)添加响应式，就要用到ref，所以ref作用如下：</p><ul><li>生成值类型响应式数据</li><li>通过.vue值修改</li><li>生成对象和数组类型的响应式对象**(对象和数组一般会选用reactive方式，比较便捷)**</li></ul><h3 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h3><ul><li>针对一个响应式对象（reactive 封装）的 prop（属性）创建一个ref，且保持响应式</li><li>两者 保持引用关系</li></ul><h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h3><p>toRefs 是一种用于破坏响应式对象并将其所有属性转换为 ref 的实用方法</p><ul><li>将响应式对象（reactive封装）转成普通对象</li><li>对象的每个属性(Prop)都是对应的ref</li><li>两者保持引用关系</li></ul><h3 id="如何选择-ref-和-reactive？建议"><a href="#如何选择-ref-和-reactive？建议" class="headerlink" title="如何选择 ref 和 reactive？建议"></a>如何选择 ref 和 reactive？建议</h3><ol><li>基础类型值(String，Number，Boolean，Symbol) 或单值对象(类似{ count: 1 }这样只有一个属性值的对象) 使用 ref</li><li>引用类型值(Object、Array)使用 reactive</li></ol><h4 id="使用toRefs-state-方式返回"><a href="#使用toRefs-state-方式返回" class="headerlink" title="使用toRefs(state)方式返回"></a>使用toRefs(state)方式返回</h4><p>注意reactive封装的响应式对象，不要通过解构的方式return，这是不具有响应式的。可以通过 toRefs 处理，然后再解构返回，这样才具有响应式</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> <span class="hljs-keyword">state</span> = reactive(&#123;...&#125;);<br>return &#123;...<span class="hljs-keyword">state</span>&#125;; // 这种方式将丢失响应式，是一种错误的方式<br>return <span class="hljs-keyword">to</span>Refs(<span class="hljs-keyword">state</span>); // works<br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs fortran">const <span class="hljs-keyword">data</span>: DataProps = reactive(&#123;<br>  <span class="hljs-built_in">count</span>: <span class="hljs-number">0</span>,<br>  increase: () =&gt; &#123;<br>    <span class="hljs-keyword">data</span>.<span class="hljs-built_in">count</span>++;<br>  &#125;,<br>  <span class="hljs-keyword">double</span>: computed(() =&gt; <span class="hljs-keyword">data</span>.<span class="hljs-built_in">count</span> * <span class="hljs-number">2</span>),<br>&#125;);<br>const refData = toRefs(<span class="hljs-keyword">data</span>);<br><span class="hljs-keyword">return</span> &#123;<br>  ...refData,<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/7034038818139275294#heading-1">Vue3： reactive, ref,toRef,toRefs用法和区别</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 3--Composition API 和 script setup</title>
    <link href="/2022/01/29/Vue3Study(2)/"/>
    <url>/2022/01/29/Vue3Study(2)/</url>
    
    <content type="html"><![CDATA[<p>说一下 Composition API<br>和 Options API 的区别？</p><p>Composition API 也叫组合式 API，它主要就是为了解决 Vue2 中 Options API 的问题。</p><p>一是在 Vue2 中只能固定用 data、computed、methods 等选项组织代码，在组件越来越复杂的时候，一个功能相关的属性和方法就会在文件上中下到处都有，很分散，变越来越难维护</p><p>二是 Vue2 中虽然可以用 minxin 来做逻辑的提取复用，但是 minxin 里的属性和方法名会和组件内部的命名冲突，还有当引入多个 minxin 的时候，我们使用的属性或方法是来于哪个 minxin 也不清楚</p><p>而 Composition API 刚才就解决了这两个问题，可以让我们自由的组织代码，同一功能相关的全部放在一起，代码有更好的可读性更便于维护，单独提取出来也不会造成命名冲突，所以也有更好的可扩展性</p><hr><h3 id="Option的弊端"><a href="#Option的弊端" class="headerlink" title="Option的弊端"></a>Option的弊端</h3><h4 id="Option的缺陷–反复横跳"><a href="#Option的缺陷–反复横跳" class="headerlink" title="Option的缺陷–反复横跳"></a>Option的缺陷–反复横跳</h4><p>相信大部分同学都维护过超过200行的.vue组件，新增或者修改一个需求，就需要分别在data，methods，computed里修改 ，滚动条反复上下移动，我称之为『反复横跳』 比如我们简单的加个拍脑门的需求 加个累加器 ，这种写代码上下反复横条的感觉， 相信大家都懂的</p><h4 id="Option的缺陷：mixin和this"><a href="#Option的缺陷：mixin和this" class="headerlink" title="Option的缺陷：mixin和this"></a>Option的缺陷：mixin和this</h4><p>反复横跳的本质，在于功能的分块组织，以及代码量太大了，如果我们能把代码控制在一屏，自然就解决了，vue2里的解决方案，是使用mixin来混合, 我们抽离一个counter.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      count:<span class="hljs-number">1</span><br>    &#125;<br>  &#125;,<br>  computed: &#123;<br>    <span class="hljs-function"><span class="hljs-title">double</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.count * <span class="hljs-number">2</span><br>    &#125;<br>  &#125;,<br>  methods:&#123;<br>    <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-built_in">this</span>.count++<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在App.vue中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Counter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./counter&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  mixins:[Counter],<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;<br> ...<br>  &#125;,<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>这样确实拆分了代码，但是有一个贼严重的问题，就是不打开counter.js，App.vue里的this上，count，add这些属性，是完全不知道从哪来的，你不知道是mixin，还是全局install，还是Vue.prototype.count设置的，数据来源完全模糊，调试爽死你，这也是option的一个大问题，this是个黑盒，template里写的count和double，完全不知道从哪来的</p><h4 id="mixin命名冲突"><a href="#mixin命名冲突" class="headerlink" title="mixin命名冲突"></a>mixin命名冲突</h4><p>如果有两个mixin，就更有意思了，比如我们又有一个需求，实时显示鼠标的坐标位置x，并且有一个乘以2的计算属性凑巧也叫double，再整一个mixin</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      x:<span class="hljs-number">0</span><br>    &#125;<br>  &#125;,<br>  methods:&#123;<br>    <span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params">e</span>)</span>&#123;<br>      <span class="hljs-built_in">this</span>.x = e.pageX<br>    &#125;<br>  &#125;,<br>  computed:&#123;<br>    <span class="hljs-function"><span class="hljs-title">double</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x*<span class="hljs-number">2</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-built_in">this</span>.update)<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">destroyed</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-built_in">this</span>.update)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是是一个独立维护的mixin，可能在N个地方用到，他根本不知道会不会有人和他冲突，然后用一下</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> Counter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./counter&#x27;</span><br><span class="hljs-keyword">import</span> Mouse <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mouse&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  mixins:[Counter,Mouse],<br>  ...... <br>&#125;<br></code></pre></td></tr></table></figure><p>两个mixin里都有double这个数，尴尬，看效果 ，lsp的count被覆盖了 很尴尬，而且在App.vue这里，你完全不知道这个double到底是哪个，调试很痛苦</p><h3 id="Composition-API-和-lt-script-setup-gt-上手"><a href="#Composition-API-和-lt-script-setup-gt-上手" class="headerlink" title="Composition API 和 &lt;script setup&gt; 上手"></a>Composition API 和 <code>&lt;script setup&gt;</code> 上手</h3><h4 id="Composition-API-拆分代码"><a href="#Composition-API-拆分代码" class="headerlink" title="Composition API 拆分代码"></a>Composition API 拆分代码</h4><p>之前的累加器和清单，虽然功能都很简单，但也属于两个功能模块。如果在一个页面里有这两个功能，那就需要在 data 和 methods 里分别进行配置。但这样的话，数据和方法相关的代码会写在一起，在组件代码行数多了以后就不好维护。所以，<strong>我们需要使用 Composition API 的逻辑来拆分代码，把一个功能相关的数据和方法都维护在一起。</strong><br>但是，所有功能代码都写在一起的话，也会带来一些问题：随着功能越来越复杂，script 内部的代码也会越来越多。因此，我们可以进一步对代码进行拆分，把功能独立的模块封装成一个独立的函数，真正做到按需拆分。<br>在下面，我们新建了一个函数 useTodos：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useTodos</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> title = ref(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">let</span> todos = ref([&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;学习Vue&quot;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;]);<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTodo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    todos.value.push(&#123;<br>      title: title.value,<br>      done: <span class="hljs-literal">false</span>,<br>    &#125;);<br>    title.value = <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clear</span>(<span class="hljs-params"></span>) </span>&#123;<br>    todos.value = todos.value.filter(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> !v.done);<br>  &#125;<br>  <span class="hljs-keyword">let</span> active = computed(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> todos.value.filter(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> !v.done).length;<br>  &#125;);<br>  <span class="hljs-keyword">let</span> all = computed(<span class="hljs-function">() =&gt;</span> todos.value.length);<br>  <span class="hljs-keyword">let</span> allDone = computed(&#123;<br>    get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> active.value === <span class="hljs-number">0</span>;<br>    &#125;,<br>    set: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>      todos.value.forEach(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> &#123;<br>        todo.done = value;<br>      &#125;);<br>    &#125;,<br>  &#125;);<br>  <span class="hljs-keyword">return</span> &#123; title, todos, addTodo, clear, active, all, allDone &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数就是把那些和清单相关的所有数据和方法，都放在函数内部定义并且返回，这样这个函数就可以放在任意的地方来维护。</p><p>而我们的组件入口，也就是<code>&lt;script setup&gt;</code>中的代码，就可以变得非常简单和清爽了。在下面的代码中，我们只需要调用 useTodos，并且获取所需要的变量即可，具体的实现逻辑可以去 useTodos 内部维护，代码可维护性大大增强。</p><p>使用</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dust"><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span></span><br><span class="xml">import </span><span class="hljs-template-variable">&#123; ref, computed &#125;</span><span class="xml"> from &quot;vue&quot;;</span><br><br><span class="xml">let count = ref(1)</span><br><span class="xml">function add()</span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    count.value++</span><br><span class="hljs-template-variable">&#125;</span><br><br><span class="xml">let </span><span class="hljs-template-variable">&#123; title, todos, addTodo, clear, active, all, allDone &#125;</span><span class="xml"> = useTodos();</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>我们在使用 Composition API 拆分功能时，也就是执行 useTodos 的时候，ref、computed 等功能都是从 Vue 中单独引入，而不是依赖<strong> this </strong> 上下文。其实你可以把组件内部的任何一段代码，从组件文件里抽离出一个独立的文件进行维护。</p><h4 id="获取鼠标位置函数封装"><a href="#获取鼠标位置函数封装" class="headerlink" title="获取鼠标位置函数封装"></a>获取鼠标位置函数封装</h4><p>现在，我们引入追踪鼠标位置的需求进行讲解，比如我们项目中可能有很多地方需要显示鼠标的坐标位置，那我们就可以在项目的 src/utils 文件夹下面新建一个 mouse.js。我们先从 Vue 中引入所需要的 ref 函数，然后暴露一个函数，函数内部和上面封装的 useTodos 类似，不过这次独立成了文件，放在 utils 文件下独立维护，提供给项目的所有组件使用。</p><p>想获取鼠标的位置，我们就需要监听 mousemove 事件。这需要在组件加载完毕后执行，在 Composition API 中，我们可以直接引入 onMounted 和 onUnmounted 来实现生命周期的功能。<br>看下面的代码，组件加载的时候，会触发 onMounted 生命周期，我们执行监听 mousemove 事件，从而去更新鼠标位置的 x 和 y 的值；组件卸载的时候，会触发 onUnmounted 生命周期，解除 mousemove 事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;ref, onMounted,onUnmounted&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useMouse</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> x = ref(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">const</span> y = ref(<span class="hljs-number">0</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params">e</span>) </span>&#123;<br>      x.value = e.pageX<br>      y.value = e.pageY<br>    &#125;<br>    onMounted(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, update)<br>    &#125;)<br>  <br>    onUnmounted(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, update)<br>    &#125;)<br>    <span class="hljs-keyword">return</span> &#123; x, y &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成了上面的鼠标事件封装这一步之后，我们在组件的入口就可以和普通函数一样使用 useMouse 函数。在下面的代码中，上面的代码返回的 x 和 y 的值可以在模板任意地方使用，也会随着鼠标的移动而改变数值。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br><span class="hljs-keyword">import</span> &#123;useMouse&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../utils/mouse&#x27;</span><br><br><span class="hljs-keyword">let</span> &#123;x,y&#125; = useMouse()<br><br></code></pre></td></tr></table></figure><p>简单来看，<strong>因为 ref 和 computed 等功能都可以从 Vue 中全局引入，所以我们就可以把组件进行任意颗粒度的拆分和组合，这样就大大提高了代码的可维护性和复用性。</strong></p><h3 id="lt-script-setup-gt-好用的功能"><a href="#lt-script-setup-gt-好用的功能" class="headerlink" title="&lt;script setup&gt; 好用的功能"></a><code>&lt;script setup&gt;</code> 好用的功能</h3><p>如果没有 <code>&lt;script setup&gt;</code>，那么我们需要写出下面这样的代码来实现累加器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> &gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> count = ref(<span class="hljs-number">1</span>)</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"></span>) </span>&#123;</span><br>      count.value++<br>    &#125;<br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br>      count,<br>      add<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们要在<code>&lt;script&gt;</code>中导出一个对象。我们在 setup 配置函数中写代码时，和 Options 的写法比，也多了两层嵌套。并且，我们还要在 setup 函数中，返回所有需要在模板中使用的变量和方法。上面的代码中，setup 函数就返回了 count 和 add。</p><blockquote><p>使用 <code>&lt;script setup&gt;</code>可以让代码变得更加精简，这也是现在开发 Vue 3 项目必备的写法。除了我们上面介绍的功能，<code>&lt;script setup&gt;</code> 还有其它一些很好用的功能，比如能够使用顶层的 await 去请求后端的数据等等，我们会在后面的项目中看到这种使用方法。</p></blockquote><h3 id="style-样式的特性"><a href="#style-样式的特性" class="headerlink" title="style 样式的特性"></a>style 样式的特性</h3><p>比如，在 style 标签上，当我们加上 <strong>scoped</strong> 这个属性的时候，我们定义的 CSS 就只会应用到当前组件的元素上，这样就很好地避免了一些样式冲突的问题。</p><p>如果在 scoped 内部，你还想写全局的样式，那么你可以用:global 来标记，这样能确保你可以很灵活地组合你的样式代码（后面项目中用到的话，我还会结合实战进行讲解）。而且我们甚至可以通过 v-bind 函数，直接在 CSS 中使用 JavaScript 中的变量。</p><p>在下面这段代码中, 我在 script 里定义了一个响应式的 color 变量，并且在累加的时候，将变量随机修改为红或者蓝。在 style 内部，我们使用<strong> v-bind</strong> 函数绑定 color 的值，就可以动态地通过 JavaScript 的变量实现 CSS 的样式修改，点击累加器的时候文本颜色会随机切换为红或者蓝。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">count</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span></span><br><span class="xml">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="xml">let count = ref(1)</span><br><span class="xml">let color = ref(&#x27;red&#x27;)</span><br><span class="xml">function add() &#123;</span><br><span class="xml">  count.value++</span><br><span class="xml">  color.value = Math.random()&gt;0.5? &quot;blue&quot;:&quot;red&quot;</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="xml">h1 &#123;</span><br><span class="xml">  color:v-bind(color);</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://time.geekbang.org/column/article/431955">新的代码组织方式：Composition API + script setup 到底好在哪里？</a><br><a href="https://juejin.cn/post/6891640356543627278#heading-2">那个忙了一夜的Vue3动画很好，就是太短了</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript专题之递归</title>
    <link href="/2022/01/24/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0--%E9%80%92%E5%BD%92/"/>
    <url>/2022/01/24/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0--%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<p>定义<br>程序调用自身的编程技巧称为递归(recursion)。</p><hr><h3 id="递归的三大要素"><a href="#递归的三大要素" class="headerlink" title="递归的三大要素"></a>递归的三大要素</h3><h4 id="第一要素：明确你这个函数想要干什么"><a href="#第一要素：明确你这个函数想要干什么" class="headerlink" title="第一要素：明确你这个函数想要干什么"></a>第一要素：明确你这个函数想要干什么</h4><p>对于递归，我觉得很重要的一个事就是，这个函数的功能是什么，他要完成什么样的一件事，而这个，是完全由你自己来定义的。也就是说，我们先不管函数里面的代码什么，而是要先明白，你这个函数是要用来干什么。</p><p>例如，我定义了一个函数</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">// 算 <span class="hljs-built_in">n</span> 的阶乘(假设<span class="hljs-built_in">n</span>不为<span class="hljs-number">0</span>)<br><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数的功能是算 n 的阶乘。好了，我们已经定义了一个函数，并且定义了它的功能是什么，接下来我们看第二要素。</p><h4 id="第二要素：寻找递归结束条件"><a href="#第二要素：寻找递归结束条件" class="headerlink" title="第二要素：寻找递归结束条件"></a>第二要素：寻找递归结束条件</h4><p>所谓递归，就是会在函数内部代码中，调用这个函数本身，所以，我们必须要找出递归的结束条件，不然的话，会一直调用自己，进入无底洞。也就是说，我们需要找出当参数为啥时，递归结束，之后直接把结果返回，请注意，这个时候我们必须能根据这个参数的值，能够直接知道函数的结果是什么。</p><p>例如，上面那个例子，当 n = 1 时，那你应该能够直接知道 f(n) 是啥吧？此时，f(1) = 1。完善我们函数内部的代码，把第二要素加进代码里面，如下</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">// 算 <span class="hljs-built_in">n</span> 的阶乘(假设<span class="hljs-built_in">n</span>不为<span class="hljs-number">0</span>)<br><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)&#123;<br>    <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> == <span class="hljs-number">1</span>)&#123;<br>        return <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有人可能会说，当 n = 2 时，那我们可以直接知道 f(n) 等于多少啊，那我可以把 n = 2 作为递归的结束条件吗？</p><p>当然可以，只要你觉得参数是什么时，你能够直接知道函数的结果，那么你就可以把这个参数作为结束的条件，所以下面这段代码也是可以的。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">// 算 <span class="hljs-built_in">n</span> 的阶乘(假设<span class="hljs-built_in">n</span>&gt;=<span class="hljs-number">2</span>)<br><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)&#123;<br>    <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> == <span class="hljs-number">2</span>)&#123;<br>        return <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意我代码里面写的注释，假设 n &gt;= 2，因为如果 n = 1时，会被漏掉，当 n &lt;= 2时，f(n) = n，所以为了更加<strong>严谨</strong>，我们可以写成这样：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">// 算 <span class="hljs-built_in">n</span> 的阶乘(假设<span class="hljs-built_in">n</span>不为<span class="hljs-number">0</span>)<br><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)&#123;<br>    <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">2</span>)&#123;<br>        return <span class="hljs-built_in">n</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第三要素：找出函数的等价关系式"><a href="#第三要素：找出函数的等价关系式" class="headerlink" title="第三要素：找出函数的等价关系式"></a>第三要素：找出函数的等价关系式</h4><p>第三要素就是，我们要不断缩小参数的范围，缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。</p><p>例如，f(n) 这个范围比较大，我们可以让 f(n) = n * f(n-1)。这样，范围就由 n 变成了 n-1 了，范围变小了，并且为了原函数f(n) 不变，我们需要让 f(n-1) 乘以 n。</p><p>说白了，就是要找到原函数的一个等价关系式，f(n) 的等价关系式为 n * f(n-1)，即</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">f(<span class="hljs-built_in">n</span>) = <span class="hljs-built_in">n</span> * f(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>)。<br></code></pre></td></tr></table></figure><blockquote><p>这个等价关系式的寻找，可以说是最难的一步了,所以需要多加做题联系…</p></blockquote><p>找出了这个等价，继续完善我们的代码，我们把这个等价式写进函数里。如下：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs excel">// 算 <span class="hljs-built_in">n</span> 的阶乘(假设<span class="hljs-built_in">n</span>不为<span class="hljs-number">0</span>)<br><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)&#123;<br>    <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">2</span>)&#123;<br>        return <span class="hljs-built_in">n</span>;<br>    &#125;<br>    // 把 f(<span class="hljs-built_in">n</span>) 的等价操作写进去<br>    return f(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>) * <span class="hljs-built_in">n</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，递归三要素已经都写进代码里了，所以这个 f(n) 功能的内部代码我们已经写好了。</p><p>这就是递归最重要的三要素，每次做递归的时候，你就强迫自己试着去寻找这三个要素。</p><h3 id="案例1：斐波那契数列"><a href="#案例1：斐波那契数列" class="headerlink" title="案例1：斐波那契数列"></a>案例1：斐波那契数列</h3><p>斐波那契数列的是这样一个数列：1、1、2、3、5、8、13、21、34….，即第一项 f(1) = 1,第二项 f(2) = 1…..,第 n 项目为 f(n) = f(n-1) + f(n-2)。求第 n 项的值是多少。</p><h4 id="1、第一递归-函数功能"><a href="#1、第一递归-函数功能" class="headerlink" title="1、第一递归 函数功能"></a>1、第一递归 函数功能</h4><p>假设 f(n) 的功能是求第 n 项的值，代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、找出递归结束的条件"><a href="#2、找出递归结束的条件" class="headerlink" title="2、找出递归结束的条件"></a>2、找出递归结束的条件</h4><p>显然，当 n = 1 或者 n = 2 ,我们可以轻易着知道结果 f(1) =1, f(2) = 1。所以递归结束条件可以为 n &lt;= 2。代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第三要素：找出函数的等价关系式-1"><a href="#第三要素：找出函数的等价关系式-1" class="headerlink" title="第三要素：找出函数的等价关系式"></a>第三要素：找出函数的等价关系式</h4><p>题目已经把等价关系式给我们了，所以我们很容易就能够知道 f(n) = f(n-1) + f(n-2)。我说过，等价关系式是最难找的一个，而这个题目却把关系式给我们了，这也太容易，好吧，我这是为了兼顾几乎零基础的读者。</p><p>所以最终代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">// 1.先写递归结束条件</span><br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>    <span class="hljs-comment">// 2.接着写等价关系式</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(n<span class="hljs-number">-1</span>) + <span class="hljs-built_in">f</span>(n - <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="案例2：小青蛙跳台阶"><a href="#案例2：小青蛙跳台阶" class="headerlink" title="案例2：小青蛙跳台阶"></a>案例2：小青蛙跳台阶</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h4 id="1、第一递归函数功能"><a href="#1、第一递归函数功能" class="headerlink" title="1、第一递归函数功能"></a>1、第一递归函数功能</h4><p>假设 f(n) 的功能是求青蛙跳上一个n级的台阶总共有多少种跳法，代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、找出递归结束的条件-1"><a href="#2、找出递归结束的条件-1" class="headerlink" title="2、找出递归结束的条件"></a>2、找出递归结束的条件</h4><p>我说了，求递归结束的条件，你直接把 n 压缩到很小很小就行了，因为 n 越小，我们就越容易直观着算出 f(n) 的多少，所以当 n = 1时，你知道 f(1) 为多少吧？够直观吧？即 f(1) = 1。代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第三要素：找出函数的等价关系式</p><p>每次跳的时候，小青蛙可以跳一个台阶，也可以跳两个台阶，也就是说，每次跳的时候，小青蛙有两种跳法。</p><p>第一种跳法：第一次我跳了一个台阶，那么还剩下n-1个台阶还没跳，剩下的n-1个台阶的跳法有f(n-1)种。</p><p>第二种跳法：第一次跳了两个台阶，那么还剩下n-2个台阶还没，剩下的n-2个台阶的跳法有f(n-2)种。</p><p>所以，小青蛙的全部跳法就是这两种跳法之和了，即 f(n) = f(n-1) + f(n-2)。至此，等价关系式就求出来了。于是写出代码：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)&#123;<br>    <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> == <span class="hljs-number">1</span>)&#123;<br>        return <span class="hljs-number">1</span>;<br>    &#125;<br>    ruturn f(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>) + f(<span class="hljs-built_in">n</span>-<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>大家觉得上面的代码对不对？</p><p>答是不大对，当 n = 2 时，显然会有 f(2) = f(1) + f(0)。我们知道，f(0) = 0，按道理是递归结束，不用继续往下调用的，但我们上面的代码逻辑中，会继续调用 f(0) = f(-1) + f(-2)。这会导致无限调用，进入<strong>死循环</strong>。</p><p>这也是我要和你们说的，关于<strong>递归结束条件是否够严谨问题</strong>，有很多人在使用递归的时候，由于结束条件不够严谨，导致出现死循环。也就是说，当我们在第二步找出了一个递归结束条件的时候，可以把结束条件写进代码，然后进行第三步，但是请注意，当我们第三步找出等价函数之后，还得再返回去第二步，根据第三步函数的调用关系，会不会出现一些漏掉的结束条件。就像上面，f(n-2)这个函数的调用，有可能出现 f(0) 的情况，导致死循环，所以我们把它补上。代码如下：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)&#123;<br>    //f(<span class="hljs-number">0</span>) = <span class="hljs-number">0</span>,f(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span>，等价于 <span class="hljs-built_in">n</span>&lt;=<span class="hljs-number">1</span>时，f(<span class="hljs-built_in">n</span>) = <span class="hljs-built_in">n</span>。<br>    <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">1</span>)&#123;<br>        return <span class="hljs-number">1</span>;<br>    &#125;<br>    ruturn f(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>) + f(<span class="hljs-built_in">n</span>-<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>有人可能会说，我不知道我的结束条件有没有漏掉怎么办？别怕，多练几道就知道怎么办了。</p><h3 id="递归优化"><a href="#递归优化" class="headerlink" title="递归优化"></a>递归优化</h3><blockquote><p>递归常见的问题：堆栈溢出、重复计算、空间度高(空间复杂度高)</p></blockquote><h4 id="1-考虑是否重复计算"><a href="#1-考虑是否重复计算" class="headerlink" title="1. 考虑是否重复计算"></a>1. 考虑是否重复计算</h4><p>告诉你吧，如果你使用递归的时候不进行优化，是有非常非常非常多的子问题被重复计算的。</p><blockquote><p>啥是子问题？ f(n-1),f(n-2)….就是 f(n) 的子问题了。</p></blockquote><p>例如对于案例2那道题，f(n) = f(n-1) + f(n-2)。递归调用的状态图如下：</p><p><img src="/imageO/leetcode1.jpg" alt="状态图"></p><p>看到没有，递归计算的时候，重复计算了两次 f(5)，五次 f(4)。。。。这是非常恐怖的，n 越大，重复计算的就越多，所以我们必须进行优化。</p><p>如何优化？一般我们可以把我们计算的结果保证起来，例如把 f(4) 的计算结果保证起来，当再次要计算 f(4) 的时候，我们先判断一下，之前是否计算过，如果计算过，直接把 f(4) 的结果取出来就可以了，没有计算过的话，再递归计算。</p><p>用什么保存呢？可以用数组或者 HashMap 保存，我们用数组来保存把，把 n 作为我们的数组下标，f(n) 作为值，例如 arr[n] = f(n)。f(n) 还没有计算过的时候，我们让 arr[n] 等于一个特殊值，例如 arr[n] = -1。</p><p>当我们要判断的时候，如果 arr[n] = -1，则证明 f(n) 没有计算过，否则， f(n) 就已经计算过了，且 f(n) = arr[n]。直接把值取出来就行了。代码如下：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs excel">// 我们实现假定 arr 数组已经初始化好的了。<br><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)&#123;<br>    <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">1</span>)&#123;<br>        return <span class="hljs-built_in">n</span>;<br>    &#125;<br>    //先判断有没计算过<br>    <span class="hljs-built_in">if</span>(arr[<span class="hljs-built_in">n</span>] != -<span class="hljs-number">1</span>)&#123;<br>        //计算过，直接返回<br>        return arr[<span class="hljs-built_in">n</span>];<br>    &#125;else&#123;<br>        // 没有计算过，递归计算,并且把结果保存到 arr数组里<br>        arr[<span class="hljs-built_in">n</span>] = f(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>) + f(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>);<br>        reutrn arr[<span class="hljs-built_in">n</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，使用递归的时候，必要 须要考虑有没有重复计算，如果重复计算了，一定要把计算过的状态保存起来。</p><h4 id="2-考虑是否可以自底向上"><a href="#2-考虑是否可以自底向上" class="headerlink" title="2. 考虑是否可以自底向上"></a>2. 考虑是否可以自底向上</h4><p>对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回。</p><p>不过，有时候当 n 比较大的时候，例如当 n = 10000 时，那么必须要往下递归10000层直到 n &lt;=1 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用。</p><p>对于这种情况，其实我们是可以考虑自底向上的做法的。例如我知道</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">f</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span>;<br><br><span class="hljs-attribute">f</span>(<span class="hljs-number">2</span>) = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>那么我们就可以推出 f(3) = f(2) + f(1) = 3。从而可以推出f(4),f(5)等直到f(n)。因此，我们可以考虑使用自底向上的方法来取代递归，代码如下：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs excel">public <span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>) &#123;<br>       <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">2</span>)<br>           return <span class="hljs-built_in">n</span>;<br>       <span class="hljs-built_in">int</span> <span class="hljs-symbol">f1</span> = <span class="hljs-number">1</span>;<br>       <span class="hljs-built_in">int</span> <span class="hljs-symbol">f2</span> = <span class="hljs-number">2</span>;<br>       <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br><br>       for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">3</span>; i &lt;= <span class="hljs-built_in">n</span>; i++) &#123;<br>           <span class="hljs-built_in">sum</span> = <span class="hljs-symbol">f1</span> + <span class="hljs-symbol">f2</span>;<br>           <span class="hljs-symbol">f1</span> = <span class="hljs-symbol">f2</span>;<br>           <span class="hljs-symbol">f2</span> = <span class="hljs-built_in">sum</span>;<br>       &#125;<br>       return <span class="hljs-built_in">sum</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>这种方法，其实也被称之为<strong>递推。</strong></p><blockquote><p>扩展</p></blockquote><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">### 将递归代码改写为非递归代码<br><br>### 尾递归：如何借助尾递归避免递归过深导致的堆栈溢出<br></code></pre></td></tr></table></figure><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6844903839783452680#heading-3">为什么你学不会递归？刷题几个月，告别递归，谈谈我的经验</a></p>]]></content>
    
    
    <categories>
      
      <category>js算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js算法学习</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue面试题总结</title>
    <link href="/2022/01/10/%5B%E6%80%BB%E7%BB%93%5DVue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2022/01/10/%5B%E6%80%BB%E7%BB%93%5DVue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>总结了最近的一些面试题和之前的知识点</p><hr><h2 id="较重要（加强）"><a href="#较重要（加强）" class="headerlink" title="较重要（加强）"></a>较重要（加强）</h2><h3 id="diff算法与虚拟dom"><a href="#diff算法与虚拟dom" class="headerlink" title="diff算法与虚拟dom"></a>diff算法与虚拟dom</h3><p><strong>如果直接渲染到真实dom上会引起整个dom树的重绘和重排</strong>,我们只更新我们修改的那一小块dom而不要更新整个dom呢？diff算法能够帮助我们。<br>我们先根据<strong>真实DOM生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使oldVnode的值为Vnode。</strong><br>diff的过程就是调用名为<strong>patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。</strong></p><ol start="2"><li>在采取diff算法比较新旧节点的时候，比较<strong>只会在同层级进行, 不会跨层级比较。</strong></li></ol><p>patch这个函数做了以下事情<br>判断<strong>两节点是否值得比较，不值得比较则用Vnode替换oldVnode,(比较子节点，逐层比较)值得比较则执行patchVnode</strong></p><p>patchVnode方法</p><ol><li>找到<strong>对应的真实dom，称为el</strong></li><li>判断Vnode和oldVnode<strong>是否指向同一个对象，如果是，那么直接return</strong></li><li>如果他们<strong>都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。</strong></li><li>如果<strong>oldVnode有子节点而Vnode没有，则删除el的子节点</strong></li><li>如果<strong>oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el</strong></li><li>如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要</li><li>状态变更时，记录新树和旧树的差异,最后把差异更新到真正的dom中<br>updateChildren<br><a href="https://pengzhenglong.github.io/2022/02/20/Vue--diff%E7%AE%97%E6%B3%95/">博客</a></li></ol><h4 id="虚拟DOM的优劣如何"><a href="#虚拟DOM的优劣如何" class="headerlink" title="虚拟DOM的优劣如何?"></a>虚拟DOM的优劣如何?</h4><p>优点:<br>保证性能下限: 虚拟DOM可以经过diff找出最小差异,然后批量进行patch,这种操作虽然比不上手动优化,但是<strong>比起粗暴的DOM操作性能要好很多,因此虚拟DOM可以保证性能下限</strong><br>无需手动操作DOM: 虚拟DOM的diff和patch都是在<strong>一次更新中自动进行的,我们无需手动操作DOM,极大提高开发效率</strong><br>跨平台: 虚拟DOM本质上是JavaScript对象,而DOM与平台强相关,相比之下虚拟DOM可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等<br>缺点:<br>无法进行极致优化: <strong>在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化,比如VScode采用直接手动操作DOM的方式进行极端的性能优化</strong></p><p><a href="https://juejin.cn/post/6844903903968903175#heading-14">虚拟DOM的优劣如何?</a></p><h4 id="虚拟-DOM-真的渲染更快，性能更好吗？"><a href="#虚拟-DOM-真的渲染更快，性能更好吗？" class="headerlink" title="虚拟 DOM 真的渲染更快，性能更好吗？"></a>虚拟 DOM 真的渲染更快，性能更好吗？</h4><h5 id="Virtual-DOM有什么好处？"><a href="#Virtual-DOM有什么好处？" class="headerlink" title="Virtual DOM有什么好处？"></a>Virtual DOM有什么好处？</h5><p>Virtual DOM 是以对象的方式来描述真实dom对象的，那么在<strong>做一些update的时候，可以在内存中进行数据比对，减少对真实dom的操作减少浏览器重排重绘的次数，减少浏览器的压力，提高程序的性能，并且因为diff算法的差异比较，记录了差异部分，那么在开发中就会提高了开发效率</strong><br><strong>跨端</strong><br>首先我们先区分一下跨平台和跨端的区别，跨平台指的是跨操作系统，而跨端是指客户端。跨平台简单的来说就是一套代码在mac和windows上都能跑，<strong>跨端就是跨客户端在web、ios、安卓等跑</strong></p><p>这时候虚拟dom就发挥了作用，就像vue、react等<strong>使用虚拟dom来缓存修改然后整体替换来优化性能，当然也可以用虚拟dom来缓存我们js画的页面，然后通过原生方法渲染出对应的原生组件，实现渲染跨端，正好我们对应dom绑定的方法也可以通过映射原生api实现逻辑跨端。</strong><br>其实Virtual DOM 的实现不仅仅是提高了开发效率和性能，并且也解决了跨终端开发的问题，例如rn， vux，uni-app 等实现跨终端开发的功能都是基于Virtual DOM的。<br><a href="https://juejin.cn/post/7034900283645755405">掘金</a></p><h5 id="Virtual-DOM-有什么坏处？-（内存消耗）"><a href="#Virtual-DOM-有什么坏处？-（内存消耗）" class="headerlink" title="Virtual DOM 有什么坏处？ （内存消耗）"></a>Virtual DOM 有什么坏处？ （内存消耗）</h5><p>在初始化时增加了对tpl的解析，<strong>最终需要生成Virtual DOM，那么就会产生一定的内存消耗，比初始化时直接挂载到真实dom 对象上的展示要慢一些</strong>。（纯web渲染的首页渲染慢，之前就一直被产品bb）<br>虚拟 DOM 真的渲染更快，性能更好吗？答案是否！<strong>虚拟dom增加了一层内存运算，那么渲染上肯定会慢上一些</strong></p><p><a href="https://juejin.cn/post/6844903991399153672">掘金</a></p><h3 id="vue-双向数据绑定原理？"><a href="#vue-双向数据绑定原理？" class="headerlink" title="vue 双向数据绑定原理？"></a>vue 双向数据绑定原理？</h3><p>vue.js是采用<strong>数据劫持结合发布者-订阅者模式的方式，使用 Object.defineProperty 将属性进行劫持（只会劫持已经存在的属性）</strong>，数组则是通过重写数组方法来实现。<strong>当页面使用对应属性时，每个属性都拥有自己的 dep 属性，存放他所依赖的 watcher（依赖收集），当属性变化后会通知自己对应的 watcher 去更新(派发更新)。</strong><br>Object.defineProperty(obj, prop, desc) obj 需要定义属性的当前对象，prop 当前需要定义的属性名，desc 属性描述符<br>proxy(target,handler)</p><h4 id="相比于vue2-x，使用proxy的优势如下"><a href="#相比于vue2-x，使用proxy的优势如下" class="headerlink" title="相比于vue2.x，使用proxy的优势如下"></a>相比于vue2.x，使用proxy的优势如下</h4><ol><li><p>Object.defineProperty 只能劫持对象的属性，而 Proxy 是直接代理对象。<br>由于 Object.defineProperty <strong>只能对属性进行劫持，需要遍历对象的每个属性，如果属性值也是对象，则需要深度遍历。而 Proxy 直接代理对象，不需要遍历操作。</strong><br>可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）<br>可以监听数组，不用再去单独的对数组做特异性操作 vue3.x可以检测到数组内部数据的变化</p></li><li><p>Object.defineProperty <strong>对新增属性需要手动进行 Observe。(监听并通知Watcher更新)</strong><br>由于 Object.defineProperty 劫持的是对象的属性，所以新增属性时，需要重新遍历对象，对其新增属性再使用 Object.defineProperty 进行劫持。</p></li><li><p>默认进行<strong>懒观察</strong>（lazy observation）。<br>在 2.x 版本里，<strong>不管数据多大，都会在一开始就为其创建观察者。当数据很大时，这可能会在页面载入时造成明显的性能压力。3.x 版本，只会对「被用于渲染初始可见部分的数据」创建观察者，而且 3.x 的观察者更高效。</strong></p></li><li><p>更<strong>精准的变更通知</strong>。<br>比例来说：2.x 版本中，<strong>使用 Vue.set 来给对象新增一个属性时，这个对象的所有 watcher 都会重新运行；3.x 版本中，只有依赖那个属性的 watcher 才会重新运行。</strong><br>详细资料可以参考：<br><a href="http://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension">《Vue.js 双向绑定的实现原理》</a><br><a href="https://pengzhenglong.github.io/2022/03/07/defineproPerty&&proxy/">Object.defineProperty和Proxy，Vue3.0为什么采用Proxy？</a></p></li></ol><h3 id="dep-watcher"><a href="#dep-watcher" class="headerlink" title="dep  watcher"></a>dep  watcher</h3><ol><li><p>Observer 将数据定义为响应式，<strong>每个 Observer 实例都有自己的 Dep 来管理依赖。</strong>实例化 Wacther 的时候进行求值会触发 getter ，进而执行 dep.depend() 将当前 Wacther 加入 Dep 维护的依赖列表，这就是依赖收集过程。</p></li><li><p>数据发生变化触发 setter 执行 dep.notify，Dep 会执行所有依赖的 update 方法并加入异步更新队列，这就是触发依赖过程。<br><a href="https://pengzhenglong.github.io/2022/02/25/Vue--Observer%E3%80%81Dep%E3%80%81Watcher/">博客</a></p></li></ol><h3 id="MVVM思想-重要-Vue并不是MVVM，而是类似于MV"><a href="#MVVM思想-重要-Vue并不是MVVM，而是类似于MV" class="headerlink" title="MVVM思想(重要)(Vue并不是MVVM，而是类似于MV*)"></a>MVVM思想(重要)(Vue并不是MVVM，而是类似于MV*)</h3><h4 id="什么是MVVM？"><a href="#什么是MVVM？" class="headerlink" title="什么是MVVM？"></a>什么是MVVM？</h4><p>视图模型双向绑定，是Model-View-ViewModel的缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，<strong>数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。以前是操作DOM结构更新视图，现在是数据驱动视图。</strong></p><h4 id="MVVM的优点"><a href="#MVVM的优点" class="headerlink" title="MVVM的优点"></a>MVVM的优点</h4><p>1.低耦合。视图（View）可以独立于Model变化和修改，一个Model可以绑定到不同的View上，当View变化的时候Model可以不变化，当Model变化的时候View也可以不变；<br>2.可重用性。你可以把一些视图逻辑放在一个Model里面，让很多View重用这段视图逻辑。<br>3.独立开发。开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计。<br>4.可测试。</p><h4 id="Observer（数据监听器）"><a href="#Observer（数据监听器）" class="headerlink" title="Observer（数据监听器）"></a>Observer（数据监听器）</h4><p> Observer的核心是通过Object.defineProprtty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher</p><h4 id="Watcher（订阅者）"><a href="#Watcher（订阅者）" class="headerlink" title="Watcher（订阅者）"></a>Watcher（订阅者）</h4><p>Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是：</p><ol><li>在自身实例化时往属性订阅器(dep)里面添加自己</li><li>自身必须有一个update()方法</li><li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调</li></ol><h4 id="Compile（指令解析器）"><a href="#Compile（指令解析器）" class="headerlink" title="Compile（指令解析器）"></a>Compile（指令解析器）</h4><p> Compile主要做的事情是解析模板指令，将模板中变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加鉴定数据的订阅者，一旦数据有变动，收到通知，更新试图</p><h3 id="computed-和-watch-的差异？"><a href="#computed-和-watch-的差异？" class="headerlink" title="computed 和 watch 的差异？"></a>computed 和 watch 的差异？</h3><p>（1）computed 是计算一个新的属性，并将该属性挂载到 Vue 实例上，而 <strong>watch 是监听已经存在且已挂载到 Vue 实例上的数据，所以用 watch 同样可以监听 computed 计算属性的变化。</strong><br>（2）computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。<br>（3）从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据。</p><h4 id="deep深度监听"><a href="#deep深度监听" class="headerlink" title="deep深度监听"></a>deep深度监听</h4><p>需要监听复杂数据（对象）内部属性的变化时，设置deep属性。<strong>Vue会递归的侦听数据和属性的变化（性能消耗较大）。也就是给所有数据和属性添加handler执行函数。</strong><br>性能优化 鉴于deep属性Vue性能消耗较大，对于要监听数据中某个属性的响应时，可以只给对应属性添加deep。<br><a href="https://juejin.im/post/5b98c4da6fb9a05d353c5fd7">《做面试的不倒翁：浅谈 Vue 中 computed 实现原理》</a><br><a href="https://juejin.im/post/5af908ea5188254265399009">《深入理解 Vue 的 watch 实现原理及其实现方式》</a><br><a href="https://pengzhenglong.github.io/2021/04/18/Vue&computed%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/">我的博客</a></p><h3 id="计算属性和watch的原理"><a href="#计算属性和watch的原理" class="headerlink" title="计算属性和watch的原理"></a>计算属性和watch的原理</h3><h4 id="计算属性原理"><a href="#计算属性原理" class="headerlink" title="计算属性原理"></a>计算属性原理</h4><p>这里还是按照惯例，将定义的computed属性的每一项使用Watcher类进行实例化，不过这里是按照computed-watcher的形式，来看下如何实例化的：</p><p>这里的变量watcher就是之前computed对应的computed-watcher实例，接下来会执行Watcher类专门为计算属性定义的两个方法，<strong>在执行evaluate方法进行求值的过程中又会触发computed内可以访问到的响应式数据的get，它们会将当前的computed-watcher作为依赖收集到自己的dep里，计算完毕之后将dirty置为false，表示已经计算过了。</strong></p><p>然后执行depend让计算属性内的响应式数据订阅当前的render-watcher，所以computed内的响应式数据会收集computed-watcher和render-watcher两个watcher，<strong>当computed内的状态发生变更触发set后，首先通知computed需要进行重新计算，然后通知到视图执行渲染，再渲染中会访问到computed计算后的值，最后渲染到页面。</strong></p><blockquote><p>Ps: 计算属性内的值须是响应式数据才能触发重新计算。</p></blockquote><p>watch总结：为什么计算属性有缓存功能？<strong>因为当计算属性经过计算后，内部的标志位会表明已经计算过了，再次访问时会直接读取计算后的值；</strong>为什么计算属性内的响应式数据发生变更后，计算属性会重新计算？<strong>因为内部的响应式数据会收集computed-watcher，变更后通知计算属性要进行计算，也会通知页面重新渲染，渲染时会读取到重新计算后的值</strong><br><a href="https://pengzhenglong.github.io/2022/03/10/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8Ccomputed%E7%9A%84%E5%8E%9F%E7%90%86/">博客：</a></p><h3 id="keep-alive-组件有什么作用？"><a href="#keep-alive-组件有什么作用？" class="headerlink" title="keep-alive 组件有什么作用？"></a>keep-alive 组件有什么作用？</h3><p>作用：<strong>实现组件缓存，保持这些组件的状态，以避免反复渲染导致的性能问题。 需要缓存组件 频繁切换，不需要重复渲染</strong><br>场景：tabs标签页 后台导航，vue性能优化</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Vue.js内部将DOM节点抽象成了一个个的<strong>VNode节点</strong>，keep-alive组件的缓存也是基于VNode节点的而不是直接存储DOM结构。<strong>它将满足条件（pruneCache与pruneCache）的组件在cache对象中缓存起来，在需要重新渲染的时候再将vnode节点从cache对象中取出并渲染。</strong></p><ol><li>使用 <strong>LRU 缓存机制进行缓存</strong>，max 限制缓存表的最大容量</li><li>根据设定的<strong>include/exclude（如果有）进行条件匹配,决定是否缓存。不匹配,直接返回组件实例</strong></li><li>根据组件<strong>ID 和 tag 生成缓存 Key ,并在缓存对象中查找是否已缓存过该组件实例。如果存在,直接取出缓存值并更新该 key 在 this.keys 中的位置(更新 key 的位置是实现 LRU 置换策略的关键)</strong></li><li>获取节点名称，或者根据节点 cid 等信息拼出当前 组件名称</li><li>获取 keep-alive 包裹着的第一个子组件对象及其组件名<br><a href="https://www.zoo.team/article/lru-keep-alive">参考文章</a></li></ol><h3 id="Vue中的key到底有什么⽤？"><a href="#Vue中的key到底有什么⽤？" class="headerlink" title="Vue中的key到底有什么⽤？"></a>Vue中的key到底有什么⽤？</h3><p>vue 中 key 值的作用可以分为两种情况来考虑。</p><h4 id="第一种情况是-v-if-中使用-key"><a href="#第一种情况是-v-if-中使用-key" class="headerlink" title="第一种情况是 v-if 中使用 key"></a>第一种情况是 v-if 中使用 key</h4><p>由于<strong>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。</strong>如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来<strong>唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用</strong>。这个时候 key 的作用是用来标识一个独立的元素。</p><h4 id="第二种情况是-v-for-中使用-key"><a href="#第二种情况是-v-for-中使用-key" class="headerlink" title="第二种情况是 v-for 中使用 key"></a>第二种情况是 v-for 中使用 key</h4><p>用<strong>v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略</strong>。如果数据项的顺序发生了改变，Vue <strong>不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素</strong>。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。<br><strong>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性</strong>。理想的 key 值是每项都有唯一 id。<br>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000016344599">《Vue 面试中，经常会被问到的面试题 Vue 知识点整理》</a><br><a href="https://www.zhihu.com/question/61064119">《Vue2.0 v-for 中 :key 到底有什么用？》</a><br><a href="https://www.cnblogs.com/RainyBear/p/8563101.html">《vue 中 key 的作用》</a></p><h5 id="Vue-为什么不建议用数组的下标index作为key"><a href="#Vue-为什么不建议用数组的下标index作为key" class="headerlink" title="Vue-为什么不建议用数组的下标index作为key"></a>Vue-为什么不建议用数组的下标index作为key</h5><blockquote><p>key 是给每一个 vnode 的唯一id,可以依靠 key,更准确,更快的拿到 oldVnode 中对应的 vnode 节点，高效的更新虚拟DOM</p></blockquote><ol><li><p>用组件唯一的 id（一般由后端返回）作为它的 key，实在没有的情况下，可以在获取到列表的时候通过某种规则为它们创建一个 key，并保证这个 key 在组件整个生命周期中都保持稳定。</p></li><li><p>如果你的列表顺序会改变，<strong>别用 index 作为 key，和没写基本上没区别</strong>，因为<strong>不管你数组的顺序怎么颠倒，index 都是 0, 1, 2 这样排列</strong>，导致 Vue 会复用错误的旧子节点，做很多额外的工作。列表顺序不变也尽量别用，可能会误导新人。</p></li><li><p>千万别用随机数作为 key，不然旧节点会被全部删掉，新节点重新创建，你的老板会被你气死。<br><a href="https://juejin.cn/post/6844904113587634184#heading-9">参考</a></p></li></ol><h3 id="路由实现原理是什么"><a href="#路由实现原理是什么" class="headerlink" title="路由实现原理是什么"></a>路由实现原理是什么</h3><p><strong>a.控制地址栏改变；b.根据地址栏的改变来控制组件的切换</strong></p><h4 id="hash通过-window-onhashchange-监听地址栏的改变"><a href="#hash通过-window-onhashchange-监听地址栏的改变" class="headerlink" title="hash通过 window.onhashchange 监听地址栏的改变"></a>hash通过 window.onhashchange 监听地址栏的改变</h4><p>URL的hash:URL的hash也就是锚点(#), <strong>本质上是改变window.location的href属性；</strong><br>我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新;</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>兼容低版本浏览器，Angular1.x和Vue默认使用的就是hash路由<br><strong>只有#符号之前的内容才会包含在请求中被发送到后端，也就是说就算后端没有对路由全覆盖，但是不会返回404错误</strong><br>hash值的改变，都会在浏览器的访问历史中增加一个记录，所以可以通过浏览器的回退、前进按钮控制hash的切换 会覆盖锚点定位元素的功能</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>不太美观，#后面传输的数据复杂的话会出现问题</p><h4 id="history通过-window-onpopState-监听地址栏的改变"><a href="#history通过-window-onpopState-监听地址栏的改变" class="headerlink" title="history通过 window.onpopState 监听地址栏的改变"></a>history通过 window.onpopState 监听地址栏的改变</h4><p>history接口是HTML5新增的, 它有六种模式改变URL而不刷新页面：<br> <strong>replaceState：替换原来的路径； pushState：使用新的路径；</strong><br> popState：路径的回退； go：向前或向后改变路径；<br>forward：向前改变路径； back：向后改变路径；</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>使用简单，比较美观<br>pushState()设置新的URL可以是任意与当前URL同源的URL，而hash只能改变#后面的内容，因此只能设置与当前URL同文档的URL<br><strong>pushState()设置的URL与当前URL一模一样时也会被添加到历史记录栈中，而hash#后面的内容必须被修改才会被添加到新的记录栈中</strong><br>pushState()可以通过stateObject参数添加任意类型的数据到记录中，而hash只能添加短字符串<br>pushState()可额外设置title属性供后续使用</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p><strong>前端的URL必须和向发送请求后端URL保持一致，否则会报404错误</strong><br>由于History API的缘故，<strong>低版本浏览器有兼容性问题</strong></p><p><a href="https://pengzhenglong.github.io/2022/02/17/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">博客</a></p><h3 id="nextTick的实现原理是什么？"><a href="#nextTick的实现原理是什么？" class="headerlink" title="nextTick的实现原理是什么？"></a>nextTick的实现原理是什么？</h3><p><strong>在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。</strong>nextTick主要使用了<strong>宏任务和微任务</strong>。 根据执行环境分别尝试采用<strong>Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个异步方法</strong>，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p><h3 id="nextTick的实现"><a href="#nextTick的实现" class="headerlink" title="nextTick的实现"></a>nextTick的实现</h3><ol><li>nextTick是Vue提供的一个全局API,是在下次DOM更新循环结束之后执行延迟回调，在修改数据之后使用$nextTick，则可以在回调中获取更新后的DOM；</li><li>Vue在更新DOM时是异步执行的。<strong>只要侦听到数据变化，Vue将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中1次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用；</strong></li><li>比如，我在干什么的时候就会使用nextTick，传一个回调函数进去，在里面执行dom操作即可；</li><li>我也有简单了解nextTick实现，它会在callbacks里面加入我们传入的函数，然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。</li></ol><h3 id="vuex-mutation为什么不可以包含异步回调，action-为什么可以"><a href="#vuex-mutation为什么不可以包含异步回调，action-为什么可以" class="headerlink" title="vuex  mutation为什么不可以包含异步回调，action 为什么可以"></a>vuex  mutation为什么不可以包含异步回调，action 为什么可以</h3><p>官网是这样说的：</p><p>现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。<strong>每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照</strong>。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：<strong>因为当 mutation 触发的时候，回调函数还没有被调用</strong>，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p><p>可以看到在Mutation中使用异步和同步最终页面的总和都是正确的，<strong>也就是说在Mutation中使用异步不会对数据造成丢失和其他影响。<br>然而我们注意Vue Devtools显示结果，当我们去查看多次Mutation状态时，发现同步的显示Ok，异步的Count显示为0 和我们预期结果不一致，所以会造成状态改变的不可追踪，</strong>所以官方说我们Mutation是同步的！</p><blockquote><p>重点事情<br>造成状态改变的不可追踪<br>在actions中就不会出现这种状态改变不可追踪的情况<br><a href="https://www.jianshu.com/p/5bb205f8b8eb">简书</a></p></blockquote><h2 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h2><h3 id="Composition-API-和-script-setup"><a href="#Composition-API-和-script-setup" class="headerlink" title="Composition API 和 script setup"></a>Composition API 和 script setup</h3><h4 id="Option的弊端-Option的缺陷–反复横跳-mixin和this"><a href="#Option的弊端-Option的缺陷–反复横跳-mixin和this" class="headerlink" title="Option的弊端(Option的缺陷–反复横跳,mixin和this)"></a>Option的弊端(Option的缺陷–反复横跳,mixin和this)</h4><p>说一下 Composition API和 Options API 的区别？</p><p>Composition API 也叫组合式 API，它主要就是为了解决 Vue2 中 Options API 的问题。</p><ol><li><p>一是在 Vue2 中<strong>只能固定用 data、computed、methods 等选项组织代码，在组件越来越复杂的时候，一个功能相关的属性和方法就会在文件上中下到处都有，很分散，变越来越难维护</strong></p></li><li><p>二是<strong>Vue2 中虽然可以用 minxin 来做逻辑的提取复用，但是 minxin 里的属性和方法名会和组件内部的命名冲突，还有当引入多个 minxin 的时候，我们使用的属性或方法是来于哪个 minxin 也不清楚</strong></p></li></ol><p>而 Composition API 刚才就解决了这两个问题，可以让我们自由的组织代码，同一功能相关的全部放在一起，代码有更好的可读性更便于维护，单独提取出来也不会造成命名冲突，所以也有更好的可扩展性<br><strong>我们需要使用 Composition API 的逻辑来拆分代码，把一个功能相关的数据和方法都维护在一起。</strong></p><h4 id="使用-lt-script-setup-gt-可以让代码变得更加精简"><a href="#使用-lt-script-setup-gt-可以让代码变得更加精简" class="headerlink" title="使用 &lt;script setup&gt;可以让代码变得更加精简"></a>使用 <code>&lt;script setup&gt;</code>可以让代码变得更加精简</h4><p>这也是现在开发 Vue 3 项目必备的写法。除了我们上面介绍的功能，<code>&lt;script setup&gt;</code> 还有其它一些很好用的功能，比如能够使用顶层的 await 去请求后端的数据等等</p><p><a href="https://pengzhenglong.github.io/2022/01/29/Vue3Study(2)/">博客</a></p><h3 id="reactive-ref-toRef-toRefs用法和区别"><a href="#reactive-ref-toRef-toRefs用法和区别" class="headerlink" title="reactive, ref,toRef,toRefs用法和区别"></a>reactive, ref,toRef,toRefs用法和区别</h3><h4 id="ref-reactive"><a href="#ref-reactive" class="headerlink" title="ref,reactive"></a>ref,reactive</h4><p>如果想给值类型(String，Number，Boolean，Symbol)添加响应式，就要用到ref<br>reactive 方法 根据传入的对象 ，创建返回一个深度响应式对象</p><h4 id="toRef-toRefs"><a href="#toRef-toRefs" class="headerlink" title="toRef  toRefs"></a>toRef  toRefs</h4><p>toRef  (针对一个响应式对象（reactive 封装）的 prop（属性）创建一个ref，且保持响应式，两者保持引用关系)</p><p>toRefs 是一种用于破坏响应式对象并将其所有属性转换为 ref 的实用方法<br>将响应式对象（reactive封装）转成普通对象<br>对象的每个属性(Prop)都是对应的ref<br>两者保持引用关系</p><h4 id="使用toRefs-state-方式返回"><a href="#使用toRefs-state-方式返回" class="headerlink" title="使用toRefs(state)方式返回"></a>使用toRefs(state)方式返回</h4><p>注意reactive封装的响应式对象，不要通过解构的方式return，这是不具有响应式的。可以通过 toRefs 处理，然后再解构返回，这样才具有响应式<br><a href="https://pengzhenglong.github.io/2022/01/30/Vue3Study(3)--ref+reactive+toRef+toRefs/#toRefs">博客</a></p><h3 id="Teleport，字面意思就是远距离传送，我们可以把它理解为传送门的意思"><a href="#Teleport，字面意思就是远距离传送，我们可以把它理解为传送门的意思" class="headerlink" title="Teleport，字面意思就是远距离传送，我们可以把它理解为传送门的意思"></a>Teleport，字面意思就是远距离传送，我们可以把它理解为传送门的意思</h3><p>其实，有一个非常常见的需求就是，我们经常要通过点击一个按钮，来实现模态框的效果。而在 vue3 之前，我们基本上控制它都是点击后上下会形成一个父子组件的关系，这样子感觉独立性就没有那么强了。</p><p>通过 teleport 的方式，<strong>现在的模态框成功显示在 id 为 app 的 div 同一层下，达到了相互独立，而不再是父子层级的结果。</strong></p><h3 id="用Suspense发起一个异步请求-处理多个异步请求方便"><a href="#用Suspense发起一个异步请求-处理多个异步请求方便" class="headerlink" title="用Suspense发起一个异步请求(处理多个异步请求方便)"></a>用Suspense发起一个异步请求(处理多个异步请求方便)</h3><p>那现在呢， vue3 推出了一个新的内置组件 Suspense ， Suspense 是一个特殊的组件，它会有两个 template slot ，刚开始会渲染 fallback 内容，直到达到某个条件以后，才会渲染正式的内容，也就是 default 的内容。这样呢，进行异步内容的渲染就会变得特别简单。<br><a href="https://pengzhenglong.github.io/2022/01/30/Vue3Study(3)--ref+reactive+toRef+toRefs/#toRefs">博客</a></p><h2 id="还未被问到（加强）"><a href="#还未被问到（加强）" class="headerlink" title="还未被问到（加强）"></a>还未被问到（加强）</h2><h3 id="vue-中-mixin-和-mixins-区别？"><a href="#vue-中-mixin-和-mixins-区别？" class="headerlink" title="vue 中 mixin 和 mixins 区别？"></a>vue 中 mixin 和 mixins 区别？</h3><h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><p>mixin 项目变得复杂的时候，多个组件间有重复的逻辑就会用到mixin,<strong>多个组件有相同的逻辑，抽离出来</strong><br>mixin并不是完美的解决方案，会有一些问题,<strong>vue3提出的Composition API旨在解决这些问题【追求完美是要消耗一定的成本的，如开发成本】</strong><br>场景：PC端新闻列表和详情页一样的右侧栏目，可以使用mixin进行混合<br>劣势：<br>1.变量来源不明确，不利于阅读<br>2.多mixin可能会造成命名冲突<br>3.mixin和组件可能出现多对多的关系，使得项目复杂度变高</p><p>mixin 用于全局混入，会影响到每个组件实例。<br>mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在<strong>遇到同名选项的时候也会有选择性的进行合并</strong><br>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc731b51882516c56ced6f">《前端面试之道》</a><br><a href="https://cn.vuejs.org/v2/guide/mixins.html">《混入》</a></p><h3 id="vue和jquery的区别（-解除jquery频繁操作dom，转为直接操作数据的思想。vue支持双向绑定，vue支持组件化）"><a href="#vue和jquery的区别（-解除jquery频繁操作dom，转为直接操作数据的思想。vue支持双向绑定，vue支持组件化）" class="headerlink" title="vue和jquery的区别（ 解除jquery频繁操作dom，转为直接操作数据的思想。vue支持双向绑定，vue支持组件化）"></a>vue和jquery的区别（ 解除jquery频繁操作dom，转为直接操作数据的思想。vue支持双向绑定，vue支持组件化）</h3><p>vue相对于jquery有什么优点：<br>一. 解除jquery频繁操作dom，转为直接操作数据的思想。<br>二. vue支持双向绑定<br>view的变化，viewmodel感知到变化view变化，通知model发生改变。反之model发生改变，view也改变。<br>三. vue支持组件化<br>提高开发效率。重复功能可单独写到组件中，供其他地方调用。</p><h3 id="单页面应用和多页面应用区别"><a href="#单页面应用和多页面应用区别" class="headerlink" title="单页面应用和多页面应用区别"></a>单页面应用和多页面应用区别</h3><h4 id="单页面应用"><a href="#单页面应用" class="headerlink" title="单页面应用"></a>单页面应用</h4><p><strong>只有一张Web页面的应用，是一种从Web服务器加载的富客户端，单页面跳转仅刷新局部资源 ，公共资源(js、css等)仅需加载一次</strong>，常用于<strong>PC端官网、购物等网站</strong><br>SPA的优点</p><p><strong>1.页面切换快</strong> 通过vue-router来局部切换组件,而非刷新整个页面,来实现无刷新切换页面的技术  (路由  <strong>history  hash</strong>)</p><p>页面每次切换跳转时，<strong>并不需要做html文件的请求，这样就节约了很多http发送时延</strong>，我们在切换页面的时候速度很快。</p><p><strong>2.用户体验好</strong></p><p>页面片段间的切换快，包括移动设备, 尤其是在网络环境差的时候, 因为组件已经预先加载好了, 并不需要发送网络请求, 所以用户体验好</p><p>SPA的缺点</p><p><strong>1.首屏加载速度慢</strong></p><p>首屏时需要请求一次html，同时还要发送一次js请求，两次请求回来了，首屏才会展示出来。相对于多页应用，首屏时间慢。</p><p><strong>2.不易于SEO</strong></p><p>SEO效果差，因为搜索引擎只认识html里的内容，不认识js的内容，而单页应用的内容都是靠js渲染生成出来的，搜索引擎不识别这部分内容，也就不会给一个好的排名，会导致SPA应用做出来的网页在百度和谷歌上的排名差。</p><h4 id="多页面应用"><a href="#多页面应用" class="headerlink" title="多页面应用"></a>多页面应用</h4><p><strong>多页面跳转刷新所有资源，每个公共资源(js、css等)需选择性重新加载，常用于 app 或 客户端等</strong><br>MPA的优点</p><p>1.首屏加载速度快</p><p>当我们访问页面的时候，<strong>服务器返回一个html，页面就会展示出来，这个过程只经历了一个HTTP请求</strong>，所以页面展示的速度非常快。</p><p>2.SEO效果好</p><p>搜索引擎在做网页排名的时候，要根据网页的内容才能给网页权重，来进行网页的排名。搜索引擎是可以识别html内容的，而我们每个页面所有的内容都放在html中，所以这种多页应用SEO排名效果好。<br>MPA的缺点</p><p>1.页面切换慢</p><p>因为每次跳转都需要发送一个 HTTP 请求，如果网络状态不好，在页面之间来回跳转时，就会发生明显的卡顿，影响用户体验。</p><p>2.用户体验不佳</p><p>如果网络慢,页面很容易半天加载不出来,用户体验非常不好<br><a href="https://juejin.cn/post/7018876571658223623">参考</a></p><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><h4 id="单向数据流的意思是指数据的改变只能从一个方向修改"><a href="#单向数据流的意思是指数据的改变只能从一个方向修改" class="headerlink" title="单向数据流的意思是指数据的改变只能从一个方向修改"></a>单向数据流的意思是指数据的改变只能从一个方向修改</h4><p>数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><blockquote><p>注意：在子组件直接用 v-model 绑定父组件传过来的 prop 这样是不规范的写法 开发环境会报警告</p></blockquote><p><strong>如果实在要改变父组件的 prop 值 可以再 data 里面定义一个变量 并用 prop 的值初始化它 之后用$emit 通知父组件去修改</strong></p><p>举个栗子：如一个父组件有两个子组件，分别为1和2。父组件向子组件传递数据，两个组件都接收到了父组件传递过来的数据，在组件1中修改父组件传递过来的数据，子组件2和父组件的值不会发生变化。这就是单向的数据流，子组件不能直接改变父组件的状态。但是如果父组件改变相应的数据，两个子组件的数据也会发生相应的改变。</p><h3 id="为何vue采用异步渲染"><a href="#为何vue采用异步渲染" class="headerlink" title="为何vue采用异步渲染"></a>为何vue采用异步渲染</h3><p>最终一次性更新DOM，避免重复操作DOM，耗费性能。</p><h3 id="vue-常用的修饰符？"><a href="#vue-常用的修饰符？" class="headerlink" title="vue 常用的修饰符？"></a>vue 常用的修饰符？</h3><p><strong>.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；</strong>.capture: 事件侦听，事件发生的时候会调用</p><h3 id="为什么v-for和v-if不建议用在一起"><a href="#为什么v-for和v-if不建议用在一起" class="headerlink" title="为什么v-for和v-if不建议用在一起"></a>为什么v-for和v-if不建议用在一起</h3><p>1.当 v-for 和 v-if 处于同一个节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。<strong>如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费</strong><br>2.这种场景建议使用 computed，先对数据进行过滤</p><blockquote><p>注意：3.x 版本中 v-if 总是优先于 v-for 生效。由于语法上存在歧义，建议避免在同一元素上同时使用两者。比起在模板层面管理相关逻辑，更好的办法是通过创建计算属性筛选出列表，并以此创建可见元素。<br>解惑传送门 ☞<a href="https://link.juejin.cn/?target=https://v3.cn.vuejs.org/guide/migration/v-if-v-for.html%23%25E6%25A6%2582%25E8%25A7%2588"># v-if 与 v-for 的优先级对比非兼容</a></p></blockquote><h3 id="使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽-I"><a href="#使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽-I" class="headerlink" title="使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽(I)"></a>使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽(I)</h3><p>vue中的插槽是一个非常好用的东西slot说白了就是一个占位的<br>在vue当中插槽包含三种</p><ol><li>一种是默认插槽（匿名）</li><li>一种是具名插槽</li><li>还有一种就是作用域插槽<br>匿名插槽就是没有名字的只要默认的都填到这里具名插槽指的是具有名字的</li></ol><p><a href="https://pengzhenglong.github.io/2021/05/01/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%BA%94)/">博客</a></p><h3 id="Vue动态加载组件的四种方式"><a href="#Vue动态加载组件的四种方式" class="headerlink" title="Vue动态加载组件的四种方式"></a>Vue动态加载组件的四种方式</h3><h4 id="import-require"><a href="#import-require" class="headerlink" title="import /require"></a>import /require</h4><p><a href="https://www.jianshu.com/p/686ce86f4042">Vue动态加载组件的四种方式</a></p><h3 id="观察者模式和发布订阅模式有什么不同？"><a href="#观察者模式和发布订阅模式有什么不同？" class="headerlink" title="观察者模式和发布订阅模式有什么不同？"></a>观察者模式和发布订阅模式有什么不同？</h3><p>发布订阅模式其实属于广义上的观察者模式</p><p>在观察者模式中，<strong>观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。</strong></p><p>而在发布订阅模式中，<strong>发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件</strong>，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。<br><a href="https://juejin.cn/post/6844903513009422343">参考</a></p><h3 id="defineProperty-和-Proxy-的区别"><a href="#defineProperty-和-Proxy-的区别" class="headerlink" title="defineProperty 和 Proxy 的区别"></a>defineProperty 和 Proxy 的区别</h3><p>为什么要用 Proxy 代替 defineProperty ？好在哪里？</p><ol><li>Object.defineProperty 是 Es5 的方法，Proxy 是 Es6 的方法</li><li>defineProperty 不能监听到数组下标变化和对象新增属性，Proxy 可以</li><li>defineProperty 是劫持对象属性，Proxy 是代理整个对象</li><li>defineProperty 局限性大，只能针对单属性监听，所以在一开始就要全部递归监听。Proxy 对象嵌套属性运行时递归，用到才代理，也不需要维护特别多的依赖关系，性能提升很大，且首次渲染更快</li><li>defineProperty 会污染原对象，修改时是修改原对象，Proxy 是对原对象进行代理并会返回一个新的代理对象，修改的是代理对象</li><li>defineProperty 不兼容 IE8，Proxy 不兼容 IE11</li></ol><h3 id="React-Vue-项目中-key-的作用"><a href="#React-Vue-项目中-key-的作用" class="headerlink" title="React/Vue 项目中 key 的作用"></a>React/Vue 项目中 key 的作用</h3><ol><li>key的作用是为了在diff算法执行时更快的找到对应的节点，<strong>提高diff速度，更高效的更新虚拟DOM</strong>;vue和react都是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。</li><li>为了在数据变化时强制更新组件，以避免<strong>“就地复用”</strong>带来的副作用。当 Vue.js 用<strong>v-for</strong> 更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。重复的key会造成渲染错误。<br>原理</li></ol><h3 id="Vue-scoped原理"><a href="#Vue-scoped原理" class="headerlink" title="Vue scoped原理"></a>Vue scoped原理</h3><ol><li>给HTML的DOM节点加一个不重复data属性(形如：data-v-2311c06a)来表示他的唯一性。</li><li>在每句css选择器的末尾（编译后的生成的css语句）加一个当前组件的data属性选择器的哈希特征值（如[data-v-2311c06a]）来私有化样式。</li></ol><p><a href="https://juejin.cn/post/6898633179587215367">掘金</a></p><h2 id="被问到了掌握了以及-较简单"><a href="#被问到了掌握了以及-较简单" class="headerlink" title="被问到了掌握了以及(较简单)"></a>被问到了掌握了以及(较简单)</h2><h3 id="Vue-的生命周期是什么？"><a href="#Vue-的生命周期是什么？" class="headerlink" title="Vue 的生命周期是什么？"></a>Vue 的生命周期是什么？</h3><p>Vue 的生命周期指的是<strong>组件从创建到销毁的一系列的过程，被称为 Vue 的生命周期</strong>。通过提供的 Vue 在生命周期各个阶段的钩子函数，我们可以很好的在 Vue 的各个生命阶段实现一些操作。</p><h3 id="Vue-的各个生命阶段是什么？"><a href="#Vue-的各个生命阶段是什么？" class="headerlink" title="Vue 的各个生命阶段是什么？"></a>Vue 的各个生命阶段是什么？</h3><p>Vue 一共有8个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br>（<span class="hljs-number">1</span>）<span class="hljs-keyword">beforeCreate </span>钩子函数，在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中我们是获取不到 data 数据的。<br><br>（<span class="hljs-number">2</span>）created 钩子函数，在实例创建完成后触发，此时可以访问 data、methods 等属性。但这个时候组件还没有被挂载到页面中去，所以这个时候访问不到 $el 属性。一般我们可以在这个函数中进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化。<br><br>（<span class="hljs-number">3</span>）<span class="hljs-keyword">beforeMount </span>钩子函数，在组件被挂载到页面之前触发。在 <span class="hljs-keyword">beforeMount </span>之前，会找到对应的 template，并编译成 render 函数。<br><br>（<span class="hljs-number">4</span>）mounted 钩子函数，在组件挂载到页面之后触发。此时可以通过 DOM API 获取到页面中的 DOM 元素。<br><br>（<span class="hljs-number">5</span>）<span class="hljs-keyword">beforeUpdate </span>钩子函数，在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候我们可以对可能会被移除的元素做一些操作，比如移除事件监听器。<br><br>（<span class="hljs-number">6</span>）updated 钩子函数，虚拟 DOM 重新渲染和打补丁之后调用。<br><br>（<span class="hljs-number">7</span>）<span class="hljs-keyword">beforeDestroy </span>钩子函数，在实例销毁之前调用。一般在这一步我们可以销毁定时器、解绑全局事件等。<br><br>（<span class="hljs-number">8</span>）destroyed 钩子函数，在实例销毁之后调用，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<br><br>当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。<br><br></code></pre></td></tr></table></figure><p>keep-alive的生命周期<br>初次进入时：<br>created &gt; mounted &gt; activated，<strong>退出后触发 deactivated</strong></p><p>再次进入：<br><strong>只会触发 activated</strong><br>事件挂载的方法等，只执行一次的放在 mounted 中；组件每次进去执行的方法放在 activated 中</p><h4 id="第一次页面加载会触发哪几个钩子？"><a href="#第一次页面加载会触发哪几个钩子？" class="headerlink" title="第一次页面加载会触发哪几个钩子？"></a>第一次页面加载会触发哪几个钩子？</h4><p>会触发 下面这几个beforeCreate, created, beforeMount, mounted 。</p><h3 id="父子组件的生命周期-子mounted-gt-父mounted-更新和销毁也是子组件先"><a href="#父子组件的生命周期-子mounted-gt-父mounted-更新和销毁也是子组件先" class="headerlink" title="父子组件的生命周期(子mounted -&gt; 父mounted (更新和销毁也是子组件先))"></a>父子组件的生命周期(子mounted -&gt; 父mounted (更新和销毁也是子组件先))</h3><p>组件，分别在他们的钩子函数中打印日志，观察执行顺序。得到的结果如图所示，父组件先创建，然后子组件创建；子组件先挂载，然后父组件挂载。<br>父beforeCreate-&gt; 父create -&gt; 子beforeCreate-&gt; 子created -&gt; 子mounted -&gt; 父mounted<br>更新过程<br>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated<br>销毁过程<br>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p><h4 id="注意-在父组件传递接口的数据给子组件时，一定要在子组件标签上加上v-if-”传递的接口数据”"><a href="#注意-在父组件传递接口的数据给子组件时，一定要在子组件标签上加上v-if-”传递的接口数据”" class="headerlink" title="注意 在父组件传递接口的数据给子组件时，一定要在子组件标签上加上v-if=”传递的接口数据”"></a>注意 在父组件传递接口的数据给子组件时，一定要在子组件标签上加上v-if=”传递的接口数据”</h4><p>解决方法</p><ol><li>v-if</li><li>在子组件中 watch 监听，父组件获取到值，这个值就会变化，自然是可以监听到的<br><a href="https://pengzhenglong.github.io/2022/02/28/Vue%E4%B8%AD%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E9%A1%BA/">博客：</a></li></ol><h3 id="父子组件及mixin的生命周期执行顺序"><a href="#父子组件及mixin的生命周期执行顺序" class="headerlink" title="父子组件及mixin的生命周期执行顺序"></a>父子组件及mixin的生命周期执行顺序</h3><p>mixin的生命周期钩子在组件的生命周期钩子之前执行</p><p>在父组件中引入了mixin，生命周期顺序如下：</p><p>mixin的beforeCreate &gt; 父beforeCreate &gt; mixin的created &gt; 父created &gt; mixin的beforeMount &gt; 父beforeMount &gt; 子beforeCreate &gt; 子created &gt; 子beforeMount &gt; <strong>子mounted &gt; mixin的mounted &gt;父mounted</strong></p><h3 id="vue组件的通信方式"><a href="#vue组件的通信方式" class="headerlink" title="vue组件的通信方式"></a>vue组件的通信方式</h3><p>props/$emit<br>父子组件通信父-&gt;子props，<br>子-&gt;父 $on、$emit 获取父子组件实例</p><p>获取实例的方式调用组件的属性或者方法parent、children Ref</p><p>父-&gt;子孙 Provide、inject 官方不推荐使用，但是写组件库时很常用</p><p>$emit/$on 自定义事件 兄弟组件通信Event Bus 实现跨组件通信 Vue.prototype.$bus = new Vue() 自定义事件<br>（event-bus原理:就是一个发布订阅着模式） (注册后挂载到Vue实例，实现监听和触发)<br><a href="https://juejin.cn/post/6888171141244911629">掘金</a><br>vuex 跨级组件通信<strong>Vuex、$attrs、$listeners Provide、inject</strong></p><h3 id="route-和-router-的区别？"><a href="#route-和-router-的区别？" class="headerlink" title="$route 和 $router 的区别？"></a>$route 和 $router 的区别？</h3><p>$route 是“路由信息对象”，包括 <strong>path，params，hash，query，fullPath，matched，name 等</strong>路由信息参数。而 $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</p><h4 id="router传参的两种方式-params-query"><a href="#router传参的两种方式-params-query" class="headerlink" title="router传参的两种方式(params /query)"></a>router传参的两种方式(params /query)</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><br><span class="hljs-attribute">params</span>、query是什么？ params：/router<span class="hljs-number">1</span>/:id ，/router<span class="hljs-number">1</span>/<span class="hljs-number">123</span>，/router<span class="hljs-number">1</span>/<span class="hljs-number">789</span> ,这里的id叫做params<br><span class="hljs-attribute">query</span>：/router<span class="hljs-number">1</span>?id=<span class="hljs-number">123</span> ,/router<span class="hljs-number">1</span>?id=<span class="hljs-number">456</span> ,这里的id叫做query。<br><br></code></pre></td></tr></table></figure><p>1、params是路由的一部分,必须要有。query是拼接在url后面的参数，没有也没关系。<br>params一旦设置在路由，params就是路由的一部分，如果这个路由有params传参，但是在跳转的时候没有传这个参数，会导致跳转失败或者页面会没有内容。<br>2、params、query不设置也可以传参，但是params不设置的时候，刷新页面或者返回参数会丢失，query并不会出现这种情况，这一点的在上面说过了</p><h3 id="vue-router-中的导航钩子函数"><a href="#vue-router-中的导航钩子函数" class="headerlink" title="vue-router 中的导航钩子函数"></a>vue-router 中的导航钩子函数</h3><p>（1）全局的钩子函数 beforeEach 和 afterEach</p><p>beforeEach 有三个参数，<strong>to 代表要进入的路由对象，from 代表离开的路由对象。next 是一个必须要执行的函数，</strong>如果不传参数，那就执行下一个钩子函数，如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错误的监听函数。</p><p>（2）单个路由独享的钩子函数 beforeEnter，它是在路由配置上直接进行定义的。</p><p>（3）组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。它们是直接在路由组<br>件内部直接进行定义的。</p><p>详细资料可以参考： <a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">《导航守卫》</a></p><h4 id="vue-router的push和replace的区别"><a href="#vue-router的push和replace的区别" class="headerlink" title="vue-router的push和replace的区别"></a>vue-router的push和replace的区别</h4><p>1.this.$router.push()</p><p>描述：跳转到不同的url，但这个方法会向history栈<strong>添加一个记录</strong>，点击后退会返回到上一个页面。</p><p>2.this.$router.replace()</p><p>描述：同样是跳转到指定的url，但是这个方法<strong>不会向history里面添加新的记录</strong>，点击返回，会跳转到上上一个页面。上一个记录是不存在的。</p><p>3.this.$router.go(n)</p><p>相对于当前页面向前或向后跳转多少个页面,类似 window.history.go(n)。n可为正数可为负数。正数返回上一个页面</p><p><a href="https://pengzhenglong.github.io/2022/02/17/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">前端两种路由实现和使用场景–Hash模式&amp;&amp;History模</a></p><h3 id="v-if-v-show-都会引发重绘与回流"><a href="#v-if-v-show-都会引发重绘与回流" class="headerlink" title="v-if  v-show (都会引发重绘与回流)"></a>v-if  v-show (都会引发重绘与回流)</h3><p>v-show</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">该指令的作用是根据真假切换元素的显示状态<br>原理是修改元素的display，实现显示隐藏<br>指令后面的内容，最终都会解析为布尔值<br>值为<span class="hljs-literal">true</span>元素显示，值为<span class="hljs-literal">false</span>元素隐藏<br>数据改变之后，对应元素的显示状态会同步更新<br></code></pre></td></tr></table></figure><p>v-if</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">该指令的作用是根据表达式的真假来切换元素的显示状态<br>本质是通过操作dom元素来切换显示状态<br>表达式的值为<span class="hljs-keyword">true</span>,元素存在于dom中；为<span class="hljs-keyword">false</span>，从dom树中移除<br>频繁的切换使用v-<span class="hljs-keyword">show</span>,反之使用v-<span class="hljs-keyword">if</span>,前者的切换消耗小<br></code></pre></td></tr></table></figure><h4 id="v-show不生效的情况（可能设置了display-block-important-层级更高的生效了）"><a href="#v-show不生效的情况（可能设置了display-block-important-层级更高的生效了）" class="headerlink" title="v-show不生效的情况（可能设置了display:block  !important 层级更高的生效了）"></a>v-show不生效的情况（可能设置了display:block  !important 层级更高的生效了）</h4><h4 id="v-if在条件切换时，会对标签进行适当的创建和销毁，而v-show则仅在初始化时加载一次，因此v-if的开销相对来说会比v-show大"><a href="#v-if在条件切换时，会对标签进行适当的创建和销毁，而v-show则仅在初始化时加载一次，因此v-if的开销相对来说会比v-show大" class="headerlink" title="v-if在条件切换时，会对标签进行适当的创建和销毁，而v-show则仅在初始化时加载一次，因此v-if的开销相对来说会比v-show大"></a>v-if在条件切换时，会对标签进行适当的创建和销毁，而v-show则仅在初始化时加载一次，因此v-if的开销相对来说会比v-show大</h4><blockquote><p>display:none; 会让元素脱离文档流，不占据页面空间。会引起回流和重绘</p></blockquote><p>visibility:hidden; 只是隐藏内容，并没有脱离文档流，会占据页面空间。会引起重绘。</p><h3 id="为什么vue组件中的data是一个函数而不是一个对象？"><a href="#为什么vue组件中的data是一个函数而不是一个对象？" class="headerlink" title="为什么vue组件中的data是一个函数而不是一个对象？"></a>为什么vue组件中的data是一个函数而不是一个对象？</h3><p>如果 <strong>data 是一个对象，当复用组件时，因为 data 都会指向同一个引用类型地址</strong>，其中一个组件的 data 一旦发生修改，则其他重用的组件中的 data 也会被一并修改。</p><p>如果 <strong>data 是一个返回对象的函数，因为每次重用组件时返回的都是一个新对象，引用地址不同，便不会出现如上问题。</strong></p><h3 id="v-model-原理其实就是绑定属性和事件。"><a href="#v-model-原理其实就是绑定属性和事件。" class="headerlink" title="v-model  (原理其实就是绑定属性和事件。)"></a>v-model  (原理其实就是绑定属性和事件。)</h3><p>当 v-model 使用在表单元素上时，会根据元素的不同而采用不同的处理：</p><ol><li>当<code>&lt;input type=&quot;text&quot;&gt;</code>文本 和 <code>&lt;textarea&gt;</code>上使用时，会默认给元素绑定名为 value 的<strong>prop</strong> 和名为 <strong>input</strong>的事件；</li><li>当<code>&lt;input type=&quot;checkbox&quot;&gt;</code>复选框 和 <code>&lt;input type=&quot;radio&quot;&gt;</code>单选框 上使用时，会默认绑定名为<strong>checked 的 prop 和名为 change</strong> 的事件；</li><li>当 <code>&lt;select&gt;</code>选择框 上使用时，则绑定名为 value 的 prop 和名为   <strong>change</strong> 的事件。<br><a href="https://pengzhenglong.github.io/2022/02/18/Vue--v-model/">博客</a></li></ol><h5 id="Vue3-中的-v-model"><a href="#Vue3-中的-v-model" class="headerlink" title="Vue3 中的 v-model"></a>Vue3 中的 v-model</h5><p>修改默认 prop 名和事件名<br>废除 model 选项和 .sync 修饰符<br>使用多个 v-model</p><h3 id="Vuex的理解及使用场景"><a href="#Vuex的理解及使用场景" class="headerlink" title="Vuex的理解及使用场景"></a>Vuex的理解及使用场景</h3><ul><li>Vuex 是一个专为 Vue 应用程序开发的<strong>状态管理模式</strong>。每一个 Vuex 应用的核心就是 store（仓库）。<br>Vuex 的状态存储是响应式的；当 Vue 组件从 store 中读取状态的时候，<br>若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新</li><li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation， 这样使得我们可以方便地跟踪每一个状态的变化 Vuex主要包括以下几个核心模块：</li></ul><ol><li>state：定义了应用的状态数据</li><li>Getter：在 store 中定义“getter”（可以认为是 store 的计算属性），<br>就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来， 且只有当它的依赖值发生了改变才会被重新计算</li><li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数</li><li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作</li><li><strong>Module</strong>：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中</li></ol><p><img src="/imageO/VueX.jpg" alt="vuex"></p><p><a href="https://pengzhenglong.github.io/2021/05/07/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%B8%83)/">博客</a></p><h3 id="开发中有没有遇见过数据修改了页面不刷新的情况"><a href="#开发中有没有遇见过数据修改了页面不刷新的情况" class="headerlink" title="开发中有没有遇见过数据修改了页面不刷新的情况"></a>开发中有没有遇见过数据修改了页面不刷新的情况</h3><p>最近在开发中遇到了这样一些情况，通过点击事件改变了对象里面得数据，但是页面却不刷新，后来发现，是在给对象添加属性时出现的问题。</p><p><strong>当vue的data里边声明或者已经赋值过的对象或者数组(数组里边的值是对象)时，向对象中添加新的属性，如果更新此属性的值，是不会更新视图的。</strong></p><p>当页面初始化时候，vue会遍历data对象所有的属性，并使用object.defineProperty把这些属性全部转化为getter/setter，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。</p><p>官方定义：<br>Vue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。</p><h4 id="方法1-set"><a href="#方法1-set" class="headerlink" title="方法1.$set"></a>方法1.$set</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 上传成功回调函数</span><br>handle<span class="hljs-constructor">AvatarSuccess(<span class="hljs-params">res</span>, <span class="hljs-params">file</span>)</span> &#123;<br>    this.<span class="hljs-constructor">$set(<span class="hljs-params">this</span>.<span class="hljs-params">form</span>,&#x27;<span class="hljs-params">imgUrl</span>&#x27;,<span class="hljs-params">res</span>.<span class="hljs-params">data</span>)</span>;<br>&#125;,<br></code></pre></td></tr></table></figure><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>可以发现 Vue.set() 和 this.$set() 这两个 api 的实现原理基本一模一样，都是使用了<strong>set函数</strong>。<br>vm.$set(target, key, value)中接收三个参数（targer 目标值，key 将要设置的属性，value 要设置的值）</p><p>$set的原理是在vue的原型上添加$set的方法，同时针对以下三种情况情况分别进行处理</p><ol><li>当key已经存在于target上的时候，直接修改target中对应key的值</li><li>当<strong>target是数组的时候，借助vue内部拦截处理后数组的splice方法进行赋值</strong>，vue对数组的’push’,’pop’,’shift’,’unshift’,’splice’,’sort’,’reverse’方法进行拦截处理成响应式，调用这些方法，可以触发界面的更新（后续添加这部分解说），如果只是通过arr[2]=2的方式进行赋值不会触发视图更新。</li><li>对于<strong>新增的属性，通过defineReactive把数据转化成getter和setter的方式，并触发数据变化通知</strong><br><a href="https://juejin.cn/post/7015214879330172964">掘金</a></li></ol><h4 id="方法2-forceUpdate"><a href="#方法2-forceUpdate" class="headerlink" title="方法2.$forceUpdate"></a>方法2.$forceUpdate</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">handleAvatarSuccess(res, file) &#123;<br>    <span class="hljs-keyword">this</span>.form.imgUrl = res.<span class="hljs-keyword">data</span>;<br>    <span class="hljs-keyword">this</span>.$forceUpdate();<br>&#125;,<br></code></pre></td></tr></table></figure><p><a href="https://v3.cn.vuejs.org/guide/change-detection.html#%E5%A3%B0%E6%98%8E%E5%93%8D%E5%BA%94%E5%BC%8F-property">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React面试题总结</title>
    <link href="/2022/01/10/%5B%E6%80%BB%E7%BB%93%5DRecat%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2022/01/10/%5B%E6%80%BB%E7%BB%93%5DRecat%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>总结了最近的一些面试题和之前的知识点(4.26)</p><hr><h2 id="较重要（加强）"><a href="#较重要（加强）" class="headerlink" title="较重要（加强）"></a>较重要（加强）</h2><h3 id="一、组件基础"><a href="#一、组件基础" class="headerlink" title="一、组件基础"></a>一、组件基础</h3><h4 id="1-React-事件机制"><a href="#1-React-事件机制" class="headerlink" title="1. React 事件机制"></a>1. React 事件机制</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">&lt;<span class="hljs-keyword">div</span> onClick=&#123;<span class="hljs-keyword">this</span>.handleClick.bind(<span class="hljs-keyword">this</span>)&#125;&gt;点我&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>React并不是将click事件绑定到了div的真实DOM上，而是在document处监听了所有的事件，当事件发生并且冒泡到document处的时候，<strong>React将事件内容封装并交由真正的处理函数运行。这样的方式不仅仅减少了内存的消耗，还能在组件挂在销毁时统一订阅和移除事件。</strong></p><p>除此之外，冒泡到document上的事件也不是原生的浏览器事件，而是由react自己实现的合成事件（SyntheticEvent）。因此如果不想要是事件冒泡的话应该调用event.preventDefault()方法，而不是调用event.stopProppagation()方法。<br><img src="/imageO/react10.png" alt="冒泡捕获"></p><p>JSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 document 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。</p><p>另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 <strong>event.preventDefault</strong>。</p><p>实现合成事件的目的如下：<br>●合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力；<br>●对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。</p><h4 id="2-React的事件和普通的HTML事件有什么不同？"><a href="#2-React的事件和普通的HTML事件有什么不同？" class="headerlink" title="2. React的事件和普通的HTML事件有什么不同？"></a>2. React的事件和普通的HTML事件有什么不同？</h4><p>区别：<br>●对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；<br>●对于事件函数处理语法，原生事件为字符串，react 事件为函数；<br>●react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。</p><p>合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：<br>●兼容所有浏览器，更好的跨平台；<br>●将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。<br>●方便 react 统一管理和事务机制。</p><p>事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。</p><h4 id="3-React-组件中怎么做事件代理？它的原理是什么？"><a href="#3-React-组件中怎么做事件代理？它的原理是什么？" class="headerlink" title="3. React 组件中怎么做事件代理？它的原理是什么？"></a>3. React 组件中怎么做事件代理？它的原理是什么？</h4><p>React基于Virtual DOM实现了一个SyntheticEvent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。</p><p>在React底层，主要对合成事件做了两件事：<br>●事件委派：React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。<br>●自动绑定：React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。</p><h4 id="4-React-高阶组件、Render-props、hooks-有什么区别，为什么要不断迭代"><a href="#4-React-高阶组件、Render-props、hooks-有什么区别，为什么要不断迭代" class="headerlink" title="4. React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代"></a>4. React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代</h4><p>这三者是目前react解决代码复用的主要方式：<br>●高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。<br>●render props是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术，更具体的说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。<br>●通常，render props 和高阶组件只渲染一个子节点。让 Hook 来服务这个使用场景更加简单。这两种模式仍有用武之地，（例如，一个虚拟滚动条组件或许会有一个 renderltem 属性，或是一个可见的容器组件或许会有它自己的 DOM 结构）。但在大部分场景下，Hook 足够了，并且能够帮助减少嵌套。</p><h5 id="（1）HOC"><a href="#（1）HOC" class="headerlink" title="（1）HOC"></a>（1）HOC</h5><p>官方解释∶ </p><blockquote><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。<br>简言之，HOC是一种组件的设计模式，HOC接受一个组件和额外的参数（如果需要），返回一个新的组件。HOC 是纯函数，没有副作用。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// hoc的定义</span><br>function withSubscription(<span class="hljs-type">WrappedComponent</span>, selectData) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    constructor(props) &#123;<br>      <span class="hljs-keyword">super</span>(props);<br>      <span class="hljs-keyword">this</span>.state = &#123;<br>        data: selectData(<span class="hljs-type">DataSource</span>, props)<br>      &#125;;<br>    &#125;<br>    <span class="hljs-comment">// 一些通用的逻辑处理</span><br>    render() &#123;<br>      <span class="hljs-comment">// ... 并使用新数据渲染被包装的组件!</span><br>      <span class="hljs-keyword">return</span> &lt;<span class="hljs-type">WrappedComponent</span> data=&#123;<span class="hljs-keyword">this</span>.state.data&#125; &#123;...<span class="hljs-keyword">this</span>.props&#125; /&gt;;<br>    &#125;<br>  &#125;;<br><br><span class="hljs-comment">// 使用</span><br>const <span class="hljs-type">BlogPostWithSubscription</span> = withSubscription(<span class="hljs-type">BlogPost</span>,<br>  (<span class="hljs-type">DataSource</span>, props) =&gt; <span class="hljs-type">DataSource</span>.getBlogPost(props.id));<br></code></pre></td></tr></table></figure><h5 id="（2）Render-props"><a href="#（2）Render-props" class="headerlink" title="（2）Render props"></a>（2）Render props</h5><p>官方解释∶</p><blockquote><p>“render prop”是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术<br>具有render prop 的组件接受一个返回React元素的函数，将render的渲染逻辑注入到组件内部。在这里，”render”的命名可以是任何其他有效的标识符。</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// DataProvider组件内部的渲染逻辑如下</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Components</span> </span>&#123;<br>     state = &#123;<br>    name: <span class="hljs-symbol">&#x27;To</span>m&#x27;<br>  &#125;<br><br>    render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;div&gt;<br>          &lt;p&gt;共享数据组件自己内部的渲染逻辑&lt;/p&gt;<br>          &#123; <span class="hljs-keyword">this</span>.props.render(<span class="hljs-keyword">this</span>.state) &#125;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用方式</span><br>&lt;<span class="hljs-type">DataProvider</span> render=&#123;data =&gt; (<br>  &lt;h1&gt;<span class="hljs-type">Hello</span> &#123;data.name&#125;&lt;/h1&gt;<br>)&#125;/&gt;<br></code></pre></td></tr></table></figure><p>由此可以看到，render props的优缺点也很明显∶<br>●优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。<br>●缺点：无法在 return 语句外访问数据、嵌套写法不够优雅</p><h5 id="（3）Hooks"><a href="#（3）Hooks" class="headerlink" title="（3）Hooks"></a>（3）Hooks</h5><p>官方解释∶</p><blockquote><p>Hook是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。通过自定义hook，可以复用代码逻辑。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 自定义一个获取订阅数据的hook</span><br>function useSubscription() &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">data</span> = DataSource.getComments();<br>  <span class="hljs-keyword">return</span> [<span class="hljs-keyword">data</span>];<br>&#125;<br><span class="hljs-comment">// </span><br>function CommentList(props) &#123;<br>  <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">data</span>&#125; = props;<br>  <span class="hljs-keyword">const</span> [subData] = useSubscription();<br>    ...<br>&#125;<br><span class="hljs-comment">// 使用</span><br>&lt;CommentList <span class="hljs-keyword">data</span>=<span class="hljs-string">&#x27;hello&#x27;</span> /&gt;<br></code></pre></td></tr></table></figure><p>以上可以看出，hook解决了hoc的prop覆盖的问题，同时使用的方式解决了render props的嵌套地狱的问题。hook的优点如下∶<br>●使用直观；<br>●解决hoc的prop 重名问题；<br>●解决render props 因共享数据 而出现嵌套地狱的问题；<br>●能在return之外使用数据的问题。</p><p>需要注意的是：hook只能在组件顶层使用，不可在分支语句中使用。</p><h5 id="总结∶"><a href="#总结∶" class="headerlink" title="总结∶"></a>总结∶</h5><p>Hoc、render props和hook都是为了解决代码复用的问题，但是hoc和render props都有特定的使用场景和明显的缺点。hook是react16.8更新的新的API，让组件逻辑复用更简洁明了，同时也解决了hoc和render props的一些缺点。</p><h4 id="6-React-Component-和-React-PureComponent-的区别"><a href="#6-React-Component-和-React-PureComponent-的区别" class="headerlink" title="6. React.Component 和 React.PureComponent 的区别"></a>6. React.Component 和 React.PureComponent 的区别</h4><p>PureComponent表示一个纯组件，可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。</p><p>在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。</p><p>不过，pureComponent中的 shouldComponentUpdate() 进行的是浅比较，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。</p><p>使用pureComponent的好处：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。</p><h4 id="7-Component-Element-Instance-之间有什么区别和联系？"><a href="#7-Component-Element-Instance-之间有什么区别和联系？" class="headerlink" title="7. Component, Element, Instance 之间有什么区别和联系？"></a>7. Component, Element, Instance 之间有什么区别和联系？</h4><p>●元素：一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。<br>●组件：一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。<br>●实例：一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。</p><p>函数式组件(Functional component)根本没有实例instance。类组件(Class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。</p><h4 id="8-React-createClass和extends-Component的区别有哪些？"><a href="#8-React-createClass和extends-Component的区别有哪些？" class="headerlink" title="8. React.createClass和extends Component的区别有哪些？"></a>8. React.createClass和extends Component的区别有哪些？</h4><p>React.createClass和extends Component的bai区别主要在于：<br>（1）语法区别<br>●createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。<br>●createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。</p><p>（2）propType 和 getDefaultProps<br>●React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.<br>●React.Component：通过设置两个属性propTypes和defaultProps</p><p>（3）状态的区别<br>●React.createClass：通过getInitialState()方法返回一个包含初始值的对象<br>●React.Component：通过constructor设置初始状态</p><p>（4）this区别<br>●React.createClass：会正确绑定this<br>●React.Component：由于使用了 ES6，这里会有些微不同，属性并不会自动绑定到 React 类的实例上。</p><p>（5）Mixins<br>●React.createClass：使用 React.createClass 的话，可以在创建组件时添加一个叫做 mixins 的属性，并将可供混合的类的集合以数组的形式赋给 mixins。<br>●如果使用 ES6 的方式来创建组件，那么 React mixins 的特性将不能被使用了。</p><h4 id="11-哪些方法会触发-React-重新渲染？重新渲染-render-会做些什么？"><a href="#11-哪些方法会触发-React-重新渲染？重新渲染-render-会做些什么？" class="headerlink" title="11. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？"></a>11. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</h4><p><strong>（1）哪些方法会触发 react 重新渲染?</strong><br><strong>●setState（）方法被调用</strong><br>setState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候不一定会重新渲染。<strong>当 setState 传入 null 时，并不会触发 render。</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  state = &#123;<br>    a: <span class="hljs-number">1</span><br>  &#125;;<br><br>  render() &#123;<br>    console.log(<span class="hljs-string">&quot;render&quot;</span>);<br>    <span class="hljs-keyword">return</span> (<br>      &lt;<span class="hljs-type">React</span>.<span class="hljs-type">Fragement</span>&gt;<br>        &lt;p&gt;&#123;<span class="hljs-keyword">this</span>.state.a&#125;&lt;/p&gt;<br>        &lt;button<br>          onClick=&#123;() =&gt; &#123;<br>            <span class="hljs-keyword">this</span>.setState(&#123; a: <span class="hljs-number">1</span> &#125;); <span class="hljs-comment">// 这里并没有改变 a 的值</span><br>          &#125;&#125;<br>        &gt;<br>          <span class="hljs-type">Click</span> me<br>        &lt;/button&gt;<br>        &lt;button onClick=&#123;() =&gt; <span class="hljs-keyword">this</span>.setState(<span class="hljs-literal">null</span>)&#125;&gt;setState <span class="hljs-literal">null</span>&lt;/button&gt;<br>        &lt;<span class="hljs-type">Child</span> /&gt;<br>      &lt;/<span class="hljs-type">React</span>.<span class="hljs-type">Fragement</span>&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>●父组件重新渲染</strong><br>只要父组件重新渲染了，即使传入子组件的 props 未发生变化，那么子组件也会重新渲染，进而触发 render</p><p><strong>（2）重新渲染 render 会做些什么?</strong><br>●会对新旧 VNode 进行对比，也就是我们所说的Diff算法。<br>●对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面<br>●遍历差异对象，根据差异的类型，根据对应对规则更新VNode</p><p>React 的处理 render 的基本思维模式是每次一有变动就会去重新渲染整个应用。在 Virtual DOM 没有出现之前，最简单的方法就是直接调用 innerHTML。Virtual DOM厉害的地方并不是说它比直接操作 DOM 快，而是说不管数据怎么变，都会尽量以最小的代价去更新 DOM。React 将 render 函数返回的虚拟 DOM 树与老的进行比较，从而确定 DOM 要不要更新、怎么更新。当 DOM 树很大时，遍历两棵树进行各种比对还是相当耗性能的，特别是在顶层 setState 一个微小的修改，默认会去遍历整棵树。尽管 React 使用高度优化的 Diff 算法，但是这个过程仍然会损耗性能.</p><h4 id="13-React声明组件有哪几种方法，有什么不同？"><a href="#13-React声明组件有哪几种方法，有什么不同？" class="headerlink" title="13. React声明组件有哪几种方法，有什么不同？"></a>13. React声明组件有哪几种方法，有什么不同？</h4><p>React 声明组件的三种方式：<br>●函数式定义的无状态组件<br>●ES5原生方式React.createClass定义的组件<br>●ES6形式的extends React.Component定义的组件</p><p><strong>（1）无状态函数式组件</strong><br>它是为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到state状态的操作<br>组件不会被实例化，整体渲染性能得到提升，不能访问this对象，不能访问生命周期的方法</p><p><strong>（2）ES5 原生方式 React.createClass // RFC</strong><br>React.createClass会自绑定函数方法，导致不必要的性能开销，增加代码过时的可能性。</p><p><strong>（3）E6继承形式 React.Component // RCC</strong><br>目前极为推荐的创建有状态组件的方式，最终会取代React.createClass形式；相对于 React.createClass可以更好实现代码复用。</p><p>无状态组件相对于于后者的区别：<br>与无状态组件相比，React.createClass和React.Component都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。</p><p>React.createClass与React.Component区别：<br>① 函数this自绑定<br>●React.createClass创建的组件，其每一个成员函数的this都有React自动绑定，函数中的this会被正确设置。<br>●React.Component创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。<br>② 组件属性类型propTypes及其默认props属性defaultProps配置不同<br>●React.createClass在创建组件时，有关组件props的属性类型及组件默认的属性会作为组件实例的属性来配置，其中defaultProps是使用getDefaultProps的方法来获取默认组件属性的<br>●React.Component在创建组件时配置这两个对应信息时，他们是作为组件类的属性，不是组件实例的属性，也就是所谓的类的静态属性来配置的。<br>③ 组件初始状态state的配置不同<br>●React.createClass创建的组件，其状态state是通过getInitialState方法来配置组件相关的状态；<br>●React.Component创建的组件，其状态state是在constructor中像初始化组件属性一样声明的。</p><h4 id="14-对有状态组件和无状态组件的理解及使用场景"><a href="#14-对有状态组件和无状态组件的理解及使用场景" class="headerlink" title="14. 对有状态组件和无状态组件的理解及使用场景"></a>14. 对有状态组件和无状态组件的理解及使用场景</h4><p>**（1）有状态组件 **<br><strong>特点：</strong><br>●是类组件<br>●有继承<br>●可以使用this<br>●可以使用react的生命周期<br>●使用较多，容易频繁触发生命周期钩子函数，影响性能<br>●内部使用 state，维护自身状态的变化，有状态组件根据外部组件传入的 props 和自身的 state进行渲染。</p><p><strong>使用场景：</strong><br>●需要使用到状态的。<br>●需要使用状态操作组件的（无状态组件的也可以实现新版本react hooks也可实现）</p><p><strong>总结：</strong><br>类组件可以维护自身的状态变量，即组件的 state ，类组件还有不同的生命周期方法，可以让开发者能够在组件的不同阶段（挂载、更新、卸载），对组件做更多的控制。类组件则既可以充当无状态组件，也可以充当有状态组件。当一个类组件不需要管理自身状态时，也可称为无状态组件。</p><p><strong>（2）无状态组件</strong><br>特点：<br>●不依赖自身的状态state<br>●可以是类组件或者函数组件。<br>●可以完全避免使用 this 关键字。（由于使用的是箭头函数事件无需绑定）<br>●有更高的性能。当不需要使用生命周期钩子时，应该首先使用无状态函数组件<br>●组件内部不维护 state ，只根据外部组件传入的 props 进行渲染的组件，当 props 改变时，组件重新渲染。</p><p><strong>使用场景：</strong><br>●组件不需要管理 state，纯展示 </p><p><strong>优点：</strong><br>●简化代码、专注于 render<br>●组件不需要被实例化，无生命周期，提升性能。 输出（渲染）只取决于输入（属性），无副作用<br>●视图和数据的解耦分离</p><p><strong>缺点：</strong><br>●无法使用 ref<br>●无生命周期方法<br>●无法控制组件的重渲染，因为无法使用shouldComponentUpdate 方法，当组件接受到新的属性时则会重渲染</p><p>总结：<br>组件内部状态且与外部无关的组件，可以考虑用状态组件，这样状态树就不会过于复杂，易于理解和管理。当一个组件不需要管理自身状态时，也就是无状态组件，应该优先设计为函数组件。比如自定义的 <code>&lt;Button/&gt;、 &lt;Input /&gt; </code>等组件。</p><h4 id="15-对React中Fragment的理解，它的使用场景是什么？"><a href="#15-对React中Fragment的理解，它的使用场景是什么？" class="headerlink" title="15. 对React中Fragment的理解，它的使用场景是什么？"></a>15. 对React中Fragment的理解，它的使用场景是什么？</h4><p>在React中，组件返回的元素只能有一个根元素。为了不添加多余的DOM节点，我们可以使用Fragment标签来包裹所有的元素，Fragment标签不会渲染出任何元素。React官方对Fragment的解释：</p><blockquote><p>React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component, Fragment &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-comment">// 一般形式</span><br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;React.Fragment&gt;<br>      &lt;ChildA /&gt;<br>      &lt;ChildB /&gt;<br>      &lt;ChildC /&gt;<br>    &lt;/React.Fragment&gt;<br>  );<br>&#125;<br><span class="hljs-comment">// 也可以写成以下形式</span><br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;&gt;<br>      &lt;ChildA /&gt;<br>      &lt;ChildB /&gt;<br>      &lt;ChildC /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="16-React如何获取组件对应的DOM元素？"><a href="#16-React如何获取组件对应的DOM元素？" class="headerlink" title="16. React如何获取组件对应的DOM元素？"></a>16. React如何获取组件对应的DOM元素？</h4><p>可以用ref来获取某个子节点的实例，然后通过当前class组件实例的一些特定属性来直接获取子节点实例。ref有三种实现方法:<br>●<strong>字符串格式</strong>：字符串格式，这是React16版本之前用得最多的，例如：<code>&lt;p ref=&quot;info&quot;&gt;span&lt;/p&gt;</code><br>●<strong>函数格式</strong>：ref对应一个方法，该方法有一个参数，也就是对应的节点实例，例如：<code>&lt;p ref=&#123;ele =&gt; this.info = ele&#125;&gt;&lt;/p&gt;</code><br>●<strong>createRef方法</strong>：React 16提供的一个API，使用React.createRef()来实现 　</p><h4 id="17-React中可以在render访问refs吗？为什么？"><a href="#17-React中可以在render访问refs吗？为什么？" class="headerlink" title="17. React中可以在render访问refs吗？为什么？"></a>17. React中可以在render访问refs吗？为什么？</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">ref</span>=</span></span><span class="hljs-template-variable">&#123;this.spanRef&#125;</span><span class="xml"><span class="hljs-tag">&gt;</span></span><span class="hljs-template-variable">&#123;this.state.title&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">     this.spanRef.current ? &#x27;有值&#x27; : &#x27;无值&#x27;</span><br><span class="hljs-template-variable">  &#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>不可以，render 阶段 DOM 还没有生成，无法获取 DOM</strong>。DOM 的获取需要在 pre-commit 阶段和 commit 阶段：<br><img src="/imageO/react11s.png" alt="生命周期"></p><h4 id="18-对React的插槽-Portals-的理解，如何使用，有哪些使用场景"><a href="#18-对React的插槽-Portals-的理解，如何使用，有哪些使用场景" class="headerlink" title="18. 对React的插槽(Portals)的理解，如何使用，有哪些使用场景"></a>18. 对React的插槽(Portals)的理解，如何使用，有哪些使用场景</h4><p>React 官方对 Portals 的定义：</p><blockquote><p>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案<br>Portals 是React 16提供的官方解决方案，使得组件可以脱离父组件层级挂载在DOM树的任何位置。通俗来讲，就是我们 render 一个组件，但这个组件的 DOM 结构并不在本组件内。</p></blockquote><p>Portals语法如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ReactDOM</span>.</span></span>create<span class="hljs-constructor">Portal(<span class="hljs-params">child</span>, <span class="hljs-params">container</span>)</span>;<br></code></pre></td></tr></table></figure><p>●第一个参数 child 是可渲染的 React 子项，比如元素，字符串或者片段等;<br>●第二个参数 container 是一个 DOM 元素。</p><p>一般情况下，组件的render函数返回的元素会被挂载在它的父级组件上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> DemoComponent <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./DemoComponent&#x27;</span>;<br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">// DemoComponent元素会被挂载在id为parent的div的元素上</span><br>  <span class="hljs-keyword">return</span> (<br>    &lt;div id=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>        &lt;DemoComponent /&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，有些元素需要被挂载在更高层级的位置。最典型的应用场景：当父组件具有overflow: hidden或者z-index的样式设置时，组件有可能被其他元素遮挡，这时就可以考虑要不要使用Portal使组件的挂载脱离父组件。例如：对话框，模态窗。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> DemoComponent <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./DemoComponent&#x27;</span>;<br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">// react会将DemoComponent组件直接挂载在真实的 dom 节点 domNode 上，生命周期还和16版本之前相同。</span><br>  <span class="hljs-keyword">return</span> ReactDOM.createPortal(<br>    &lt;DemoComponent /&gt;,<br>    domNode,<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="19-在React中如何避免不必要的render？"><a href="#19-在React中如何避免不必要的render？" class="headerlink" title="19. 在React中如何避免不必要的render？"></a>19. 在React中如何避免不必要的render？</h4><p>React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点：<br><strong>●shouldComponentUpdate 和 PureComponent</strong><br>在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。<br><strong>●利用高阶组件</strong><br>在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能<br><strong>●使用 React.memo</strong><br>React.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。</p><h4 id="21-对-React-context-的理解"><a href="#21-对-React-context-的理解" class="headerlink" title="21. 对 React context 的理解"></a>21. 对 React context 的理解</h4><p>在React中，数据传递一般使用props传递数据，维持单向数据流，这样可以让组件之间的关系变得简单且可预测，但是单项数据流在某些场景中并不适用。单纯一对的父子组件传递并无问题，但要是组件之间层层依赖深入，props就需要层层传递显然，这样做太繁琐了。</p><p>Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。</p><p>可以把context当做是特定一个组件树内共享的store，用来做数据传递。<strong>简单说就是，当你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。</strong></p><p>JS的代码块在执行期间，会创建一个相应的作用域链，这个作用域链记录着运行时JS代码块执行期间所能访问的活动对象，包括变量和函数，JS程序通过作用域链访问到代码块内部或者外部的变量和函数。</p><p>假如以JS的作用域链作为类比，React组件提供的Context对象其实就好比一个提供给子组件访问的作用域，而 Context对象的属性可以看成作用域上的活动对象。由于组件 的 Context 由其父节点链上所有组件通 过 getChildContext（）返回的Context对象组合而成，所以，组件通过Context是可以访问到其父组件链上所有节点组件提供的Context的属性。</p><h4 id="22-为什么React并不推荐优先考虑使用Context？"><a href="#22-为什么React并不推荐优先考虑使用Context？" class="headerlink" title="22. 为什么React并不推荐优先考虑使用Context？"></a>22. 为什么React并不推荐优先考虑使用Context？</h4><p>●Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。<br>●尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context<br>●对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。<br>●context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注</p><h4 id="23-React中什么是受控组件和非控组件？"><a href="#23-React中什么是受控组件和非控组件？" class="headerlink" title="23. React中什么是受控组件和非控组件？"></a>23. React中什么是受控组件和非控组件？</h4><p>（1）受控组件<br>在使用表单来收集用户输入时，例如<code>&lt;input&gt;&lt;select&gt;&lt;textearea&gt;</code>等元素都要绑定一个change事件，当表单的状态发生变化，就会触发onChange事件，更新组件的state。这种组件在React中被称为受控组件，在受控组件中，组件渲染出的状态与它的value或checked属性相对应，react通过这种方式消除了组件的局部状态，使整个状态可控。react官方推荐使用受控表单组件。</p><p>受控组件更新state的流程：<br>●可以通过初始state中设置表单的默认值<br>●每当表单的值发生变化时，调用onChange事件处理器<br>●事件处理器通过事件对象e拿到改变后的状态，并更新组件的state<br>●一旦通过setState方法更新state，就会触发视图的重新渲染，完成表单组件的更新</p><p><strong>受控组件缺陷：</strong><br>表单元素的值都是由React组件进行管理，当有多个输入框，或者多个这种组件时，如果想同时获取到全部的值就必须每个都要编写事件处理函数，这会让代码看着很臃肿，所以为了解决这种情况，出现了非受控组件。</p><p>（2）非受控组件<br>如果一个表单组件没有value props（单选和复选按钮对应的是checked props）时，就可以称为非受控组件。在非受控组件中，可以使用一个ref来从DOM获得表单值。而不是为每个状态更新编写一个事件处理程序。</p><p>React官方的解释：</p><blockquote><p>要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以使用 ref来从 DOM 节点中获取表单数据。</p></blockquote><blockquote><p>因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。</p></blockquote><p>例如，下面的代码在非受控组件中接收单个属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(props);<br>    <span class="hljs-built_in">this</span>.handleSubmit = <span class="hljs-built_in">this</span>.handleSubmit.bind(<span class="hljs-built_in">this</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">handleSubmit</span>(<span class="hljs-params">event</span>)</span> &#123;<br>    alert(<span class="hljs-string">&#x27;A name was submitted: &#x27;</span> + <span class="hljs-built_in">this</span>.input.value);<br>    event.preventDefault();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;form onSubmit=&#123;<span class="hljs-built_in">this</span>.handleSubmit&#125;&gt;<br>        &lt;label&gt;<br>          Name:<br>          &lt;input type=<span class="hljs-string">&quot;text&quot;</span> ref=&#123;<span class="hljs-function">(<span class="hljs-params">input</span>) =&gt;</span> <span class="hljs-built_in">this</span>.input = input&#125; /&gt;<br>        &lt;/label&gt;<br>        &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;Submit&quot;</span> /&gt;<br>      &lt;/form&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：页面中所有输入类的DOM如果是现用现取的称为非受控组件，而通过setState将输入的值维护到了state中，需要时再从state中取出，这里的数据就受到了state的控制，称为受控组件。</p><h4 id="24-React中refs的作用是什么？有哪些应用场景？"><a href="#24-React中refs的作用是什么？有哪些应用场景？" class="headerlink" title="24. React中refs的作用是什么？有哪些应用场景？"></a>24. React中refs的作用是什么？有哪些应用场景？</h4><p>Refs 提供了一种方式，用于访问在 render 方法中创建的 React 元素或 DOM 节点。Refs 应该谨慎使用，如下场景使用 Refs 比较适合：<br>●处理焦点、文本选择或者媒体的控制<br>●触发必要的动画<br>●集成第三方 DOM 库</p><p>Refs 是使用 React.createRef() 方法创建的，他通过 ref 属性附加到 React 元素上。要在整个组件中使用 Refs，需要将 ref 在构造函数中分配给其实例属性：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props)<br>    <span class="hljs-keyword">this</span>.myRef = <span class="hljs-type">React</span>.createRef()<br>  &#125;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> &lt;div ref=&#123;<span class="hljs-keyword">this</span>.myRef&#125; /&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于函数组件没有实例，因此不能在函数组件上直接使用 ref：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala">function <span class="hljs-type">MyFunctionalComponent</span>() &#123;<br>  <span class="hljs-keyword">return</span> &lt;input /&gt;;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-keyword">this</span>.textInput = <span class="hljs-type">React</span>.createRef();<br>  &#125;<br>  render() &#123;<br>    <span class="hljs-comment">// 这将不会工作！</span><br>    <span class="hljs-keyword">return</span> (<br>      &lt;<span class="hljs-type">MyFunctionalComponent</span> ref=&#123;<span class="hljs-keyword">this</span>.textInput&#125; /&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但可以通过闭合的帮助在函数组件内部进行使用 Refs：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CustomTextInput</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-comment">// 这里必须声明 textInput，这样 ref 回调才可以引用它</span><br>  <span class="hljs-keyword">let</span> textInput = <span class="hljs-literal">null</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleClick</span>(<span class="hljs-params"></span>) </span>&#123;<br>    textInput.focus();<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div&gt;<br>      &lt;input<br>        type=<span class="hljs-string">&quot;text&quot;</span><br>        ref=&#123;<span class="hljs-function">(<span class="hljs-params">input</span>) =&gt;</span> &#123; textInput = input; &#125;&#125; /&gt;<br>      &lt;input<br>        type=<span class="hljs-string">&quot;button&quot;</span><br>        value=<span class="hljs-string">&quot;Focus the text input&quot;</span><br>        onClick=&#123;handleClick&#125;<br>      /&gt;<br>    &lt;/div&gt;<br>  );  <br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<br>●不应该过度的使用 Refs<br>●ref 的返回值取决于节点的类型：<br>○当 ref 属性被用于一个普通的 HTML 元素时，React.createRef() 将接收底层 DOM 元素作为他的 current 属性以创建 ref。<br>○当 ref 属性被用于一个自定义的类组件时，ref 对象将接收该组件已挂载的实例作为他的 current。<br>●当在父组件中需要访问子组件中的 ref 时可使用传递 Refs 或回调 Refs。</p><h4 id="25-React中除了在构造函数中绑定this，还有别的方式吗？"><a href="#25-React中除了在构造函数中绑定this，还有别的方式吗？" class="headerlink" title="25. React中除了在构造函数中绑定this，还有别的方式吗？"></a>25. React中除了在构造函数中绑定this，还有别的方式吗？</h4><p>●在构造函数中绑定this</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(props)</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">      super(props); </span></span><br><span class="hljs-function"><span class="hljs-comment">       this.state=&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">           msg:&#x27;hello world&#x27;,</span></span><br><span class="hljs-function"><span class="hljs-comment">       &#125;</span></span><br><span class="hljs-function">       <span class="hljs-title">this</span>.<span class="hljs-title">getMsg</span> = <span class="hljs-title">this</span>.<span class="hljs-title">getMsg</span>.<span class="hljs-title">bind</span><span class="hljs-params">(this)</span></span><br><span class="hljs-function">   &#125;</span><br></code></pre></td></tr></table></figure><p>●函数定义的时候使用箭头函数</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(props)</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">    super(props);</span></span><br><span class="hljs-function"><span class="hljs-comment">    this.state=&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">           msg:&#x27;hello world&#x27;,</span></span><br><span class="hljs-function"><span class="hljs-comment">    &#125;</span></span><br><span class="hljs-function">    <span class="hljs-title">render</span><span class="hljs-params">()</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">      &lt;button onClcik=&#123;()=&gt;&#123;alert(this.state.msg)&#125;</span>&#125;&gt;点我&lt;/<span class="hljs-title">button</span>&gt;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>●函数调用是使用bind绑定this</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&lt;button onClick=&#123;<span class="hljs-keyword">this</span>.getMsg.bind(<span class="hljs-keyword">this</span>)&#125;&gt;点我&lt;/button&gt;<br></code></pre></td></tr></table></figure><h4 id="26-React组件的构造函数有什么作用？它是必须的吗？"><a href="#26-React组件的构造函数有什么作用？它是必须的吗？" class="headerlink" title="26. React组件的构造函数有什么作用？它是必须的吗？"></a>26. React组件的构造函数有什么作用？它是必须的吗？</h4><p>构造函数主要用于两个目的：<br>●通过将对象分配给this.state来初始化本地状态<br>●将事件处理程序方法绑定到实例上<br>所以，当在React class中需要设置state的初始值或者绑定事件时，需要加上构造函数，官方Demo：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LikeButton</span> <span class="hljs-title">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>() &#123;<br>    <span class="hljs-keyword">super</span>();<br>    <span class="hljs-keyword">this</span>.state = &#123;<br>      liked: <span class="hljs-literal">false</span><br>    &#125;;<br>    <span class="hljs-keyword">this</span>.handleClick = <span class="hljs-keyword">this</span>.handleClick.bind(<span class="hljs-keyword">this</span>);<br>  &#125;<br>  handleClick() &#123;<br>    <span class="hljs-keyword">this</span>.setState(&#123;liked: !<span class="hljs-keyword">this</span>.state.liked&#125;);<br>  &#125;<br>  render() &#123;<br>    <span class="hljs-keyword">const</span> text = <span class="hljs-keyword">this</span>.state.liked ? <span class="hljs-string">&#x27;liked&#x27;</span> : <span class="hljs-string">&#x27;haven\&#x27;t liked&#x27;</span>;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div onClick=&#123;<span class="hljs-keyword">this</span>.handleClick&#125;&gt;<br>        You &#123;text&#125; <span class="hljs-keyword">this</span>. Click to toggle.<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br>ReactDOM.render(<br>  &lt;LikeButton /&gt;,<br>  document.getElementById(<span class="hljs-string">&#x27;example&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>构造函数用来新建父类的this对象；子类必须在constructor方法中调用super方法；否则新建实例时会报错；因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法；子类就得不到this对象。</p><p>注意：<br>●constructor () 必须配上 super(), 如果要在constructor 内部使用 this.props 就要 传入props , 否则不用<br>●JavaScript中的 bind 每次都会返回一个新的函数, 为了性能等考虑, 尽量在constructor中绑定事件</p><h4 id="27-React-forwardRef是什么？它有什么作用？"><a href="#27-React-forwardRef是什么？它有什么作用？" class="headerlink" title="27. React.forwardRef是什么？它有什么作用？"></a>27. React.forwardRef是什么？它有什么作用？</h4><p>React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。这种技术并不常见，但在以下两种场景中特别有用：<br>●转发 refs 到 DOM 组件<br>●在高阶组件中转发 refs</p><h4 id="28-类组件与函数组件有什么异同？"><a href="#28-类组件与函数组件有什么异同？" class="headerlink" title="28. 类组件与函数组件有什么异同？"></a>28. 类组件与函数组件有什么异同？</h4><p><strong>相同点：</strong><br>组件是 React 可复用的最小代码片段，它们会返回要在页面中渲染的 React 元素。也正因为组件是 React 的最小编码单位，所以无论是函数组件还是类组件，在使用方式和最终呈现效果上都是完全一致的。</p><p>我们甚至可以将一个类组件改写成函数组件，或者把函数组件改写成一个类组件（虽然并不推荐这种重构行为）。从使用者的角度而言，很难从使用体验上区分两者，而且在现代浏览器中，闭包和类的性能只在极端场景下才会有明显的差别。所以，基本可认为两者作为组件是完全一致的。</p><p><strong>不同点：</strong><br>●它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。<br>●之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。<br>●性能优化上，类组件主要依靠 shouldComponentUpdate 阻断渲染来提升性能，而函数组件依靠 React.memo 缓存渲染结果来提升性能。<br>●从上手程度而言，类组件更容易上手，从未来趋势上看，由于React Hooks 的推出，函数组件成了社区未来主推的方案。<br>●类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展。</p><h3 id="二、数据管理"><a href="#二、数据管理" class="headerlink" title="二、数据管理"></a>二、数据管理</h3><h4 id="1-React-setState-调用的原理"><a href="#1-React-setState-调用的原理" class="headerlink" title="1. React setState 调用的原理"></a>1. React setState 调用的原理</h4><p><img src="/imageO/react11.png" alt="setState"><br>具体的执行过程如下（源码级解析）：<br>●首先调用了setState 入口函数，入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去；</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ReactComponent</span>.</span></span>prototype.setState = <span class="hljs-keyword">function</span> (partialState, callback) &#123;<br>  this.updater.enqueue<span class="hljs-constructor">SetState(<span class="hljs-params">this</span>, <span class="hljs-params">partialState</span>)</span>;<br>  <span class="hljs-keyword">if</span> (callback) &#123;<br>    this.updater.enqueue<span class="hljs-constructor">Callback(<span class="hljs-params">this</span>, <span class="hljs-params">callback</span>, &#x27;<span class="hljs-params">setState</span>&#x27;)</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>●enqueueSetState 方法将新的 state 放进组件的状态队列里，并调用 enqueueUpdate 来处理将要更新的实例对象；</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pf">enqueueSetState: function (publicInstance, partialState) &#123;<br>  // 根据 this 拿到对应的组件实例<br>  var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, &#x27;<span class="hljs-built_in">set</span>State&#x27;);<br>  // 这个 <span class="hljs-keyword">queue</span> 对应的就是一个组件实例的 <span class="hljs-keyword">state</span> 数组<br>  var <span class="hljs-keyword">queue</span> = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);<br>  <span class="hljs-keyword">queue</span>.push(partialState);<br>  //  enqueueUpdate 用来处理当前的组件实例<br>  enqueueUpdate(internalInstance);<br>&#125;<br></code></pre></td></tr></table></figure><p>●在 enqueueUpdate 方法中引出了一个关键的对象——batchingStrategy，该对象所具备的isBatchingUpdates 属性直接决定了当下是要走更新流程，还是应该排队等待；如果轮到执行，就调用 batchedUpdates 方法来直接发起更新流程。由此可以推测，batchingStrategy 或许正是 React 内部专门用于管控批量更新的对象。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> enqueue<span class="hljs-constructor">Update(<span class="hljs-params">component</span>)</span> &#123;<br>  ensure<span class="hljs-constructor">Injected()</span>;<br>  <span class="hljs-comment">// 注意这一句是问题的关键，isBatchingUpdates标识着当前是否处于批量创建/更新组件的阶段</span><br>  <span class="hljs-keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123;<br>    <span class="hljs-comment">// 若当前没有处于批量创建/更新组件的阶段，则立即更新组件</span><br>    batchingStrategy.batched<span class="hljs-constructor">Updates(<span class="hljs-params">enqueueUpdate</span>, <span class="hljs-params">component</span>)</span>;<br>    return;<br>  &#125;<br>  <span class="hljs-comment">// 否则，先把组件塞入 dirtyComponents 队列里，让它“再等等”</span><br>  dirtyComponents.push(component);<br>  <span class="hljs-keyword">if</span> (component._updateBatchNumber<span class="hljs-operator"> == </span>null) &#123;<br>    component._updateBatchNumber = updateBatchNumber + <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：batchingStrategy 对象可以理解为“锁管理器”。这里的“锁”，是指 React 全局唯一的 isBatchingUpdates 变量，isBatchingUpdates 的初始值是 false，意味着“当前并未进行任何批量更新操作”。每当 React 调用 batchedUpdate 去执行更新动作时，会先把这个锁给“锁上”（置为 true），表明“现在正处于批量更新过程中”。当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入 dirtyComponents 里排队等候下一次的批量更新，而不能随意“插队”。此处体现的“任务锁”的思想，是 React 面对大量状态仍然能够实现有序分批处理的基石。</p><h4 id="2-React-setState-调用之后发生了什么？是同步还是异步？"><a href="#2-React-setState-调用之后发生了什么？是同步还是异步？" class="headerlink" title="2. React setState 调用之后发生了什么？是同步还是异步？"></a>2. React setState 调用之后发生了什么？是同步还是异步？</h4><p><strong>（1）React中setState后发生了什么</strong><br>在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发调和过程(Reconciliation)。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。</p><p>在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p><p>如果在短时间内频繁setState。React会将state的改变压入栈中，在合适的时机，批量更新state和视图，达到提高性能的效果。</p><p><strong>（2）setState 是同步还是异步的</strong><br>假如所有setState是同步的，意味着每执行一次setState时（有可能一个同步代码中，多次setState），都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异步，则可以把一个同步代码中的多个setState合并成一次组件更新。所以默认是异步的，但是在一些情况下是同步的。</p><p>setState 并不是单纯同步/异步的，它的表现会因调用场景的不同而不同。在源码中，通过 isBatchingUpdates 来判断setState 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。<br><strong>●异步</strong>：在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。<br><strong>●同步</strong>：在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。</p><p>一般认为，做异步设计是为了性能优化、减少渲染次数：<br>●setState设计为异步，可以显著的提升性能。如果每次调用 setState都进行一次更新，那么意味着render函数会被频繁调用，界面重新渲染，这样效率是很低的；最好的办法应该是获取到多个更新，之后进行批量更新；<br>●如果同步更新了state，但是还没有执行render函数，那么state和props不能保持同步。state和props不能保持一致性，会在开发中产生很多的问题；</p><h4 id="3-React中的setState批量更新的过程是什么？"><a href="#3-React中的setState批量更新的过程是什么？" class="headerlink" title="3. React中的setState批量更新的过程是什么？"></a>3. React中的setState批量更新的过程是什么？</h4><p>调用 setState 时，组件的 state 并不会立即改变， setState 只是把要修改的 state 放入一个队列， React 会优化真正的执行时机，并出于性能原因，会将 React 事件处理程序中的多次React 事件处理程序中的多次 setState 的状态修改合并成一次状态修改。 最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pf">this.<span class="hljs-built_in">set</span>State(&#123;<br>  count: this.<span class="hljs-keyword">state</span>.count + <span class="hljs-number">1</span>    ===&gt;    入队，[count+<span class="hljs-number">1</span>的任务]<br>&#125;);<br>this.<span class="hljs-built_in">set</span>State(&#123;<br>  count: this.<span class="hljs-keyword">state</span>.count + <span class="hljs-number">1</span>    ===&gt;    入队，[count+<span class="hljs-number">1</span>的任务，count+<span class="hljs-number">1</span>的任务]<br>&#125;);<br>                                          ↓<br>                                         合并 <span class="hljs-keyword">state</span>，[count+<span class="hljs-number">1</span>的任务]<br>                                          ↓<br>                                         执行 count+<span class="hljs-number">1</span>的任务<br></code></pre></td></tr></table></figure><p>需要注意的是，只要同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。</p><h4 id="4-React中有使用过getDefaultProps吗？它有什么作用？"><a href="#4-React中有使用过getDefaultProps吗？它有什么作用？" class="headerlink" title="4.  React中有使用过getDefaultProps吗？它有什么作用？"></a>4.  React中有使用过getDefaultProps吗？它有什么作用？</h4><p>通过实现组件的getDefaultProps，对属性设置默认值（ES5的写法）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ShowTitle = React.createClass(&#123;<br>  getDefaultProps:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>      title : <span class="hljs-string">&quot;React&quot;</span><br>    &#125;<br>  &#125;,<br>  render : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;this.props.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="5-React中setState的第二个参数作用是什么？"><a href="#5-React中setState的第二个参数作用是什么？" class="headerlink" title="5. React中setState的第二个参数作用是什么？"></a>5. React中setState的第二个参数作用是什么？</h4><p>setState 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentDidUpdate 生命周期内执行。通常建议使用 componentDidUpdate 来代替此方式。在这个回调函数中你可以拿到更新后 state 的值：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">this.<span class="hljs-built_in">set</span>State(&#123;<br>    key1: newState1,<br>    key2: newState2,<br>    ...<br>&#125;, callback) // 第二个参数是 <span class="hljs-keyword">state</span> 更新完成后的回调函数<br></code></pre></td></tr></table></figure><h4 id="6-React中的setState和replaceState的区别是什么？"><a href="#6-React中的setState和replaceState的区别是什么？" class="headerlink" title="6. React中的setState和replaceState的区别是什么？"></a>6. React中的setState和replaceState的区别是什么？</h4><p><strong>（1）setState()</strong><br>setState()用于设置状态对象，其语法如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">set<span class="hljs-constructor">State(<span class="hljs-params">object</span> <span class="hljs-params">nextState</span>[, <span class="hljs-params">function</span> <span class="hljs-params">callback</span>])</span><br></code></pre></td></tr></table></figure><p>●nextState，将要设置的新状态，该状态会和当前的state合并<br>●callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。</p><p>合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。<br><strong>（2）replaceState()</strong><br>replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">replace<span class="hljs-constructor">State(<span class="hljs-params">object</span> <span class="hljs-params">nextState</span>[, <span class="hljs-params">function</span> <span class="hljs-params">callback</span>])</span><br></code></pre></td></tr></table></figure><p>●nextState，将要设置的新状态，该状态会替换当前的state。<br>●callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。</p><p><strong>总结：</strong>setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。</p><h4 id="7-在React中组件的this-state和setState有什么区别？"><a href="#7-在React中组件的this-state和setState有什么区别？" class="headerlink" title="7. 在React中组件的this.state和setState有什么区别？"></a>7. 在React中组件的this.state和setState有什么区别？</h4><p>this.state通常是用来初始化state的，this.setState是用来修改state值的。如果初始化了state之后再使用this.state，之前的state会被覆盖掉，如果使用this.setState，只会替换掉相应的state值。所以，如果想要修改state的值，就需要使用setState，而不能直接修改state，直接修改state之后页面是不会更新的。</p><h4 id="8-state-是怎么注入到组件的，从-reducer-到组件经历了什么样的过程"><a href="#8-state-是怎么注入到组件的，从-reducer-到组件经历了什么样的过程" class="headerlink" title="8. state 是怎么注入到组件的，从 reducer 到组件经历了什么样的过程"></a>8. state 是怎么注入到组件的，从 reducer 到组件经历了什么样的过程</h4><p>通过connect和mapStateToProps将state注入到组件中：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span><br><span class="hljs-keyword">import</span> &#123; setVisibilityFilter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/reducers/Todo/actions&#x27;</span><br><span class="hljs-keyword">import</span> Link <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/containers/Todo/components/Link&#x27;</span><br><br>const mapStateToProps = <span class="hljs-function"><span class="hljs-params">(state, ownProps)</span> =&gt;</span> (&#123;<br>    active: ownProps.filter === state.visibilityFilter<br>&#125;)<br><br>const mapDispatchToProps = <span class="hljs-function"><span class="hljs-params">(dispatch, ownProps)</span> =&gt;</span> (&#123;<br>    setFilter: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        dispatch(setVisibilityFilter(ownProps.filter))<br>    &#125;<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(<br>    mapStateToProps,<br>    mapDispatchToProps<br>)(Link)<br></code></pre></td></tr></table></figure><p>上面代码中，active就是注入到Link组件中的状态。 mapStateToProps（state，ownProps）中带有两个参数，含义是∶<br>●state-store管理的全局状态对象，所有都组件状态数据都存储在该对象中。<br>●ownProps 组件通过props传入的参数。 </p><p><strong>reducer 到组件经历的过程：</strong><br>●reducer对action对象处理，更新组件状态，并将新的状态值返回store。<br>●通过connect（mapStateToProps，mapDispatchToProps）（Component）对组件 Component进行升级，此时将状态值从store取出并作为props参数传递到组件。<br><strong>高阶组件实现源码∶</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;prop-types&#x27;</span><br><br><span class="hljs-comment">// 高阶组件 contect </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> connect = <span class="hljs-function">(<span class="hljs-params">mapStateToProps, mapDispatchToProps</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connect</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>        <span class="hljs-comment">// 通过对context调用获取store</span><br>        <span class="hljs-keyword">static</span> contextTypes = &#123;<br>            store: PropTypes.object<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-built_in">super</span>()<br>            <span class="hljs-built_in">this</span>.state = &#123;<br>                allProps: &#123;&#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 第一遍需初始化所有组件初始状态</span><br>        <span class="hljs-function"><span class="hljs-title">componentWillMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-keyword">const</span> store = <span class="hljs-built_in">this</span>.context.store<br>            <span class="hljs-built_in">this</span>._updateProps()<br>            store.subscribe(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>._updateProps()); <span class="hljs-comment">// 加入_updateProps()至store里的监听事件列表</span><br>        &#125;<br><br>        <span class="hljs-comment">// 执行action后更新props，使组件可以更新至最新状态（类似于setState）</span><br>        <span class="hljs-function"><span class="hljs-title">_updateProps</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-keyword">const</span> store = <span class="hljs-built_in">this</span>.context.store;<br>            <span class="hljs-keyword">let</span> stateProps = mapStateToProps ?<br>                mapStateToProps(store.getState(), <span class="hljs-built_in">this</span>.props) : &#123;&#125; <span class="hljs-comment">// 防止 mapStateToProps 没有传入</span><br>            <span class="hljs-keyword">let</span> dispatchProps = mapDispatchToProps ?<br>                mapDispatchToProps(store.dispatch, <span class="hljs-built_in">this</span>.props) : &#123;<br>                                    dispatch: store.dispatch<br>                                &#125; <span class="hljs-comment">// 防止 mapDispatchToProps 没有传入</span><br>            <span class="hljs-built_in">this</span>.setState(&#123;<br>                allProps: &#123;<br>                    ...stateProps,<br>                    ...dispatchProps,<br>                    ...this.props<br>                &#125;<br>            &#125;)<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...this.state.allProps</span>&#125; /&gt;</span></span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Connect<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-React组件的state和props有什么区别？"><a href="#9-React组件的state和props有什么区别？" class="headerlink" title="9. React组件的state和props有什么区别？"></a>9. React组件的state和props有什么区别？</h4><p><strong>（1）props</strong><br>props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。<br><strong>（2）state</strong><br>state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。<br><strong>（3）区别</strong><br>●props 是传递给组件的（类似于函数的形参），而state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。<br>●props 是不可修改的，所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。<br>●state 是在组件中创建的，一般在 constructor中初始化 state。state 是多变的、可以修改，每次setState都异步更新的。</p><h4 id="10-React中的props为什么是只读的？"><a href="#10-React中的props为什么是只读的？" class="headerlink" title="10. React中的props为什么是只读的？"></a>10. React中的props为什么是只读的？</h4><p>this.props是组件之间沟通的一个接口，原则上来讲，它只能从父组件流向子组件。React具有浓重的函数式编程的思想。</p><p>提到函数式编程就要提一个概念：纯函数。它有几个特点：<br>●给定相同的输入，总是返回相同的输出。<br>●过程没有副作用。<br>●不依赖外部状态。</p><p>this.props就是汲取了纯函数的思想。props的不可以变性就保证的相同的输入，页面显示的内容是一样的，并且不会产生副作用</p><h4 id="11-在React中组件的props改变时更新组件的有哪些方法？"><a href="#11-在React中组件的props改变时更新组件的有哪些方法？" class="headerlink" title="11. 在React中组件的props改变时更新组件的有哪些方法？"></a>11. 在React中组件的props改变时更新组件的有哪些方法？</h4><p>在一个组件传入的props更新时重新渲染该组件常用的方法是在componentWillReceiveProps中将新的props更新到组件的state中（这种state被成为派生状态（Derived State）），从而实现重新渲染。React 16.3中还引入了一个新的钩子函数getDerivedStateFromProps来专门实现这一需求。</p><p><strong>（1）componentWillReceiveProps（已废弃）</strong><br>在react的componentWillReceiveProps(nextProps)生命周期中，可以在子组件的render函数执行前，通过this.props获取旧的属性，通过nextProps获取新的props，对比两次props是否相同，从而更新子组件自己的state。</p><p>这样的好处是，可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。<br><strong>（2）getDerivedStateFromProps（16.3引入）</strong><br>这个生命周期函数是为了替代componentWillReceiveProps存在的，所以在需要使用componentWillReceiveProps时，就可以考虑使用getDerivedStateFromProps来进行替代。</p><p>两者的参数是不相同的，而getDerivedStateFromProps是一个静态函数，也就是这个函数不能通过this访问到class的属性，也并不推荐直接访问属性。而是应该通过参数提供的nextProps以及prevState来进行判断，根据新传入的props来映射到state。</p><p>需要注意的是，<strong>如果props传入的内容不需要影响到你的state，那么就需要返回一个null</strong>，这个返回值是必须的，所以尽量将其写到函数的末尾：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getDerivedStateFromProps</span>(<span class="hljs-params">nextProps, prevState</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">type</span>&#125; = nextProps;<br>    <span class="hljs-comment">// 当传入的type发生变化的时候，更新state</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> !== prevState.type) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-keyword">type</span>,<br>        &#125;;<br>    &#125;<br>    <span class="hljs-comment">// 否则，对于state不进行任何操作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="12-React中怎么检验props？验证props的目的是什么？"><a href="#12-React中怎么检验props？验证props的目的是什么？" class="headerlink" title="12. React中怎么检验props？验证props的目的是什么？"></a>12. React中怎么检验props？验证props的目的是什么？</h4><p>React为我们提供了<strong>PropTypes</strong>以供验证使用。当我们向Props传入的数据无效（向Props传入的数据类型和验证的数据类型不符）就会在控制台发出警告信息。它可以避免随着应用越来越复杂从而出现的问题。并且，它还可以让程序变得更易读。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> <span class="hljs-type">PropTypes</span> from <span class="hljs-symbol">&#x27;prop</span>-types&#x27;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;h1&gt;<span class="hljs-type">Hello</span>, &#123;<span class="hljs-keyword">this</span>.props.name&#125;&lt;/h1&gt;<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-type">Greeting</span>.propTypes = &#123;<br>  name: <span class="hljs-type">PropTypes</span>.string<br>&#125;;<br></code></pre></td></tr></table></figure><p>当然，如果项目汇中使用了TypeScript，那么就可以不用PropTypes来校验，而使用TypeScript定义接口来校验props。</p><h3 id="三、生命周期"><a href="#三、生命周期" class="headerlink" title="三、生命周期"></a>三、生命周期</h3><h4 id="1-React的生命周期有哪些？"><a href="#1-React的生命周期有哪些？" class="headerlink" title="1. React的生命周期有哪些？"></a>1. React的生命周期有哪些？</h4><p> React 通常将组件生命周期分为三个阶段：<br>●装载阶段（Mount），组件第一次在DOM树中被渲染的过程；<br>●更新过程（Update），组件状态发生变化，重新更新渲染的过程；<br>●卸载过程（Unmount），组件从DOM树中被移除的过程；<br><img src="/imageO/react11.png" alt="生命周期"></p><h5 id="1）组件挂载阶段"><a href="#1）组件挂载阶段" class="headerlink" title="1）组件挂载阶段"></a><strong>1）组件挂载阶段</strong></h5><p>挂载阶段组件被创建，然后组件实例插入到 DOM 中，完成组件的第一次渲染，该过程只会发生一次，在此阶段会依次调用以下这些方法：<br>●constructor<br>●getDerivedStateFromProps<br>●render<br>●componentDidMount<br><strong>（1）constructor</strong><br>组件的构造函数，第一个被执行，若没有显式定义它，会有一个默认的构造函数，但是若显式定义了构造函数，我们必须在构造函数中执行 super(props)，否则无法在构造函数中拿到this。</p><p>如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数<strong>Constructor</strong>。</p><p>constructor中通常只做两件事：<br>●初始化组件的 state<br>●给事件处理方法绑定 this</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(props)</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">  super(props);</span></span><br><span class="hljs-function"><span class="hljs-comment">  // 不要在构造函数中调用 setState，可以直接给 state 设置初始值</span></span><br><span class="hljs-function"><span class="hljs-comment">  this.state = &#123; counter: 0 &#125;</span></span><br><span class="hljs-function">  <span class="hljs-title">this</span>.<span class="hljs-title">handleClick</span> = <span class="hljs-title">this</span>.<span class="hljs-title">handleClick</span>.<span class="hljs-title">bind</span><span class="hljs-params">(this)</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>（2）getDerivedStateFromProps</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">static getDerivedStateFromProps(props, <span class="hljs-keyword">state</span>)<br></code></pre></td></tr></table></figure><p>这是个静态方法，所以不能在这个函数里使用 this，有两个参数 props 和 state，分别指接收到的新参数和当前组件的 state 对象，这个函数会返回一个对象用来更新当前的 state 对象，如果不需要更新可以返回 null。</p><p>该函数会在装载时，接收到新的 props 或者调用了 setState 和 forceUpdate 时被调用。如当接收到新的属性想修改 state ，就可以使用。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs pf">// 当 props.counter 变化时，赋值给 <span class="hljs-keyword">state</span> <br>class App extends React.Component &#123;<br>  constructor(props) &#123;<br>    super(props)<br>    this.<span class="hljs-keyword">state</span> = &#123;<br>      counter: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>  static getDerivedStateFromProps(props, <span class="hljs-keyword">state</span>) &#123;<br>    if (props.counter !== <span class="hljs-keyword">state</span>.counter) &#123;<br>      return &#123;<br>        counter: props.counter<br>      &#125;<br>    &#125;<br>    return null<br>  &#125;<br>  <br>  handleClick = () =&gt; &#123;<br>    this.<span class="hljs-built_in">set</span>State(&#123;<br>      counter: this.<span class="hljs-keyword">state</span>.counter + <span class="hljs-number">1</span><br>    &#125;)<br>  &#125;<br>  render() &#123;<br>    return (<br>      <span class="hljs-variable">&lt;div&gt;</span><br>        <span class="hljs-variable">&lt;h1 onClick=&#123;this.handleClick&#125;&gt;</span>Hello, world!&#123;this.<span class="hljs-keyword">state</span>.counter&#125;&lt;/h1&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在可以显式传入 counter ，但是这里有个问题，如果想要通过点击实现 state.counter 的增加，但这时会发现值不会发生任何变化，一直保持 props 传进来的值。这是由于在 React 16.4^ 的版本中 setState 和 forceUpdate 也会触发这个生命周期，所以当组件内部 state 变化后，就会重新走这个方法，同时会把 state 值赋值为 props 的值。因此需要多加一个字段来记录之前的 props 值，这样就会解决上述问题。具体如下：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs pf">// 这里只列出需要变化的地方<br>class App extends React.Component &#123;<br>  constructor(props) &#123;<br>    super(props)<br>    this.<span class="hljs-keyword">state</span> = &#123;<br>      // 增加一个 preCounter 来记录之前的 props 传来的值<br>      preCounter: <span class="hljs-number">0</span>,<br>      counter: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>  static getDerivedStateFromProps(props, <span class="hljs-keyword">state</span>) &#123;<br>    // 跟 <span class="hljs-keyword">state</span>.preCounter 进行比较<br>    if (props.counter !== <span class="hljs-keyword">state</span>.preCounter) &#123;<br>      return &#123;<br>        counter: props.counter,<br>        preCounter: props.counter<br>      &#125;<br>    &#125;<br>    return null<br>  &#125;<br>  handleClick = () =&gt; &#123;<br>    this.<span class="hljs-built_in">set</span>State(&#123;<br>      counter: this.<span class="hljs-keyword">state</span>.counter + <span class="hljs-number">1</span><br>    &#125;)<br>  &#125;<br>  render() &#123;<br>    return (<br>      <span class="hljs-variable">&lt;div&gt;</span><br>        <span class="hljs-variable">&lt;h1 onClick=&#123;this.handleClick&#125;&gt;</span>Hello, world!&#123;this.<span class="hljs-keyword">state</span>.counter&#125;&lt;/h1&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）render</strong><br>render是React 中最核心的方法，一个组件中必须要有这个方法，它会根据状态 state 和属性 props 渲染组件。这个函数只做一件事，就是返回需要渲染的内容，所以不要在这个函数内做其他业务逻辑，通常调用该方法会返回以下类型中一个：<br>●<strong>React 元素</strong>：这里包括原生的 DOM 以及 React 组件；<br>●<strong>数组和 Fragment（片段）</strong>：可以返回多个元素；<br>●<strong>Portals（插槽）</strong>：可以将子元素渲染到不同的 DOM 子树种；<br>●<strong>字符串和数字</strong>：被渲染成 DOM 中的 text 节点；<br>●<strong>布尔值或 null</strong>：不渲染任何内容。<br><strong>（4）componentDidMount()</strong><br>componentDidMount()会在组件挂载后（插入 DOM 树中）立即调。该阶段通常进行以下操作：<br>●执行依赖于DOM的操作；<br>●发送网络请求；（官方建议）<br>●添加订阅消息（会在componentWillUnmount取消订阅）；</p><p>如果在 componentDidMount 中调用 setState ，就会触发一次额外的渲染，多调用了一次 render 函数，由于它是在浏览器刷新屏幕前执行的，所以用户对此是没有感知的，但是我应当避免这样使用，这样会带来一定的性能问题，尽量是在 constructor 中初始化 state 对象。</p><p>在组件装载之后，将计数数字变为1：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>  </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props)<br>    <span class="hljs-keyword">this</span>.state = &#123;<br>      counter: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>  componentDidMount () &#123;<br>    <span class="hljs-keyword">this</span>.setState(&#123;<br>      counter: <span class="hljs-number">1</span><br>    &#125;)<br>  &#125;<br>  render ()  &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div className=<span class="hljs-string">&quot;counter&quot;</span>&gt;<br>        counter值: &#123; <span class="hljs-keyword">this</span>.state.counter &#125;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2）组件更新阶段</strong><br>当组件的 props 改变了，或组件内部调用了 setState/forceUpdate，会触发更新重新渲染，这个过程可能会发生多次。这个阶段会依次调用下面这些方法：<br>●getDerivedStateFromProps<br>●shouldComponentUpdate<br>●render<br>●getSnapshotBeforeUpdate<br>●componentDidUpdate<br><strong>（1）shouldComponentUpdate</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">should<span class="hljs-constructor">ComponentUpdate(<span class="hljs-params">nextProps</span>, <span class="hljs-params">nextState</span>)</span><br></code></pre></td></tr></table></figure><p>在说这个生命周期函数之前，来看两个问题：<br><strong>●setState 函数在任何情况下都会导致组件重新渲染吗？例如下面这种情况：</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">this.<span class="hljs-built_in">set</span>State(&#123;number: this.<span class="hljs-keyword">state</span>.number&#125;)<br></code></pre></td></tr></table></figure><p><strong>●如果没有调用 setState，props 值也没有变化，是不是组件就不会重新渲染？</strong></p><p>第一个问题答案是 <strong>会</strong> ，第二个问题如果是父组件重新渲染时，不管传入的 props 有没有变化，都会引起子组件的重新渲染。</p><p>那么有没有什么方法解决在这两个场景下不让组件重新渲染进而提升性能呢？这个时候 shouldComponentUpdate 登场了，这个生命周期函数是用来提升速度的，它是在重新渲染组件开始前触发的，默认返回 true，可以比较 this.props 和 nextProps ，this.state 和 nextState 值是否变化，来确认返回 true 或者 false。当返回 false 时，组件的更新过程停止，后续的 render、componentDidUpdate 也不会被调用。</p><p>注意：添加 shouldComponentUpdate 方法时，不建议使用深度相等检查（如使用 JSON.stringify()），因为深比较效率很低，可能会比重新渲染组件效率还低。而且该方法维护比较困难，建议使用该方法会产生明显的性能提升时使用。<br><strong>（2）getSnapshotBeforeUpdate</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">get<span class="hljs-constructor">SnapshotBeforeUpdate(<span class="hljs-params">prevProps</span>, <span class="hljs-params">prevState</span>)</span><br></code></pre></td></tr></table></figure><p>这个方法在 render 之后，componentDidUpdate 之前调用，有两个参数 prevProps 和 prevState，表示更新之前的 props 和 state，这个函数必须要和 componentDidUpdate 一起使用，并且要有一个返回值，默认是 null，这个返回值作为第三个参数传给 componentDidUpdate。<br><strong>（3）componentDidUpdate</strong><br>componentDidUpdate() 会在更新后会被立即调用，首次渲染不会执行此方法。 该阶段通常进行以下操作：<br>●当组件更新后，对 DOM 进行操作；<br>●如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求；（例如，当 props 未发生变化时，则不会执行网络请求）。 </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">component<span class="hljs-constructor">DidUpdate(<span class="hljs-params">prevProps</span>, <span class="hljs-params">prevState</span>, <span class="hljs-params">snapshot</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>该方法有三个参数：<br>●prevProps: 更新前的props<br>●prevState: 更新前的state<br>●snapshot: getSnapshotBeforeUpdate()生命周期的返回值<br><strong>3）组件卸载阶段</strong><br>卸载阶段只有一个生命周期函数，componentWillUnmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作：<br>●清除 timer，取消网络请求或清除<br>●取消在 componentDidMount() 中创建的订阅等；<br>这个生命周期在一个组件被卸载和销毁之前被调用，因此你不应该再这个方法中使用 setState，因为组件一旦被卸载，就不会再装载，也就不会重新渲染。<br><strong>4）错误处理阶段</strong><br>componentDidCatch(error, info)，此生命周期在后代组件抛出错误后被调用。 它接收两个参数∶<br>●error：抛出的错误。<br>●info：带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息</p><p>React常见的生命周期如下：<br><img src="/imageO/react5.png" alt="生命周期"><br><strong>React常见生命周期的过程大致如下：</strong><br>●挂载阶段，首先执行constructor构造方法，来创建组件<br>●创建完成之后，就会执行render方法，该方法会返回需要渲染的内容<br>●随后，React会将需要渲染的内容挂载到DOM树上<br><strong>●挂载完成之后就会执行componentDidMount生命周期函数</strong><br>●如果我们给组件创建一个props（用于组件通信）、调用setState（更改state中的数据）、调用forceUpdate（强制更新组件）时，都会重新调用render函数<br>●render函数重新执行之后，就会重新进行DOM树的挂载<br><strong>●挂载完成之后就会执行componentDidUpdate生命周期函数</strong><br><strong>●当移除组件时，就会执行componentWillUnmount生命周期函数</strong></p><p><strong>React主要生命周期总结：</strong><br><strong>1.getDefaultProps</strong>：这个函数会在组件创建之前被调用一次（有且仅有一次），它被用来初始化组件的 Props；<br><strong>2.getInitialState</strong>：用于初始化组件的 state 值；<br><strong>3.componentWillMount</strong>：在组件创建后、render 之前，会走到 componentWillMount 阶段。这个阶段我个人一直没用过、非常鸡肋。后来React 官方已经不推荐大家在 componentWillMount 里做任何事情、到现在 React16 直接废弃了这个生命周期，足见其鸡肋程度了；<br><strong>4.render</strong>：这是所有生命周期中唯一一个你必须要实现的方法。一般来说需要返回一个 jsx 元素，这时 React 会根据 props 和 state 来把组件渲染到界面上；不过有时，你可能不想渲染任何东西，这种情况下让它返回 null 或者 false 即可；<br><strong>5.componentDidMount</strong>：会在组件挂载后（插入 DOM 树中后）立即调用，标志着组件挂载完成。一些操作如果依赖获取到 DOM 节点信息，我们就会放在这个阶段来做。此外，这还是 React 官方推荐的发起 ajax 请求的时机。该方法和 componentWillMount 一样，有且仅有一次调用。</p><h4 id="2-React-废弃了哪些生命周期？为什么？"><a href="#2-React-废弃了哪些生命周期？为什么？" class="headerlink" title="2. React 废弃了哪些生命周期？为什么？"></a>2. React 废弃了哪些生命周期？为什么？</h4><h4 id="3-React-16-X-中-props-改变后在哪个生命周期中处理"><a href="#3-React-16-X-中-props-改变后在哪个生命周期中处理" class="headerlink" title="3. React 16.X 中 props 改变后在哪个生命周期中处理"></a>3. React 16.X 中 props 改变后在哪个生命周期中处理</h4><h4 id="4-React-性能优化在哪个生命周期？它优化的原理是什么？"><a href="#4-React-性能优化在哪个生命周期？它优化的原理是什么？" class="headerlink" title="4. React 性能优化在哪个生命周期？它优化的原理是什么？"></a>4. React 性能优化在哪个生命周期？它优化的原理是什么？</h4><h4 id="5-state-和-props-触发更新的生命周期分别有什么区别？"><a href="#5-state-和-props-触发更新的生命周期分别有什么区别？" class="headerlink" title="5. state 和 props 触发更新的生命周期分别有什么区别？"></a>5. state 和 props 触发更新的生命周期分别有什么区别？</h4><h4 id="6-React中发起网络请求应该在哪个生命周期中进行？为什么？"><a href="#6-React中发起网络请求应该在哪个生命周期中进行？为什么？" class="headerlink" title="6. React中发起网络请求应该在哪个生命周期中进行？为什么？"></a>6. React中发起网络请求应该在哪个生命周期中进行？为什么？</h4><h4 id="7-React-16中新生命周期有哪些"><a href="#7-React-16中新生命周期有哪些" class="headerlink" title="7. React 16中新生命周期有哪些"></a>7. React 16中新生命周期有哪些</h4><p><a href="https://www.yuque.com/cuggz/interview/pgw8v4#b75bdbe861c53e813f8f288f1fec6115">参考</a></p><h3 id="四、组件通信"><a href="#四、组件通信" class="headerlink" title="四、组件通信"></a>四、组件通信</h3><p>React组件间通信常见的几种情况:<br>●父组件向子组件通信<br>●子组件向父组件通信<br>●跨级组件通信<br>●非嵌套关系的组件通信</p><h4 id="1-父子组件的通信方式？"><a href="#1-父子组件的通信方式？" class="headerlink" title="1. 父子组件的通信方式？"></a>1. 父子组件的通信方式？</h4><p>父组件向子组件通信：父组件通过 props 向子组件传递需要的信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 子组件: Child</span><br><span class="hljs-keyword">const</span> Child = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>&#125;<br><span class="hljs-comment">// 父组件 Parent</span><br><span class="hljs-keyword">const</span> Parent = <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;react&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>子组件向父组件通信：: props+回调的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 子组件: Child</span><br><span class="hljs-keyword">const</span> Child = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span>&#123;<br>  <span class="hljs-keyword">const</span> cb = <span class="hljs-function"><span class="hljs-params">msg</span> =&gt;</span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">()=&gt;</span>&#123;<br>          props.callback(msg)<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>      &lt;button onClick=&#123;cb(<span class="hljs-string">&quot;你好!&quot;</span>)&#125;&gt;你好&lt;/button&gt;<br>  )<br>&#125;<br><span class="hljs-comment">// 父组件 Parent</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">callback</span>(<span class="hljs-params">msg</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(msg)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">callback</span>=<span class="hljs-string">&#123;this.callback.bind(this)&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-跨级组件的通信方式？"><a href="#2-跨级组件的通信方式？" class="headerlink" title="2. 跨级组件的通信方式？"></a>2. 跨级组件的通信方式？</h4><p>父组件向子组件的子组件通信，向更深层子组件通信：<br>●使用props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递props，增加了复杂度，并且这些props并不是中间组件自己需要的。<br>●使用context，context相当于一个大容器，可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用context实现。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// context方式实现跨级组件通信 </span><br><span class="hljs-comment">// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据</span><br>const <span class="hljs-type">BatteryContext</span> = createContext();<br><span class="hljs-comment">//  子组件的子组件 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GrandChild</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    render()&#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;<span class="hljs-type">BatteryContext</span>.<span class="hljs-type">Consumer</span>&gt;<br>                &#123;<br>                    color =&gt; &lt;h1 style=&#123;&#123;<span class="hljs-string">&quot;color&quot;</span>:color&#125;&#125;&gt;我是红色的:&#123;color&#125;&lt;/h1&gt;<br>                &#125;<br>            &lt;/<span class="hljs-type">BatteryContext</span>.<span class="hljs-type">Consumer</span>&gt;<br>        )<br>    &#125;<br>&#125;<br><span class="hljs-comment">//  子组件</span><br>const <span class="hljs-type">Child</span> = () =&gt;&#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;<span class="hljs-type">GrandChild</span>/&gt;<br>    )<br>&#125;<br><span class="hljs-comment">// 父组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>      state = &#123;<br>          color:<span class="hljs-string">&quot;red&quot;</span><br>      &#125;<br>      render()&#123;<br>          const &#123;color&#125; = <span class="hljs-keyword">this</span>.state<br>          <span class="hljs-keyword">return</span> (<br>          &lt;<span class="hljs-type">BatteryContext</span>.<span class="hljs-type">Provider</span> value=&#123;color&#125;&gt;<br>              &lt;<span class="hljs-type">Child</span>&gt;&lt;/<span class="hljs-type">Child</span>&gt;<br>          &lt;/<span class="hljs-type">BatteryContext</span>.<span class="hljs-type">Provider</span>&gt;<br>          )<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-非嵌套关系组件的通信方式？"><a href="#3-非嵌套关系组件的通信方式？" class="headerlink" title="3. 非嵌套关系组件的通信方式？"></a>3. 非嵌套关系组件的通信方式？</h4><p>即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。<br>●可以使用自定义事件通信（发布订阅模式）<br>●可以通过redux等进行全局状态管理<br>●如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。</p><h4 id="4-如何解决-props-层级过深的问题"><a href="#4-如何解决-props-层级过深的问题" class="headerlink" title="4. 如何解决 props 层级过深的问题"></a>4. 如何解决 props 层级过深的问题</h4><p>●使用Context API：提供一种组件之间的状态共享，而不必通过显式组件树逐层传递props；<br>●使用Redux等状态库。</p><h4 id="5-组件通信的方式有哪些"><a href="#5-组件通信的方式有哪些" class="headerlink" title="5. 组件通信的方式有哪些"></a>5. 组件通信的方式有哪些</h4><p><strong>●⽗组件向⼦组件通讯</strong>: ⽗组件可以向⼦组件通过传 props 的⽅式，向⼦组件进⾏通讯<br><strong>●⼦组件向⽗组件通讯</strong>: props+回调的⽅式，⽗组件向⼦组件传递props进⾏通讯，此props为作⽤域为⽗组件⾃身的函 数，⼦组件调⽤该函数，将⼦组件想要传递的信息，作为参数，传递到⽗组件的作⽤域中<br>●兄弟组件通信: 找到这两个兄弟节点共同的⽗节点,结合上⾯两种⽅式由⽗节点转发信息进⾏通信<br><strong>●跨层级通信</strong>: Context 设计⽬的是为了共享那些对于⼀个组件树⽽⾔是“全局”的数据，例如当前认证的⽤户、主题或⾸选语⾔，对于跨越多层的全局数据通过 Context 通信再适合不过<br><strong>●发布订阅模式</strong>: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引⼊event模块进⾏通信<br><strong>●全局状态管理⼯具</strong>: 借助Redux或者Mobx等全局状态管理⼯具进⾏通信,这种⼯具会维护⼀个全局状态中⼼Store,并根据不同的事件产⽣新的状态</p><h3 id="五、路由"><a href="#五、路由" class="headerlink" title="五、路由"></a>五、路由</h3><h4 id="1-React-Router的实现原理是什么？"><a href="#1-React-Router的实现原理是什么？" class="headerlink" title="1. React-Router的实现原理是什么？"></a>1. React-Router的实现原理是什么？</h4><p>客户端路由实现的思想：<br>●基于 hash 的路由：通过监听hashchange事件，感知 hash 的变化<br>○改变 hash 可以直接通过 location.hash=xxx<br>●基于 H5 history 路由：<br>○改变 url 可以通过 history.pushState 和 resplaceState 等，会将URL压入堆栈，同时能够应用 history.go() 等 API<br>○监听 url 的变化可以通过自定义事件触发实现</p><p><strong>react-router 实现的思想：</strong><br>●基于 history 库来实现上述不同的客户端路由实现思想，并且能够保存历史记录等，磨平浏览器差异，上层无感知<br>●通过维护的列表，在每次 URL 发生变化的回收，通过配置的 路由路径，匹配到对应的 Component，并且 render</p><h4 id="2-如何配置-React-Router-实现路由切换"><a href="#2-如何配置-React-Router-实现路由切换" class="headerlink" title="2. 如何配置 React-Router 实现路由切换"></a>2. 如何配置 React-Router 实现路由切换</h4><p><strong>（1）使用<code>&lt;Route&gt;</code>组件</strong><br>路由匹配是通过比较<code> &lt;Route&gt;</code> 的 path 属性和当前地址的 pathname 来实现的。当一个<code> &lt;Route&gt;</code> 匹配成功时，它将渲染其内容，当它不匹配时就会渲染 null。没有路径的 <code>&lt;Route&gt; </code>将始终被匹配。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">// when location = </span><span class="hljs-template-variable">&#123; pathname: &#x27;/about&#x27; &#125;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#x27;/about&#x27;</span> <span class="hljs-attr">component</span>=</span></span><span class="hljs-template-variable">&#123;About&#125;</span><span class="xml"><span class="hljs-tag">/&gt;</span> // renders <span class="hljs-tag">&lt;<span class="hljs-name">About</span>/&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#x27;/contact&#x27;</span> <span class="hljs-attr">component</span>=</span></span><span class="hljs-template-variable">&#123;Contact&#125;</span><span class="xml"><span class="hljs-tag">/&gt;</span> // renders null</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">component</span>=</span></span><span class="hljs-template-variable">&#123;Always&#125;</span><span class="xml"><span class="hljs-tag">/&gt;</span> // renders <span class="hljs-tag">&lt;<span class="hljs-name">Always</span>/&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>（2）结合使用 <code>&lt;Switch&gt;</code> 组件和 <code>&lt;Route&gt;</code> 组件</strong><br><code>&lt;Switch&gt;</code> 用于将 <code>&lt;Route&gt;</code> 分组。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Home&#125;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/about&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;About&#125;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/contact&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Contact&#125;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;Switch&gt;</code> 不是分组<code>&lt;Route&gt;</code>所必须的，但他通常很有用。 一个 <code>&lt;Switch&gt; </code>会遍历其所有的子 <code>&lt;Route&gt;</code>元素，并仅渲染与当前地址匹配的第一个元素。<br><strong>（3）使用<code> &lt;Link&gt;、 &lt;NavLink&gt;、&lt;Redirect&gt;</code> 组件</strong><br><code>&lt;Link&gt; </code>组件来在你的应用程序中创建链接。无论你在何处渲染一个<code> &lt;Link&gt;</code> ，都会在应用程序的 HTML 中渲染锚（<code>&lt;a&gt;</code>）。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&lt;<span class="hljs-keyword">Link</span> <span class="hljs-keyword">to</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;Home&lt;/<span class="hljs-keyword">Link</span>&gt;   <br><span class="hljs-comment">// &lt;a href=&#x27;/&#x27;&gt;Home&lt;/a&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;NavLink&gt; </code>是一种特殊类型的 <code>&lt;Link&gt;</code> 当它的 to属性与当前地址匹配时，可以将其定义为”活跃的”。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> location = &#123; pathname: <span class="hljs-string">&#x27;/react&#x27;</span> &#125;<br>&lt;NavLink to=<span class="hljs-string">&quot;/react&quot;</span> activeClassName=<span class="hljs-string">&quot;hurray&quot;</span>&gt;<br>    React<br>&lt;/NavLink&gt;<br><span class="hljs-regexp">//</span> &lt;a href=<span class="hljs-string">&#x27;/react&#x27;</span> className=<span class="hljs-string">&#x27;hurray&#x27;</span>&gt;React&lt;/a&gt;<br></code></pre></td></tr></table></figure><p>当我们想强制导航时，可以渲染一个<code>&lt;Redirect&gt;</code>，当一个<code>&lt;Redirect&gt;</code>渲染时，它将使用它的to属性进行定向</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">from</span>=<span class="hljs-string">&#x27;/users/:id&#x27;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#x27;/users/profile/:id&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#x27;/users/profile/:id&#x27;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Profile&#125;/</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当我们想强制导航时，可以渲染一个<code>&lt;Redirect&gt;</code>，当一个<code>&lt;Redirect&gt;</code>渲染时，它将使用它的to属性进行定向。</p><h4 id="3-React-Router怎么设置重定向？"><a href="#3-React-Router怎么设置重定向？" class="headerlink" title="3. React-Router怎么设置重定向？"></a>3. React-Router怎么设置重定向？</h4><p>使用<code>&lt;Redirect&gt;</code>组件实现路由的重定向：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">from</span>=<span class="hljs-string">&#x27;/users/:id&#x27;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#x27;/users/profile/:id&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#x27;/users/profile/:id&#x27;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Profile&#125;/</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当请求 /users/:id 被重定向去 ‘/users/profile/:id’：<br>●属性 from: string：需要匹配的将要被重定向路径。<br>●属性 to: string：重定向的 URL 字符串<br>●属性 to: object：重定向的 location 对象<br>●属性 push: bool：若为真，重定向操作将会把新地址加入到访问历史记录里面，并且无法回退到前面的页面。</p><h4 id="4-react-router-里的-Link-标签和-a-标签的区别"><a href="#4-react-router-里的-Link-标签和-a-标签的区别" class="headerlink" title="4. react-router 里的 Link 标签和 a 标签的区别"></a>4. react-router 里的 Link 标签和 a 标签的区别</h4><p>从最终渲染的 DOM 来看，这两者都是链接，都是 标签，区别是∶<br><code>&lt;Link&gt;</code>是react-router 里实现路由跳转的链接，一般配合<code>&lt;Route&gt; </code>使用，react-router接管了其默认的链接跳转行为，区别于传统的页面跳转，<code>&lt;Link&gt;</code> 的“跳转”行为只会触发相匹配的<code>&lt;Route&gt;</code>对应的页面内容更新，而不会刷新整个页面。</p><p><code>&lt;Link&gt;</code>做了3件事情:<br>●有onclick那就执行onclick<br>●click的时候阻止a标签默认事件<br>●根据跳转href(即是to)，用history (web前端路由两种方式之一，history &amp; hash)跳转，此时只是链接变了，并没有刷新页面而<code>&lt;a&gt;</code>标签就是普通的超链接了，用于从当前页面跳转到href指向的另一 个页面(非锚点情况)。</p><p>a标签默认事件禁掉之后做了什么才实现了跳转?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> domArr = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;a&#x27;</span>)<br>[...domArr].forEach(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>    item.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        location.href = <span class="hljs-built_in">this</span>.href<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="5-React-Router如何获取URL的参数和历史对象？"><a href="#5-React-Router如何获取URL的参数和历史对象？" class="headerlink" title="5. React-Router如何获取URL的参数和历史对象？"></a>5. React-Router如何获取URL的参数和历史对象？</h4><p>（1）获取URL的参数<br><strong>●get传值</strong><br>路由配置还是普通的配置，如：’admin’，传参方式如：’admin?id=’1111’’。通过this.props.location.search获取url获取到一个字符串’?id=’1111’<br>可以用url，qs，querystring，浏览器提供的api URLSearchParams对象或者自己封装的方法去解析出id的值。<br><strong>●动态路由传值</strong><br>路由需要配置成动态路由：如path=’/admin/:id’，传参方式，如’admin/111’。通过this.props.match.params.id 取得url中的动态路由id部分的值，除此之外还可以通过useParams（Hooks）来获取<br><strong>●通过query或state传值</strong><br>传参方式如：在Link组件的to属性中可以传递对象{pathname:’/admin’,query:’111’,state:’111’};。通过this.props.location.state或this.props.location.query来获取即可，传递的参数可以是对象、数组等，但是存在缺点就是只要刷新页面，参数就会丢失。<br><strong>（2）获取历史对象</strong><br>●如果React &gt;= 16.8 时可以使用 React Router中提供的Hooks</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123; useHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;<br><span class="hljs-keyword">let</span> history = useHistory();<br></code></pre></td></tr></table></figure><p>2.使用this.props.history获取历史对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> <span class="hljs-built_in">history</span> = this.props.history;<br></code></pre></td></tr></table></figure><h4 id="6-React-Router-4怎样在路由变化时重新渲染同一个组件？"><a href="#6-React-Router-4怎样在路由变化时重新渲染同一个组件？" class="headerlink" title="6. React-Router 4怎样在路由变化时重新渲染同一个组件？"></a>6. React-Router 4怎样在路由变化时重新渲染同一个组件？</h4><p>当路由变化时，即组件的props发生了变化，会调用componentWillReceiveProps等生命周期钩子。那需要做的只是： 当路由改变时，根据路由，也去请求数据：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewsList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  componentDidMount () &#123;<br>     <span class="hljs-keyword">this</span>.fetchData(<span class="hljs-keyword">this</span>.props.location);<br>  &#125;<br>  <br>  fetchData(location) &#123;<br>    const <span class="hljs-class"><span class="hljs-keyword">type</span> </span>= location.pathname.replace(&#x27;/&#x27;, &#x27;&#x27;) || <span class="hljs-symbol">&#x27;to</span>p&#x27;<br>    <span class="hljs-keyword">this</span>.props.dispatch(fetchListData(<span class="hljs-class"><span class="hljs-keyword">type</span>))</span><br><span class="hljs-class">  &#125;</span><br><span class="hljs-class">  <span class="hljs-title">componentWillReceiveProps</span>(<span class="hljs-params">nextProps</span>) </span>&#123;<br>     <span class="hljs-keyword">if</span> (nextProps.location.pathname != <span class="hljs-keyword">this</span>.props.location.pathname) &#123;<br>         <span class="hljs-keyword">this</span>.fetchData(nextProps.location);<br>     &#125; <br>  &#125;<br>  render () &#123;<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用生命周期componentWillReceiveProps，进行重新render的预处理操作。</p><h4 id="7-React-Router的路由有几种模式？"><a href="#7-React-Router的路由有几种模式？" class="headerlink" title="7. React-Router的路由有几种模式？"></a>7. React-Router的路由有几种模式？</h4><p>React-Router 支持使用 hash（对应 HashRouter）和 browser（对应 BrowserRouter） 两种路由规则， react-router-dom 提供了 BrowserRouter 和 HashRouter 两个组件来实现应用的 UI 和 URL 同步：<br>●BrowserRouter 创建的 URL 格式：<a href="http://xxx.com/path">http://xxx.com/path</a><br>●HashRouter 创建的 URL 格式：<a href="http://xxx.com/#/path">http://xxx.com/#/path</a></p><p><strong>（1）BrowserRouter</strong><br>它使用 HTML5 提供的 history API（pushState、replaceState 和 popstate 事件）来保持 UI 和 URL 的同步。由此可以看出，<strong>BrowserRouter 是使用 HTML 5 的 history API 来控制路由跳转的</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;BrowserRouter<br>    basename=&#123;string&#125;<br>    forceRefresh=&#123;bool&#125;<br>    getUserConfirmation=&#123;func&#125;<br>    keyLength=&#123;number&#125;<br>/&gt;<br></code></pre></td></tr></table></figure><p>其中的属性如下：<br>●basename 所有路由的基准 URL。basename 的正确格式是前面有一个前导斜杠，但不能有尾部斜杠；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span> <span class="hljs-attr">basename</span>=<span class="hljs-string">&quot;/calendar&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/today&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span><br></code></pre></td></tr></table></figure><p>等同于</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/calendar/today&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>●forceRefresh 如果为 true，在导航的过程中整个页面将会刷新。一般情况下，只有在不支持 HTML5 history API 的浏览器中使用此功能；<br>●getUserConfirmation 用于确认导航的函数，默认使用 window.confirm。例如，当从 /a 导航至 /b 时，会使用默认的 confirm 函数弹出一个提示，用户点击确定后才进行导航，否则不做任何处理；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这是默认的确认函数</span><br><span class="hljs-keyword">const</span> getConfirmation = <span class="hljs-function">(<span class="hljs-params">message, callback</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> allowTransition = <span class="hljs-built_in">window</span>.confirm(message);<br>  callback(allowTransition);<br>&#125;<br>&lt;BrowserRouter getUserConfirmation=&#123;getConfirmation&#125; /&gt;<br></code></pre></td></tr></table></figure><p>需要配合<code>&lt;Prompt&gt;</code> 一起使用。<br>●KeyLength 用来设置 Location.Key 的长度。</p><p><strong>（2）HashRouter</strong><br>使用 URL 的 hash 部分（即 window.location.hash）来保持 UI 和 URL 的同步。由此可以看出，<strong>HashRouter 是通过 URL 的 hash 属性来控制路由跳转的：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;HashRouter<br>    basename=&#123;string&#125;<br>    getUserConfirmation=&#123;func&#125;<br>    hashType=&#123;string&#125;  <br>/&gt;<br></code></pre></td></tr></table></figure><p>其中的参数如下：<br>●basename, getUserConfirmation 和 BrowserRouter 功能一样；<br>●hashType window.location.hash 使用的 hash 类型，有如下几种：<br>  ○ slash - 后面跟一个斜杠，例如 #/ 和 #/sunshine/lollipops；<br>  ○ noslash - 后面没有斜杠，例如 # 和 #sunshine/lollipops；<br>  ○ hashbang - Google 风格的 ajax crawlable，例如 #!/ 和 #!/sunshine/lollipops。</p><h4 id="8-React-Router-4的Switch有什么用？"><a href="#8-React-Router-4的Switch有什么用？" class="headerlink" title="8. React-Router 4的Switch有什么用？"></a>8. React-Router 4的Switch有什么用？</h4><p>Switch 通常被用来包裹 Route，用于渲染与路径匹配的第一个子 <code>&lt;Route&gt;</code> 或 <code>&lt;Redirect&gt;</code>，它里面不能放其他元素。</p><p>假如不加<code>&lt;Switch&gt;</code>：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">import </span><span class="hljs-template-variable">&#123; Route &#125;</span><span class="xml"> from &#x27;react-router-dom&#x27;</span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">component</span>=</span></span><span class="hljs-template-variable">&#123;Home&#125;</span><span class="xml"><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">component</span>=</span></span><span class="hljs-template-variable">&#123;Login&#125;</span><span class="xml"><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>Route 组件的 path 属性用于匹配路径，因为需要匹配 / 到 Home，匹配 /login 到 Login，所以需要两个 Route，但是不能这么写。这样写的话，当 URL 的 path 为 “/login” 时，<code>&lt;Route path=&quot;/&quot; /&gt;和&lt;Route path=&quot;/login&quot; /&gt; </code>都会被匹配，因此页面会展示 Home 和 Login 两个组件。这时就需要借助 <code>&lt;Switch&gt;</code> 来做到只显示一个匹配组件：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">import </span><span class="hljs-template-variable">&#123; Switch, Route&#125;</span><span class="xml"> from &#x27;react-router-dom&#x27;</span><br><span class="xml">    </span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">component</span>=</span></span><span class="hljs-template-variable">&#123;Home&#125;</span><span class="xml"><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">component</span>=</span></span><span class="hljs-template-variable">&#123;Login&#125;</span><span class="xml"><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="六、Redux"><a href="#六、Redux" class="headerlink" title="六、Redux"></a>六、Redux</h3><h4 id="1-对-Redux-的理解，主要解决什么问题"><a href="#1-对-Redux-的理解，主要解决什么问题" class="headerlink" title="1. 对 Redux 的理解，主要解决什么问题"></a>1. 对 Redux 的理解，主要解决什么问题</h4><p>React是视图层框架。Redux是一个用来管理数据状态和UI状态的JavaScript应用工具。随着JavaScript单页应用（SPA）开发日趋复杂， JavaScript需要管理比任何时候都要多的state（状态）， Redux就是降低管理难度的。（Redux支持React、Angular、jQuery甚至纯JavaScript）。</p><p>在 React 中，UI 以组件的形式来搭建，组件之间可以嵌套组合。但 React 中组件间通信的数据流是单向的，顶层组件可以通过 props 属性向下层组件传递数据，而下层组件不能向上层组件传递数据，兄弟组件之间同样不能。这样简单的单向数据流支撑起了 React 中的数据可控性。</p><p>当项目越来越大的时候，管理数据的事件或回调函数将越来越多，也将越来越不好管理。管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等。state 的管理在大项目中相当复杂。</p><p>Redux 提供了一个叫 store 的统一仓储库，组件通过 dispatch 将 state 直接传入store，不用通过其他的组件。并且组件通过 subscribe 从 store获取到 state 的改变。使用了 Redux，所有的组件都可以从 store 中获取到所需的 state，他们也能从store 获取到 state 的改变。这比组件之间互相传递数据清晰明朗的多。</p><p><strong>主要解决的问题：</strong><br>单纯的Redux只是一个状态机，是没有UI呈现的，react- redux作用是将Redux的状态机和React的UI呈现绑定在一起，当你dispatch action改变state的时候，会自动更新页面。</p><h4 id="2-Redux-原理及工作流程"><a href="#2-Redux-原理及工作流程" class="headerlink" title="2. Redux 原理及工作流程"></a>2. Redux 原理及工作流程</h4><p><strong>（1）原理</strong><br>Redux源码主要分为以下几个模块文件<br>●compose.js 提供从右到左进行函数式编程<br>●createStore.js 提供作为生成唯一store的函数<br>●combineReducers.js 提供合并多个reducer的函数，保证store的唯一性<br>●bindActionCreators.js 可以让开发者在不直接接触dispacth的前提下进行更改state的操作<br>●applyMiddleware.js 这个方法通过中间件来增强dispatch的功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> actionTypes = &#123;<br>    ADD: <span class="hljs-string">&#x27;ADD&#x27;</span>,<br>    CHANGEINFO: <span class="hljs-string">&#x27;CHANGEINFO&#x27;</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> initState = &#123;<br>    info: <span class="hljs-string">&#x27;初始化&#x27;</span>,<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initReducer</span>(<span class="hljs-params">state=initState, action</span>) </span>&#123;<br>    <span class="hljs-keyword">switch</span>(action.type) &#123;<br>        <span class="hljs-keyword">case</span> actionTypes.CHANGEINFO:<br>            <span class="hljs-keyword">return</span> &#123;<br>                ...state,<br>                info: action.preload.info || <span class="hljs-string">&#x27;&#x27;</span>,<br>            &#125;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> &#123; ...state &#125;;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createStore</span>(<span class="hljs-params">reducer, initialState, middleFunc</span>) </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (initialState &amp;&amp; <span class="hljs-keyword">typeof</span> initialState === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        middleFunc = initialState;<br>        initialState = <span class="hljs-literal">undefined</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> currentState = initialState;<br><br>    <span class="hljs-keyword">const</span> listeners = [];<br><br>    <span class="hljs-keyword">if</span> (middleFunc &amp;&amp; <span class="hljs-keyword">typeof</span> middleFunc === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 封装dispatch </span><br>        <span class="hljs-keyword">return</span> middleFunc(createStore)(reducer, initialState);<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> getState = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> currentState;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> dispatch = <span class="hljs-function">(<span class="hljs-params">action</span>) =&gt;</span> &#123;<br>        currentState = reducer(currentState, action);<br><br>        listeners.forEach(<span class="hljs-function"><span class="hljs-params">listener</span> =&gt;</span> &#123;<br>            listener();<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> subscribe = <span class="hljs-function">(<span class="hljs-params">listener</span>) =&gt;</span> &#123;<br>        listeners.push(listener);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &#123;<br>        getState,<br>        dispatch,<br>        subscribe<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）工作流程</strong><br>●const store= createStore（fn）生成数据;<br>●action: {type: Symble(‘action01), payload:’payload’ }定义行为;<br>●dispatch发起action：store.dispatch(doSomething(‘action001’));<br>●reducer：处理action，返回新的state;</p><p>通俗点解释：<br>●首先，用户（通过View）发出Action，发出方式就用到了dispatch方法<br>●然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State<br>●State—旦有变化，Store就会调用监听函数，来更新View</p><p>以 store 为核心，可以把它看成数据存储中心，但是他要更改数据的时候不能直接修改，数据修改更新的角色由Reducers来担任，store只做存储，中间人，当Reducers的更新完成以后会通过store的订阅来通知react component，组件把新的状态重新获取渲染，组件中也能主动发送action，创建action后这个动作是不会执行的，所以要dispatch这个action，让store通过reducers去做更新React Component 就是react的每个组件。</p><h4 id="3-Redux-中异步的请求怎么处理"><a href="#3-Redux-中异步的请求怎么处理" class="headerlink" title="3. Redux 中异步的请求怎么处理"></a>3. Redux 中异步的请求怎么处理</h4><p>可以在 componentDidmount 中直接进⾏请求⽆须借助redux。但是在⼀定规模的项⽬中,上述⽅法很难进⾏异步流的管理,通常情况下我们会借助redux的异步中间件进⾏异步处理。redux异步流中间件其实有很多，当下主流的异步中间件有两种redux-thunk、redux-saga。<br><strong>（1）使用react-thunk中间件</strong><br><strong>redux-thunk</strong>优点:<br>●体积⼩: redux-thunk的实现⽅式很简单,只有不到20⾏代码<br>●使⽤简单: redux-thunk没有引⼊像redux-saga或者redux-observable额外的范式,上⼿简单<br><strong>redux-thunk</strong>缺陷:<br>●样板代码过多: 与redux本身⼀样,通常⼀个请求需要⼤量的代码,⽽且很多都是重复性质的<br>●耦合严重: 异步操作与redux的action偶合在⼀起,不⽅便管理<br>●功能孱弱: 有⼀些实际开发中常⽤的功能需要⾃⼰进⾏封装 </p><p>使用步骤：<br>●配置中间件，在store的创建中配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;createStore, applyMiddleware, compose&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducer&#x27;</span>;<br><span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span><br><br><span class="hljs-comment">// 设置调试工具</span><br><span class="hljs-keyword">const</span> composeEnhancers = <span class="hljs-built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? <span class="hljs-built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;) : compose;<br><span class="hljs-comment">// 设置中间件</span><br><span class="hljs-keyword">const</span> enhancer = composeEnhancers(<br>  applyMiddleware(thunk)<br>);<br><br><span class="hljs-keyword">const</span> store = createStore(reducer, enhancer);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure><p>●添加一个返回函数的actionCreator，将异步请求逻辑放在里面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  发送get请求，并生成相应action，更新store的函数</span><br><span class="hljs-comment">  <span class="hljs-doctag">@param </span>url &#123;string&#125; 请求地址</span><br><span class="hljs-comment">  <span class="hljs-doctag">@param </span>func &#123;function&#125; 真正需要生成的action对应的actionCreator</span><br><span class="hljs-comment">  <span class="hljs-doctag">@return <span class="hljs-type">&#123;function&#125;</span> </span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// dispatch为自动接收的store.dispatch函数 </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getHttpAction = <span class="hljs-function">(<span class="hljs-params">url, func</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span> &#123;<br>    axios.get(url).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)</span>&#123;<br>        <span class="hljs-keyword">const</span> action = func(res.data)<br>        dispatch(action)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>●生成action，并发送action</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">componentDidMount</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-selector-tag">var</span> action = getHttpAction(<span class="hljs-string">&#x27;/getData&#x27;</span>, getInitTodoItemAction)<br>    <span class="hljs-comment">// 发送函数类型的action时，该action的函数体会自动执行</span><br>    store<span class="hljs-selector-class">.dispatch</span>(action)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（2）使用redux-saga中间件</strong><br><strong>redux-saga优点:</strong><br>●异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js 中<br>●action摆脱thunk function: dispatch 的参数依然是⼀个纯粹的 action (FSA)，⽽不是充满 “⿊魔法” thunk function<br>●异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过 try/catch 语法直接捕获处理<br>●功能强⼤: redux-saga提供了⼤量的Saga 辅助函数和Effect 创建器供开发者使⽤,开发者⽆须封装或者简单封装即可使⽤<br>●灵活: redux-saga可以将多个Saga可以串⾏/并⾏组合起来,形成⼀个⾮常实⽤的异步flow<br>●易测试，提供了各种case的测试⽅案，包括mock task，分⽀覆盖等等 </p><p><strong>redux-saga缺陷:</strong><br>●额外的学习成本: redux-saga不仅在使⽤难以理解的 generator function,⽽且有数⼗个API,学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和⼀整套思想<br>●体积庞⼤: 体积略⼤,代码近2000⾏，min版25KB左右<br>●功能过剩: 实际上并发控制等功能很难⽤到,但是我们依然需要引⼊这些代码<br>●ts⽀持不友好: yield⽆法返回TS类型 </p><p>redux-saga可以捕获action，然后执行一个函数，那么可以把异步代码放在这个函数中，使用步骤如下：<br>●配置中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;createStore, applyMiddleware, compose&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducer&#x27;</span>;<br><span class="hljs-keyword">import</span> createSagaMiddleware <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-saga&#x27;</span><br><span class="hljs-keyword">import</span> TodoListSaga <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./sagas&#x27;</span><br><br><span class="hljs-keyword">const</span> composeEnhancers = <span class="hljs-built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? <span class="hljs-built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;) : compose;<br><span class="hljs-keyword">const</span> sagaMiddleware = createSagaMiddleware()<br><br><span class="hljs-keyword">const</span> enhancer = composeEnhancers(<br>  applyMiddleware(sagaMiddleware)<br>);<br><br><span class="hljs-keyword">const</span> store = createStore(reducer, enhancer);<br>sagaMiddleware.run(TodoListSaga)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure><p>●将异步请求放在sagas.js中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;takeEvery, put&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-saga/effects&#x27;</span><br><span class="hljs-keyword">import</span> &#123;initTodoList&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./actionCreator&#x27;</span><br><span class="hljs-keyword">import</span> &#123;GET_INIT_ITEM&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./actionTypes&#x27;</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">func</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-comment">// 可以获取异步返回数据</span><br>        <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> axios.get(<span class="hljs-string">&#x27;/getData&#x27;</span>)<br>        <span class="hljs-keyword">const</span> action = initTodoList(res.data)<br>        <span class="hljs-comment">// 将action发送到reducer</span><br>        <span class="hljs-keyword">yield</span> put(action)<br>    &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;网络请求失败&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">mySaga</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// 自动捕获GET_INIT_ITEM类型的action，并执行func</span><br>    <span class="hljs-keyword">yield</span> takeEvery(GET_INIT_ITEM, func)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> mySaga<br></code></pre></td></tr></table></figure><p>●发送action</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">componentDidMount</span><span class="hljs-params">()</span></span>&#123;<br>  const action = getInitTodoItemAction()<br>  store<span class="hljs-selector-class">.dispatch</span>(action)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-Redux-怎么实现属性传递，介绍下原理"><a href="#4-Redux-怎么实现属性传递，介绍下原理" class="headerlink" title="4. Redux 怎么实现属性传递，介绍下原理"></a>4. Redux 怎么实现属性传递，介绍下原理</h4><p>react-redux 数据传输∶ view–&gt;action–&gt;reducer–&gt;store–&gt;view。看下点击事件的数据是如何通过redux传到view上：<br>●view 上的AddClick 事件通过mapDispatchToProps 把数据传到action —&gt; click:()=&gt;dispatch(ADD)<br>●action 的ADD 传到reducer上<br>●reducer传到store上 const store = createStore(reducer);<br>●store再通过 mapStateToProps 映射穿到view上text:State.text</p><p>代码示例∶</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Provider, connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">let</span> &#123; text, click, clickR &#125; = <span class="hljs-built_in">this</span>.props;<br>        <span class="hljs-keyword">return</span>(<br>            &lt;div&gt;<br>                &lt;div&gt;数据:已有人&#123;text&#125;&lt;/div&gt;<br>                &lt;div onClick=&#123;click&#125;&gt;加人&lt;/div&gt;<br>                &lt;div onClick=&#123;clickR&#125;&gt;减人&lt;/div&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> initialState = &#123;<br>    text:<span class="hljs-number">5</span><br>&#125;<br><span class="hljs-keyword">const</span> reducer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">state,action</span>)</span>&#123;<br>    <span class="hljs-keyword">switch</span>(action.type)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD&#x27;</span>:<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">text</span>:state.text+<span class="hljs-number">1</span>&#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;REMOVE&#x27;</span>:<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">text</span>:state.text-<span class="hljs-number">1</span>&#125;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> initialState;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ADD = &#123;<br>    type:<span class="hljs-string">&#x27;ADD&#x27;</span><br>&#125;<br><span class="hljs-keyword">let</span> Remove = &#123;<br>    type:<span class="hljs-string">&#x27;REMOVE&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> store = createStore(reducer);<br><br><span class="hljs-keyword">let</span> mapStateToProps = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        text:state.text<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> mapDispatchToProps = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">dispatch</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        click:<span class="hljs-function">()=&gt;</span>dispatch(ADD),<br>        clickR:<span class="hljs-function">()=&gt;</span>dispatch(Remove)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> App1 = connect(mapStateToProps,mapDispatchToProps)(App);<br><br>ReactDOM.render(<br>    &lt;Provider store = &#123;store&#125;&gt;<br>        &lt;App1&gt;&lt;/App1&gt;<br>    &lt;/Provider&gt;,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure><h4 id="5-Redux-中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？"><a href="#5-Redux-中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？" class="headerlink" title="5. Redux 中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？"></a>5. Redux 中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？</h4><p>Redux 的中间件提供的是位于 action 被发起之后，到达 reducer 之前的扩展点，换而言之，原本 view -→&gt; action -&gt; reducer -&gt; store 的数据流加上中间件后变成了 view -&gt; action -&gt; middleware -&gt; reducer -&gt; store ，在这一环节可以做一些”副作用”的操作，如异步请求、打印日志等。</p><p>applyMiddleware源码：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">export <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyMiddleware</span><span class="hljs-params">(<span class="hljs-rest_arg">...middlewares</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> createStore =&gt; (...args) =&gt; &#123;<br>        <span class="hljs-comment">// 利用传入的createStore和reducer和创建一个store</span><br>        <span class="hljs-keyword">const</span> store = createStore(...args)<br>        let dispatch = () =&gt; &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error()<br>        &#125;<br>        <span class="hljs-keyword">const</span> middlewareAPI = &#123;<br>            getState: store.getState,<br>            dispatch: (...args) =&gt; dispatch(...args)<br>        &#125;<br>        <span class="hljs-comment">// 让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍</span><br>        <span class="hljs-keyword">const</span> chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))<br>        <span class="hljs-comment">// 接着 compose 将 chain 中的所有匿名函数，组装成一个新的函数，即新的 dispatch</span><br>        dispatch = compose(...chain)(store.dispatch)<br>        <span class="hljs-keyword">return</span> &#123;<br>            ...store,<br>            dispatch<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从applyMiddleware中可以看出∶<br>●redux中间件接受一个对象作为参数，对象的参数上有两个字段 dispatch 和 getState，分别代表着 Redux Store 上的两个同名函数。<br>●柯里化函数两端一个是 middewares，一个是store.dispatch</p><h4 id="6-Redux-请求中间件如何处理并发"><a href="#6-Redux-请求中间件如何处理并发" class="headerlink" title="6. Redux 请求中间件如何处理并发"></a>6. Redux 请求中间件如何处理并发</h4><p>使用redux-Saga<br>redux-saga是一个管理redux应用异步操作的中间件，用于代替 redux-thunk 的。它通过创建 Sagas 将所有异步操作逻辑存放在一个地方进行集中处理，以此将react中的同步操作与异步操作区分开来，以便于后期的管理与维护。 redux-saga如何处理并发：<br><strong>●takeEvery</strong><br>可以让多个 saga 任务并行被 fork 执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;<br>    fork,<br>    take<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux-saga/effects&quot;</span><br><br><span class="hljs-keyword">const</span> takeEvery = <span class="hljs-function">(<span class="hljs-params">pattern, saga, ...args</span>) =&gt;</span> fork(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">const</span> action = <span class="hljs-keyword">yield</span> take(pattern)<br>        <span class="hljs-keyword">yield</span> fork(saga, ...args.concat(action))<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>●takeLatest</strong><br>takeLatest 不允许多个 saga 任务并行地执行。一旦接收到新的发起的 action，它就会取消前面所有 fork 过的任务（如果这些任务还在执行的话）。<br>在处理 AJAX 请求的时候，如果只希望获取最后那个请求的响应， takeLatest 就会非常有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;<br>    cancel,<br>    fork,<br>    take<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux-saga/effects&quot;</span><br><br><span class="hljs-keyword">const</span> takeLatest = <span class="hljs-function">(<span class="hljs-params">pattern, saga, ...args</span>) =&gt;</span> fork(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> lastTask<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">const</span> action = <span class="hljs-keyword">yield</span> take(pattern)<br>        <span class="hljs-keyword">if</span> (lastTask) &#123;<br>            <span class="hljs-keyword">yield</span> cancel(lastTask) <span class="hljs-comment">// 如果任务已经结束，则 cancel 为空操作</span><br>        &#125;<br>        lastTask = <span class="hljs-keyword">yield</span> fork(saga, ...args.concat(action))<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="7-Redux-状态管理器和变量挂载到-window-中有什么区别"><a href="#7-Redux-状态管理器和变量挂载到-window-中有什么区别" class="headerlink" title="7. Redux 状态管理器和变量挂载到 window 中有什么区别"></a>7. Redux 状态管理器和变量挂载到 window 中有什么区别</h4><p>两者都是存储数据以供后期使用。但是Redux状态更改可回溯——Time travel，数据多了的时候可以很清晰的知道改动在哪里发生，完整的提供了一套状态管理模式。</p><p>随着 JavaScript 单页应用开发日趋复杂，JavaScript 需要管理比任何时候都要多的 state （状态）。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。</p><p>管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。<br>如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等等。前端开发者正在经受前所未有的复杂性，难道就这么放弃了吗?当然不是。</p><p>这里的复杂性很大程度上来自于：我们总是将两个难以理清的概念混淆在一起：变化和异步。 可以称它们为曼妥思和可乐。如果把二者分开，能做的很好，但混到一起，就变得一团糟。一些库如 React 视图在视图层禁止异步和直接操作 DOM来解决这个问题。美中不足的是，React 依旧把处理 state 中数据的问题留给了你。Redux就是为了帮你解决这个问题。</p><h4 id="8-mobox-和-redux-有什么区别？"><a href="#8-mobox-和-redux-有什么区别？" class="headerlink" title="8. mobox 和 redux 有什么区别？"></a>8. mobox 和 redux 有什么区别？</h4><p><strong>（1）共同点</strong><br>●为了解决状态管理混乱，无法有效同步的问题统一维护管理应用状态;<br>●某一状态只有一个可信数据来源（通常命名为store，指状态容器）;<br>●操作更新状态方式统一，并且可控（通常以action方式提供更新状态的途径）;<br>●支持将store与React组件连接，如react-redux，mobx- react;<br><strong>（2）区别</strong><br>Redux更多的是遵循Flux模式的一种实现，是一个 JavaScript库，它关注点主要是以下几方面∶<br>●Action∶ 一个JavaScript对象，描述动作相关信息，主要包含type属性和payload属性∶<br>         o type∶ action 类型;<br>         o payload∶ 负载数据;<br>●Reducer∶ 定义应用状态如何响应不同动作（action），如何更新状态;<br>●Store∶ 管理action和reducer及其关系的对象，主要提供以下功能∶<br>         o 维护应用状态并支持访问状态(getState());<br>         o 支持监听action的分发，更新状态(dispatch(action));<br>         o 支持订阅store的变更(subscribe(listener));<br>●异步流∶ 由于Redux所有对store状态的变更，都应该通过action触发，异步任务（通常都是业务或获取数据任务）也不例外，而为了不将业务或数据相关的任务混入React组件中，就需要使用其他框架配合管理异步任务流程，如redux-thunk，redux-saga等; </p><p>Mobx是一个透明函数响应式编程的状态管理库，它使得状态管理简单可伸缩∶<br>●Action∶定义改变状态的动作函数，包括如何变更状态;<br>●Store∶ 集中管理模块状态（State）和动作(action)<br>●Derivation（衍生）∶ 从应用状态中派生而出，且没有任何其他影响的数据</p><p>对比总结：<br>●redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中<br>●redux使用plain object保存数据，需要手动处理变化后的操作;mobx适用observable保存数据，数据变化后自动处理响应的操作<br>●redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数;mobx中的状态是可变的，可以直接对其进行修改<br>●mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维;redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用<br>●mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测;而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易</p><h4 id="9-Redux-和-Vuex-有什么区别，它们的共同思想"><a href="#9-Redux-和-Vuex-有什么区别，它们的共同思想" class="headerlink" title="9. Redux 和 Vuex 有什么区别，它们的共同思想"></a>9. Redux 和 Vuex 有什么区别，它们的共同思想</h4><p><strong>（1）Redux 和 Vuex区别</strong><br>●Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可<br>●Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可<br>●Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数-&gt;store改变（vue检测到数据变化自动渲染）</p><p>通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变；取消了action概念，不必传入特定的 action形式进行指定变更；弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易; </p><p><strong>（2）共同思想</strong><br>●单—的数据源<br>●变化可以预测</p><p>本质上∶ redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案。</p><h4 id="10-Redux-中间件是怎么拿到store-和-action-然后怎么处理"><a href="#10-Redux-中间件是怎么拿到store-和-action-然后怎么处理" class="headerlink" title="10. Redux 中间件是怎么拿到store 和 action? 然后怎么处理?"></a>10. Redux 中间件是怎么拿到store 和 action? 然后怎么处理?</h4><p>redux中间件本质就是一个函数柯里化。redux applyMiddleware Api 源码中每个middleware 接受2个参数， Store 的getState 函数和dispatch 函数，分别获得store和action，最终返回一个函数。该函数会被传入 next 的下一个 middleware 的 dispatch 方法，并返回一个接收 action 的新函数，这个函数可以直接调用 next（action），或者在其他需要的时刻调用，甚至根本不去调用它。调用链中最后一个 middleware 会接受真实的 store的 dispatch 方法作为 next 参数，并借此结束调用链。所以，middleware 的函数签名是（{ getState，dispatch })=&gt; next =&gt; action。</p><h4 id="11-Redux中的connect有什么作用"><a href="#11-Redux中的connect有什么作用" class="headerlink" title="11. Redux中的connect有什么作用"></a>11. Redux中的connect有什么作用</h4><p>connect负责连接React和Redux<br><strong>（1）获取state</strong><br>connect 通过 context获取 Provider 中的 store，通过 store.getState() 获取整个store tree 上所有state<br><strong>（2）包装原组件</strong><br>将state和action通过props的方式传入到原组件内部 wrapWithConnect 返回—个 ReactComponent 对 象 Connect，Connect 重 新 render 外部传入的原组件 WrappedComponent ，并把 connect 中传入的 mapStateToProps，mapDispatchToProps与组件上原有的 props合并后，通过属性的方式传给WrappedComponent<br><strong>（3）监听store tree变化</strong><br>connect缓存了store tree中state的状态，通过当前state状态 和变更前 state 状态进行比较，从而确定是否调用 this.setState()方法触发Connect及其子组件的重新渲染</p><h3 id="七、Hooks"><a href="#七、Hooks" class="headerlink" title="七、Hooks"></a>七、Hooks</h3><h4 id="1-对-React-Hook-的理解，它的实现原理是什么"><a href="#1-对-React-Hook-的理解，它的实现原理是什么" class="headerlink" title="1. 对 React Hook 的理解，它的实现原理是什么"></a>1. 对 React Hook 的理解，它的实现原理是什么</h4><p>React-Hooks 是 React 团队在 React 组件开发实践中，逐渐认知到的一个改进点，这背后其实涉及对<strong>类组件和函数组件</strong>两种组件形式的思考和侧重。</p><p><strong>（1）类组件</strong>：所谓类组件，就是基于 ES6 Class 这种写法，通过继承 React.Component 得来的 React 组件。以下是一个类组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  state = &#123;<br>    text: <span class="hljs-string">&quot;&quot;</span><br>  &#125;;<br>  <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>  changeText = <span class="hljs-function">(<span class="hljs-params">newText</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>      text: newText<br>    &#125;);<br>  &#125;;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div className=<span class="hljs-string">&quot;demoClass&quot;</span>&gt;<br>        &lt;p&gt;&#123;<span class="hljs-built_in">this</span>.state.text&#125;&lt;/p&gt;<br>        &lt;button onClick=&#123;<span class="hljs-built_in">this</span>.changeText&#125;&gt;修改&lt;/button&gt;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，React 类组件内部预置了相当多的“现成的东西”等着我们去调度/定制，state 和生命周期就是这些“现成东西”中的典型。要想得到这些东西，难度也不大，只需要继承一个 React.Component 即可。</p><p>当然，这也是类组件的一个不便，它太繁杂了，对于解决许多问题来说，编写一个类组件实在是一个过于复杂的姿势。复杂的姿势必然带来高昂的理解成本，这也是我们所不想看到的。除此之外，由于开发者编写的逻辑在封装后是和组件粘在一起的，这就使得<strong>类组件内部的逻辑难以实现拆分和复用。</strong></p><p>（2）<strong>函数组件</strong>：函数组件就是以函数的形态存在的 React 组件。早期并没有 React-Hooks，函数组件内部无法定义和维护 state，因此它还有一个别名叫“无状态组件”。以下是一个函数组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DemoFunction</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123; text &#125; = props<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div className=<span class="hljs-string">&quot;demoFunction&quot;</span>&gt;<br>      &lt;p&gt;&#123;<span class="hljs-string">`函数组件接收的内容：[<span class="hljs-subst">$&#123;text&#125;</span>]`</span>&#125;&lt;/p&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于类组件，函数组件肉眼可见的特质自然包括轻量、灵活、易于组织和维护、较低的学习成本等。</p><p>通过对比，从形态上可以对两种组件做区分，它们之间的区别如下：<br>●类组件需要继承 class，函数组件不需要；<br>●类组件可以访问生命周期方法，函数组件不能；<br>●类组件中可以获取到实例化后的 this，并基于这个 this 做各种各样的事情，而函数组件不可以；<br>●类组件中可以定义并维护 state（状态），而函数组件不可以；</p><p>除此之外，还有一些其他的不同。通过上面的区别，我们不能说谁好谁坏，它们各有自己的优势。在 React-Hooks 出现之前，类组件的能力边界明显强于函数组件。</p><p>实际上，类组件和函数组件之间，是面向对象和函数式编程这两套不同的设计思想之间的差异。而函数组件更加契合 React 框架的设计理念：<br>React 组件本身的定位就是函数，一个输入数据、输出 UI 的函数。作为开发者，我们编写的是声明式的代码，而 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用户可见的 UI 变化中去。这就意味着从原则上来讲，React 的数据应该总是紧紧地和渲染绑定在一起的，而类组件做不到这一点。<strong>函数组件就真正地将数据和渲染绑定到了一起。函数组件是一个更加匹配其设计理念、也更有利于逻辑拆分与重用的组件表达形式。</strong></p><p>为了能让开发者更好的的去编写函数式组件。于是，React-Hooks 便应运而生。</p><p>React-Hooks 是一套能够使函数组件更强大、更灵活的“钩子”。</p><p>函数组件比起类组件少了很多东西，比如生命周期、对 state 的管理等。这就给函数组件的使用带来了非常多的局限性，导致我们并不能使用函数这种形式，写出一个真正的全功能的组件。而React-Hooks 的出现，就是为了帮助函数组件补齐这些（相对于类组件来说）缺失的能力。</p><p>如果说函数组件是一台轻巧的快艇，那么 React-Hooks 就是一个内容丰富的零部件箱。“重装战舰”所预置的那些设备，这个箱子里基本全都有，同时它还不强制你全都要，而是允许你自由地选择和使用你需要的那些能力，然后将这些能力以 Hook（钩子）的形式“钩”进你的组件里，从而定制出一个最适合你的“专属战舰”。</p><h4 id="2-为什么-useState-要使用数组而不是对象"><a href="#2-为什么-useState-要使用数组而不是对象" class="headerlink" title="2. 为什么 useState 要使用数组而不是对象"></a>2. 为什么 useState 要使用数组而不是对象</h4><p>useState 的用法：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">count</span>, setCount] = useState(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>可以看到 useState 返回的是一个数组，那么为什么是返回数组而不是返回对象呢？</p><p>这里用到了解构赋值，所以先来看一下ES6 的解构赋值：<br><strong>数组的解构赋值</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> foo = [1, 2, 3];<br><span class="hljs-keyword">const</span> [<span class="hljs-keyword">one</span>, <span class="hljs-keyword">two</span>, three] = foo;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">one</span>);<span class="hljs-comment">// 1</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">two</span>);<span class="hljs-comment">// 2</span><br>console.<span class="hljs-built_in">log</span>(three);<span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p><strong>对象的解构赋值</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const <span class="hljs-keyword">user</span> = &#123;<br>  id: <span class="hljs-number">888</span>,<br>  <span class="hljs-type">name</span>: &quot;xiaoxin&quot;<br>&#125;;<br>const &#123; id, <span class="hljs-type">name</span> &#125; = <span class="hljs-keyword">user</span>;<br>console.log(id);// <span class="hljs-number">888</span><br>console.log(<span class="hljs-type">name</span>);// &quot;xiaoxin&quot;<br></code></pre></td></tr></table></figure><p>看完这两个例子，答案应该就出来了：<br>●如果 useState 返回的是数组，那么使用者可以对数组中的元素命名，代码看起来也比较干净<br>●如果 useState 返回的是对象，在解构对象的时候必须要和 useState 内部实现返回的对象同名，想要使用多次的话，必须得设置别名才能使用返回值</p><p>下面来看看如果 useState 返回对象的情况：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">// 第一次使用<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">state</span>, <span class="hljs-built_in">set</span>State &#125; = useState(false);<br>// 第二次使用<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">state</span>: counter, <span class="hljs-built_in">set</span>State: <span class="hljs-built_in">set</span>Counter &#125; = useState(<span class="hljs-number">0</span>) <br></code></pre></td></tr></table></figure><p>这里可以看到，返回对象的使用方式还是挺麻烦的，更何况实际项目中会使用的更频繁。<br><strong>总结</strong>：useState 返回的是 array 而不是 object 的原因就是为了<strong>降低使用的复杂度</strong>，返回数组的话可以直接根据顺序解构，而返回对象的话要想使用多次就需要定义别名了。</p><h4 id="3-React-Hooks-解决了哪些问题？"><a href="#3-React-Hooks-解决了哪些问题？" class="headerlink" title="3. React Hooks 解决了哪些问题？"></a>3. React Hooks 解决了哪些问题？</h4><p>React Hooks 主要解决了以下问题：<br><strong>（1）在组件之间复用状态逻辑很难</strong><br>React 没有提供将可复用性行为“附加”到组件的途径（例如，把组件连接到 store）解决此类问题可以使用 render props 和 高阶组件。但是这类方案需要重新组织组件结构，这可能会很麻烦，并且会使代码难以理解。由 providers，consumers，高阶组件，render props 等其他抽象层组成的组件会形成“嵌套地狱”。尽管可以在 DevTools 过滤掉它们，但这说明了一个更深层次的问题：React 需要为共享状态逻辑提供更好的原生途径。</p><p>可以使用 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook 使我们在无需修改组件结构的情况下复用状态逻辑。 这使得在组件间或社区内共享 Hook 变得更便捷。<br><strong>（2）复杂组件变得难以理解</strong><br>在组件中，每个生命周期常常包含一些不相关的逻辑。例如，组件常常在 componentDidMount 和 componentDidUpdate 中获取数据。但是，同一个 componentDidMount 中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount 中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。</p><p>在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 React 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。</p><p>为了解决这个问题，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。<br><strong>（3）难以理解的 class</strong><br>除了代码复用和代码管理会遇到困难外，class 是学习 React 的一大屏障。我们必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。没有稳定的语法提案，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。即便在有经验的 React 开发者之间，对于函数组件与 class 组件的差异也存在分歧，甚至还要区分两种组件的使用场景。</p><p>为了解决这些问题，Hook 使你在非 class 的情况下可以使用更多的 React 特性。 从概念上讲，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术</p><h4 id="4-React-Hook-的使用限制有哪些？"><a href="#4-React-Hook-的使用限制有哪些？" class="headerlink" title="4. React Hook 的使用限制有哪些？"></a>4. React Hook 的使用限制有哪些？</h4><p>React Hooks 的限制主要有两条：<br>●不要在循环、条件或嵌套函数中调用 Hook；<br>●在 React 的函数组件中调用 Hook。</p><p>那为什么会有这样的限制呢？Hooks 的设计初衷是为了改进 React 组件的开发模式。在旧有的开发模式下遇到了三个问题。<br>●组件之间难以复用状态逻辑。过去常见的解决方案是高阶组件、render props 及状态管理框架。<br>●复杂的组件变得难以理解。生命周期函数与业务逻辑耦合太深，导致关联部分难以拆分。<br>●人和机器都很容易混淆类。常见的有 this 的问题，但在 React 团队中还有类难以优化的问题，希望在编译优化层面做出一些改进。</p><p>这三个问题在一定程度上阻碍了 React 的后续发展，所以为了解决这三个问题，Hooks 基于函数组件开始设计。然而第三个问题决定了 Hooks 只支持函数组件。</p><p>那为什么不要在循环、条件或嵌套函数中调用 Hook 呢？因为 Hooks 的设计是基于数组实现。在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的 Hook。当然，实质上 React 的源码里不是数组，是链表。</p><p>这些限制会在编码上造成一定程度的心智负担，新手可能会写错，为了避免这样的情况，可以引入 ESLint 的 Hooks 检查插件进行预防。</p><h4 id="5-useEffect-与-useLayoutEffect-的区别"><a href="#5-useEffect-与-useLayoutEffect-的区别" class="headerlink" title="5. useEffect 与 useLayoutEffect 的区别"></a>5. useEffect 与 useLayoutEffect 的区别</h4><p><strong>（1）共同点</strong><br><strong>●运用效果</strong>：useEffect 与 useLayoutEffect 两者都是用于处理副作用，这些副作用包括改变 DOM、设置订阅、操作定时器等。在函数组件内部操作副作用是不被允许的，所以需要使用这两个函数去处理。<br><strong>●使用方式：</strong>useEffect 与 useLayoutEffect 两者底层的函数签名是完全一致的，都是调用的 mountEffectImpl方法，在使用上也没什么差异，基本可以直接替换。</p><p><strong>（2）不同点</strong><br><strong>●使用场景：</strong>useEffect 在 React 的渲染过程中是被异步调用的，用于绝大多数场景；而 useLayoutEffect 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 useLayoutEffect 做计算量较大的耗时任务从而造成阻塞。<br><strong>●使用效果</strong>：useEffect是按照顺序执行代码的，改变屏幕像素之后执行（先渲染，后改变DOM），当改变屏幕内容时可能会产生闪烁；useLayoutEffect是改变屏幕像素之前就执行了（会推迟页面显示的事件，先改变DOM后渲染），不会产生闪烁。<strong>useLayoutEffect总是比useEffect先执行。</strong></p><p>在未来的趋势上，两个 API 是会长期共存的，暂时没有删减合并的计划，需要开发者根据场景去自行选择。React 团队的建议非常实用，如果实在分不清，先用 useEffect，一般问题不大；如果页面有异常，再直接替换为 useLayoutEffect 即可。</p><h4 id="6-React-Hooks在平时开发中需要注意的问题和原因"><a href="#6-React-Hooks在平时开发中需要注意的问题和原因" class="headerlink" title="6. React Hooks在平时开发中需要注意的问题和原因"></a>6. React Hooks在平时开发中需要注意的问题和原因</h4><p><strong>（1）不要在循环，条件或嵌套函数中调用Hook，必须始终在 React函数的顶层使用Hook</strong><br>这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性，从而产生难以预料到的后果。<br><strong>（2）使用useState时候，使用push，pop，splice等直接更改数组对象的坑</strong><br>使用push直接更改数组无法获取到新值，应该采用析构方式，但是在class里面不会有这个问题。代码示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Indicatorfilter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> [num,setNums] = useState([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br>  <span class="hljs-keyword">const</span> test = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 这里坑是直接采用push去更新num</span><br>    <span class="hljs-comment">// setNums(num)是无法更新num的</span><br>    <span class="hljs-comment">// 必须使用num = [...num ,1]</span><br>    num.push(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// num = [...num ,1]</span><br>    setNums(num)<br>  &#125;<br><span class="hljs-keyword">return</span> (<br>    &lt;div className=<span class="hljs-string">&#x27;filter&#x27;</span>&gt;<br>      &lt;div onClick=&#123;test&#125;&gt;测试&lt;/div&gt;<br>        &lt;div&gt;<br>          &#123;num.map(<span class="hljs-function">(<span class="hljs-params">item,index</span>) =&gt;</span> (<br>              &lt;div key=&#123;index&#125;&gt;&#123;item&#125;&lt;/div&gt;<br>          ))&#125;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Indicatorfilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;<span class="hljs-title">any</span>,<span class="hljs-title">any</span>&gt;</span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props:<span class="hljs-built_in">any</span></span>)</span>&#123;<br>      <span class="hljs-built_in">super</span>(props)<br>      <span class="hljs-built_in">this</span>.state = &#123;<br>          nums:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>      &#125;<br>      <span class="hljs-built_in">this</span>.test = <span class="hljs-built_in">this</span>.test.bind(<span class="hljs-built_in">this</span>)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-comment">// class采用同样的方式是没有问题的</span><br>      <span class="hljs-built_in">this</span>.state.nums.push(<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">this</span>.setState(&#123;<br>          nums: <span class="hljs-built_in">this</span>.state.nums<br>      &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-keyword">let</span> &#123;nums&#125; = <span class="hljs-built_in">this</span>.state<br>      <span class="hljs-keyword">return</span>(<br>          &lt;div&gt;<br>              &lt;div onClick=&#123;<span class="hljs-built_in">this</span>.test&#125;&gt;测试&lt;/div&gt;<br>                  &lt;div&gt;<br>                      &#123;nums.map(<span class="hljs-function">(<span class="hljs-params">item:<span class="hljs-built_in">any</span>,index:<span class="hljs-built_in">number</span></span>) =&gt;</span> (<br>                          &lt;div key=&#123;index&#125;&gt;&#123;item&#125;&lt;/div&gt;<br>                      ))&#125;<br>                  &lt;/div&gt;<br>          &lt;/div&gt;<br><br>      )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3）useState设置状态的时候，只有第一次生效，后期需要更新状态，必须通过useEffect</strong><br>TableDeail是一个公共组件，在调用它的父组件里面，我们通过set改变columns的值，以为传递给TableDeail 的 columns是最新的值，所以tabColumn每次也是最新的值，但是实际tabColumn是最开始的值，不会随着columns的更新而更新：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> TableDeail = (&#123;<br>    columns,<br>&#125;:TableData) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> [tabColumn, setTabColumn] = useState(columns) <br>&#125;<br><br><span class="hljs-comment">// 正确的做法是通过useEffect改变这个值</span><br><span class="hljs-keyword">const</span> TableDeail = (&#123;<br>    columns,<br>&#125;:TableData) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> [tabColumn, setTabColumn] = useState(columns) <br>    useEffect(<span class="hljs-function">() =&gt;</span>&#123;setTabColumn(columns)&#125;,[columns])<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（4）善用useCallback</strong><br>父组件传递给子组件事件句柄时，如果我们没有任何参数变动可能会选用useMemo。但是每一次父组件渲染子组件即使没变化也会跟着渲染一次。<br><strong>（5）不要滥用useContext</strong><br>可以使用基于 useContext 封装的状态管理工具。</p><h4 id="7-React-Hooks-和生命周期的关系？"><a href="#7-React-Hooks-和生命周期的关系？" class="headerlink" title="7. React Hooks 和生命周期的关系？"></a>7. React Hooks 和生命周期的关系？</h4><p><strong>函数组件</strong> 的本质是函数，没有 state 的概念的，因此<strong>不存在生命周期</strong>一说，仅仅是一个 <strong>render 函数</strong>而已。<br>但是引入 <strong>Hooks</strong>之后就变得不同了，它能让组件在不使用 class 的情况下拥有 state，所以就有了生命周期的概念，所谓的生命周期其实就是 <strong>useState、 useEffect() 和 useLayoutEffect() 。</strong></p><p>即：<strong>Hooks 组件（使用了Hooks的函数组件）有生命周期，而函数组件（未使用Hooks的函数组件）是没有生命周期的。</strong><br>下面是具体的 class 与 Hooks 的<strong>生命周期对应关系</strong>：<br><strong>●constructor</strong>：函数组件不需要构造函数，可以通过调用 useState 来初始化 state。如果计算的代价比较昂贵，也可以传一个函数给 useState。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> [<span class="hljs-built_in">num</span>, UpdateNum] = useState(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><strong>●getDerivedStateFromProps</strong>：一般情况下，我们不需要使用它，可以在渲染过程中更新 state，以达到实现 getDerivedStateFromProps 的目的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ScrollView</span>(<span class="hljs-params">&#123;row&#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> [isScrollingDown, setIsScrollingDown] = useState(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">let</span> [prevRow, setPrevRow] = useState(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">if</span> (row !== prevRow) &#123;<br>    <span class="hljs-comment">// Row 自上次渲染以来发生过改变。更新 isScrollingDown。</span><br>    setIsScrollingDown(prevRow !== <span class="hljs-literal">null</span> &amp;&amp; row &gt; prevRow);<br>    setPrevRow(row);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Scrolling down: <span class="hljs-subst">$&#123;isScrollingDown&#125;</span>`</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>React 会立即退出第一次渲染并用更新后的 state 重新运行组件以避免耗费太多性能。<br>●shouldComponentUpdate：可以用 React.memo 包裹一个组件来对它的 props 进行浅比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Button = React.memo(<span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 具体的组件</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>注意：React.memo 等效于 PureComponent，它只浅比较 props。这里也可以使用 useMemo 优化每一个节点。<br>●render：这是函数组件体本身。<br>●componentDidMount, componentDidUpdate： useLayoutEffect 与它们两的调用阶段是一样的。但是，我们推荐<strong>你一开始先用 useEffect</strong>，只有当它出问题的时候再尝试使用 useLayoutEffect。useEffect 可以表达所有这些的组合。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// componentDidMount</span><br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>  <span class="hljs-comment">// 需要在 componentDidMount 执行的内容</span><br>&#125;, [])<br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <br>  <span class="hljs-comment">// 在 componentDidMount，以及 count 更改时 componentDidUpdate 执行的内容</span><br>  document.title = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span>; <br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 需要在 count 更改时 componentDidUpdate（先于 document.title = ... 执行，遵守先清理后更新）</span><br>    <span class="hljs-comment">// 以及 componentWillUnmount 执行的内容       </span><br>  &#125; <span class="hljs-comment">// 当函数中 Cleanup 函数会按照在代码中定义的顺序先后执行，与函数本身的特性无关</span><br>&#125;, [count]); <span class="hljs-comment">// 仅在 count 更改时更新</span><br></code></pre></td></tr></table></figure><p><strong>请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 ，因此会使得额外操作很方便</strong><br>●componentWillUnmount：相当于 useEffect 里面返回的 cleanup 函数</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// componentDidMount/componentWillUnmount</span><br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>  <span class="hljs-comment">// 需要在 componentDidMount 执行的内容</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanup</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 需要在 componentWillUnmount 执行的内容      </span><br>  &#125;<br>&#125;, [])<br></code></pre></td></tr></table></figure><p>●componentDidCatch and getDerivedStateFromError：目前还没有这些方法的 Hook 等价写法，但很快会加上。<br><img src="/imageO/react12.png"></p><h3 id="八、虚拟DOM"><a href="#八、虚拟DOM" class="headerlink" title="八、虚拟DOM"></a>八、虚拟DOM</h3><p><a href="https://www.yuque.com/cuggz/interview/pgw8v4#bf7c58762878b0c5101b22e7fdce9b85">参考</a></p><h3 id="九、其他"><a href="#九、其他" class="headerlink" title="九、其他"></a>九、其他</h3><p><a href="https://www.yuque.com/cuggz/interview/pgw8v4#c7e1632a1282e9f715f629812a8c5c44">参考</a></p><h2 id="还未被问到（加强）"><a href="#还未被问到（加强）" class="headerlink" title="还未被问到（加强）"></a>还未被问到（加强）</h2><h2 id="被问到了掌握了以及-较简单"><a href="#被问到了掌握了以及-较简单" class="headerlink" title="被问到了掌握了以及(较简单)"></a>被问到了掌握了以及(较简单)</h2><h2 id="其他待整理-（掘金）"><a href="#其他待整理-（掘金）" class="headerlink" title="其他待整理 （掘金）"></a>其他待整理 （掘金）</h2><h3 id="hooks用过吗？聊聊react中class组件和函数组件的区别"><a href="#hooks用过吗？聊聊react中class组件和函数组件的区别" class="headerlink" title="hooks用过吗？聊聊react中class组件和函数组件的区别"></a>hooks用过吗？聊聊react中class组件和函数组件的区别</h3><p>类组件是使用ES6 的 class 来定义的组件。 函数组件是接收一个单一的 <strong>props</strong> 对象并返回一个React元素。</p><p>关于React的两套API（类（class）API 和基于函数的钩子（hooks） API）。官方推荐使用钩子（函数），而不是类。因为钩子更简洁，代码量少，用起来比较”轻”，而类比较”重”。而且，钩子是函数，更符合 React 函数式的本质。</p><p>函数一般来说，只应该做一件事，就是返回一个值。 如果你有多个操作，每个操作应该写成一个单独的函数。而且，数据的状态应该与操作方法分离。根据函数这种理念，React 的函数组件只应该做一件事情：返回组件的 HTML 代码，而没有其他的功能。函数的返回结果只依赖于它的参数。不改变函数体外部数据、函数执行过程里面没有副作用。</p><p>类（class）是数据和逻辑的封装。 也就是说，组件的状态和操作方法是封装在一起的。如果选择了类的写法，就应该把相关的数据和操作，都写在同一个 class 里面。</p><h3 id="类组件的缺点"><a href="#类组件的缺点" class="headerlink" title="类组件的缺点 :"></a>类组件的缺点 :</h3><p>大型组件很难拆分和重构，也很难测试。<br>业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。<br>组件类引入了复杂的编程模式，比如 render props 和高阶组件。<br>难以理解的 class，理解 JavaScript 中 this 的工作方式。</p><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><p>函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。<br>1.状态的有无<br>hooks出现之前，函数组件<strong>没有实例，没有生命周期，没有state，没有this</strong>，所以我们称函数组件为无状态组件。 hooks出现之前，react中的函数组件通常只考虑负责UI的渲染，没有自身的状态没有业务逻辑代码，是一个纯函数。它的输出只由参数props决定，不受其他任何因素影响。</p><p>2.调用方式的不同<br>函数组件重新渲染，将重新调用组件方法返回新的react元素。类组件重新渲染将new一个新的组件实例，然后调用render类方法返回react元素，这也说明为什么类组件中this是可变的。</p><p>3.因为调用方式不同，在函数组件使用中会出现问题<br>在操作中改变状态值，类组件可以获取最新的状态值，而函数组件则会按照顺序返回状态值</p><h3 id="React-Hooks（钩子的作用）"><a href="#React-Hooks（钩子的作用）" class="headerlink" title="React Hooks（钩子的作用）"></a>React Hooks（钩子的作用）</h3><p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。<br>React Hooks的几个常用钩子:</p><ol><li>useState() //状态钩子</li><li>useContext() //共享状态钩子</li><li>useReducer() //action 钩子</li><li>useEffect() //副作用钩子</li></ol><p>还有几个不常见的大概的说下</p><p>1.useCallback 记忆函数 一般把<strong>函数式组件理解为class组件render函数的语法糖</strong>，所以每次重新渲染的时候，函数式组件内部所有的代码都会重新执行一遍。而有了 useCallback 就不一样了，你可以通过 useCallback 获得一个记忆后的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> memoizedHandleClick = useCallback(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Click happened&#x27;</span>)<br>  &#125;, []); <span class="hljs-comment">// 空数组代表无论什么情况下该函数都不会发生改变</span><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">SomeComponent</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;memoizedHandleClick&#125;</span>&gt;</span>Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">SomeComponent</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二个参数传入一个数组，数组中的每一项一旦值或者引用发生改变，useCallback 就会重新返回一个新的记忆函数提供给后面进行渲染。</p><p>2.useMemo 记忆组件 useCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。 唯一的区别是：<strong>useCallback 不会执行第一个参数函数，而是将它返回给你，而 useMemo 会执行第一个函数并且将函数执行结果返回给你。</strong><br>所以 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。</p><p>3.useRef 保存引用值<br>useRef 跟 createRef 类似，都可以用来生成对 DOM 对象的引用。useRef 返回的值传递给组件或者 DOM 的 ref 属性，就可以通过 ref.current 值<strong>访问组件或真实的 DOM 节点，重点是组件也是可以访问到的</strong>，从而可以对 DOM 进行一些操作，比如监听事件等等。</p><p>4.useImperativeHandle 穿透 Ref<br>通过 useImperativeHandle 用于让父组件获取子组件内的索引</p><p>5.useLayoutEffect 同步执行副作用<br>大部分情况下，使用 useEffect 就可以帮我们处理组件的副作用，但是如果想要同步调用一些副作用，比如对 DOM 的操作，就需要使用 useLayoutEffect，useLayoutEffect 中的副作用会在 DOM 更新之后同步执行。<br><strong>useEffect和useLayoutEffect有什么区别</strong>：简单来说就是调用时机不同，useLayoutEffect和原来componentDidMount&amp;componentDidUpdate一致，在react完成DOM更新后马上同步调用的代码，会阻塞页面渲染。而useEffect是会在整个页面渲染完才会调用的代码。官方建议优先使用useEffect</p><h3 id="setState-既存在异步情况也存在同步情况"><a href="#setState-既存在异步情况也存在同步情况" class="headerlink" title="setState 既存在异步情况也存在同步情况"></a>setState 既存在异步情况也存在同步情况</h3><p>1.异步情况 <strong>在React事件当中是异步操作</strong><br>2.同步情况 如果是在<strong>setTimeout事件或者自定义的dom事件</strong>中，都是同步的</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pf">//<span class="hljs-built_in">set</span>Timeout事件<br>import React,&#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br>class Count extends Component&#123;<br>    constructor(props)&#123;<br>        super(props);<br>        this.<span class="hljs-keyword">state</span> = &#123;<br>            count:<span class="hljs-number">0</span><br>        &#125;<br>    &#125;<br><br>    render()&#123;<br>        return (<br>            <span class="hljs-variable">&lt;&gt;</span><br>                <span class="hljs-variable">&lt;p&gt;</span>count:&#123;this.<span class="hljs-keyword">state</span>.count&#125;&lt;/p&gt;<br>                <span class="hljs-variable">&lt;button onClick=&#123;this.btnAction&#125;&gt;</span>增加&lt;/button&gt;<br>            &lt;/&gt;<br>        )<br>    &#125;<br>    <br>    btnAction = ()=&gt;&#123;<br>        //不能直接修改<span class="hljs-keyword">state</span>，需要通过<span class="hljs-built_in">set</span>State进行修改<br>        //同步<br>        <span class="hljs-built_in">set</span>Timeout(()=&gt;&#123;<br>            this.<span class="hljs-built_in">set</span>State(&#123;<br>                count: this.<span class="hljs-keyword">state</span>.count + <span class="hljs-number">1</span><br>            &#125;);<br>            console.<span class="hljs-keyword">log</span>(this.<span class="hljs-keyword">state</span>.count);<br>        &#125;)<br>    &#125;<br>&#125;<br><br>export <span class="hljs-keyword">default</span> Count;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//自定义dom事件</span><br><span class="hljs-keyword">import</span> React,&#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Count</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            count:<span class="hljs-number">0</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;&gt;<br>                &lt;p&gt;count:&#123;<span class="hljs-built_in">this</span>.state.count&#125;&lt;/p&gt;<br>                &lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;绑定点击事件&lt;/button&gt;<br>            &lt;/&gt;<br>        )<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">//自定义dom事件，也是同步修改</span><br>        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#btn&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-built_in">this</span>.setState(&#123;<br>                count: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span><br>            &#125;);<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count);<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Count;<br></code></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/imageO/react5.png" alt="生命周期"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs stylus">安装<br>当组件的实例被创建并插入到 DOM 中时，这些方法按以下顺序调用：<br><br><span class="hljs-function"><span class="hljs-title">constructor</span><span class="hljs-params">()</span></span><br>static getDerivedStateFromProps()<br><span class="hljs-function"><span class="hljs-title">render</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">componentDidMount</span><span class="hljs-params">()</span></span><br><br>更新中<br>更新可能由道具或状态的更改引起。当重新渲染组件时，这些方法按以下顺序调用：<br><br>static getDerivedStateFromProps()<br><span class="hljs-function"><span class="hljs-title">shouldComponentUpdate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">render</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">getSnapshotBeforeUpdate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">componentDidUpdate</span><span class="hljs-params">()</span></span><br><br>卸载<br>当组件从 DOM 中移除时调用此方法：<br><br><span class="hljs-function"><span class="hljs-title">componentWillUnmount</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><h3 id="说一下-react-fiber"><a href="#说一下-react-fiber" class="headerlink" title="说一下 react-fiber"></a>说一下 react-fiber</h3><h4 id="1）背景"><a href="#1）背景" class="headerlink" title="1）背景"></a>1）背景</h4><p>react-fiber 产生的根本原因，是<strong>大量的同步计算任务阻塞了浏览器的 UI 渲染</strong>。默认情况下，JS 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。如果 JS 运算持续占用主线程，页面就没法得到及时的更新。当我们调用setState更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI。如果页面元素很多，整个过程占用的时机就可能超过 16 毫秒，就容易出现掉帧的现象。</p><h4 id="2）实现原理"><a href="#2）实现原理" class="headerlink" title="2）实现原理"></a>2）实现原理</h4><p>react内部运转分三层：</p><ol><li>Virtual DOM 层，描述页面长什么样。</li><li>Reconciler 层，负责调用组件生命周期方法，进行 Diff 运算等。</li><li>Renderer 层，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。</li></ol><p><strong>Fiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">const fiber = &#123;<br>    stateNode,    <span class="hljs-regexp">//</span> 节点实例<br>    child,        <span class="hljs-regexp">//</span> 子节点<br>    sibling,      <span class="hljs-regexp">//</span> 兄弟节点<br>    return,       <span class="hljs-regexp">//</span> 父节点<br>&#125;<br></code></pre></td></tr></table></figure><p>为了实现不卡顿，就需要有一个调度器 (Scheduler) 来进行任务分配。优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效。任务的优先级有六种：</p><ol><li>synchronous，与之前的Stack Reconciler操作一样，同步执行</li><li>task，在next tick之前执行</li><li>animation，下一帧之前执行</li><li>high，在不久的将来立即执行</li><li>low，稍微延迟执行也没关系</li><li>offscreen，下一次render时或scroll时才执行</li></ol><p>Fiber Reconciler（react ）执行过程分为2个阶段：</p><ol><li>阶段一，生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率。</li><li>阶段二，将需要更新的节点一次过批量更新，这个过程不能被打断。</li></ol><p>Fiber树：React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 Virtual DOM Tree，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 Fiber Tree。Fiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复。</p><p>从Stack Reconciler到Fiber Reconciler，源码层面其实就是干了一件递归改循环的事情<br>传送门 ☞# <a href="https://juejin.cn/post/7002250258826657799">深入了解 Fiber</a></p><h3 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a>Portals</h3><p>Portals 提供了一种一流的方式来将子组件渲染到存在于父组件的 DOM 层次结构之外的 DOM 节点中。结构不受外界的控制的情况下就可以使用portals进行创建</p><h3 id="何时要使用异步组件？如和使用异步组件"><a href="#何时要使用异步组件？如和使用异步组件" class="headerlink" title="何时要使用异步组件？如和使用异步组件"></a>何时要使用异步组件？如和使用异步组件</h3><p>加载大组件的时候<br>路由异步加载的时候</p><p>react 中要配合 Suspense 使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 异步懒加载</span><br><span class="hljs-keyword">const</span> Box = lazy(<span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./components/Box&#x27;</span>));<br><span class="hljs-comment">// 使用组件的时候要用suspense进行包裹</span><br>&lt;Suspense fallback=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;&gt;<br>    &#123;show &amp;&amp; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Box</span>/&gt;</span></span>&#125;<br>&lt;/Suspense&gt;<br></code></pre></td></tr></table></figure><h3 id="React-事件绑定原理"><a href="#React-事件绑定原理" class="headerlink" title="React 事件绑定原理"></a>React 事件绑定原理</h3><p>React并不是将click事件绑在该div的真实DOM上，而是<strong>在document处监听所有支持的事件</strong>，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。<br>另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 <strong>event.preventDefault</strong>。<br><img src="/imageO/react10.png" alt="绑定事件"></p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/7016593221815910408#heading-83">连八股文都不懂还指望在前端混下去么</a></p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网+HTTP+浏览器+网络安全面试题总结</title>
    <link href="/2022/01/07/%5B%E6%80%BB%E7%BB%93%5D%E8%AE%A1%E7%BD%91+%E6%B5%8F%E8%A7%88%E5%99%A8+http+%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/01/07/%5B%E6%80%BB%E7%BB%93%5D%E8%AE%A1%E7%BD%91+%E6%B5%8F%E8%A7%88%E5%99%A8+http+%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>总结了最近的一些面试题和之前的知识点</p><hr><h2 id="计网-HTTP-常问-掌握"><a href="#计网-HTTP-常问-掌握" class="headerlink" title="计网+HTTP (常问+掌握)"></a>计网+HTTP (常问+掌握)</h2><p>说到 HTTP，不得不提的就是 TCP/IP 网络模型，一般是五层模型。如下图所示<br>但是也可以分为四层，就是把链路层和物理层都表示为网络接口层<br><img src="/imageO/WC.jpg" alt="TCP/IP网络模型"><br>还有一种就是 OSI 七层网络模型，它就是在五层协议之上加了表示层和会话层<br><img src="/imageO/QC.jpg" alt="TCP/IP网络模型"></p><h3 id="从输入URL到浏览器显示页面过程中都发生了什么"><a href="#从输入URL到浏览器显示页面过程中都发生了什么" class="headerlink" title="从输入URL到浏览器显示页面过程中都发生了什么"></a>从输入URL到浏览器显示页面过程中都发生了什么</h3><ol><li>浏览器根据请求的url交给DNS域名解析</li><li>发起TCP连接  （三次握手）</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束。（Tcp四次挥手）</li></ol><p>  <a href="https://pengzhenglong.github.io/2021/05/27/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%BF%87%E7%A8%8B%E9%9D%A2%E8%AF%95/#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">从输入URL到浏览器显示页面过程中都发生了什么</a></p><h3 id="什么是浏览器的同源政策？"><a href="#什么是浏览器的同源政策？" class="headerlink" title="什么是浏览器的同源政策？"></a>什么是浏览器的同源政策？</h3><p>我对浏览器的同源政策的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个域的  <strong>协议、域名、端口号</strong>必须相同，否则不属于同一个域。<br>同源政策主要限制了三个方面</p><ol><li>第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</li><li>第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</li><li>第三个是当前域下 ajax 无法发送跨域请求。</li></ol><p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。<br>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是80（默认端口可以省略）。</p><h3 id="跨域怎么实现？jsonp的原理是什么？"><a href="#跨域怎么实现？jsonp的原理是什么？" class="headerlink" title="跨域怎么实现？jsonp的原理是什么？"></a>跨域怎么实现？jsonp的原理是什么？</h3><h4 id="跨域，指的是浏览器不能执行其他网站的脚本。浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行"><a href="#跨域，指的是浏览器不能执行其他网站的脚本。浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行" class="headerlink" title="跨域，指的是浏览器不能执行其他网站的脚本。浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行"></a>跨域，指的是浏览器不能执行其他网站的脚本。浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行</h4><p>解决办法：</p><ol><li>JSONP：注意JSONP只支持GET请求，不支持POST请求。<br>原理：ajax请求受同源策略影响，不允许进行跨域请求，而<strong>script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码</strong>，在src中进行了调用，这样实现了跨域。 —   callback</li><li>代理：写后端接口，在后端调用页面拿到返回值返回给html文件。相当于绕过了浏览器，就不会存在跨域问题。例；(nigx反向代理)</li><li>CORS CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对CORS的支持原理：<strong>服务器设置Access-Control-Allow-Origin HTTP响应头</strong>之后，浏览器将会允许跨域请求</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin:*&#x27;</span>);<span class="hljs-comment">//允许所有来源访问</span><br><span class="hljs-selector-tag">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Method:POST,GET&#x27;</span>);<span class="hljs-comment">//允许访问的方式</span><br></code></pre></td></tr></table></figure><ol start="4"><li>proxy代理 目前常用方式,<strong>通过服务器设置代理</strong>  在 vue.config.js 项目中配置 proxy 解决跨域问题</li><li>window.postMessage() 利用h5新特性window.postMessage()</li></ol><h5 id="Options-CORS跨域，非简单请求"><a href="#Options-CORS跨域，非简单请求" class="headerlink" title="Options(CORS跨域，非简单请求)"></a>Options(CORS跨域，非简单请求)</h5><p>1.HTTP的options方法作用</p><blockquote><p>检测服务器所支持的请求方法。（比如：‘／user’路由支持哪些方法：get、post、delete…）<br>CORS中的预检请求（检测某个接口是否支持跨域）</p></blockquote><p>2.allowedMethods方法<br>响应options方法，告诉它所支持的请求方法<br>相应的返回405（不允许）和501（没实现）（比如我使用delete，会返回405，因为我没有写这个接口。但我使用link接口请求，会返回501，因为koa里不支持link请求）<br>options 请求就是预检请求，可用于检测服务器允许的 http 方法。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起 OPTIONS 请求，即 CORS 预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS">MDN</a></p><h3 id="浏览器会拦截跨域请求，但是只是拦截返回结果，请求还是会被发送到服务器，这样有意义么"><a href="#浏览器会拦截跨域请求，但是只是拦截返回结果，请求还是会被发送到服务器，这样有意义么" class="headerlink" title="浏览器会拦截跨域请求，但是只是拦截返回结果，请求还是会被发送到服务器，这样有意义么"></a>浏览器会拦截跨域请求，但是只是拦截返回结果，请求还是会被发送到服务器，这样有意义么</h3><p>有意义。<br>首先，请求因为跨域被拦截后，会改成OPTIONS请求送达服务器，这样服务器就可以知道有人在请求。<br>至于你说跨域POST也能修改，那因为服务器没对method进行校验，来者不拒，这是你服务器的问题。<br>正常的API数据操作method不包括OPTIONS，OPTIONS只用来确认允许的操作。</p><h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><p>仅记录在 RFC2616 上的 HTTP 状态码就达 40 种，若再加上 WebDAV（RFC4918、5842）和附加 HTTP 状态码 （RFC6585）等扩展，数量就达 60 余种。接下来，我们就介绍一下这些具有代表性的一些状态码。<br>1xx: 指示信息——表示请求已接收，继续处理<br>2xx: 成功——表示请求已被成功接收<br>3xx: 重定向——表示要完成请求必须进行进一步操作<br>4xx: 客户端错误——表示请求有语法错误或请求无法实现<br>5xx: 服务端错误——表示服务器未能实现合法的请求</p><h4 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h4><p>状态码 描述<br><strong>200 请求成功</strong> （强缓存也是返回这个）<br>201 Created  资源创建成功，多用于 POST 请求<br>202-服务器端已经收到请求消息，但是尚未进行处理<br><strong>204   只有响应头，没有body数据（无内容） 预检请求</strong><br>206 已完成指定范围的请求(带Range头的GET请求),场景如video,audio播放文件较大,文件分片时<br>301 <strong>永久重定向  永久移动。请求的资源已被永久的移动到新URI，</strong>返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替<br>302 <strong>临时重定向</strong>与301类似。但资源只是临时被移动。客户端应继续使用原有URI<br>304 请求资源未修改，可以使用缓存的资源，不用在服务器取  <strong>（协商缓存）</strong><br><strong>400 请求有语法错误</strong><br><strong>401 没有权限访问</strong><br><strong>403 服务器拒绝执行请求，场景如不允许直接访问，只能通过服务器访问时</strong><br><strong>404 请求资源不存在</strong><br><strong>500 服务器内部错误，无法完成请求</strong><br>503 请求未完成，因服务器过载、宕机或维护等<br><a href="https://www.runoob.com/http/http-status-codes.html">《HTTP 状态码》</a></p><h3 id="HTTP-和-HTTPS-的主要区别是什么呢？"><a href="#HTTP-和-HTTPS-的主要区别是什么呢？" class="headerlink" title="HTTP 和 HTTPS 的主要区别是什么呢？"></a>HTTP 和 HTTPS 的主要区别是什么呢？</h3><ol><li>最简单的，HTTP 在地址栏上的协议是以 http:// 开头，而 HTTPS 在地址栏上的协议是以 https:// 开头</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>pengzhenglong.github.io/<br>https:<span class="hljs-regexp">//</span>pengzhenglong.github.io/<br></code></pre></td></tr></table></figure><ol start="2"><li>HTTP 是未经安全加密的协议，它的传输过程容易被攻击者监听、数据容易被窃取、发送方和接收方容易被伪造；而 HTTPS 是安全的协议，它通过<strong>密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法</strong>能够解决上面这些问题。</li><li>HTTP <strong>的默认端口是 80，而 HTTPS 的默认端口是 443。</strong></li><li>http <strong>是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议安全，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变</strong>，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。</li><li>http 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li><li>https 缓存不如 http 高效，会增加数据开销。</li><li>Https 协议需要<strong>ca 证书，费用较高，</strong>功能越强大的证书费用越高。</li><li>SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。</li></ol><h3 id="HTTPS是如何保证安全的？"><a href="#HTTPS是如何保证安全的？" class="headerlink" title="HTTPS是如何保证安全的？"></a>HTTPS是如何保证安全的？</h3><p>过程比较复杂，我们得先理解两个概念</p><h4 id="1-对称加密：即通信的双方都使用同一个秘钥进行加解密，比如特务接头的暗号，就属于对称加密"><a href="#1-对称加密：即通信的双方都使用同一个秘钥进行加解密，比如特务接头的暗号，就属于对称加密" class="headerlink" title="1. 对称加密：即通信的双方都使用同一个秘钥进行加解密，比如特务接头的暗号，就属于对称加密"></a>1. 对称加密：<strong>即通信的双方都使用同一个秘钥进行加解密</strong>，比如特务接头的暗号，就属于对称加密</h4><p>对称加密虽然很简单性能也好，但是<strong>无法解决首次把秘钥发给对方的问题，很容易被hacker拦截秘钥。</strong></p><h4 id="2-非对称加密"><a href="#2-非对称加密" class="headerlink" title="2. 非对称加密"></a>2. 非对称加密</h4><ol><li><strong>私钥 + 公钥= 密钥对</strong></li><li><strong>即用私钥加密的数据,只有对应的公钥才能解密,用公钥加密的数据,只有对应的私钥才能解密</strong></li><li><strong>因为通信双方的手里都有一套自己的密钥对,通信之前双方会先把自己的公钥都先发给对方</strong></li><li><strong>然后对方再拿着这个公钥来加密数据响应给对方,等到到了对方那里,对方再用自己的私钥进行解密</strong></li></ol><p>非对称加密<strong>虽然安全性更高，但是带来的问题就是速度很慢(要等拿到公钥再解开)，影响性能。</strong><br>解决方案：</p><p>那么结合两种加密方式，<strong>将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。</strong></p><p>此时又带来一个问题，中间人问题：</p><p>如果此时在客户端和服务器之间<strong>存在一个中间人,这个中间人只需要把原本双方通信互发的公钥,换成自己的公钥,这样中间人就可以轻松解密通信双方所发送的所有数据。</strong></p><p>所以这个时候需要一个安全的<strong>第三方颁发证书（CA），证明身份的身份，防止被中间人攻击。</strong></p><p>证书中包括：<strong>签发者、证书用途、使用者公钥、使用者私钥、使用者的HASH算法、证书到期时间等</strong></p><p>但是问题来了，如果中间人篡改了证书，那么身份证明是不是就无效了？这个证明就白买了，这个时候需要一个新的技术，数字签名。</p><p><strong>数字签名就是用CA自带的HASH算法对证书的内容进行HASH得到一个摘要，再用CA的私钥加密，最终组成数字签名。</strong><br>当<strong>别人把他的证书发过来的时候,我再用同样的Hash算法,再次生成消息摘要，然后用CA的公钥对数字签名解密,得到CA创建的消息摘要,两者一比,就知道中间有没有被人篡改了。</strong><br>这个时候就能最大程度保证通信的安全了。</p><h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><ol><li>TCP是<strong>面向链接的，而UDP是面向无连接的。</strong></li><li>TCP仅支持<strong>单播传输，UDP 提供了单播，多播，广播的功能。</strong></li><li>TCP的<strong>三次握手保证了连接的可靠性; UDP是无连接的、不可靠的一种数据传输协议</strong>，首先不可靠性体现在无连接上，<strong>通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</strong></li><li><strong>UDP的头部开销比TCP的更小，数据传输速率更高，</strong>实时性更好。(UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的)</li></ol><h4 id="TCP-和-UDP-应用场景"><a href="#TCP-和-UDP-应用场景" class="headerlink" title="TCP 和 UDP 应用场景"></a>TCP 和 UDP 应用场景</h4><ol><li><p>UDP的应用场景：即时通信。面向数据报方式；网络数据大多为短消息；拥有大量客户端；对数据安全性无特殊要求；网络负担重但对响应速度要求高的场景。eg: <strong>IP电话、实时视频会议等。</strong></p></li><li><p>TCP的应用场景：对数据准确性要求高，速度可以相对较慢的。eg: <strong>文件传输、邮件的发送与接收等。</strong><br>传送门 ☞<a href="https://juejin.cn/post/6992743999756845087"># 深度剖析TCP与UDP的区别</a><br><a href="https://pengzhenglong.github.io/2021/07/09/TCP%E5%8D%8F%E8%AE%AE/">博客</a></p></li></ol><h3 id="Cookie、sessionStorage、localStorage-的区别"><a href="#Cookie、sessionStorage、localStorage-的区别" class="headerlink" title="Cookie、sessionStorage、localStorage 的区别"></a>Cookie、sessionStorage、localStorage 的区别</h3><h4 id="相同点-存储在客户端"><a href="#相同点-存储在客户端" class="headerlink" title="相同点(存储在客户端)"></a>相同点(存储在客户端)</h4><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul><li>cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+</li><li>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</li><li>cookie的数据会<strong>自动的传递到服务器</strong>；sessionStorage和localStorage数据保存在本地</li></ul><p>localStorage和SessionStorage</p><ul><li>只能存储字符串对象</li><li>不同浏览器无法共享localStorage与SessionStroage中的信息。相同浏览器的不同页面间（同源页面）可以共享相同的localStorage，但不能共享sessionStorage。</li></ul><h4 id="cookie-的缺点"><a href="#cookie-的缺点" class="headerlink" title="cookie 的缺点"></a>cookie 的缺点</h4><p>cookie 的大小一般被浏览器限制为 4kb<br>请求自动携带 cookie 其实会造成无效的带宽浪费<br>安全问题（csrf 与 xss）</p><p>CORS解决带cookie跨域问题  （如果您想在使用 CORS（可以识别发送者）时发送 cookie，您需要向请求和响应添加额外的标头。）</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><a href="https://zhuanlan.zhihu.com/p/414034535">知乎</a></p><h4 id="2-Session"><a href="#2-Session" class="headerlink" title="2. Session"></a>2. Session</h4><p>Session是一种服务端解决方案，通过服务器来保持状态。<br>Session是服务器为了保存用户状态而创建的一个特殊对象。客户端请求服务端，服务端会为这次请示开辟一块内存空间。<br>Session弥补了HTTP的无状态特性。</p><h5 id="Session的创建过程"><a href="#Session的创建过程" class="headerlink" title="Session的创建过程"></a>Session的创建过程</h5><p>当浏览器第一次访问服务器时，服务器会创建一个Session对象(该对象有唯一的ID，即SessionID)。服务器会将SessionID以cookie的方式返回浏览器。<br>当浏览器再次访问服务器时，会将SessionID发送过来，服务器依据sessionID就可以找到对应的session对象。</p><h6 id="Session的缺点"><a href="#Session的缺点" class="headerlink" title="Session的缺点"></a>Session的缺点</h6><p>A 服务器存储了 Session，就是做了负载均衡后，假如一段时间内 A 的访问量激增，会转发到 B 进行访问，但是 B 服务器并没有存储 A 的 Session，会导致 Session 的失效。</p><p><a href="https://pengzhenglong.github.io/2021/06/16/cookie%E3%80%81localStorage%E3%80%81sessionStorage&token/">博客</a><br><a href="https://juejin.cn/post/7012506796489359368">JavaScript的存储–Cookie、Session、localStorage、sessionStorage</a></p><h4 id="什么是-Token（令牌）"><a href="#什么是-Token（令牌）" class="headerlink" title="什么是 Token（令牌）"></a>什么是 Token（令牌）</h4><p>Acesss Token</p><ol><li>访问资源接口（API）时所需要的资源凭证</li><li>简单 token 的组成：<strong>uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</strong></li></ol><p>特点：(1. 服务端无状态化、可扩展性好2. 支持移动端设备3. 安全4. 支持跨程序调用)</p><p>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里<br>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库<br>token 完全由应用管理，所以它可以避开同源策略</p><h5 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h5><p>另外一种 token——refresh token<br>refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。<br><a href="https://juejin.cn/post/6844904034181070861#heading-6">Acesss Token</a></p><h3 id="Ajax-是什么-如何创建一个-Ajax？"><a href="#Ajax-是什么-如何创建一个-Ajax？" class="headerlink" title="Ajax 是什么? 如何创建一个 Ajax？"></a>Ajax 是什么? 如何创建一个 Ajax？</h3><p><strong>Gmail开发人员发现IE里面有个XMLHTTPRequest对象来请求数据时，可以实现无刷新数据请求</strong>，所以使用这个特性，进行网络数据请求，这就是AJAX的由来。<br>AJAX不是一个单词，他的全称是Asynchronous JavaScript and XML，就是<strong>异步的JavaScript和XML</strong>，它是一套用于创建快速动态网页的技术标准，使用步骤如下：</p><ol><li>创建异步XMLHttpRequest对象</li><li>设置请求参数，包括请求的方法和URL等</li><li>发送请求</li><li>注册事件，事件状态变更会及时响应监听</li><li>在监听里面获取并处理返回数据</li></ol><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-comment">//创建 XMLHttpRequest 对象</span><br><span class="hljs-keyword">var</span> ajax = <span class="hljs-keyword">new</span> XMLHttpRequest();<br><span class="hljs-comment">//规定请求的类型、URL 以及是否异步处理请求。</span><br>ajax.open(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-built_in">url</span>,<span class="hljs-literal">true</span>);<br><span class="hljs-comment">//发送信息至服务器时内容编码类型</span><br>ajax.setRequestHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>); <br><span class="hljs-comment">//发送请求</span><br>ajax.send(<span class="hljs-literal">null</span>);  <br><span class="hljs-comment">//接受服务器响应数据</span><br>ajax.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (obj.readyState == <span class="hljs-number">4</span> &amp;&amp; (obj.status == <span class="hljs-number">200</span> || obj.status == <span class="hljs-number">304</span>)) &#123; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>所以AJAX的核心就是XMLHttpRequest对象，这是一个非常早的实现方法，也是兼容性最好的，已经成为了浏览器标准，虽然我们现在都使用其它的API规范，但对象名字暂时还是用XML命名</p><p><a href="https://pengzhenglong.github.io/2021/05/28/ajax%E9%9D%A2%E8%AF%95/#http%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">博客</a></p><h4 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h4><p>axios是一个<strong>基于Promise的HTTP库</strong>，可以用在浏览器和node.js中，它底层还是基于XMLHttpRequest对象的，你可以认为它是一个方便的封装库，除了基础请求数据，它还增加了如下功能：</p><ol><li>对PromiseAPI的支持</li><li>支持请求拦截和响应、转换请求数据和响应数据、取消请求</li><li>可以自动转换JSON数据</li><li>支持防御XSRF</li></ol><h4 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h4><p>fetch就<strong>不是XMLHttpRequest对象了，fetch是原生的js对象，也就是说，它不依赖浏览器</strong>，fetch提供了一个理解的请求替换方案，可以提供给其它技术使用。我们主要需要了解下fetch和ajax的本质区别：</p><ol><li>fetch<strong>返回的是Promise</strong>，所以如果HTTP状态码是404之类的，fetch也是成功返回的，只有在网络连接错误的情况下，才会reject</li><li>fetch不发送cookies</li></ol><p>fetch的请求写法会比AJAX简单许多，但我想，最主要的问题是，<strong>无法区分HTTP状态码了</strong>，这个在编程时还是比较常用的，所以我们目前还是使用axios比较多，而很少使用fetch<br><img src="/imageO/Ajax.jpg" alt="Ajax"></p><h3 id="HTTP2相对于HTTP1-x有什么优势和特点？"><a href="#HTTP2相对于HTTP1-x有什么优势和特点？" class="headerlink" title="HTTP2相对于HTTP1.x有什么优势和特点？"></a>HTTP2相对于HTTP1.x有什么优势和特点？</h3><h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4><p>帧：HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。<br>流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID<br><strong>HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。</strong></p><h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>服务端可以在<strong>发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。</strong>例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。</p><p>服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。</p><h4 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h4><p>HTTP/1.x会<strong>在请求和响应中中重复地携带不常改变的、冗长的头部数据，给网络带来额外的负担。</strong></p><ol><li>HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，<strong>对于相同的数据，不再通过每次请求和响应发送</strong></li><li>首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</li><li>每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。</li></ol><p><strong>你可以理解为只发送差异数据，而不是全部发送，从而减少头部的信息量</strong></p><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>HTTP <strong>1.x</strong> 中，如果想<strong>并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。</strong><br>HTTP2中：<br><strong>同域名下所有通信都在单个连接上完成。</strong>单个连接可以承载任意数量的双向数据流。<br>数据流以消息的形式发送，而消息又<strong>由一个或多个帧组成，多个帧之间可以乱序发送</strong>，因为<strong>根据帧首部的流标识可以重新组装（保证后端接收后返回数据正常）</strong></p><h3 id="浏览器的缓存机制-强制缓存-amp-amp-协商缓存"><a href="#浏览器的缓存机制-强制缓存-amp-amp-协商缓存" class="headerlink" title="浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存"></a>浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存</h3><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：<br><img src="/imageO/HC.jpg" alt="如图"><br>由上图我们可以知道：</p><ol><li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li></ol><p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。</p><h4 id="强制缓存强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程"><a href="#强制缓存强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程" class="headerlink" title="强制缓存强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程"></a>强制缓存强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程</h4><p>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <strong>Expires 和 Cache-Control</strong>，其中<strong>Cache-Control优先级比Expires高</strong>。强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下： <strong>状态仍然返回200，但不会请求数据，在浏览器中能明显看到from cache字样。</strong></p><ol><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。</li><li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。</li><li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li></ol><h4 id="协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程"><a href="#协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程" class="headerlink" title="协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程"></a>协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</h4><p><strong>Etag &gt;Last-Modifie</strong> <strong>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified</strong>，最后才决定是否返回304<br>同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since 和 Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。协商缓存主要有以下两种情况：</p><ol><li><strong>协商缓存生效，返回304</strong></li><li><strong>协商缓存失效，返回200和请求结果结果</strong><br>传送门 ☞ #<a href="https://juejin.cn/post/6992843117963509791">彻底理解浏览器的缓存机制</a></li></ol><h4 id="介绍下304过程"><a href="#介绍下304过程" class="headerlink" title="介绍下304过程"></a>介绍下304过程</h4><p>a. 浏览器请求资源时首先命中资源的Expires 和 Cache-Control，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过Cache-control: max-age指定最大生命周期，状态仍然返回200，但不会请求数据，在浏览器中能明显看到from cache字样。<br>b. 强缓存失效，进入协商缓存阶段，首先验证ETagETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据客户端上送的If-None-Match值来判断是否命中缓存。<br>c. 协商缓存Last-Modify/If-Modify-Since阶段，客户端第一次请求资源时，服务服返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间。再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。</p><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><ol><li>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入<strong>SYN_SENT状态</strong>，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li><li>第二次握手：服务器收到syn包并确认客户的SYN（ack=j+1），同时也发送一个自己的SYN包（syn=k），即<strong>SYN+ACK</strong>包，此时服务器进入<strong>SYN_RECV</strong>状态；</li><li>第三次握手：客户端收到服务器的<strong>SYN+ACK</strong>包，向服务器发送确认包<strong>ACK</strong>(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li></ol><blockquote><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p></blockquote><h4 id="目的：-建立可靠的通信通道-，数据的发送和接收（双方正常）"><a href="#目的：-建立可靠的通信通道-，数据的发送和接收（双方正常）" class="headerlink" title="目的： 建立可靠的通信通道 ，数据的发送和接收（双方正常）"></a>目的： 建立可靠的通信通道 ，数据的发送和接收（双方正常）</h4><p>翻译成大白话就是： 客户端：你能接收到我的消息吗？ 服务端：可以的，那你能接收到我的回复吗？ 客户端：可以，那我们开始聊正事吧。</p><h4 id="为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人-为什么不是4次？：3次够了第四次浪费"><a href="#为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人-为什么不是4次？：3次够了第四次浪费" class="headerlink" title="为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人 为什么不是4次？：3次够了第四次浪费"></a>为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人 为什么不是4次？：3次够了第四次浪费</h4><h4 id="三次握手过程中可以携带数据吗？"><a href="#三次握手过程中可以携带数据吗？" class="headerlink" title="三次握手过程中可以携带数据吗？"></a>三次握手过程中可以携带数据吗？</h4><p>其实第三次握手的时候，<strong>是可以携带数据的</strong>。但是，<strong>第一次、第二次握手不可以携带数据</strong><br>为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p><p>也就是说，<strong>第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。</strong></p><h4 id="SYN攻击是什么？"><a href="#SYN攻击是什么？" class="headerlink" title="SYN攻击是什么？"></a>SYN攻击是什么？</h4><p><strong>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的</strong>，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 <strong>DoS/DDoS 攻击</strong>。</p><p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。<br>netstat -n -p TCP | grep SYN_RECV<br>常见的防御 SYN 攻击的方法有如下几种：</p><ol><li>缩短超时（SYN Timeout）时间</li><li>增加最大半连接数</li><li>过滤网关防护</li><li>SYN cookies技术</li></ol><h3 id="TCP-协议四次挥手"><a href="#TCP-协议四次挥手" class="headerlink" title="TCP 协议四次挥手"></a>TCP 协议四次挥手</h3><p>客户端-发送一个FIN,用来关闭客户端到服务器的数据传输<br>服务器-收到这个FIN,它发回一个ACK，确认序号为收到的序号加1.和SYN一样，一个FIN将占用一个序号<br>服务器-关闭与客户端的连接，发送一个FIN给客户端<br>客户端-发回ACK报文确认，并将确认序号设置为收到序号加1</p><h4 id="为什么不是两次？"><a href="#为什么不是两次？" class="headerlink" title="为什么不是两次？"></a>为什么不是两次？</h4><p>两次情况客户端说完结束就立马断开不再接收，无法确认服务端是否接收到断开消息，但且服务端可能还有消息未发送完。</p><h4 id="为什么不是三次？"><a href="#为什么不是三次？" class="headerlink" title="为什么不是三次？"></a>为什么不是三次？</h4><p>3次情况服务端接收到断开消息，向客户端发送确认接受消息，客户端未给最后确认断开的回复。</p><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p><h4 id="TCP作为一种可靠的传输控制协议，其核心思想就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求"><a href="#TCP作为一种可靠的传输控制协议，其核心思想就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求" class="headerlink" title="TCP作为一种可靠的传输控制协议，其核心思想就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求"></a>TCP作为一种可靠的传输控制协议，其核心思想就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求</h4><p><a href="https://pengzhenglong.github.io/2021/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">博客</a></p><h3 id="进程作为拥有资源的基本单位-线程作为调度和分配的基本单位"><a href="#进程作为拥有资源的基本单位-线程作为调度和分配的基本单位" class="headerlink" title="进程作为拥有资源的基本单位,线程作为调度和分配的基本单位"></a>进程作为拥有资源的基本单位,线程作为调度和分配的基本单位</h3><h3 id="HTTP队头阻塞-HTTP1-0"><a href="#HTTP队头阻塞-HTTP1-0" class="headerlink" title="HTTP队头阻塞(HTTP1.0)"></a>HTTP队头阻塞(HTTP1.0)</h3><p>众所周知，服务器和客户端是经过三次握手创建TCP通道进行交流的，最后通过四次回收告别的。<br>所以一次TCP通道的创建是需要消耗一定资源和时间的。<br>那么在HTTP0.9之前，每发送一次请求就必须创建一次TCP通道，<strong>但是一个网站往往都需要发送几十个请求，那么就需要创建几十个TCP通道，那样岂不是很消耗资源？有没有什么方法可以解决呢？</strong><br>有的！ 在HTPP1.0开始增加了<strong>Connection: Keep-Alive字段，可以让TCP链接持续打开。这样就可以节省了一个请求创建一次TCP通道的性能消耗。</strong><br>在HTTP1.1引入了<strong>持久连接 和 管道机制</strong></p><h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><p>持久连接：即不用声明Connection: keep-alive字段，TCP连接默认不关闭，并且可以被多个请求复用。长连接的连接时长可以通过请求头中的 keep-alive 来设置。<br><strong>当客户端请求中含有Connection: Keep-Alive首部，服务器响应中也有Connection: Keep-Alive首部时，双方才会成功建立持久连接。</strong><br>在服务器返回【Connection: Keep-Alive】字段时，还可以追加【Keep-Alive: max=5, timeout=120】字段<br>Connection: Keep-Alive<br>Keep-Alive: max=5, timeout=120</p><p>上面个例子说明，服务器最多还会为另外5个事务保持TCP连接的打开状态，或者将打开状态保持到连接空闲了2分钟之后。</p><h4 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h4><p>HTTP1.1 允许在持久连接上可选的使用请求管道。这是相对于keep-alive连接的又一性能优化。在相应到达之前，可以将多条请求放入队列，当第一条请求发往服务器的时候，第二第三条请求也可以开始发送了，在高延时网络条件下，这样做可以降低网络的环回时间，提高性能。</p><h3 id="持久连接-管道机制-引发-HTTP队头阻塞"><a href="#持久连接-管道机制-引发-HTTP队头阻塞" class="headerlink" title="持久连接 + 管道机制 引发 HTTP队头阻塞"></a>持久连接 + 管道机制 引发 HTTP队头阻塞</h3><p>当我们在发送 1号 请求的时候得到了正常响应, 之后我们向服务器发送 2号请求时, 由于网络带宽或者种种原因, 导致发送请求到服务器缓慢或者服务器对其响应缓慢就会形成等待状态, 由于客户端请求是以队列形式发送到服务器, 所以二号请求发送后, 迟迟未收到响应, 所以导致 3号 请求需要等待二号请求完成后才能发送.</p><p>这就是著名的队头阻塞.<br>我们来看下维基百科是怎么解释的:</p><blockquote><p>队头阻塞（英語：Head-of-line blocking，缩写：HOL blocking）在计算机网络的范畴中是一种性能受限的现象。 它的原因是一列的第一个数据包（队头）受阻而导致整列数据包受阻。 例如它有可能在缓存式输入的交换机中出现，有可能因为传输顺序错乱而出现，亦有可能在HTTP流水线中有多个请求的情况下出现。</p></blockquote><p>前面提到HTTP管道化要求服务端必须按照请求发送的顺序返回响应，<strong>那如果一个响应返回延迟了，那么其后续的响应都会被延迟，直到队头的响应送达。</strong></p><h3 id="HTTP队头阻塞-的解决方法"><a href="#HTTP队头阻塞-的解决方法" class="headerlink" title="HTTP队头阻塞 的解决方法"></a>HTTP队头阻塞 的解决方法</h3><h4 id="利用HTTP2的多路复用解决"><a href="#利用HTTP2的多路复用解决" class="headerlink" title="利用HTTP2的多路复用解决"></a>利用HTTP2的多路复用解决</h4><p>对于HTTP1.1中管道化导致的请求/响应级别的队头阻塞，可以使用HTTP2的多路复用解决。<br>HTTP2不使用管道化的方式，<strong>而是引入了帧、消息和数据流等概念，每个请求/响应被称为消息，每个消息都被拆分成若干个帧进行传输，每个帧都分配一个序号。</strong>每个帧在传输是属于一个数据流，而一个连接上可以存在多个流，各个帧在流和连接上独立传输，到达之后在组装成消息，这样就避免了请求/响应阻塞。<br>当然，即使使用HTTP2，如果<strong>HTTP2底层使用的是TCP协议，仍可能出现TCP队头阻塞。</strong><br>多路复用对同一域名下所有请求都是基于流，所以不存在同域并行的阻塞</p><h4 id="并发连接"><a href="#并发连接" class="headerlink" title="并发连接"></a>并发连接</h4><p>我们知道对于一个域名而言，是允许分配多个长连接的，那么可以理解成增加了任务队列，也就是说不会导致一个任务阻塞了该任务队列的其他任务，在RFC规范中规定客户端最多并发2个连接，不过实际情况就是要比这个还要多，举个例子，Chrome中是6个。</p><h4 id="域名分片"><a href="#域名分片" class="headerlink" title="域名分片"></a>域名分片</h4><p>顾名思义，我们可以在一个域名下分出多个二级域名出来，而它们最终指向的还是同一个服务器，这样子的话就可以并发处理的任务队列更多，也更好的解决了队头阻塞的问题。<br>举个例子，比如TianTian.com，可以分出很多二级域名，比如Day1.TianTian.com，Day2.TianTian.com, Day3.TianTian.com, 这样子就可以有效解决队头阻塞问题。</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6857382886573047822#heading-11">带你回顾一下：HTTP缓存策略、HTTP队头阻塞、HTTP2.0</a><br><a href="https://juejin.cn/post/7049296242924322830">HTTP队头阻塞</a></p><h3 id="TCP队头阻塞"><a href="#TCP队头阻塞" class="headerlink" title="TCP队头阻塞"></a>TCP队头阻塞</h3><p>队头阻塞<strong>发生在一个TCP分节丢失，导致其后续分节不按序到达接收端的时候。该后续分节将被接收端一直保持直到丢失的第一个分节被发送端重传并到达接收端为止</strong>。该后续分节的延迟递送确保接收应用进程能够按照发送端的发送顺序接收数据。这种<strong>为了达到完全有序而引入的延迟机制非常有用，但也有不利之处</strong>。</p><p>要是第一幅图像的某个断片内容的TCP分节丢失了，<strong>客户端将保持已到达的不按序的所有数据，直到丢失的分节重传成功</strong>。这样不仅延缓了第一幅图像数据的递送，也延缓了第二幅和第三幅图像数据的递送。</p><h4 id="如何解决TCP队头阻塞"><a href="#如何解决TCP队头阻塞" class="headerlink" title="如何解决TCP队头阻塞"></a>如何解决TCP队头阻塞</h4><p>TCP中的队头阻塞的产生是<strong>由TCP自身的实现机制决定的，无法避免</strong>。想要在应用程序当中避免TCP队头阻塞带来的影响，只有舍弃TCP协议。<br>比如google推出的quic协议，在某种程度上可以说避免了TCP中的队头阻塞，因为它根本不使用TCP协议，而是在UDP协议的基础上实现了可靠传输。而UDP是面向数据报的协议，数据报之间不会有阻塞约束。<br>此外还有一个SCTP（流控制传输协议），它是和TCP、UDP在同一层次的传输协议。SCTP的多流特性也可以尽可能的避免队头阻塞的情况。</p><p><a href="https://juejin.cn/post/6844903853985366023">掘金</a></p><h2 id="其他不常问（多看）"><a href="#其他不常问（多看）" class="headerlink" title="其他不常问（多看）"></a>其他不常问（多看）</h2><h3 id="1-http-和-https-的基本概念"><a href="#1-http-和-https-的基本概念" class="headerlink" title="1.http 和 https 的基本概念"></a>1.http 和 https 的基本概念</h3><p>HTTP 是一种 超文本传输协议(Hypertext Transfer Protocol)，HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范<br><img src="/imageO/Http.jpg" alt="Http"><br>HTTP 主要内容分为三部分，<strong>超文本（Hypertext）、传输（Transfer）、协议（Protocol）</strong>。</p><ol><li>超文本就是不单单只是本文，它还可以传输图片、音频、视频，甚至点击文字或图片能够进行超链接的跳转。</li><li>上面这些概念可以统称为数据，传输就是数据需要经过一系列的物理介质从一个端系统传送到另外一个端系统的过程。通常我们2把传输数据包的一方称为请求方，把接到二进制数据包的一方称为应答方。</li><li>而协议指的就是是网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为协议，只不过是网络协议。</li></ol><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层协议定义了应用进程间的交互和通信规则，不同主机的应用进程间如何相互传递报文，比如传递的报文的类型、格式、  有哪些字段等等。</p><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。<br>HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</p><p>HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP连接三次握手时所花费的时间。</p><p>在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-alive 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。</p><h3 id="HTTP的keep-alive是干什么的？"><a href="#HTTP的keep-alive是干什么的？" class="headerlink" title="HTTP的keep-alive是干什么的？"></a>HTTP的keep-alive是干什么的？</h3><p>在早期的HTTP/1.0中，每次http请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的HTTP/1.0中以及HTTP/1.1中，引入了重用连接的机制，就是在http请求头中加入Connection: keep-alive来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive。</p><h4 id="keep-alive的优点"><a href="#keep-alive的优点" class="headerlink" title="keep-alive的优点"></a>keep-alive的优点</h4><p>较少的CPU和内存的使用（由于同时打开的连接的减少了）<br>允许请求和应答的HTTP管线化<br>降低拥塞控制 （TCP连接减少了）<br>减少了后续请求的延迟（无需再进行握手）<br>报告错误无需关闭TCP连</p><h3 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h3><h4 id="HTTP-报文有两种，一种是请求报文，一种是响应报文"><a href="#HTTP-报文有两种，一种是请求报文，一种是响应报文" class="headerlink" title="HTTP 报文有两种，一种是请求报文，一种是响应报文"></a>HTTP 报文有两种，一种是请求报文，一种是响应报文</h4><p>HTTP 请求报文的格式如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GET</span> / HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span>User-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Macintosh; Intel Mac OS X <span class="hljs-number">10</span>_<span class="hljs-number">10</span>_<span class="hljs-number">5</span>)Accept: */*<br></code></pre></td></tr></table></figure><p>HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这个空行不能省略，它用来划分首部与实体。</p><p>请求行包含三个字段：方法字段、URL 字段和 HTTP 版本字段。</p><p>方法字段可以取几种不同的值，一般有 GET、POST、HEAD、PUT 和 DELETE。<br>一般 GET 方法只被用于向服务器获取数据。<br>POST 方法用于将实体提交到指定的资源，通常会造成服务器资源的修改。<br>HEAD 方法与 GET 方法类似，但是在返回的响应中，不包含请求对象。<br>PUT 方法用于上传文件到服务器，<br>DELETE 方法用于删除服务器上的对象。<br>虽然请求的方法很多，但更多表达的是一种语义上的区别，并不是说 POST 能做的事情，GET 就不能做了，主要看我们如何选择。更多的方法可以参<br>看  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">文档</a>。</p><h3 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a>HTTP 响应报文</h3><p>HTTP 响应报文的格式如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">0</span> <span class="hljs-number">200</span> OKContent-Type: text/plainContent-Length: <span class="hljs-number">137582</span>Expires: Thu, <span class="hljs-number">05</span> Dec <span class="hljs-number">1997</span> <span class="hljs-number">16</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> GMTLast-Modified: Wed, <span class="hljs-number">5</span> August <span class="hljs-number">1996</span> <span class="hljs-number">15</span>:<span class="hljs-number">55</span>:<span class="hljs-number">28</span> GMTServer: Apache <span class="hljs-number">0</span>.<span class="hljs-number">84</span>&lt;html&gt; &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>HTTP 响应报文的第一行叫做状态行，后面的行是首部行，最后是实体主体。<br>状态行包含了三个字段：协议版本字段、状态码和相应的状态信息。<br>实体部分是报文的主要部分，它包含了所请求的对象。</p><h4 id="首部行"><a href="#首部行" class="headerlink" title="首部行"></a>首部行</h4><p>首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设置，区别在于请求首部和响应首部。<br>常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。<br>常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。<br>常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。<br>常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修改时间。<br>更多关于首部的资料可以查看：<br><a href="https://www.cnblogs.com/jycboy/p/http_head.html">《HTTP 首部字段详细介绍》</a><br><a href="https://blog.csdn.net/qq_34289537/article/details/52971516">《图解 HTTP》</a></p><h3 id="3-https-协议的工作原理"><a href="#3-https-协议的工作原理" class="headerlink" title="3.https 协议的工作原理"></a>3.https 协议的工作原理</h3><p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p><ol><li>客户端使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。</li><li>web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），传输给客户端。</li><li>客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。</li><li>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</li><li>web 服务器通过自己的私钥解密出会话密钥。</li><li>web 服务器通过会话密钥加密与客户端之间的通信。<br>传送门 ☞ #<a href="https://juejin.cn/post/6995109407545622542">解读 HTTP1/HTTP2/HTTP3</a></li></ol><h3 id="TCP-IP-如何保证数据包传输的有序可靠？"><a href="#TCP-IP-如何保证数据包传输的有序可靠？" class="headerlink" title="TCP/IP / 如何保证数据包传输的有序可靠？"></a>TCP/IP / 如何保证数据包传输的有序可靠？</h3><p>对字节流分段并进行编号然后通过 ACK 回复和超时重发这两个机制来保证。<br>（1）为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；<br>（2）并为每个已发送的数据包启动一个超时定时器；<br>（3）如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;<br>（4）否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。<br>（5）接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</p><h3 id="长轮询和短轮询"><a href="#长轮询和短轮询" class="headerlink" title="长轮询和短轮询"></a>长轮询和短轮询</h3><h4 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h4><p>客户端发送请求后服务器端不会立即返回数据，服务器端会阻塞请求<strong>连接不会立即断开，直到服务器端有数据更新或者是连接超时才返回，客户端才再次发出请求新建连接、如此反复从而获取最新数据</strong>。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LongAjax</span>(<span class="hljs-params"></span>) </span>&#123;<br>    fetch(url).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>     <span class="hljs-comment">// 数据正确拿到后，</span><br>        LongPolling();<br>    &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>     <span class="hljs-comment">// 出错或者就是超时间</span><br>        LongPolling();<br><br>    &#125;);<br>&#125;<br>LongAjax()<br></code></pre></td></tr></table></figure><p>优点：长轮询与短轮询相比，明显减少了很多不必要的http请求，节约资源。<br>节点：连接挂起也会导致资源的浪费，停留在服务器端。</p><h4 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h4><p>短轮询(Polling)的实现思路就是浏览器端每隔几秒钟向服务器端<strong>发送http请求，服务端在收到请求后，不论是否有数据更新，都直接进行响应。</strong>在服务端响应完成，就会关闭这个Tcp连接。</p><p>优点：就是兼容性比较好，只要支持http协议就可以实现该方式。<br>缺点：很明显消耗资源，因为下一次的建立Tcp是非常消耗资源的，服务器端响应后就会关闭这个Tcp连接。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LongAjax</span>(<span class="hljs-params"></span>) </span>&#123;<br>    fetch(url).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 数据正确拿到后，dosometing</span><br><br>    &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 发现错误，比如返回的数据为空等。</span><br>        console.log(err);<br>    &#125;);<br>&#125;<br>setInterval(LongAjax, <span class="hljs-number">5000</span>);<br></code></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/6864398060702760968#heading-105">长轮询和短轮询</a></p><h3 id="说下进程、线程和协程"><a href="#说下进程、线程和协程" class="headerlink" title="说下进程、线程和协程"></a>说下进程、线程和协程</h3><p> 进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，<strong>是操作系统进行资源分配和调度的一个独立单位</strong>，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义</p><p> 线程是程序执行中一个单一的顺序控制流程，是<strong>程序执行流的最小单元</strong>，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成</p><p> 协程，英文Coroutines，<strong>是一种基于线程之上</strong>，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性</p><p>进程和线程的区别与联系<br>【区别】：</p><h4 id="进程作为拥有资源的基本单位-线程作为调度和分配的基本单位-1"><a href="#进程作为拥有资源的基本单位-线程作为调度和分配的基本单位-1" class="headerlink" title="进程作为拥有资源的基本单位,线程作为调度和分配的基本单位"></a>进程作为拥有资源的基本单位,线程作为调度和分配的基本单位</h4><h4 id="并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行"><a href="#并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行" class="headerlink" title="并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行"></a>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行</h4><p>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。</p><p>系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。<br>【联系】：</p><blockquote><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</p></blockquote><blockquote><p>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</p></blockquote><blockquote><p>处理机分给线程，即真正在处理机上运行的是线程；</p></blockquote><p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p><p>传送门 ☞ # <a href="https://juejin.cn/post/7005465381791875109">一文搞懂进程、线程、协程及JS协程的发展 ☞了解更多</a><br>关于浏览器传送门 ☞#<a href="https://juejin.cn/post/6993095345576083486">深入了解现代 Web 浏览器</a><br><a href="https://pengzhenglong.github.io/2021/04/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%A7%A3(%E4%B8%80)/">博客</a></p><h3 id="粘包问题分析与对策"><a href="#粘包问题分析与对策" class="headerlink" title="粘包问题分析与对策"></a>粘包问题分析与对策</h3><p>TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。<br>粘包出现原因<br>简单得说，在流传输中出现，UDP不会出现粘包，因为它有消息边界</p><h4 id="粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包"><a href="#粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包" class="headerlink" title="粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包"></a>粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包</h4><h4 id="为了避免粘包现象，可采取以下几种措施"><a href="#为了避免粘包现象，可采取以下几种措施" class="headerlink" title="为了避免粘包现象，可采取以下几种措施"></a>为了避免粘包现象，可采取以下几种措施</h4><p>（1）对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；<br>（2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；<br>（3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。分包多发。</p><h4 id="以上提到的三种措施，都有其不足之处"><a href="#以上提到的三种措施，都有其不足之处" class="headerlink" title="以上提到的三种措施，都有其不足之处"></a>以上提到的三种措施，都有其不足之处</h4><p>（1）第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。<br>（2）第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。<br>（3）第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</p><blockquote><p>一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。实验证明这种方法是高效可行的。</p></blockquote><h2 id="网路安全"><a href="#网路安全" class="headerlink" title="网路安全"></a>网路安全</h2><h3 id="什么是-XSS？如何预防？"><a href="#什么是-XSS？如何预防？" class="headerlink" title="什么是 XSS？如何预防？"></a>什么是 XSS？如何预防？</h3><p>XSS 全称是 Cross Site Scripting ,为了与CSS区分开来，故简称 XSS，翻译过来就是“跨站脚本”。<br><strong>XSS是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。</strong><br>最开始的时候，这种攻击是通过跨域来实现的，所以叫“跨域脚本”。发展到现在，往HTML文件中中插入恶意代码方式越来越多，所以是否跨域注入脚本已经不是唯一的注入手段了，但是 XSS 这个名字却一直保留至今。注入恶意脚本可以完成这些事情：</p><ol><li>窃取Cookie</li><li>监听用户行为，比如输入账号密码后之间发给黑客服务器</li><li>在网页中生成浮窗广告</li><li>修改DOM伪造登入表单</li></ol><p>一般的情况下，XSS攻击有三种实现方式</p><h4 id="存储型-XSS-攻击"><a href="#存储型-XSS-攻击" class="headerlink" title="存储型 XSS 攻击"></a>存储型 XSS 攻击</h4><p>存储型 XSS 攻击大致步骤如下：</p><ol><li>首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；</li><li>然后用户向网站请求包含了恶意 JavaScript 脚本的页面；</li><li>当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。</li></ol><p>比如常见的场景：</p><p><strong>在评论区提交一份脚本代码，假设前后端没有做好转义工作，那内容上传到服务器，在页面渲染的时候就会直接执行，相当于执行一段未知的JS代码。这就是存储型 XSS 攻击。</strong></p><h4 id="反射型-XSS-攻击"><a href="#反射型-XSS-攻击" class="headerlink" title="反射型 XSS 攻击"></a>反射型 XSS 攻击</h4><p>反射型 XSS 攻击指的就是恶意脚本作为<strong>「网络请求的一部分」，随后网站又把恶意的JavaScript脚本返回给用户，当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。</strong><br>举个例子:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">http://dragon.com?query=<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">alert(<span class="hljs-string">&quot;你受到了XSS攻击&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如上，服务器拿到后解析参数query，最后将内容返回给浏览器，浏览器将这些内容作为HTML的一部分解析，发现是Javascript脚本，直接执行，这样子被XSS攻击了。<br>这也就是反射型名字的由来，将恶意脚本作为参数，通过网络请求，最后经过服务器，在反射到HTML文档中，执行解析。<br>主要注意的就是，<strong>「服务器不会存储这些恶意的脚本，这也算是和存储型XSS攻击的区别吧」。</strong></p><h4 id="基于-DOM-的-XSS-攻击"><a href="#基于-DOM-的-XSS-攻击" class="headerlink" title="基于 DOM 的 XSS 攻击"></a>基于 DOM 的 XSS 攻击</h4><p>基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，在数据传输的时候劫持网络数据包.常见的劫持手段有：<br>WIFI路由器劫持,本地恶意软件</p><h3 id="阻止-XSS-攻击的策略"><a href="#阻止-XSS-攻击的策略" class="headerlink" title="阻止 XSS 攻击的策略"></a>阻止 XSS 攻击的策略</h3><p>以上讲述的XSS攻击原理，都有一个共同点：让恶意脚本直接在浏览器执行。<br>针对三种不同形式的XSS攻击，有以下三种解决办法</p><h4 id="对输入脚本进行过滤或转码"><a href="#对输入脚本进行过滤或转码" class="headerlink" title="对输入脚本进行过滤或转码"></a>对输入脚本进行过滤或转码</h4><p>对用户输入的信息过滤或者是转码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-symbol">&amp;lt;</span>script<span class="hljs-symbol">&amp;gt;</span>alert(<span class="hljs-symbol">&amp;#39;</span>你受到XSS攻击了<span class="hljs-symbol">&amp;#39;</span>)<span class="hljs-symbol">&amp;lt;</span>/script<span class="hljs-symbol">&amp;gt;</span><br></code></pre></td></tr></table></figure><p>这样的代码在 html 解析的过程中是无法执行的。<br>当然了对于<code>&lt;script&gt;、&lt;img&gt;、&lt;a&gt;</code>等关键字标签也是可以过来的，效果如下👇</p><p>最后什么都没有剩下了</p><h4 id="利用-CSP"><a href="#利用-CSP" class="headerlink" title="利用 CSP"></a>利用 CSP</h4><p>该安全策略的实现基于一个称作 Content-Security-Policy的 HTTP 首部。<br>可以移步MDN，有更加规范的解释。我在这里就是梳理一下吧。<br>CSP，即浏览器中的内容安全策略，它的核心思想大概就是服务器决定浏览器加载哪些资源，具体来说有几个功能👇</p><p>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；<br>禁止向第三方域提交数据，这样用户数据也不会外泄；<br>提供上报机制，能帮助我们及时发现 XSS 攻击。<br>禁止执行内联脚本和未授权的脚本；</p><h4 id="利用-HttpOnly"><a href="#利用-HttpOnly" class="headerlink" title="利用 HttpOnly"></a>利用 HttpOnly</h4><p>由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。这样子的话，JavaScript 便无法读取 Cookie 的值。这样也能很好的防范 XSS 攻击。<br>通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的，下面是打开 Google 时，HTTP 响应头中的一段：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set</span>-cookie: NID=<span class="hljs-number">189</span>=M<span class="hljs-number">8</span>l<span class="hljs-number">6</span>-z<span class="hljs-number">41</span>asXtm<span class="hljs-number">2</span>uEwcOC<span class="hljs-number">5</span>oh<span class="hljs-number">9</span>djkffOMhWqQrlnCtOI; expires=Sat, <span class="hljs-number">18</span>-Apr-<span class="hljs-number">2020</span> <span class="hljs-number">06</span>:<span class="hljs-number">52</span>:<span class="hljs-number">22</span> GMT; path=/; domain=.google.com; HttpOnly<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>XSS 攻击是指浏览器中执行恶意脚本, 然后拿到用户的信息进行操作。主要分为存储型、反射型和文档型。防范的措施包括</p><p>对输入内容过滤或者转码，尤其是类似于<code>&lt;script&gt;、&lt;img&gt;、&lt;a&gt;</code>标签<br>利用CSP<br>利用Cookie的HttpOnly属性</p><p>除了以上策略之外，我们还可以通过添加验证码防止脚本冒充用户提交危险操作。而对于一些不受信任的输入，还可以限制其输入长度，这样可以增大 XSS 攻击的难度。<br><a href="https://juejin.cn/post/6864398060702760968#heading-93">掘金</a></p><h3 id="什么是-CSP？"><a href="#什么是-CSP？" class="headerlink" title="什么是 CSP？"></a>什么是 CSP？</h3><p>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</p><p>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式<code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></p><h3 id="什么是-CSRF-攻击？如何防范-CSRF-攻击？"><a href="#什么是-CSRF-攻击？如何防范-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？如何防范 CSRF 攻击？"></a>什么是 CSRF 攻击？如何防范 CSRF 攻击？</h3><p>CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被<br>攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</p><p>CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</p><p>一般的 CSRF 攻击类型有三种：</p><p>第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提<br>交。</p><p>第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</p><p>第三种是链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</p><p>CSRF 可以用下面几种方法来防护：</p><p>第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。</p><p>第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。</p><p>第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</p><p>第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</p><h3 id="什么是-Samesite-Cookie-属性？"><a href="#什么是-Samesite-Cookie-属性？" class="headerlink" title="什么是 Samesite Cookie 属性？"></a>什么是 Samesite Cookie 属性？</h3><p>Samesite Cookie 表示同站 cookie，避免 cookie 被第三方所利用。</p><p>将 Samesite 设为 strict ，这种称为严格模式，表示这个 cookie 在任何情况下都不可能作为第三方 cookie。</p><p>将 Samesite 设为 Lax ，这种模式称为宽松模式，如果这个请求是个 GET 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie。</p><p>使用这种方法的缺点是，因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都回重新登录。还有一个问题就是它的兼容性不够好。</p><h3 id="什么是点击劫持？如何防范点击劫持？"><a href="#什么是点击劫持？如何防范点击劫持？" class="headerlink" title="什么是点击劫持？如何防范点击劫持？"></a>什么是点击劫持？如何防范点击劫持？</h3><p>点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。</p><p>我们可以在 http 相应头中设置 X-FRAME-OPTIONS 来防御用 iframe 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特定的一些情况才能作为 iframe 来使用。</p><h3 id="SQL-注入攻击？"><a href="#SQL-注入攻击？" class="headerlink" title="SQL 注入攻击？"></a>SQL 注入攻击？</h3><p>SQL 注入攻击指的是攻击者在 HTTP 请求中注入恶意的 SQL 代码，服务器使用参数构建数据库 SQL 命令时，恶意 SQL 被一起构造，破坏原有 SQL 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。</p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS+ES6面试题总结</title>
    <link href="/2022/01/05/%5B%E6%80%BB%E7%BB%93%5DJS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/01/05/%5B%E6%80%BB%E7%BB%93%5DJS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>总结了最近的一些面试题和之前的知识点</p><hr><h2 id="进阶-多看"><a href="#进阶-多看" class="headerlink" title="进阶(多看)"></a>进阶(多看)</h2><h3 id="EventLoop-事件循环"><a href="#EventLoop-事件循环" class="headerlink" title="EventLoop 事件循环"></a>EventLoop 事件循环</h3><p>JS是单线程的，为了<strong>防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列</strong>。微任务队列的代表就是，<strong>Promise.then，MutationObserver</strong>，宏任务的话就是 <strong>setImmediate setTimeout setInterval</strong></p><ol><li><p>首先，整体的<strong>script(作为第一个宏任务)开始执行的时候</strong>，会把<strong>所有代码分为同步任务、异步任务</strong>两部分</p></li><li><p><strong>同步任务</strong>会直接进入<strong>主线程依次执行</strong>(执行栈)</p></li><li><p><strong>异步任务</strong>会再分为<strong>宏任务和微任务</strong></p></li><li><p>宏任务进入到<strong>Event Table中，并在里面注册回调函数</strong>，<strong>每当指定的事件完成时（例如延时器，或者异步请求，dom监听）</strong>，Event Table会将这个函数移到<strong>Event Queue</strong>中</p></li><li><p><strong>微任务</strong>也会进入到另一个Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中</p></li><li><p>当<strong>主线程内的任务执行完毕，主线程为空时，会检查微任务的Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务</strong>（微任务队列清空后，进入宏任务队列，<strong>取队列的第一项任务放入Stack(栈）中执行</strong>，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列）<br>上述过程会<strong>不断重复</strong>（循环），这就是Event Loop，比较完整的事件循环</p></li></ol><p>JS运行的环境。一般为浏览器或者Node。 在浏览器环境中，有<strong>JS 引擎线程和渲染线程，且两个线程互斥</strong>。 Node环境中，只有JS 线程。 不同环境执行机制有差异，不同任务进入不同Event Queue队列。 当主程结束，先执行准备好微任务，然后再执行准备好的宏任务，一个轮询结束。</p><h4 id="当一个宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完（宏任务-gt-微任务-gt-GUI渲染-gt-宏任务-gt-…）-（也就是当前）"><a href="#当一个宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完（宏任务-gt-微任务-gt-GUI渲染-gt-宏任务-gt-…）-（也就是当前）" class="headerlink" title="当一个宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完（宏任务 -&gt; 微任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; …） （也就是当前）"></a>当一个宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完（宏任务 -&gt; 微任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; …） （也就是当前）</h4><h4 id="你怎么理解执行栈的？"><a href="#你怎么理解执行栈的？" class="headerlink" title="你怎么理解执行栈的？"></a>你怎么理解执行栈的？</h4><h5 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h5><p>JavaScript 中有三种执行上下文类型。</p><p><strong>全局执行上下文</strong> — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。<br><strong>函数执行上下文</strong> — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。<br><strong>Eval 函数执行上下文</strong> — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。</p><h5 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h5><p>执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO<strong>先进后出</strong>数据结构的栈，被用来存储代码运行时创建的所有执行上下文。<br>当 JavaScript 引擎第一次遇到你的脚本时，它会<strong>创建一个全局的执行上下文并且压入当前执行栈</strong>。每当引擎<strong>遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。</strong><br>引擎会执行那些执行<strong>上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出</strong>，控制流程到达当前栈中的下一个上下文。<br><a href="https://juejin.cn/post/6844903682283143181">掘金</a></p><h5 id="怎么创建执行上下文？"><a href="#怎么创建执行上下文？" class="headerlink" title="怎么创建执行上下文？"></a>怎么创建执行上下文？</h5><ol><li>this 值的决定，即我们所熟知的 This 绑定。</li><li>创建词法环境组件。</li><li>创建变量环境组件。</li></ol><ul><li>eventLoop 是由<strong>JS的宿主环境（浏览器）</strong>来实现的；</li><li>浏览器中的任务源(task):<ol><li>宏任务(macrotask)：<strong>宿主环境提供的</strong>，比如浏览器<strong>ajax、setTimeout、setInterval、setTmmediate(只兼容ie)、script、</strong>2. 2.requestAnimationFrame、messageChannel、<strong>UI渲染</strong>、一些浏览器api</li><li>微任务(microtask)：<strong>语言本身提供</strong>的，比如**promise.thenthen、queueMicrotask(基于then)、mutationObserver(浏览器提供)**、messageChannel 、mutationObersve<br><img src="/imageO/20.png" alt="如图"></li></ol></li></ul><p><a href="https://pengzhenglong.github.io/2021/07/03/Js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/">博客：这一次，彻底弄懂 JavaScript 执行机制</a><br><a href="https://juejin.cn/post/7001881781125251086">传送门 ☞ # 宏任务和微任务</a></p><h3 id="promise-原理-（回调函数-状态处理队列）"><a href="#promise-原理-（回调函数-状态处理队列）" class="headerlink" title="promise 原理 （回调函数+状态处理队列）"></a>promise 原理 （回调函数+状态处理队列）</h3><p>promise 的本质是回调函数，then 方法的本质是依赖收集，它把 fulfilled 状态要执行的回调函数放在一个队列， rejected 状态要执行的回调函数放在另一个队列。待 promise 从 pending 变为 fulfilled/rejected 状态后，把相应队列的所有函数，执行一遍。</p><h3 id="如何解决异步回调地狱-异步编程的实现方式？"><a href="#如何解决异步回调地狱-异步编程的实现方式？" class="headerlink" title="如何解决异步回调地狱||  异步编程的实现方式？"></a>如何解决异步回调地狱||  异步编程的实现方式？</h3><p>promise、generator、async/await<br>js 中的异步机制可以分为以下几种：</p><ol><li>第一种最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是，<strong>多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高</strong>，不利于代码的可维护。</li></ol><h4 id="2-第二种是-Promise-的方式，使用-Promise-的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个-then-的链式调用，可能会造成代码的语义不够明确"><a href="#2-第二种是-Promise-的方式，使用-Promise-的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个-then-的链式调用，可能会造成代码的语义不够明确" class="headerlink" title="2. 第二种是 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确"></a>2. 第二种是 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确</h4><p>从语法上说，<strong>Promise 是一个对象，从它可以获取异步操作的消息。</strong><br>Promise 异步操作有三种状态：<strong>pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。</strong><br>Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。<br>语法：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim">new <span class="hljs-type">Promise</span>( function(resolve, reject) <span class="hljs-meta">&#123;...&#125;</span>);<br></code></pre></td></tr></table></figure><p>状态的缺点：<br><strong>无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。</strong><br><strong>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部</strong><br>当<strong>处于 pending 状态时，无法得知目前进展到哪一个阶段</strong>（刚刚开始还是即将完成）。</p><ol><li><p>generator</p></li><li><p>第四种是使用 async 函数的形式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候， <strong>如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行</strong>。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。<br><a href="https://pengzhenglong.github.io/2021/05/11/Es6async&await/">博客：</a></p></li></ol><h3 id="promise-generotor-await-await后面接收的是什么"><a href="#promise-generotor-await-await后面接收的是什么" class="headerlink" title="promise  /generotor /await  (await后面接收的是什么)"></a>promise  /generotor /await  (await后面接收的是什么)</h3><h4 id="then-方法"><a href="#then-方法" class="headerlink" title="then 方法"></a>then 方法</h4><p>then是<strong>实例状态发生改变</strong>时的回调函数，第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数<br>then方法返回的是一个新的Promise实例，也就是promise能链式书写的原因<br>在 <strong>JavaScript 事件队列的当前运行完成之前，回调函数永远不会被调用。</strong></p><h5 id="promise-then-返回的新的promise状态与值是怎样决定的？"><a href="#promise-then-返回的新的promise状态与值是怎样决定的？" class="headerlink" title="promise.then 返回的新的promise状态与值是怎样决定的？"></a>promise.then 返回的新的promise状态与值是怎样决定的？</h5><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">let promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    resolve(<span class="hljs-number">1</span>)<br>&#125;).<span class="hljs-keyword">then</span>(<br>    value =&gt; &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;success1&#x27;</span>,value)<br>        <span class="hljs-regexp">//</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span> <span class="hljs-regexp">//</span>默认为<span class="hljs-literal">undefined</span><br>        <span class="hljs-regexp">//</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-regexp">//</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>)<br>        <span class="hljs-regexp">//</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">3</span>)<br>        <span class="hljs-regexp">//</span> <span class="hljs-keyword">throw</span> <span class="hljs-number">4</span><br>    &#125;)<br></code></pre></td></tr></table></figure><p>结论：<br>1、通过return 返回一个非promise的值，则新promise的状态fulfilled，值为return 的值<br>2、不做任何处理（不return == return undefined），所以根据结论1新promise的状态为fulfilled，值为undefined<br>3、<strong>通过throw主动抛出错误或者代码出现错误，则promise的状态为rejected，值为throw的值</strong><br>4、通过<strong>return 返回一个promise对象，则新promise就是return的promsie</strong></p><ul><li>可根据以上代码，挨个取消注释并在控制台打印promise2查看</li></ul><h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p>catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数</p><h4 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h4><p>finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作<br><a href="https://vue3js.cn/interview/es6/promise.html#%E4%B8%80%E3%80%81%E4%BB%8B%E7%BB%8D">参考</a><br>正常情况下，async中的<strong>await命令是一个Promise对象，返回该对象的结果。<br>但如果不是Promise对象的话，就会直接返回对应的值，相当于Promise.resolve()<br>如果在async函数中抛出了错误，则终止错误结果，不会继续向下执行。</strong></p><h3 id="Promise-all、Promise-race、Promise-allSettled-分别怎么用？"><a href="#Promise-all、Promise-race、Promise-allSettled-分别怎么用？" class="headerlink" title="Promise.all、Promise.race、Promise.allSettled 分别怎么用？"></a>Promise.all、Promise.race、Promise.allSettled 分别怎么用？</h3><h4 id="Promise-all方法"><a href="#Promise-all方法" class="headerlink" title="Promise.all方法"></a>Promise.all方法</h4><p>简而言之：Promise.all( ).then( )适用于处理多个异步任务，且所有的异步任务都得到结果时的情况。</p><blockquote><p>promise1和promise2都成功才会调用success1<br>比如：用户点击按钮，会弹出一个弹出对话框，对话框中有两部分数据呈现，这两部分数据分别是不同的后端接口获取的数据。<br>弹框弹出后的初始情况下，就让这个弹出框处于数据加载中的状态，当这两部分数据都从接口获取到的时候，才让这个数据加载中状态消失。让用户看到这两部分的数据。</p></blockquote><h4 id="Promise-race方法"><a href="#Promise-race方法" class="headerlink" title="Promise.race方法"></a>Promise.race方法</h4><p>Promise.race赛跑机制，只认第一名</p><blockquote><p>promise1和promise2只要有一个成功就会调用success1<br>Promise.race其实使用的并不多，如果真要使用。我们可以提出这样一个需求：<br><strong>比如：点击按钮发请求，当后端的接口超过一定时间，假设超过三秒，没有返回结果，我们就提示用户请求超时</strong></p></blockquote><h4 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h4><p>Promise.allSettled(promises) 允许您并行执行互相独立的promise, 并每一个promise执行之后的状态（已完成或拒绝）存放在数组中。</p><p>当您需要执行并行和独立的异步操作并获取到异步操作的所有结果时，Promise.allSettled(…) 非常有用，即使某些异步操作可能会失败。</p><p><a href="https://pengzhenglong.github.io/2021/04/17/ES6(promise)/#Promise-all">博客</a><br><a href="https://juejin.cn/post/6998891444312211492#heading-4">博客</a></p><h3 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h3><blockquote><p>简单来说，作用域 指程序中定义变量的区域，它决定了当前执行代码对变量的访问权限。</p></blockquote><p>javascript 中大部分情况下，只有两种作用域类型：</p><ol><li>全局作用域：全局作用域为程序的最外层作用域，一直存在。</li><li>函数作用域：函数作用域只有函数被定义时才会创建，包含在父级函数作用域 / 全局作用域内。</li></ol><p>由于作用域的限制，每段独立的执行代码块<strong>只能访问自己作用域和外层作用域中的变量，无法访问到内层作用域的变量</strong>。</p><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>当<strong>可执行代码内部访问变量时，会先查找本地作用域，如果找到目标变量即返回，否则会去父级作用域继续查找…一直找到全局作用域</strong>。我们把这种作用域的嵌套机制，称为 作用域链。<br><a href="https://juejin.cn/post/6844904165672484871#heading-14">面试官：说说作用域和闭包吧</a></p><h3 id="闭包是什么？有什么优点和缺点？-（作用域-amp-amp-函数套函数，内部函数对外部函数变量的引用会产生闭包）"><a href="#闭包是什么？有什么优点和缺点？-（作用域-amp-amp-函数套函数，内部函数对外部函数变量的引用会产生闭包）" class="headerlink" title="闭包是什么？有什么优点和缺点？ （作用域&amp;&amp;函数套函数，内部函数对外部函数变量的引用会产生闭包）"></a>闭包是什么？有什么优点和缺点？ （作用域&amp;&amp;函数套函数，内部函数对外部函数变量的引用会产生闭包）</h3><p> 解答：闭包是指有权访问另一个函数作用域中的变量的函数。<br>  优点：① 能够读取函数内部的变量；②让这些变量一直存在于内存中，不会在调用结束后被垃圾回收机制回收；3.对变量进行保护，防止全局污染<br>  缺点：由于闭包会使用函数中的变量存在在内存中，内存消耗很大，所以不能滥用闭包；解决的办法是退出函数之前，将不使用的局部变量删除；<br><a href="https://pengzhenglong.github.io/2021/04/26/JS%E9%97%AD%E5%8C%85%E7%90%86%E8%A7%A3/">博客：</a></p><h4 id="闭包的使用"><a href="#闭包的使用" class="headerlink" title="闭包的使用"></a>闭包的使用</h4><ol><li>for循环+setTimeout中i访问的是全局变量，使用闭包保存变量</li></ol><p>原因是，for循环在主线程内，setTimeout是异步方法，在任务队列里面，只有主线程执行完后，任务队列才执行，此时i的值已经是5，所以得到结果是5个5<br>2. 防抖节流</p><h3 id="防抖-amp-amp-节流"><a href="#防抖-amp-amp-节流" class="headerlink" title="防抖&amp;&amp;节流"></a>防抖&amp;&amp;节流</h3><h4 id="介绍节流防抖原理、区别以及应用"><a href="#介绍节流防抖原理、区别以及应用" class="headerlink" title="介绍节流防抖原理、区别以及应用"></a>介绍节流防抖原理、区别以及应用</h4><h5 id="防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如-1-秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待-1-秒，直到能最终执行-（-clearTimeout-timeout-）"><a href="#防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如-1-秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待-1-秒，直到能最终执行-（-clearTimeout-timeout-）" class="headerlink" title="防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行 （ clearTimeout(timeout) ）"></a>防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行 （ clearTimeout(timeout) ）</h5><h5 id="节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次"><a href="#节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次" class="headerlink" title="节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次"></a>节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次</h5><p>函数执行的前提条件是开关打开，持续触发时，持续关闭开关，等到setTimeout到时间了，再把开关打开，函数就会执行了。</p><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>防抖：搜索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染。<br>节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……<br><a href="https://pengzhenglong.github.io/2021/05/16/JS&%E9%98%B2%E6%8A%96&%E8%8A%82%E6%B5%81/">函数的防抖与节流 _</a></p><h4 id="匿名函数的作用"><a href="#匿名函数的作用" class="headerlink" title="匿名函数的作用"></a>匿名函数的作用</h4><p>1、通过匿名函数可以实现闭包（必须掌握的知识点）</p><p>2、模拟块级作用域，减少全局变量。执行完匿名函数，存储在内存中相对应的变量会被销毁，使用块级作用域，会大大降低命名冲突的问题，不必担心搞乱全局作用域了。</p><h3 id="JS垃圾回收机制-（GC）"><a href="#JS垃圾回收机制-（GC）" class="headerlink" title="JS垃圾回收机制 （GC）"></a>JS垃圾回收机制 （GC）</h3><ol><li>项目中，<strong>如果存在大量不被释放的内存（堆/栈/上下文），页面性能会变得很慢。当某些代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存。</strong></li><li>浏览器垃圾回收机制/内存回收机制:浏览器的<strong>Javascript</strong>具有自动垃圾回收机制(GC:Garbage Collecation)，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</li></ol><p><strong>标记清除</strong>:在js中，最常用的垃圾回收机制是标记清除：<strong>当变量进入上下文，比如在函数内声明了一个变量时，这个变量就会被加上存在于上下文中的标记，而在上下文中的变量，逻辑上讲永远不应该释放他们的内存，因为只要在上下文中的代码运行了，就可能用到它们，当变量离开上下文中的时候，也会被加上离开上下文的标记。（上下文中的变量都访问不到他们了）</strong>垃圾回收器会<strong>销毁那些带离开上下文标记的值并回收它们所占用的内存空间</strong>。谷歌浏览器：“查找引用”，浏览器不定时去查找当前内存的引用，如果没有被占用了，浏览器会回收它；如果被占用，就不能回收。<br>过程</p><ol><li>垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0</li><li>然后从各个根对象开始遍历，把不是垃圾的节点改成1</li><li>清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间</li><li>最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收<br>优点 ：</li></ol><p>标记清除算法的优点只有一个，那就是<strong>实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单</strong></p><p>缺点</p><p>标记清除算法有一个很大的缺点，就是在<strong>清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 内存碎片</strong>，并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的</p><p>IE浏览器：<strong>“引用计数法”</strong>，当前内存被占用一次，计数累加1次，移除占用就减1，减到0时，浏览器就回收它。<br>缺点<br>引用计数的缺点想必大家也都很明朗了，首先它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限，还有就是<strong>无法解决循环引用无法回收的问题，这也是最严重的</strong></p><ol><li>优化手段：内存优化 ; 手动释放：取消内存的占用即可。（1）堆内存：fn = null 【null：空指针对象】（2）栈内存：把上下文中，被外部占用的堆的占用取消即可。</li><li>内存泄漏在 JS 中，常见的内存泄露主要有 4 种,全局变量、闭包、DOM 元素的引用、定时器</li></ol><h4 id="V8对GC的优化-（待）"><a href="#V8对GC的优化-（待）" class="headerlink" title="V8对GC的优化  （待）"></a>V8对GC的优化  （待）</h4><ol><li>分代式垃圾回收</li></ol><p>V8 的垃圾回收策略主要基于分代式垃圾回收机制，<strong>V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收</strong></p><p>新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大<br>2. 新老生代<br>3. 新生代垃圾回收<br>4. 老生代垃圾回收<br>5. 为什么需要分代式？<br>6. 并行回收(Parallel)</p><p><strong>所谓并行，也就是同时的意思，它指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作</strong><br>7. 增量标记与懒性清理<br>8. 并发回收(Concurrent)</p><p><strong>它指的是主线程在执行 JavaScript 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起</strong><br><a href="https://pengzhenglong.github.io/2022/03/26/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%90%97/">博客</a></p><h3 id="new-操作符具体干了什么呢？如何实现？"><a href="#new-操作符具体干了什么呢？如何实现？" class="headerlink" title="new 操作符具体干了什么呢？如何实现？"></a>new 操作符具体干了什么呢？如何实现？</h3><p>（1）首先创建了一个新的空对象<br>（2）设置原型，将对象的原型设置为函数的 prototype 对象。<br>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）<br>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p><p>new共经历了四个过程。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><br><span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; &#125;;<br><span class="hljs-keyword">var</span> fnObj = <span class="hljs-keyword">new</span> fn();<br><br><span class="hljs-number">1</span>、创建了一个空对象<br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br><br><span class="hljs-number">2</span>、设置原型链<br>obj._proto_ = fn.prototype;<br><br><span class="hljs-number">3</span>、让fn的<span class="hljs-built_in">this</span>指向obj，并执行fn的函数体<br><br><span class="hljs-keyword">var</span> result = fn.call(obj);<br><br><span class="hljs-number">4</span>、判断fn的返回值类型，如果是值类型，返回obj。如果是引用类型，就返回这个引用类型的对象。<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(result) == <span class="hljs-string">&quot;object&quot;</span>)&#123;      fnObj = result;  &#125; <span class="hljs-keyword">else</span> &#123;      fnObj = obj;&#125;  <br><span class="hljs-comment">// 实现:</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFactory</span>(<span class="hljs-params"></span>) </span>&#123;<br> <span class="hljs-keyword">let</span> newObject = <span class="hljs-literal">null</span>,<br>    <span class="hljs-title">constructor</span> = <span class="hljs-title">Array</span>.<span class="hljs-title">prototype</span>.<span class="hljs-title">shift</span>.<span class="hljs-title">call</span>(<span class="hljs-params"><span class="hljs-built_in">arguments</span></span>),<br>    <span class="hljs-title">result</span> = <span class="hljs-title">null</span>;<br><br> <span class="hljs-comment">// 参数判断</span><br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title">constructor</span> !== &quot;<span class="hljs-title">function</span>&quot;) &#123;<br> <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;type error&quot;</span>);<br> <span class="hljs-keyword">return</span>;<br>  &#125;<br><br> <span class="hljs-comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br>  newObject = <span class="hljs-built_in">Object</span>.create(<span class="hljs-title">constructor</span>.<span class="hljs-title">prototype</span>);<br><br> <span class="hljs-comment">// 将 this 指向新建对象，并执行函数</span><br>  result = <span class="hljs-title">constructor</span>.<span class="hljs-title">apply</span>(<span class="hljs-params">newObject, <span class="hljs-built_in">arguments</span></span>);<br><br> <span class="hljs-comment">// 判断返回对象</span><br> <span class="hljs-keyword">let</span> flag =<br>    result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;function&quot;</span>);<br><br> <span class="hljs-comment">// 判断返回结果</span><br> <span class="hljs-keyword">return</span> flag ? result : newObject;<br>&#125;<br><br><span class="hljs-comment">// 使用方法</span><br><span class="hljs-comment">// objectFactory(构造函数, 初始化参数);</span><br><br></code></pre></td></tr></table></figure><p><a href="https://pengzhenglong.github.io/2021/07/02/JS%20new%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/">博客</a></p><h3 id="JavaScript-原型，原型链？-有什么特点？"><a href="#JavaScript-原型，原型链？-有什么特点？" class="headerlink" title="JavaScript 原型，原型链？ 有什么特点？"></a>JavaScript 原型，原型链？ 有什么特点？</h3><p>在 js 中我们是<strong>使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。</strong></p><p>当我们使用构造函数新建一个对象后，<strong>在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值</strong>，在 ES5 中这个指针被称为对象的原型。</p><p>一般来说我们是不应该能够获取到这个值的，但是现在浏览器中都实现了<code>__proto__</code>属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个Object.<strong>getPrototypeOf() 方法</strong>，我们可以通过这个方法来获取对象的原型。</p><p>当我们<strong>访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype</strong>所以这就是我们新建的对象为什么能够使用 toString() 等方法的原因。</p><p>2、隐式原型也是一个对象,是指向我们构造函数的原型</p><p>3、除了最顶层的Object对象没有__proto_，其他所有的对象都有__proto__,这是隐式原型</p><p>4、<strong>隐式原型__proto__的作用是让对象通过它来一直往上查找属性或方法，直到找到最顶层的Object的__proto__属性，它的值是null,这个查找的过程就是原型链</strong><br>特点：<br>JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。<br><img src="/imageO/YX.jpg" alt="原型链"></p><h4 id="面试题–原型链的顶端是什么（如果找不到是什么）"><a href="#面试题–原型链的顶端是什么（如果找不到是什么）" class="headerlink" title="面试题–原型链的顶端是什么（如果找不到是什么）"></a>面试题–原型链的顶端是什么（如果找不到是什么）</h4><p>在JavaScript中，每个对象都有一个原型（prototype）属性，指向它的原型对象。原型对象也有原型属性，指向它的原型对象，这样就形成了原型链。</p><p>原型链的顶端是Object.prototype，它是所有对象的祖先对象。<strong>Object.prototype的原型指向null，即它没有原型对象</strong>，所以<strong>当在原型链中找不到某个属性或方法时，就会返回undefined</strong>，而不是继续查找。</p><p>例如，当我们创建一个对象，并尝试访问它的属性或方法时，JavaScript引擎会先查找该对象本身是否具有该属性或方法，如果没有，则沿着原型链向上查找，直到找到该属性或方法或者到达Object.prototype为止。如果在整个原型链上都没有找到该属性或方法，那么就返回undefined。</p><p>总之，<strong>原型链的顶端是Object.prototype，它是所有对象的祖先对象</strong>，当在原型链中<strong>找不到某个属性或方法时，就会返回undefined</strong>。（这个答错了，回答的是null）</p><h4 id="js-获取原型的方法？"><a href="#js-获取原型的方法？" class="headerlink" title="js 获取原型的方法？"></a>js 获取原型的方法？</h4><p>p.<code>__proto__</code><br>p.constructor.prototype<br>Object.getPrototypeOf(p)</p><h4 id="hasOwnProperty表示是否有自己的属性。这个方法会查找一个对象是否有某个属性，但是不会去查找它的原型链"><a href="#hasOwnProperty表示是否有自己的属性。这个方法会查找一个对象是否有某个属性，但是不会去查找它的原型链" class="headerlink" title="hasOwnProperty表示是否有自己的属性。这个方法会查找一个对象是否有某个属性，但是不会去查找它的原型链"></a>hasOwnProperty表示是否有自己的属性。这个方法会查找一个对象是否有某个属性，但是不会去查找它的原型链</h4><h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><h4 id="1-没有-this"><a href="#1-没有-this" class="headerlink" title="1.没有 this"></a>1.没有 this</h4><p>箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。<br>这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this。</p><h5 id="箭头函数this为父作用域的this，不是调用时的this"><a href="#箭头函数this为父作用域的this，不是调用时的this" class="headerlink" title="箭头函数this为父作用域的this，不是调用时的this"></a>箭头函数this为父作用域的this，不是调用时的this</h5><p><img src="/imageO/JTHS.jpg" alt="this"><br>箭头函数的<strong>this永远指向其父作用域，任何方法都改变不了，包括call，apply，bind</strong>。</p><p>普通函数的this指向调用它的那个对象。</p><blockquote><p>上例中，init为箭头函数，其内部的this为全局window，onclick的this也就是init函数的this，也是window，得到的this.name就为undefined。</p></blockquote><h4 id="2-没有-arguments-（arguments是一个类数组对象，用来存储实际传递给函数的参数）"><a href="#2-没有-arguments-（arguments是一个类数组对象，用来存储实际传递给函数的参数）" class="headerlink" title="2.没有 arguments  （arguments是一个类数组对象，用来存储实际传递给函数的参数）"></a>2.没有 arguments  （arguments是一个类数组对象，用来存储实际传递给函数的参数）</h4><p>箭头函数没有自己的 arguments 对象，这不一定是件坏事，因为箭头函数可以访问外围函数的 arguments 对象：<br>那如果我们就是要访问箭头函数的参数呢？<br>你可以通过<strong>命名参数或者 rest 参数的形式访问参数</strong>:<br>let nums = (…nums) =&gt; nums;</p><h5 id="…args剩余参数和-arguments对象的区别"><a href="#…args剩余参数和-arguments对象的区别" class="headerlink" title="…args剩余参数和 arguments对象的区别"></a>…args剩余参数和 arguments对象的区别</h5><p>剩余参数只包含那些<strong>没有对应形参的实参</strong>，而 arguments 对象包含了传给函数的<strong>所有实参</strong>。<br>arguments对象<strong>不是一个真正的数组（类数组）</strong>，而<strong>剩余参数是真正的 Array实例</strong>，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach或pop。<br>arguments对象还有一些附加的属性 （如callee属性）。</p><h4 id="3-不能通过-new-关键字调用"><a href="#3-不能通过-new-关键字调用" class="headerlink" title="3.不能通过 new 关键字调用"></a>3.不能通过 new 关键字调用</h4><p>JavaScript 函数有两个内部方法： <strong>[[Call]]</strong> 和 **[[Construct]]**。</p><p>当通过 new 调用函数时，执行 [[Construct]] 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。</p><p>当直接调用的时候，执行 [[Call]] 方法，直接执行函数体。</p><p>箭头函数并没有 [[Construct]] 方法，不能被用作构造函数，如果通过 new 的方式调用，会报错。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> Foo = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;;<br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">new</span> Foo(); <span class="hljs-comment">// TypeError: Foo is not a constructor</span><br></code></pre></td></tr></table></figure><h4 id="4-没有-new-target"><a href="#4-没有-new-target" class="headerlink" title="4.没有 new.target"></a>4.没有 new.target</h4><p>因为不能使用 new 调用，所以也没有 new.target 值。</p><p>关于 new.target，可以参考 <a href="https://es6.ruanyifeng.com/#docs/class#new-target-%E5%B1%9E%E6%80%A7">es6</a></p><h4 id="5-没有原型"><a href="#5-没有原型" class="headerlink" title="5.没有原型"></a>5.没有原型</h4><p>由于不能使用 new 调用箭头函数，所以也没有构建原型的需求，于是箭头函数也不存在 prototype 这个属性。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">var Foo = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;;<br><span class="hljs-built_in">console</span>.log(Foo.prototype); <span class="hljs-regexp">//</span> <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><h5 id="解释——箭头函数为什么不能当做构造函数-（不能被实例化）"><a href="#解释——箭头函数为什么不能当做构造函数-（不能被实例化）" class="headerlink" title="解释——箭头函数为什么不能当做构造函数 （不能被实例化）"></a>解释——箭头函数为什么不能当做构造函数 （不能被实例化）</h5><p>一句话解释：</p><p>因为箭头函数没有 [ [Construct] ] 方法<br>和ES6的类的概念有点像，如果一个类没有定义constructor，直接new也会报错</p><h4 id="6-没有-super"><a href="#6-没有-super" class="headerlink" title="6.没有 super"></a>6.没有 super</h4><p>连原型都没有，自然也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的，不过跟 this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。</p><h4 id="箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或-new-target。这些函数表达式最适合用于非方法函数-non-method-functions-，并且它们不能用作构造函数"><a href="#箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或-new-target。这些函数表达式最适合用于非方法函数-non-method-functions-，并且它们不能用作构造函数" class="headerlink" title="箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数(non-method functions)，并且它们不能用作构造函数"></a>箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数(non-method functions)，并且它们不能用作构造函数</h4><h4 id="扩展-面试题"><a href="#扩展-面试题" class="headerlink" title="扩展(面试题)"></a>扩展(面试题)</h4><h5 id="类里面可以用箭头函数嘛"><a href="#类里面可以用箭头函数嘛" class="headerlink" title="类里面可以用箭头函数嘛"></a>类里面可以用箭头函数嘛</h5><p>在JavaScript的类中，<strong>可以使用箭头函数</strong>，但是<strong>需要注意箭头函数的this指向</strong>。</p><p>在箭头函数中，this的值是在定义函数时确定的，而不是在运行时确定的。这意味着如果<strong>箭头函数中引用了this，它将指向箭头函数定义时的上下文，而不是类实例</strong>。</p><p>在大多数情况下，我们需要访问类实例中的属性和方法，因此在类中定义方法时通常使用传统函数语法而不是箭头函数。但是，<strong>在某些情况下，比如定义只读属性时，箭头函数可能更方便。</strong></p><p>以下是一个例子，展示了在类中使用箭头函数的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.greet = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>.`</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 只读属性</span><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">description</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> is a person.`</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br>person.greet(); <span class="hljs-comment">// 输出 &quot;Hello, my name is Alice.&quot;</span><br><span class="hljs-built_in">console</span>.log(person.description); <span class="hljs-comment">// 输出 &quot;Alice is a person.&quot;</span><br></code></pre></td></tr></table></figure><h5 id="为什么有的时候可以用箭头函数有的时候不可以用"><a href="#为什么有的时候可以用箭头函数有的时候不可以用" class="headerlink" title="为什么有的时候可以用箭头函数有的时候不可以用"></a>为什么有的时候可以用箭头函数有的时候不可以用</h5><p>箭头函数与普通函数语法的一个主要区别是<strong>它们的this绑定方式不同</strong>。</p><p>在普通函数中，this的值是在运行时确定的，它取决于函数是如何调用的。this的值可以在函数调用时使用bind、call或apply方法进行修改。而<strong>在箭头函数中，this的值在函数定义时就已经确定，它始终指向箭头函数定义时所在的上下文，而不是调用时的上下文</strong>。</p><p>这就意味着，在某些情况下，箭头函数不适合使用。例如，<strong>在需要动态绑定this的情况下，箭头函数就不太合适</strong>。另外，<strong>在类的方法中，通常需要访问类实例的属性和方法</strong>，因此在这种情况下使用箭头函数可能会导致意外的行为。</p><p>另外一个需要注意的地方是，箭头函数不可以作为构造函数使用，因为它们没有自己的this绑定。在尝试使用箭头函数作为构造函数时，JavaScript会抛出一个TypeError错误。<br>因此，在选择使用箭头函数还是普通函数时，需要考虑到函数的用途和上下文，以确保正确的this绑定和预期的行为。</p><h5 id="在类的方法中，通常需要访问类实例的属性和方法，因此在这种情况下使用箭头函数可能会导致意外的行为。代码示例"><a href="#在类的方法中，通常需要访问类实例的属性和方法，因此在这种情况下使用箭头函数可能会导致意外的行为。代码示例" class="headerlink" title="在类的方法中，通常需要访问类实例的属性和方法，因此在这种情况下使用箭头函数可能会导致意外的行为。代码示例"></a>在类的方法中，通常需要访问类实例的属性和方法，因此在这种情况下使用箭头函数可能会导致意外的行为。代码示例</h5><p>当在类中使用箭头函数作为方法时，this将会指向箭头函数定义时所在的上下文，而不是类实例。这可能会导致一些意外的行为，例如无法访问类实例的属性或方法。下面是一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>  &#125;<br><br>  <span class="hljs-comment">// 使用箭头函数定义方法</span><br>  printDetails = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Name: <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>, Age: <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.age&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">25</span>);<br><br><span class="hljs-comment">// 调用方法，输出 &quot;Name: undefined, Age: undefined&quot;</span><br>person.printDetails();<br><br><span class="hljs-comment">// 尝试访问实例属性，输出 &quot;Alice&quot;</span><br><span class="hljs-built_in">console</span>.log(person.name);<br></code></pre></td></tr></table></figure><p>在上面的例子中，我们使用箭头函数定义了一个名为printDetails的方法。当我们创建Person实例并调用该方法时，它会输出undefined，<strong>因为箭头函数的this指向Person类的定义上下文，而不是实例</strong>。因此，this.name和this.age都是undefined。此外，在类外部访问实例属性和方法时，它们仍然是可以访问的。</p><p>为了避免这种问题，我们通常<strong>使用普通函数语法</strong>定义类的方法，它们具有正确的this绑定，可以访问实例的属性和方法。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>  &#125;<br><br>  <span class="hljs-comment">// 使用普通函数定义方法</span><br>  <span class="hljs-function"><span class="hljs-title">printDetails</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Name: <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>, Age: <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.age&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">25</span>);<br><br><span class="hljs-comment">// 调用方法，输出 &quot;Name: Alice, Age: 25&quot;</span><br>person.printDetails();<br><span class="hljs-comment">// 尝试访问实例属性，输出 &quot;Alice&quot;</span><br><span class="hljs-built_in">console</span>.log(person.name);<br></code></pre></td></tr></table></figure><p>在上面的例子中，我们使用普通函数定义了printDetails方法，它具有正确的this绑定，可以访问实例的属性和方法。在创建Person实例并调用该方法时，它会输出正确的实例属性值。<br><a href="https://juejin.cn/post/6844903616231260174#heading-4">参考文章</a></p><h3 id="This"><a href="#This" class="headerlink" title="This"></a>This</h3><p>谈一谈你对this的理解，以及在各种环境下的this<br>在浏览器里，在全局范围内this指向window对象<br>在函数中，this永远指向最后调用他的那个对象(箭头函数除外)。<br>在构造函数中，this指向new出来的新对象。<br>call、apply、bind中的this被强绑定在指定的那个对象上。<br>箭头函数this为父作用域的this，不是调用时的this。<br><a href="https://pengzhenglong.github.io/2021/05/12/JS&this%E6%8C%87%E5%90%91/">博客：</a></p><h3 id="call-和-apply-的区别？"><a href="#call-和-apply-的区别？" class="headerlink" title="call() 和 .apply() 的区别？"></a>call() 和 .apply() 的区别？</h3><ol><li>它们的作用一模一样，区别仅在于传入参数的形式的不同。</li><li><strong>call 传入的参数数量不固定</strong>，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li></ol><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Function.call(obj,<span class="hljs-comment">[param1<span class="hljs-comment">[,param2<span class="hljs-comment">[,…<span class="hljs-comment">[,paramN]</span>]</span>]</span>]</span>)<br></code></pre></td></tr></table></figure><ol start="3"><li><p>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</p></li><li><p>bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。</p></li></ol><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl">function add (a, b) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br>function <span class="hljs-function"><span class="hljs-keyword">sub</span> (<span class="hljs-title">a</span>, <span class="hljs-title">b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a - b;<br>&#125;<br>add.bind(<span class="hljs-function"><span class="hljs-keyword">sub</span>, 5, 3)</span>; // 这时，并不会返回 <span class="hljs-number">8</span><br>add.bind(<span class="hljs-function"><span class="hljs-keyword">sub</span>, 5, 3)</span>(); // 调用后，返回 <span class="hljs-number">8</span><br><br></code></pre></td></tr></table></figure><p><a href="https://pengzhenglong.github.io/2021/05/14/Js&call&apply&bind/">博客：</a></p><h3 id="get-和-post-请求在缓存方面的区别"><a href="#get-和-post-请求在缓存方面的区别" class="headerlink" title="get 和 post 请求在缓存方面的区别"></a>get 和 post 请求在缓存方面的区别</h3><p>相关知识点：<br>get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。<br>post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 get 请求适合于请求缓存。</p><p>回答：<br>缓存一般只适用于那些不会更新服务端数据的请求。一般 get 请求都是查找请求，不会对服务器资源数据造成修改</p><h4 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h4><p>GET请求的数据会附加在URL之后，用问号分割，多个参数用&amp;进行连接。<br>GET请求的数据会暴露在地址栏中。<br>GET请求URL的编码格式采用的是ASCII编码，而不是Unicode编码。<br>GET请求传输大小有限制，大小在<strong>2KB。</strong><br>GET相对<strong>安全性较差，会被浏览器主动缓存。</strong><br>GET产生一个TCP数据包，head和data一起发送。<br>GET浏览器回退无害。</p><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>POST请求会把数据放置在HTTP请求包的包体中，不会直接暴露给用户。<br>POST请求，理论上大小是不会限制的，但是实际上各个服务器会规定POST提交数据大小。<br>POST相对Get更安全，因为参数不会保存浏览器立式或者是web服务器日志中。<br>POST产生两个TCP数据包，header先发送，服务器响应100ms然后继续，发送data，服务器200然后返回数据。<br>POST浏览器回退重新请求。<br>其他http方法</p><h3 id="setTimeout输出值的时候，如何实现i按序输出？"><a href="#setTimeout输出值的时候，如何实现i按序输出？" class="headerlink" title="setTimeout输出值的时候，如何实现i按序输出？"></a>setTimeout输出值的时候，如何实现i按序输出？</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br>//<span class="hljs-number">55555</span><br></code></pre></td></tr></table></figure><p>这道题挺经典的，输出结果是什么呢？结果是1000毫秒之后，输出5个5（隔一秒输出在1000上乘个i就行）<br><strong>原因是，for循环在主线程内，setTimeout是异步方法，在任务队列里面，只有主线程执行完后，任务队列才执行，此时i的值已经是5，所以得到结果是5个5</strong></p><p>那么怎么解决呢？其实思路很容易，只要每次循环把当前的i值传入setTimeout内即可</p><h4 id="方法1：使用let"><a href="#方法1：使用let" class="headerlink" title="方法1：使用let"></a>方法1：使用let</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br>//<span class="hljs-number">01234</span><br></code></pre></td></tr></table></figure><p>使用let 相当于每次循环的时候都新建了1个i并为其赋值</p><p>这是因为第一个代码块中setTimeout 的 console.log(i); 的i是 var 定义的，所以是函数级的作用域，不属于 for 循环体，属于 全局变量。等到 for 循环结束，i 已经等于 5 了，这个时候再执行 setTimeout 的五个回调函数（参考上面对事件机制的阐述），里面的 console.log(i); 的 i 去向上找作用域，只能找到 全局作用下 的 i，即 5。所以输出都是 5。</p><p>而let是代码块的作用域，即是局部变量，所以每一次 for 循环，console.log(i); 都引用到 for 代码块作用域下的i，因为这样被引用，所以 for 循环结束后，这些作用域在 setTimeout 未执行前都不会被释放。</p><h4 id="方法2：定义函数并传值"><a href="#方法2：定义函数并传值" class="headerlink" title="方法2：定义函数并传值"></a>方法2：定义函数并传值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params">i</span>) </span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(i)<br>        &#125;, <span class="hljs-number">1000</span>);        <br>    &#125;<br>    a(i)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法3：IIFE（立即执行函数）"><a href="#方法3：IIFE（立即执行函数）" class="headerlink" title="方法3：IIFE（立即执行函数）"></a>方法3：IIFE（立即执行函数）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    ~<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) </span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(i)<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;(i)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>MDN<br>IIFE（立即调用函数表达式）<br>IIFE（ 立即调用函数表达式）是一个在定义时就会立即执行的  JavaScript 函数。</p></blockquote><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name">function</span> () &#123;<br>    statements<br>&#125;)()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这是一个被称为 自执行匿名函数 的设计模式，主要包含两部分。第一部分是包围在 圆括号运算符 () 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。</p><p>第二部分再一次使用 () 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。</p><h4 id="方法4：使用闭包"><a href="#方法4：使用闭包" class="headerlink" title="方法4：使用闭包"></a>方法4：使用闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<br>        (<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span><br>            () =&gt; <span class="hljs-built_in">console</span>.log(i)<br>        )(i), <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法5：setTimeout第三个参数传入i-是的，你没看错，setTimeout还有第三个参数"><a href="#方法5：setTimeout第三个参数传入i-是的，你没看错，setTimeout还有第三个参数" class="headerlink" title="方法5：setTimeout第三个参数传入i(是的，你没看错，setTimeout还有第三个参数)"></a>方法5：setTimeout第三个参数传入i(是的，你没看错，setTimeout还有第三个参数)</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">for</span> (var i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">(i)</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(i),<span class="hljs-number">1000</span>,i);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="正确定义的匿名函数"><a href="#正确定义的匿名函数" class="headerlink" title="正确定义的匿名函数"></a>正确定义的匿名函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 由于没有执行该匿名函数，所以不会执行匿名函数体内的语句。</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;zxx&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="小括号的作用"><a href="#小括号的作用" class="headerlink" title="小括号的作用"></a>小括号的作用</h4><p>小括号能把我们的表达式组合分块，并且每一块，也就是每一对小括号，都有一个返回值。这个返回值实际上也就是小括号中表达式的返回值。所以，当我们用一对小括号把匿名函数括起来的时候，实际上小括号返回的就是一个匿名函数的Function对象。因此，小括号对加上匿名函数就如同有名字的函数般被我们取得它的引用位置了。所以如果在这个引用变量后面再加上参数列表，就会实现普通函数的调用形式。 通俗点讲就是，加入小括号后就实现了和具名函数一样的形式</p><p><a href="https://juejin.cn/post/6844903962257129485">详解JavaScript的匿名函数（面试重点）</a></p><h3 id="深拷贝和浅拷贝-赋值"><a href="#深拷贝和浅拷贝-赋值" class="headerlink" title="深拷贝和浅拷贝||赋值"></a>深拷贝和浅拷贝||赋值</h3><p>相关资料：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 浅拷贝的实现;</span><br><br><span class="hljs-keyword">function</span> shallow<span class="hljs-constructor">Copy(<span class="hljs-params">object</span>)</span> &#123;<br> <span class="hljs-comment">// 只拷贝对象</span><br> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">object</span><span class="hljs-operator"> || </span>typeof <span class="hljs-keyword">object</span> !== <span class="hljs-string">&quot;object&quot;</span>) return;<br><br> <span class="hljs-comment">// 根据 object 的类型判断是新建一个数组还是对象</span><br> <span class="hljs-keyword">let</span> newObject = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">object</span>)</span> ? <span class="hljs-literal">[]</span> : &#123;&#125;;<br><br> <span class="hljs-comment">// 遍历 object，并且判断是 object 的属性才拷贝</span><br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">object</span>) &#123;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">object</span>.has<span class="hljs-constructor">OwnProperty(<span class="hljs-params">key</span>)</span>) &#123;<br>      newObject<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> = <span class="hljs-keyword">object</span><span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span>;<br>    &#125;<br>  &#125;<br><br> return newObject;<br>&#125;<br><br><span class="hljs-comment">// 深拷贝的实现;</span><br><br><span class="hljs-keyword">function</span> deep<span class="hljs-constructor">Copy(<span class="hljs-params">object</span>)</span> &#123;<br> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">object</span><span class="hljs-operator"> || </span>typeof <span class="hljs-keyword">object</span> !== <span class="hljs-string">&quot;object&quot;</span>) return <span class="hljs-keyword">object</span>;<br><br> <span class="hljs-keyword">let</span> newObject = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">object</span>)</span> ? <span class="hljs-literal">[]</span> : &#123;&#125;;<br><br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">object</span>) &#123;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">object</span>.has<span class="hljs-constructor">OwnProperty(<span class="hljs-params">key</span>)</span>) &#123;<br>      newObject<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> = deep<span class="hljs-constructor">Copy(<span class="hljs-params">object</span>[<span class="hljs-params">key</span>])</span>;<br>    &#125;<br>  &#125;<br><br> return newObject;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>JS的基本类型不存在浅拷贝还是深拷贝的问题,深拷贝与浅拷贝的概念<strong>只存在于引用类型。</strong></li><li>对于仅仅是复制了引用（地址），换句话说，复制了之后，<strong>原来的变量和新的变量指向同一个东西，彼此之间的操作会互相影响，为 浅拷贝。而如果是在堆中重新分配内存，拥有不同的地址，但是值是一样的，复制后的对象与原来的对象是完全隔离，互不影响，为 深拷贝。</strong></li></ol><p>利用{…}（剩余运算符，不定参数）实现拷贝。注意这里是拷贝，先不区分是深还是浅</p><p><strong>如果是引用类型，且只有一层对象</strong>，则<strong>这一层就是深拷贝。拷贝前后，对象的基本类型互不影响</strong>，<br>如果是引用类型，<strong>且有两层以上嵌套对象，则这嵌套的，就是浅拷贝</strong>。嵌套的对象，拷贝的嵌套对象的引用。<strong>拷贝前后，嵌套对象数据相互影响，一层对象，互不影响</strong><br><a href="https://juejin.cn/post/6963515965791272967">掘金</a></p><ol><li>深浅拷贝 的主要区别就是：复制的是引用(地址)还是复制的是实例。</li></ol><p>浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用<strong>Object.assign 和展开运算符</strong>来实现。</p><p>深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。<br><a href="https://pengzhenglong.github.io/2021/04/17/javascript%20%E5%85%B3%E4%BA%8E%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/#%E4%BE%8B">博客：</a></p><h5 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h5><ol><li>Object.assign()</li><li>Array.prototype.concat()</li><li>Array.prototype.slice()</li><li>展开运算符…</li><li>函数库lodash的_.clone方法</li></ol><h5 id="深拷贝的实现方式"><a href="#深拷贝的实现方式" class="headerlink" title="深拷贝的实现方式"></a>深拷贝的实现方式</h5><ol><li>JSON.parse()</li><li>JSON.stringify()</li><li>函数库lodash的_.cloneDeep方法</li><li>jQuery.extend()方法</li><li>手写递归方法<br>参考<br><a href="https://juejin.cn/post/6844904197595332622#heading-3">掘金</a></li></ol><h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><ol><li>当我们把一个变量赋值给另一个变量时，是在<strong>栈内存中新增一个变量</strong>，并且赋值。<strong>二者互不影响</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> c = <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> d = c<br>d = <span class="hljs-number">2</span><br><span class="hljs-built_in">console</span>.log(c) <span class="hljs-comment">//c1</span><br><span class="hljs-built_in">console</span>.log(d) <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><ol start="2"><li>当我们把一个对象赋值给一个新的对象时,<strong>赋的是该对象在栈中的地址，而不是堆中的数据，也就是赋值之后，两个对象指向同一个存储空间。无论哪个对象发生改变，其实都是改变的堆中的数据(会互相影响，指向的引用地址都相同)</strong></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let a = &#123;<br><span class="hljs-type">name</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br><span class="hljs-keyword">like</span>: [<span class="hljs-string">&#x27;吃饭&#x27;</span>]<br>&#125;<br>let b = a<br><br>b.name = <span class="hljs-string">&#x27;b&#x27;</span><br>b.<span class="hljs-keyword">like</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;睡觉&#x27;</span><br>console.log(<span class="hljs-string">&#x27;a&#x27;</span>, a) //a &#123;<span class="hljs-type">name</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-keyword">like</span>: <span class="hljs-keyword">Array</span>(<span class="hljs-number">1</span>)&#125;<span class="hljs-keyword">like</span>: [<span class="hljs-string">&#x27;睡觉&#x27;</span>]<span class="hljs-type">name</span>: &quot;b&quot;<br>console.log(<span class="hljs-string">&#x27;b&#x27;</span>, b)//b  &#123;<span class="hljs-type">name</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-keyword">like</span>: <span class="hljs-keyword">Array</span>(<span class="hljs-number">1</span>)&#125;<span class="hljs-keyword">like</span>: [<span class="hljs-string">&#x27;睡觉&#x27;</span>]<span class="hljs-type">name</span>: &quot;b&quot;<br>打印的一样<br></code></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/6963515965791272967">掘金</a></p><h4 id="slice（不会改变原始数组）-和-concat（不会更改现有数组，而是返回一个新数组）"><a href="#slice（不会改变原始数组）-和-concat（不会更改现有数组，而是返回一个新数组）" class="headerlink" title="slice（不会改变原始数组） 和 concat（不会更改现有数组，而是返回一个新数组）"></a>slice（不会改变原始数组） 和 concat（不会更改现有数组，而是返回一个新数组）</h4><p>Array 的 slice 和 concat 方法 和 jQuery 中的 extend 复制方法，他们都会复制第一层的值，对于 第一层 的值都是 深拷贝，而到 第二层 的时候 Array 的 slice 和 concat 方法就是 复制引用 ，jQuery 中的 extend 复制方法 则 取决于 你的 第一个参数， 也就是是否进行递归复制。所谓第一层 就是 key 所对应的 value 值是基本数据类型，也就像上面栗子中的name、age，而对于 value 值是引用类型 则为第二层，也就像上面栗子中的 company。</p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="ES6-语法知道哪些，分别怎么用？"><a href="#ES6-语法知道哪些，分别怎么用？" class="headerlink" title="ES6 语法知道哪些，分别怎么用？"></a>ES6 语法知道哪些，分别怎么用？</h3><p>let const 块级作用域 箭头函数 词法this Class 解构，剩余运算符，Promise等，往这些方面展开。 不定参数…rest</p><h4 id="let与var对比-做项目中习惯用let声明变量"><a href="#let与var对比-做项目中习惯用let声明变量" class="headerlink" title="let与var对比(做项目中习惯用let声明变量)"></a>let与var对比(做项目中习惯用let声明变量)</h4><p>var声明的变量往往会越狱 (let 是在代码块内有效，var 是在全局范围内有效:)<br>let声明的变量有严格局部作用域<br>var可以声明多次，let只能声明一次<br>let 不存在变量提升var 会变量提升 （undefined）</p><h4 id="const声明变量-只读变量"><a href="#const声明变量-只读变量" class="headerlink" title="const声明变量 (只读变量)"></a>const声明变量 (只读变量)</h4><p>声明之后不允许改变<br><strong>一旦声明必须初始化，否者会报错</strong><br>const 如何做到变量在声明初始化之后不允许改变的？其实 const 其实保证的不是变量的值不变，<strong>而是保证变量指向的内存地址所保存的数据不允许改动</strong><br>解释：<br>对于简单类型的数据（数值、字符串、布尔值），<strong>值就保存在变量指向的那个内存地址，因此等同于常量</strong>。但对于<strong>复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针</strong>，const<strong>只能保证这个指针是固定的（即总是指向另一个固定的地址）</strong>，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p><h3 id="Set-Map-Reduce"><a href="#Set-Map-Reduce" class="headerlink" title="Set  Map  Reduce"></a>Set  Map  Reduce</h3><blockquote><p>Set类似于数组，但是它里面每一项的值是唯一的，没有重复的值，Set是一个构造函数，用来生成set的数据结构<br>Set中两个对象永远是不相等的，即使键和值都是一样的</p></blockquote><h4 id="Map的特点？Map类似于对象，也是键值对的集合"><a href="#Map的特点？Map类似于对象，也是键值对的集合" class="headerlink" title="Map的特点？Map类似于对象，也是键值对的集合"></a>Map的特点？Map类似于对象，也是键值对的集合</h4><p>方法(1. set2. get3. has4. delete5. clear)<br>6. Map默认情况下不包含任何键，所有键都是开发人员添加进去的。不像Object原型链上有一些默认的键。<br>7. Map的键可以是<strong>任意类型数据，就连函数都可以</strong>。Object的键<strong>只能是String或Symbol。</strong><br>8. Map的键值<strong>对个数可以轻易通过size属性获取，Object需要手动计算。</strong><br>9. Map在<strong>频繁增删键值对</strong>的场景下性能要比Object好。</p><h4 id="什么时候用Map？"><a href="#什么时候用Map？" class="headerlink" title="什么时候用Map？"></a>什么时候用Map？</h4><p>要<strong>添加的键值名和Object上的默认键值名冲突，又不想改名时，</strong>可以换用Map。 JS对象自己的对象属性可能会与从原型继承的属性键冲突（例如 toString，constructor等）。<br>需要<strong>String和Symbol以外的数据类型</strong>做键值时，用Map。<br><strong>键值对很多，有需要计算数量时，用Map。</strong><br>需要<strong>频繁增删键值对</strong>时，用Map。</p><p><strong>Map()和map是不一样的</strong></p><blockquote><p>reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。<br><a href="https://pengzhenglong.github.io/2021/04/14/Map&&Set&&Weakmap&&Weakset/">博客：</a></p></blockquote><p><img src="/imageO/Reduce.jpg" alt="Reduce"></p><h3 id="Map-和-WeakMap-的区别"><a href="#Map-和-WeakMap-的区别" class="headerlink" title="Map 和 WeakMap 的区别"></a>Map 和 WeakMap 的区别</h3><p>1.Map <strong>的键可以是任意类型，WeakMap  只接受对象作为键（null除外），不接受其他类型的值作为键</strong></p><ol><li>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键； WeakMap 的键是<strong>弱引用，键所指向的对象可以被垃圾回收，此时键是无效的</strong></li><li><strong>Map 可以被遍历， WeakMap 不能被遍历</strong></li></ol><h4 id="WeakMap的使用场景（Map-和-Weakmap-之间的主要区别是，Weakmap-允许对键对象进行垃圾收集，从而防止内存泄漏。）"><a href="#WeakMap的使用场景（Map-和-Weakmap-之间的主要区别是，Weakmap-允许对键对象进行垃圾收集，从而防止内存泄漏。）" class="headerlink" title="WeakMap的使用场景（Map 和 Weakmap 之间的主要区别是，Weakmap 允许对键对象进行垃圾收集，从而防止内存泄漏。）"></a>WeakMap的使用场景（Map 和 Weakmap 之间的主要区别是，Weakmap 允许对键对象进行垃圾收集，从而防止内存泄漏。）</h4><ol><li>DOM 节点元数据<br>因为 weakMap 不会影响垃圾回收，所以可以用来<strong>关联元数据</strong></li><li>部署私有属性<br>利用弱映射，<strong>将内部属性设置为实例的弱引用对象，当实例删除时，私有属性也会随之消失</strong>，因此不会内存泄漏</li><li>数据缓存<br>当我们<strong>需要在不修改原有对象的情况下储存某些属性等，而又不想管理这些数据时</strong>，可以使用WeakMap<br><a href="https://pengzhenglong.github.io/2021/04/14/Map&&Set&&Weakmap&&Weakset/#%E4%BA%94%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-WeakMap-%EF%BC%9F">博客</a><br><a href="https://juejin.cn/post/6993101968545677319#heading-18">浅析 Map 和 WeakMap 区别以及使用场景</a></li></ol><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>模块化就是把代码进行拆分，方便重复利用，类似java中的导包，需要使用一个包，必须先导包，而js中没有包的概念，换来的是模块<br>ES6 的模块化分为导出（export） @与导入（import）两个模块。</p><h4 id="模块化优点"><a href="#模块化优点" class="headerlink" title="模块化优点"></a>模块化优点</h4><p>避免命名冲突（减少命名空间污染）更好的分类，按需加载,更高的复用性,高可维护性</p><h3 id="CommomJS-node应用由模块组成"><a href="#CommomJS-node应用由模块组成" class="headerlink" title="CommomJS(node应用由模块组成)"></a>CommomJS(node应用由模块组成)</h3><p>CommonJS定义了两个主要概念：<br>require函数，用于导入模块<br>module.exports变量，用于导出模块<br>require导入，代码很简单，let {count,addCount}=require(“./utils”)就可以了。<br>require的第一步是解析路径获取到模块内容：</p><h3 id="ES6模块与CommonJS的区别"><a href="#ES6模块与CommonJS的区别" class="headerlink" title="ES6模块与CommonJS的区别"></a>ES6模块与CommonJS的区别</h3><h4 id="CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用"><a href="#CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用" class="headerlink" title="CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用"></a>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</h4><ol><li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li><li>ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。</li><li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，<strong>遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值</strong>。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li></ol><h4 id="CommonJS-模块是运行时加载，ES6-模块是编译时输出接口"><a href="#CommonJS-模块是运行时加载，ES6-模块是编译时输出接口" class="headerlink" title="CommonJS 模块是运行时加载，ES6 模块是编译时输出接口"></a>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</h4><ol><li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li><li>编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li></ol><h4 id="CommonJs导出有有缓存，而ES6没有"><a href="#CommonJs导出有有缓存，而ES6没有" class="headerlink" title="CommonJs导出有有缓存，而ES6没有"></a>CommonJs导出有有缓存，而ES6没有</h4><p><a href="https://pengzhenglong.github.io/2022/03/01/CommonJS%E5%92%8CES6%E6%A8%A1%E5%9D%97/">博客</a></p><p><a href="https://pengzhenglong.github.io/2021/04/17/ES6%E6%A8%A1%E5%9D%97%E5%8C%96/">博客：</a></p><h3 id="ECMAScript6-怎么写-class，为什么会出现-class-这种东西"><a href="#ECMAScript6-怎么写-class，为什么会出现-class-这种东西" class="headerlink" title="ECMAScript6 怎么写 class，为什么会出现 class 这种东西?"></a>ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</h3><p>在我看来 ES6 新添加的 class 只是为了补充 js 中缺少的一些<strong>面向对象语言的特性</strong>，但本质上来说它只是一种<strong>语法糖，不是一个新的东西，其背后还是原型继承的思想</strong>。通过加入 class 可以有利于我们更好的组织代码。在 class 中添加的方法，其实是添加在类的原型上的。</p><h2 id="数组-amp-amp-对象-方法（基础）"><a href="#数组-amp-amp-对象-方法（基础）" class="headerlink" title="数组&amp;&amp;对象 方法（基础）"></a>数组&amp;&amp;对象 方法（基础）</h2><h3 id="数组去重-indexOf-set-map-for-Object键值对"><a href="#数组去重-indexOf-set-map-for-Object键值对" class="headerlink" title="数组去重 (indexOf  set  map  for  Object键值对)"></a>数组去重 (indexOf  set  map  for  Object键值对)</h3><p>法一：indexOf循环去重<br>法二：ES6 Set去重；Array.from(new Set(array))<br>法三：Object 键值对去重；把数组的值存成 Object 的 key 值，比如 Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的。<br><a href="https://juejin.cn/post/6844904121380667399#heading-65">掘金</a></p><h3 id="数组常用方法-一般方法"><a href="#数组常用方法-一般方法" class="headerlink" title="数组常用方法(一般方法)"></a>数组常用方法(一般方法)</h3><p>push()，pop()，shift()，unshift()，splice()，sort()，reverse()，map()等</p><h4 id="会改变原始数组的方法有"><a href="#会改变原始数组的方法有" class="headerlink" title="会改变原始数组的方法有"></a>会改变原始数组的方法有</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">push</span><span class="hljs-params">()</span></span>  压入到尾部        pop:  弹出尾部的一个元素<br>unshift  压入到头部           shift    弹出头部的一个元素<br><span class="hljs-function"><span class="hljs-title">sort</span><span class="hljs-params">()</span></span>  方法用于对数组的元素进行排序。 排序顺序可以是字母或数字，并按升序或降序。默认排序顺序为按字母升序。<br><span class="hljs-function"><span class="hljs-title">reverse</span><span class="hljs-params">()</span></span>   方法用于颠倒数组中元素的顺序。<br><span class="hljs-function"><span class="hljs-title">splice</span><span class="hljs-params">()</span></span>    方法用于添加或删除数组中的元素。注意：这种方法会改变原始数组。<br><br></code></pre></td></tr></table></figure><h4 id="不改变原始数组的方法有"><a href="#不改变原始数组的方法有" class="headerlink" title="不改变原始数组的方法有"></a>不改变原始数组的方法有</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">filter</span>()   返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组<br>concat()   方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。<br><span class="hljs-keyword">slice</span>() 截取<span class="hljs-keyword">Array</span>的一部分，返回一个新数组，类似于String中的substring  [)<br>map()   <span class="hljs-keyword">forEach</span>()   (数据为基本类型,改变其值（不会改变）)(数据为引用类型,改变其属性方法的值（会改变）)<br>every、<span class="hljs-keyword">some</span>、<span class="hljs-keyword">filter</span>、reduce ES6新增的方法entries、find、findIndex、keys、<span class="hljs-keyword">values</span><br></code></pre></td></tr></table></figure><h3 id="数组和对象方法（进阶）"><a href="#数组和对象方法（进阶）" class="headerlink" title="数组和对象方法（进阶）"></a>数组和对象方法（进阶）</h3><p>indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。如果没有找到匹配的字符串则返回 -1。<br>find(返回数组中满足条件的第一个元素的值，如果没有，返回undefined)<br>array.findeIndex(callback[,thisArg]) 返回数组中满足条件的第一个元素的下标，如果没有找到，返回**-1**</p><ol><li><p>数组常用的方法  find  filter  every  some</p></li><li><p>判断一个数组中有符合我需求的元素用哪个比较合适–indexof    find</p></li><li><p><strong>如果要返回一个布尔值—   includes  some every</strong></p></li></ol><h3 id="js字符串数组互转"><a href="#js字符串数组互转" class="headerlink" title="js字符串数组互转"></a>js字符串数组互转</h3><h4 id="字符串转数组"><a href="#字符串转数组" class="headerlink" title="字符串转数组"></a>字符串转数组</h4><ol><li>split() 方法  将字符串转换成一个数组</li><li>扩展运算符[…]  es6里面的扩展运算符</li><li>Array.from()方法  es6 Array.from()方法</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">split() 方法 <br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;abc&quot;</span>.split(<span class="hljs-string">&#x27;&#x27;</span>)); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>] <br><br>扩展运算符[...] <br><span class="hljs-built_in">console</span>.log([...<span class="hljs-string">&quot;abc&quot;</span>]); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br><br> <span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>()方法<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>(<span class="hljs-string">&quot;abc&quot;</span>)); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br></code></pre></td></tr></table></figure><h4 id="数组转字符串"><a href="#数组转字符串" class="headerlink" title="数组转字符串"></a>数组转字符串</h4><p>toString()方法 将数组转换成一个字符串<br>toLocaleString()方法 把数组转换成本地约定的字符串<br>join()方法 将数组元素连接起来以构建一个字符串</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf">console.<span class="hljs-built_in">log</span>([<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>].<span class="hljs-built_in">join</span>(<span class="hljs-string">&#x27;;&#x27;</span>)); <span class="hljs-comment">// a;b;c </span><br>console.<span class="hljs-built_in">log</span>([<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>].<span class="hljs-built_in">toString</span>()); <span class="hljs-comment">// a;b;c </span><br>console.<span class="hljs-built_in">log</span>([<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>].toLocaleString()); <span class="hljs-comment">// a;b;c </span><br></code></pre></td></tr></table></figure><h3 id="JS如何实现数组扁平化？"><a href="#JS如何实现数组扁平化？" class="headerlink" title="JS如何实现数组扁平化？"></a>JS如何实现数组扁平化？</h3><ol><li>ES6的flat</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ary = arr<span class="hljs-selector-class">.flat</span>(Infinity)<br>console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-attr">[1, [2, 3, [4, 5]</span>]]<span class="hljs-selector-class">.flat</span>(Infinity))<br></code></pre></td></tr></table></figure><ol start="2"><li>正则处理</li><li>递归</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-keyword">let</span> arr = <span class="hljs-literal">[<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]</span>]];<br><br> <span class="hljs-keyword">function</span> flattern(arr,result =<span class="hljs-literal">[]</span>) &#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">arr</span>[<span class="hljs-params">i</span>])</span>) &#123;<br>                flattern(arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, result)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result.push(arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)<br>            &#125;<br>        &#125;<br>        return result;<br>    &#125;<br>console.log(flattern(arr));<br></code></pre></td></tr></table></figure><ol start="4"><li>reduce</li><li>toString</li></ol><p><a href="https://pengzhenglong.github.io/2022/02/28/Js%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/">博客地址</a></p><h3 id="JS求数组的交集、并集、差集"><a href="#JS求数组的交集、并集、差集" class="headerlink" title="JS求数组的交集、并集、差集"></a>JS求数组的交集、并集、差集</h3><p>现有两个数组</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span> = [<span class="hljs-number">101</span>,<span class="hljs-number">201</span>,<span class="hljs-number">601</span>]<br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span> = [<span class="hljs-number">201</span>,<span class="hljs-number">301</span>,<span class="hljs-number">801</span>]<br></code></pre></td></tr></table></figure><h4 id="求交集（交集元素由既属于集合a又属于集合b的元素组成）"><a href="#求交集（交集元素由既属于集合a又属于集合b的元素组成）" class="headerlink" title="求交集（交集元素由既属于集合a又属于集合b的元素组成）"></a>求交集（交集元素由既属于集合a又属于集合b的元素组成）</h4><ol><li>方法1  filter  includes()</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let intersection = <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.filter</span>(v =&gt; <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.includes</span>(v)) <span class="hljs-comment">// [201]</span><br></code></pre></td></tr></table></figure><ol start="2"><li>方法2  filter  indexOf()</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> intersection = a.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>&#123; <span class="hljs-keyword">return</span> b.indexOf(v) &gt; -<span class="hljs-number">1</span> &#125;) <span class="hljs-comment">//[201]</span><br></code></pre></td></tr></table></figure><ol start="3"><li>方法3  filter Set() set.has</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> intersection = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>from(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Set(<span class="hljs-params">a</span>.<span class="hljs-params">filter</span>(<span class="hljs-params">v</span>=&gt; <span class="hljs-params">new</span> Set(<span class="hljs-params">b</span>)</span>.has(v))))  <span class="hljs-comment">//[201]</span><br><br></code></pre></td></tr></table></figure><ol start="4"><li>方法4  </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> intersection = a.filter(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(b).has(v))  <span class="hljs-comment">// [201]</span><br></code></pre></td></tr></table></figure><h4 id="2-求并集-并集元素由集合a和集合b中所有元素去重组成"><a href="#2-求并集-并集元素由集合a和集合b中所有元素去重组成" class="headerlink" title="2.求并集 (并集元素由集合a和集合b中所有元素去重组成)"></a>2.求并集 (并集元素由集合a和集合b中所有元素去重组成)</h4><ol><li>方法1  filter  includes()</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let union = <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.concat</span>(<span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.filter</span>(v=&gt; &#123;<br>   return !<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.includes</span>(v)<br> &#125;<br>)) <span class="hljs-comment">// [101, 201, 601, 301, 801]</span><br></code></pre></td></tr></table></figure><ol start="2"><li>方法2  Array.from()  Set()  concat() (最简单)</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> union = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>from(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Set(<span class="hljs-params">a</span>.<span class="hljs-params">concat</span>(<span class="hljs-params">b</span>)</span>)) <span class="hljs-comment">// [101, 201, 601, 301, 801]</span><br></code></pre></td></tr></table></figure><ol start="3"><li>方法3    concat()  filter()  indexOf()</li></ol><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">let <span class="hljs-built_in">union</span> = <span class="hljs-keyword">a</span>.concat(b.<span class="hljs-built_in">filter</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-title">v</span>) &#123;</span><br>    <span class="hljs-literal">return</span> <span class="hljs-keyword">a</span>.indexOf(v) === <span class="hljs-number">-1</span><br>&#125;))<span class="hljs-comment"> // [101, 201, 601, 301, 801]</span><br></code></pre></td></tr></table></figure><p><a href="https://pengzhenglong.github.io/2022/02/28/Js%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/">博客地址</a></p><h4 id="对象常用的方法–遍历一个对象-for-in-Object-keys-Object-values-Object-entries"><a href="#对象常用的方法–遍历一个对象-for-in-Object-keys-Object-values-Object-entries" class="headerlink" title="对象常用的方法–遍历一个对象  for in   Object.keys  Object.values  Object.entries"></a>对象常用的方法–遍历一个对象  for in   Object.keys  Object.values  Object.entries</h4><p>工作中遍历对象都用for  in 嘛，遍历用的比较多的方法是(有用过forEach嘛)</p><h5 id="ES6-Object新增的Api"><a href="#ES6-Object新增的Api" class="headerlink" title="ES6 Object新增的Api"></a>ES6 Object新增的Api</h5><p>-keys(obj)，获取对象的所有key形成的数组<br>-values(obj),获取对象的所有value形成的数组<br>-entries(obj)，获取对象的所有key和value形成的二维数组<br>Object.assign(dest, ···src) ,将多个src对象的值拷贝到dest中(第一层为深拷贝，第二层为浅拷贝)<br>Object.is()<br>__proto__属性<br>对象拓展运算符 (…)第一层为深拷贝，第二层为浅拷贝<br><a href="https://pengzhenglong.github.io/2021/04/13/ES6(%E5%9B%9B)/">博客</a></p><h3 id="for-in和for-of-区别"><a href="#for-in和for-of-区别" class="headerlink" title="for in和for of 区别"></a>for in和for of 区别</h3><h4 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h4><p>我们直接从一段代码来看</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-built_in">Array</span>.prototype.method=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.length);<br>&#125;<br><span class="hljs-keyword">var</span> myArray=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>myArray.name=<span class="hljs-string">&quot;数组&quot;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> index <span class="hljs-keyword">in</span> myArray) &#123;<br>  <span class="hljs-built_in">console</span>.log(myArray[index]);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>有哪些缺陷呢👇<br>index获取的是索引<br>遍历的顺序可能不是按照顺序进行的<br>使用for in 会遍历数组所有可枚举属性，包括原型。例如上面的method和name都会遍历</p><blockquote><p>for in 更适合遍历对象，不要使用for in去遍历数组</p></blockquote><h4 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-built_in">Array</span>.prototype.method=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.length);<br>&#125;<br><span class="hljs-keyword">var</span> myArray=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>myArray.name=<span class="hljs-string">&quot;数组&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> value <span class="hljs-keyword">of</span> myArray) &#123;<br>  <span class="hljs-built_in">console</span>.log(value);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>for of语法遍历的是数组元素的值<br>for in 遍历的是索引</p><blockquote><p>for of遍历的只是数组内的元素(value)，而不包括数组的原型属性method和索引name</p></blockquote><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li><p>for in 可以遍历一个普通的对象，这样也是它的本质工作，for in<strong>会遍历原型以及可枚举属性</strong>，最好的情况下，使用hasOwnProperty判断是不是实例属性。</p></li><li><p>for..of<strong>适用遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合，不能遍历对象</strong>，因为没有迭代对象，与forEach()不同的是，它可以正确响应break、continue和return语句。</p></li></ol><h4 id="如何使用for-of-循环遍历对象-给对象添加迭代器"><a href="#如何使用for-of-循环遍历对象-给对象添加迭代器" class="headerlink" title="如何使用for of 循环遍历对象(给对象添加迭代器)"></a>如何使用for of 循环遍历对象(给对象添加迭代器)</h4><ol><li>类数组对象<br>如果对象是一个类数组对象，那好办，用Array.from转成数组即可。</li><li>非类数组对象<br>如果不是类数组对象，也有办法，添加一个[Symbol.iterator]属性，并指向一个迭代器即可。</li></ol><p><strong>Object.keys/Object.values/Object.entries</strong></p><h4 id="任何数据结构只要部署-Iterator-接口，就可以完成遍历操作，即依次处理该数据结构的所有成员"><a href="#任何数据结构只要部署-Iterator-接口，就可以完成遍历操作，即依次处理该数据结构的所有成员" class="headerlink" title="任何数据结构只要部署 Iterator 接口，就可以完成遍历操作，即依次处理该数据结构的所有成员"></a>任何数据结构只要部署 Iterator 接口，就可以完成遍历操作，即依次处理该数据结构的所有成员</h4><p>迭代器对象本质上，就是一个指针对象。通过指针对象的next()，用来移动指针。</p><p>【迭代器协议】对象必须提供一个next()，执行该方法要么返回迭代中的下一项，要么就引起一个Stopiteration异常，以终止迭代。</p><p>next()返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性，value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next()。对于遍历器对象来说，done: false和value: undefined属性都是可以省略的。</p><p>ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性上。</p><h5 id="如何判断一个类型是不是可迭代对象"><a href="#如何判断一个类型是不是可迭代对象" class="headerlink" title="如何判断一个类型是不是可迭代对象"></a>如何判断一个类型是不是可迭代对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">let</span> someString = <span class="hljs-string">&quot;hi&quot;</span>;<br><span class="hljs-keyword">typeof</span> someString[<span class="hljs-built_in">Symbol</span>.iterator];          <span class="hljs-comment">// &quot;function&quot;</span><br><br></code></pre></td></tr></table></figure><p>常见的可迭代对象，有Array，Map, Set, String,TypeArray, arguments<br>可以通过判断Symbol.iterator判断当前变量是否是可迭代对象</p><h3 id="forEach（数组方法）首先forEach是不能使用任何手段跳出循环的"><a href="#forEach（数组方法）首先forEach是不能使用任何手段跳出循环的" class="headerlink" title="forEach（数组方法）首先forEach是不能使用任何手段跳出循环的"></a>forEach（数组方法）首先forEach是不能使用任何手段跳出循环的</h3><p>特性：</p><p>便利的时候更加简洁，效率和for循环相同，不用关心集合下标的问题，减少了出错的概率。<br>没有返回值<br>不能使用break中断循环，不能使用return返回到外层函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>实例：<br><span class="hljs-keyword">let</span> newarr=arr.forEach(<span class="hljs-function"><span class="hljs-params">i</span>=&gt;</span>&#123;<br> i+=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">console</span>.log(i);<span class="hljs-comment">//2,4,5</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(arr)<span class="hljs-comment">//[1,3,4]</span><br><span class="hljs-built_in">console</span>.log(newarr)<span class="hljs-comment">//undefined</span><br><br></code></pre></td></tr></table></figure><p>注意：</p><ol><li>forEach() 对于空数组是不会执行回调函数的。</li><li>for可以用continue跳过循环中的一个迭代，forEach用continue会报错。</li><li>forEach() 需要用 return 跳过循环中的一个迭代，跳过之后会执行下一个迭代。</li></ol><h3 id="forEach-map-ES5-的区别"><a href="#forEach-map-ES5-的区别" class="headerlink" title="forEach map(ES5)的区别"></a>forEach map(ES5)的区别</h3><p>能用forEach()做到的，map()同样可以。反过来也是如此<br>map()会<strong>分配内存空间存储新数组并返回，forEach()不会返回数据。</strong><br>forEach()<strong>允许callback更改原始数组的元素</strong>。map()<strong>返回新的数组</strong>。 map() <strong>不会改变原始数组</strong>。<br>map()   forEach()   <strong>(数据为基本类型,改变其值（不会改变）)(数据为引用类型,改变其属性方法的值（会改变）)</strong><br>map() <strong>可以利用 return</strong> 语句来返回值，该值将被放入新数组中。forEach() 方法<strong>不能</strong>使用 return 语句返回值。</p><h4 id="map和forEach是按-（value-key）的方式遍历的"><a href="#map和forEach是按-（value-key）的方式遍历的" class="headerlink" title="map和forEach是按 （value,key）的方式遍历的"></a>map和forEach是按 （value,key）的方式遍历的</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">const  arr = [1,2,3]</span><br><span class="xml">arr.forEach((value,index)=&gt;</span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">console.log(value,index)</span><br><span class="hljs-template-variable">&#125;</span><span class="xml">)</span><br><span class="xml">arr.map((value,key)=&gt;</span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    console.log(value,key)</span><br><span class="hljs-template-variable">&#125;</span><span class="xml">)</span><br><span class="xml"><span class="hljs-comment">&lt;!-- 两个打印的结果为 --&gt;</span></span><br><span class="xml">1 0</span><br><span class="xml">2 1</span><br><span class="xml">3 2</span><br></code></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">mdn –forEach </a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">mdn–map</a><br><a href="https://juejin.cn/post/7034350835668615199#heading-2">js学习-forEach和map是否改变原数组？</a></p><h2 id="基础-（已掌握）"><a href="#基础-（已掌握）" class="headerlink" title="基础 （已掌握）"></a>基础 （已掌握）</h2><h3 id="js种8种数据类型"><a href="#js种8种数据类型" class="headerlink" title="js种8种数据类型"></a>js种8种数据类型</h3><h4 id="六种基本数据类型：undefined-null-number-bollean-string"><a href="#六种基本数据类型：undefined-null-number-bollean-string" class="headerlink" title="六种基本数据类型：undefined,null,number,bollean, string"></a>六种基本数据类型：undefined,null,number,bollean, string</h4><p>还有在 ES6 中新增的 Symbol 和 ES10 中新增的 BigInt 类型。</p><blockquote><p>Symbol 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。<br>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</p></blockquote><h4 id="另一种是复杂数据类型：Object"><a href="#另一种是复杂数据类型：Object" class="headerlink" title="另一种是复杂数据类型：Object"></a>另一种是复杂数据类型：Object</h4><p>js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。<br>复杂数据类型指的是 Object 类型，所有其他的如 <strong>又称为引用类型，包括 Array  Date  function</strong> 等数据类型都可以理解为 Object 类型的子类。</p><h4 id="两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值"><a href="#两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值" class="headerlink" title="两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值"></a>两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值</h4><h3 id="js判断类型"><a href="#js判断类型" class="headerlink" title="js判断类型"></a>js判断类型</h3><p>判断方法：<strong>typeof()，instanceof，constructor,Object.prototype.toString.call()等</strong></p><h4 id="1-typeof-其中数组、对象、null都会被判断为Object，其他判断都正确"><a href="#1-typeof-其中数组、对象、null都会被判断为Object，其他判断都正确" class="headerlink" title="1. typeof   其中数组、对象、null都会被判断为Object，其他判断都正确"></a>1. typeof   其中数组、对象、null都会被判断为Object，其他判断都正确</h4><p>返回数据类型，包含这7种： number、boolean、symbol、string、object、undefined、function。typeof null   返回类型错误，返回object ,引用类型，除了function返回function类型外，其他均返回object。其中，null 有属于自己的数据类型 Null</p><h4 id="2-instanceof-只能判断引用数据类型-不能判断基本数据类型"><a href="#2-instanceof-只能判断引用数据类型-不能判断基本数据类型" class="headerlink" title="2. instanceof 只能判断引用数据类型,不能判断基本数据类型"></a>2. instanceof 只能判断引用数据类型,不能判断基本数据类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">　　<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>];<br>　　<span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型，<br><img src="/imageO/instance.jpg" alt="instance"><br> 由上图可以看出[]的原型指向Array.prototype，间接指向Object.prototype, 因此 [] instanceof Array 返回true， [] instanceof Object 也返回true。<br>instanceof <strong>只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</strong></p><h4 id="3-constructor-2个作用-一是判断数据的类型，二是对象实例通过constructor对象访问它的构造函数。需要注意的事情是如果创建一个对象来改变它的原型-constructor就不能来判断数据类型了"><a href="#3-constructor-2个作用-一是判断数据的类型，二是对象实例通过constructor对象访问它的构造函数。需要注意的事情是如果创建一个对象来改变它的原型-constructor就不能来判断数据类型了" class="headerlink" title="3. constructor(2个作用 一是判断数据的类型，二是对象实例通过constructor对象访问它的构造函数。需要注意的事情是如果创建一个对象来改变它的原型,constructor就不能来判断数据类型了)"></a>3. constructor(2个作用 一是判断数据的类型，二是对象实例通过constructor对象访问它的构造函数。需要注意的事情是如果创建一个对象来改变它的原型,constructor就不能来判断数据类型了)</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><br>　　<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>];<br>　　console.log(arr.<span class="hljs-keyword">constructor</span> === <span class="hljs-keyword">Array</span>)<span class="hljs-comment">//true</span><br><br></code></pre></td></tr></table></figure><p>constructor是原型prototype的一个属性，当函数被定义时候，js引擎会为函数添加原型prototype，并且这个prototype中constructor属性指向函数引用， 因此重写prototype会丢失原来的constructor。<br>不过这种方法有问题：<br>1：<strong>null 和 undefined 无constructor，这种方法判断不了</strong>。<br>2：还有，如果自定义对象，开发者重写prototype之后，原有的constructor会丢失，因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改。</p><h4 id="4-toString-这个是最完美的"><a href="#4-toString-这个是最完美的" class="headerlink" title="4. toString 这个是最完美的"></a>4. toString 这个是最完美的</h4><p>toString() 是 Object 的原型方法，调用该方法，<strong>默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。</strong><br>对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。<strong>而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</strong></p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>在toString方法被调用时,会执行下面的操作步骤:</p><ol><li><p>获取this对象的[[Class]]属性的值.</p></li><li><p>计算出三个字符串”[object “, 第一步的操作结果Result(1), 以及 “]”连接后的新字符串.</p></li><li><p>返回第二步的操作结果Result(2).<br>判断类型举例：</p></li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;&#x27;</span>) ;   // [<span class="hljs-keyword">object</span> String]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-number">1</span>) ;    // [<span class="hljs-keyword">object</span> Number]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">true</span>) ; // [<span class="hljs-keyword">object</span> <span class="hljs-type">Boolean</span>]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(Symbol()); //[<span class="hljs-keyword">object</span> Symbol]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(undefined) ; // [<span class="hljs-keyword">object</span> Undefined]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">null</span>) ; // [<span class="hljs-keyword">object</span> <span class="hljs-keyword">Null</span>]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> <span class="hljs-keyword">Function</span>()) ; // [<span class="hljs-keyword">object</span> <span class="hljs-keyword">Function</span>]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>()) ; // [<span class="hljs-keyword">object</span> <span class="hljs-type">Date</span>]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>([]) ; // [<span class="hljs-keyword">object</span> <span class="hljs-keyword">Array</span>]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> RegExp()) ; // [<span class="hljs-keyword">object</span> RegExp]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> Error()) ; // [<span class="hljs-keyword">object</span> Error]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(document) ; // [<span class="hljs-keyword">object</span> HTMLDocument]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">window</span>) ; //[<span class="hljs-keyword">object</span> <span class="hljs-keyword">global</span>] <span class="hljs-keyword">window</span> 是全局对象 <span class="hljs-keyword">global</span> 的引用<br></code></pre></td></tr></table></figure><h3 id="如何判断一个对象是数组还是对象"><a href="#如何判断一个对象是数组还是对象" class="headerlink" title="如何判断一个对象是数组还是对象"></a>如何判断一个对象是数组还是对象</h3><p>一、typeof判断数据类型（判断数组跟对象都返回object）<br>二、instanceof判断对象的原型链是否是指向构造函数的prototype</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">　　<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>];<br>　　<span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>三、对象的constructor属性</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">　　<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>];<br>　　console.log(arr.<span class="hljs-keyword">constructor</span> === <span class="hljs-keyword">Array</span>)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>四、Object.prototype.toString.call(arr)<br>　　利用对象的toString可以准确判断是什么类型，call()改变this指向，这里是借用Object的方法，然后有人可能会问为什么不直接用arr.toString而要借用Object的方法，</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(&quot;jerry&quot;));//[<span class="hljs-keyword">object</span> String]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-number">12</span>));//[<span class="hljs-keyword">object</span> Number]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">true</span>));//[<span class="hljs-keyword">object</span> <span class="hljs-type">Boolean</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(undefined));//[<span class="hljs-keyword">object</span> Undefined]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">null</span>));//[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Null</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(&#123;<span class="hljs-type">name</span>: &quot;jerry&quot;&#125;));//[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Object</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">function</span>()&#123;&#125;));//[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Function</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>([]));//[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Array</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>));//[<span class="hljs-keyword">object</span> <span class="hljs-type">Date</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(/\d/));//[<span class="hljs-keyword">object</span> RegExp]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> Person));//[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Object</span>]<br></code></pre></td></tr></table></figure><p>直接用tostring()</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">console.log(<span class="hljs-string">&quot;jerry&quot;</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//jerry</span><br>console.log((<span class="hljs-number">1</span>).<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//1</span><br>console.log(<span class="hljs-literal">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//1,2</span><br>console.log(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//Wed Dec 21 2016 20:35:48 GMT+0800 (中国标准时间)</span><br>console.log(<span class="hljs-keyword">function</span><span class="hljs-literal">()</span>&#123;&#125;.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//function ()&#123;&#125;</span><br>console.log(null.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//error</span><br>console.log(undefined.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure><h4 id="因为toString为Object原型上的方法，而Array、Function都是Object的实例，实例重新改写了原型上的toString方法，不同的对象调用toString方法，调用的是改写之后的方法"><a href="#因为toString为Object原型上的方法，而Array、Function都是Object的实例，实例重新改写了原型上的toString方法，不同的对象调用toString方法，调用的是改写之后的方法" class="headerlink" title="因为toString为Object原型上的方法，而Array、Function都是Object的实例，实例重新改写了原型上的toString方法，不同的对象调用toString方法，调用的是改写之后的方法"></a>因为toString为Object原型上的方法，而Array、Function都是Object的实例，实例重新改写了原型上的toString方法，不同的对象调用toString方法，调用的是改写之后的方法</h4><p>（转成各种类型的字符串），而不会调用Object原型上的toString()方法，因此直接调用不能判断对象类型</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var arr=<span class="hljs-literal">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]</span>;<br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>prototype.has<span class="hljs-constructor">OwnProperty(<span class="hljs-string">&quot;toString&quot;</span>)</span>);<span class="hljs-comment">//true</span><br>console.log(arr.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//1,2,3</span><br>delete <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>prototype.toString;<span class="hljs-comment">//delete操作符可以删除实例属性</span><br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>prototype.has<span class="hljs-constructor">OwnProperty(<span class="hljs-string">&quot;toString&quot;</span>)</span>);<span class="hljs-comment">//false</span><br>console.log(arr.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//&quot;[object Array]&quot;</span><br></code></pre></td></tr></table></figure><p>　我们可以看到，删除实例上的toString方法后调用的是Object原型上的toString()方法，返回对象类型</p><p>五、es6的方法——Array.isArray()</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">　　<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array([])</span> <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>六、看好多博客说用length判断，这个其实不准确</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> obj=&#123;<span class="hljs-selector-tag">a</span>:<span class="hljs-number">1</span>&#125;<br><span class="hljs-selector-tag">var</span> arr = <span class="hljs-selector-attr">[]</span><br>console<span class="hljs-selector-class">.log</span>(obj.length)<span class="hljs-comment">//undefined</span><br>console<span class="hljs-selector-class">.log</span>(arr.length)<span class="hljs-comment">//0</span><br><br>obj<span class="hljs-selector-class">.length</span> = <span class="hljs-number">1</span><br>console<span class="hljs-selector-class">.log</span>(obj.length)<span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><p>对象可以直接添加length这个属性，就无法区分了</p><h3 id="暂停死区"><a href="#暂停死区" class="headerlink" title="暂停死区"></a>暂停死区</h3><p>在代码块内，使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”</p><h2 id="较陌生不常问-需掌握"><a href="#较陌生不常问-需掌握" class="headerlink" title="较陌生不常问(需掌握)"></a>较陌生不常问(需掌握)</h2><h3 id="js-延迟加载的方式有哪些？"><a href="#js-延迟加载的方式有哪些？" class="headerlink" title="js 延迟加载的方式有哪些？"></a>js 延迟加载的方式有哪些？</h3><h5 id="js-延迟加载，也就是等页面加载完成之后再加载-JavaScript-文件。-js-延迟加载有助于提高页面加载速度"><a href="#js-延迟加载，也就是等页面加载完成之后再加载-JavaScript-文件。-js-延迟加载有助于提高页面加载速度" class="headerlink" title="js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度"></a>js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度</h5><p>一般有以下几种方式：(defer 属性async 属性动态创建 DOM 方式使用 setTimeout 延迟方法  让 JS 最后加载)</p><p>js 的<strong>加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载</strong>，提高页面的渲染速度。<br>我了解到的几种方式是：</p><ol><li><p>第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</p></li><li><p>第二种方式是给 js 脚本添加 defer 属性，<strong>这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，</strong>这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</p></li><li><p>第三种方式是给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是<strong>当脚本加载完成后立即执行 js 脚本</strong>，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</p></li><li><p>第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</p></li></ol><h3 id="0-1-0-2为什么不等于0-3？"><a href="#0-1-0-2为什么不等于0-3？" class="headerlink" title="0.1+0.2为什么不等于0.3？"></a>0.1+0.2为什么不等于0.3？</h3><p>当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在<strong>计算机里所存储的二进制</strong>，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。js 中是以 <strong>64 位双精度格式</strong>来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。</p><p>对于这样的情况，<strong>我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数</strong>，以这种方式来解决这个问题。<br>(<strong>toPrecision vs toFixed</strong> –toPrecision 是处理精度，精度是从左至右第一个不为0的数开始数起。<br>–toFixed 是小数点后指定位数取整，从小数点开始数起。)</p><p>我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以<br>使用 es6 的 Number.EPSILON</p><h3 id="Node-环境中的事件环（Event-Loop"><a href="#Node-环境中的事件环（Event-Loop" class="headerlink" title="Node 环境中的事件环（Event Loop)"></a>Node 环境中的事件环（Event Loop)</h3><p>Node是基于V8引擎的运行在服务端的JavaScript运行环境，在处理高并发、I/O密集(文件操作、网络操作、数据库操作等)场景有明显的优势。虽然用到也是V8引擎，但由于服务目的和环境不同，导致了它的API与原生JS有些区别，其Event Loop还要处理一些I/O，比如新的网络连接等，所以Node的Event Loop(事件环机制)与浏览器的是不太一样。<br> 执行顺序如下：</p><p><img src="/imageO/Node.jpg" alt="Node"></p><p>timers: 计时器，执行setTimeout和setInterval的回调<br>pending callbacks: 执行延迟到下一个循环迭代的 I/O 回调<br>idle, prepare: 队列的移动，仅系统内部使用<br>poll轮询: 检索新的 I/O 事件;执行与 I/O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。<br>check: 执行setImmediate回调，setImmediate在这里执行<br>close callbacks: 执行close事件的callback，一些关闭的回调函数，如：socket.on(‘close’, …)</p><h3 id="哪些操作会造成内存泄漏？"><a href="#哪些操作会造成内存泄漏？" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h3><p>相关知识点：</p><p>1.意外的全局变量<br>2.被遗忘的计时器或回调函数<br>3.脱离 DOM 的引用<br>4.闭包</p><p>第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</p><p>第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留<br>在内存中，而无法被回收。</p><p>第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回<br>收。</p><p>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</p><h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>创建函数的时候，已经声明了当前函数的作用域==&gt;当前创建函数所处的上下文。如果是在全局下创建的函数就是[[scope]]:EC(G)，函数执行的时候，形成一个全新的私有上下文EC(FN)，供字符串代码执行(进栈执行)<br>定义：简单来说作用域就是变量与函数的可访问范围，由当前环境与上层环境的一系列变量对象组成<br>1.全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。</p><p>2.函数作用域：在固定的代码片段才能被访问</p><p>作用：作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。<br>作用域链参考链接一般情况下，变量到 创建该变量 的函数的作用域中取值。但是如果在当前作用域中没有查到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。<br><a href="https://juejin.cn/post/7016593221815910408#heading-43">掘金</a></p><h3 id="什么是-DOM-和-BOM？"><a href="#什么是-DOM-和-BOM？" class="headerlink" title="什么是 DOM 和 BOM？"></a>什么是 DOM 和 BOM？</h3><p>DOM 指的是<strong>文档对象模型，它指的是把文档当做一个对象来对待，</strong>这个对象主要定义了处理网页内容的方法和接口。</p><p>BOM 指的是<strong>浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。</strong><br>BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。<strong>window 对象含有 location 对象、navigator 对象、screen 对象等子对象，</strong>并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。<br><a href="https://pengzhenglong.github.io/2021/04/06/Javascript%E5%85%A5%E9%97%A8(%E4%BA%94)/#%E6%93%8D%E4%BD%9CBOM%E5%AF%B9%E8%B1%A1-%E9%87%8D%E7%82%B9">博客：</a></p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>事件会从最内层的元素开始发生，一直向上传播，直到document对象。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;<br>    &lt;p <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;Click <span class="hljs-keyword">me</span>!&lt;/p&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">div</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">body</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">html</span> -&gt;</span> document<br></code></pre></td></tr></table></figure><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。<br>上面的例子在事件捕获的概念下发生click事件的顺序应该是</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">document</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">html</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">body</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">div</span> -&gt;</span> p<br></code></pre></td></tr></table></figure><h3 id="addEventListener-事件-捕获和冒泡（应用场景：事件委托）"><a href="#addEventListener-事件-捕获和冒泡（应用场景：事件委托）" class="headerlink" title="addEventListener  事件 捕获和冒泡（应用场景：事件委托）"></a>addEventListener  事件 捕获和冒泡（应用场景：事件委托）</h3><p>addEventListener方法用来为一个特定的元素绑定一个事件处理函数，是JavaScript中的常用方法。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">element.add<span class="hljs-constructor">EventListener(<span class="hljs-params">event</span>, <span class="hljs-params">function</span>, <span class="hljs-params">useCapture</span>)</span><br></code></pre></td></tr></table></figure><p>重点来看看第三个参数useCapture</p><p>true - 事件句柄在捕获阶段执行（即在事件捕获阶段调用处理函数）<br>false- <strong>false- 默认。</strong>事件句柄在冒泡阶段执行（即表示在事件冒泡的阶段调用事件处理函数）</p><p>所以我们通常来说，<strong>默认第三个参数不写的话，是按照事件句柄在冒泡执行的。</strong></p><h4 id="attachEvent-兼容IE的写法"><a href="#attachEvent-兼容IE的写法" class="headerlink" title="attachEvent (兼容IE的写法)"></a>attachEvent (兼容IE的写法)</h4><p>默认是事件冒泡阶段调用处理函数，写事件名时候要加上”on”前缀（”onload”、”onclick”等）。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">object</span>.attach<span class="hljs-constructor">Event(<span class="hljs-params">event</span>, <span class="hljs-params">function</span>)</span><br></code></pre></td></tr></table></figure><h4 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h4><p>利用事件流的特性，我们可以使用一种叫做事件代理的方法，其实利用的就是事件冒泡的机制。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span>下面的内容是子元素1<br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>li内容&gt;&gt;&gt; <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> 这是span内容123<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        下面的内容是子元素2<br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>li内容&gt;&gt;&gt; <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> 这是span内容123<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        下面的内容是子元素3<br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>li内容&gt;&gt;&gt; <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> 这是span内容123<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>js代码</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stan">xxx.addEventListener(&#x27;click&#x27;, function (<span class="hljs-built_in">e</span>) &#123;<br>            console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">e</span>,<span class="hljs-built_in">e</span>.<span class="hljs-built_in">target</span>)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">e</span>.<span class="hljs-built_in">target</span>.tagName.toLowerCase() === &#x27;li&#x27;) &#123;<br>                console.<span class="hljs-built_in">log</span>(&#x27;打印&#x27;)<br>            &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>更加规范的写法👇</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delegate</span><span class="hljs-params">(element, eventType, selector, fn)</span> &#123;</span><br>          element.addEventListener(eventType, <span class="hljs-keyword">e</span> =&gt; &#123;<br>              <span class="hljs-keyword">let</span> <span class="hljs-keyword">el</span> = <span class="hljs-keyword">e</span>.target<br>              <span class="hljs-keyword">while</span> (!el.matches(selector)) &#123;<br>                  <span class="hljs-keyword">if</span> (element === <span class="hljs-keyword">el</span>) &#123;<br>                      <span class="hljs-keyword">el</span> = null<br>                      <span class="hljs-keyword">break</span><br>                  &#125;<br>                  <span class="hljs-keyword">el</span> = <span class="hljs-keyword">el</span>.parentNode<br>              &#125;<br>              <span class="hljs-keyword">el</span> &amp;&amp; fn.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">el</span>, <span class="hljs-keyword">e</span>, <span class="hljs-keyword">el</span>)<br>          &#125;,true)<br>          <span class="hljs-keyword">return</span> element<br>      &#125;<br></code></pre></td></tr></table></figure><h4 id="事件委托如何获取哪个子节点触发的函数"><a href="#事件委托如何获取哪个子节点触发的函数" class="headerlink" title="事件委托如何获取哪个子节点触发的函数"></a>事件委托如何获取哪个子节点触发的函数</h4><p>事件委托所有子元素都会触发点击事件，所以给需要监听的元素设置一个相同的类名或者相同的标签，先判断点击的元素是否为需要触发事件的标签。然后再进行相应的判断</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stan">ul.onclick = (<span class="hljs-built_in">e</span>) =&gt; &#123;<br>      console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">e</span>.<span class="hljs-built_in">target</span>.innerHTML)<span class="hljs-comment">//目标的文本</span><br>      console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">e</span>.<span class="hljs-built_in">target</span>.tagName)<span class="hljs-comment">//目标的标签名</span><br>      console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">e</span>.<span class="hljs-built_in">target</span>.nodeName)<span class="hljs-comment">//目标的节点名</span><br>      console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">e</span>.<span class="hljs-built_in">target</span>.id)<span class="hljs-comment">//目标的id（标签不设置为空）</span><br>      console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">e</span>.<span class="hljs-built_in">target</span>.className<span class="hljs-comment">//目标的类名（标签不设置为空）)</span><br>      console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">e</span>.<span class="hljs-built_in">target</span>.childNode<span class="hljs-comment">//目标的子节点</span><br>      console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">e</span>.<span class="hljs-built_in">target</span>.parentNode)<span class="hljs-comment">//目标的父节点</span><br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="阻止事件冒泡和默认事件-event-preventDefault-阻止默认事件-amp-amp-event-stopPropagation-阻止冒泡"><a href="#阻止事件冒泡和默认事件-event-preventDefault-阻止默认事件-amp-amp-event-stopPropagation-阻止冒泡" class="headerlink" title="阻止事件冒泡和默认事件(event.preventDefault()   // 阻止默认事件&amp;&amp;event.stopPropagation() //阻止冒泡)"></a>阻止事件冒泡和默认事件(event.preventDefault()   // 阻止默认事件&amp;&amp;event.stopPropagation() //阻止冒泡)</h4><p><a href="https://juejin.cn/post/6864398060702760968#heading-19">天天文章</a></p><h3 id="全局主题切换如何实现"><a href="#全局主题切换如何实现" class="headerlink" title="全局主题切换如何实现"></a>全局主题切换如何实现</h3><p>几种方法<br>基于css变量实现，高效快捷。<br>动态切换根元素样式名或ID。<br>element官方动态主题色 + 动态切换文件（要兼容IE低版本，最终决定使用此方法）<br><a href="https://juejin.cn/post/6898958088301182983">掘金</a><br><a href="https://juejin.cn/post/7053031139694346248#heading-3">三步实现主题切换</a></p><h3 id="typeof-NaN-的结果是什么？"><a href="#typeof-NaN-的结果是什么？" class="headerlink" title="typeof NaN 的结果是什么？"></a>typeof NaN 的结果是什么？</h3><p>NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出<br>数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>typeof NaN; <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;number&quot;</span><br><br></code></pre></td></tr></table></figure><p>NaN 是一个特殊值，它和自身不相等，是<strong>唯一一个非自反</strong>（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN为 true。</p><h3 id="null是对象吗？为什么？"><a href="#null是对象吗？为什么？" class="headerlink" title="null是对象吗？为什么？"></a>null是对象吗？为什么？</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>typeof 运算符对基本数据类型的运算：<br>typeof <span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;string&#x27;</span><br>typeof NaN <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;number&#x27;</span><br>typeof <span class="hljs-number">1</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;number&#x27;</span><br>typeof true <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;boolean&#x27;</span><br>typeof undefined <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;undefined&#x27;</span><br>typeof Symbol() <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;symbol&#x27;</span><br>typeof null <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;object&#x27;</span><br><br></code></pre></td></tr></table></figure><p>结论: null不是对象。</p><p>解释: 虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。<br>在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存</p><h3 id="null和undefined的区别"><a href="#null和undefined的区别" class="headerlink" title="null和undefined的区别"></a>null和undefined的区别</h3><p><a href="https://juejin.cn/post/6912298148098473998#comment">null和undefined的区别（简单易懂）</a><br>null==undefined结果为true<br>null===undefined结果为false</p><h3 id="事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3><p>1.<strong>事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。</strong>事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。<br>2.事件处理机制：IE 支持事件冒泡、Firefox 同时支持两种事件模型，也就是：事件冒泡和事件捕获。<br>3.event.stopPropagation() 或者 ie 下的方法 event.cancelBubble = true;</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/lvdabao/p/3265870.html">《Javascript 事件模型系列（一）事件及事件的三种模型》</a><br><a href="https://blog.csdn.net/wuseyukui/article/details/13771493">《Javascript 事件模型：事件捕获和事件冒泡》</a></p><h3 id="操作符的作用？-x-大致等同于-x-1"><a href="#操作符的作用？-x-大致等同于-x-1" class="headerlink" title="~ 操作符的作用？~x 大致等同于 -(x+1)"></a>~ 操作符的作用？~x 大致等同于 -(x+1)</h3><p>~ 返回 2 的补码，并且 ~ 会将数字转换为 32 位整数，因此我们可以使用 ~ 来进行取整操作。</p><h3 id="和-的-valueOf-和-toString-的结果是什么？"><a href="#和-的-valueOf-和-toString-的结果是什么？" class="headerlink" title="{} 和 [] 的 valueOf 和 toString 的结果是什么？"></a>{} 和 [] 的 valueOf 和 toString 的结果是什么？</h3><p>{} 的 valueOf 结果为 {} ，toString 的结果为 “[object Object]”</p><p>[] 的 valueOf 结果为 [] ，toString 的结果为 “”</p><h3 id="mouseover和mouseenter的区别"><a href="#mouseover和mouseenter的区别" class="headerlink" title="mouseover和mouseenter的区别"></a>mouseover和mouseenter的区别</h3><p>mouseover：当鼠标移入元素或其子元素都会触发事件，<strong>所以有一个重复触发，冒泡的过程</strong>。对应的移除事件是mouseout<br>mouseenter：<strong>当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡</strong>，对应的移除事件是mouseleave</p><h3 id="去除字符串首尾空格"><a href="#去除字符串首尾空格" class="headerlink" title="去除字符串首尾空格"></a>去除字符串首尾空格</h3><ol><li>使用正则(^\s*)|(\s*$)即可</li><li>使用jquery</li></ol><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel"><br>$.<span class="hljs-keyword">trim</span>(str)<br><br></code></pre></td></tr></table></figure><h3 id="比较运算符！！！重要"><a href="#比较运算符！！！重要" class="headerlink" title="比较运算符！！！重要"></a>比较运算符！！！重要</h3><p>=    赋值<br>==   等于(类型不一样，值一样，也会判断为true)<br>===   绝对等于 (类型一样，值一样，结果为true)</p><h4 id="Object-is-使用过吗？跟-和-区别"><a href="#Object-is-使用过吗？跟-和-区别" class="headerlink" title="Object.is()使用过吗？跟 === 和 == 区别"></a>Object.is()使用过吗？跟 === 和 == 区别</h4><p>两等号判等，会在比较时进行类型转换。<br>三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回false）<br>使用 Object.is 来进行相等判断时，<strong>一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。</strong></p><h2 id="其他不常见"><a href="#其他不常见" class="headerlink" title="其他不常见"></a>其他不常见</h2><h3 id="js如何将json字符串转换为json对象-SON-是轻量级的文本数据交换格式"><a href="#js如何将json字符串转换为json对象-SON-是轻量级的文本数据交换格式" class="headerlink" title="js如何将json字符串转换为json对象(SON 是轻量级的文本数据交换格式)"></a>js如何将json字符串转换为json对象(SON 是轻量级的文本数据交换格式)</h3><p>JSON字符串:<br>var str1 = ‘{ “name”: “cxh”, “sex”: “man” }’;<br>JSON对象:<br>var str2 = { “name”: “cxh”, “sex”: “man” };</p><h4 id="一、JSON字符串转换为JSON对象-（eval-函数-amp-amp-parseJSON-amp-amp-parse）"><a href="#一、JSON字符串转换为JSON对象-（eval-函数-amp-amp-parseJSON-amp-amp-parse）" class="headerlink" title="一、JSON字符串转换为JSON对象 （eval(()函数 &amp;&amp;parseJSON &amp;&amp; parse）"></a>一、JSON字符串转换为JSON对象 （eval(()函数 &amp;&amp;parseJSON &amp;&amp; parse）</h4><h5 id="二、可以使用toJSONString-或者全局方法JSON-stringify-将JSON对象转化为JSON字符串"><a href="#二、可以使用toJSONString-或者全局方法JSON-stringify-将JSON对象转化为JSON字符串" class="headerlink" title="二、可以使用toJSONString()或者全局方法JSON.stringify()将JSON对象转化为JSON字符串"></a>二、可以使用toJSONString()或者全局方法JSON.stringify()将JSON对象转化为JSON字符串</h5><p>例如：</p><p>var last=obj.toJSONString(); //将JSON对象转化为JSON字符<br>或者</p><p>var last=JSON.stringify(obj); //将JSON对象转化为JSON字符</p><p><a href="https://zhuanlan.zhihu.com/p/138712665">js如何将json字符串转换为json对象</a></p><h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><h4 id="number与string的转换-面试题"><a href="#number与string的转换-面试题" class="headerlink" title="number与string的转换(面试题)"></a>number与string的转换(面试题)</h4><h5 id="number-gt-string"><a href="#number-gt-string" class="headerlink" title="number -&gt; string"></a>number -&gt; string</h5><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs q"><br><span class="hljs-comment">// toString()</span><br>/*<br><span class="hljs-built_in">var</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">var</span> res = num.toString();<br>alert(typeof (num));<br>alert(typeof (res));<br>*/<br><br><span class="hljs-comment">// 加一个空格</span><br>/*<br><span class="hljs-built_in">var</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">var</span> res = num + <span class="hljs-string">&quot;&quot;</span><br>alert(num + <span class="hljs-string">&quot;, &quot;</span> + typeof (num));<br>alert(res + <span class="hljs-string">&quot;, &quot;</span> + typeof (res));<br>*/<br><br><span class="hljs-comment">// 使用String(数字)函数</span><br>/*<br><span class="hljs-built_in">var</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">var</span> res = String(num);<br>alert(num + <span class="hljs-string">&quot;, &quot;</span> + typeof (num));<br>alert(res + <span class="hljs-string">&quot;, &quot;</span> + typeof (res));<br>*/<br><br><span class="hljs-comment">// 没有固定精度的表示</span><br>/*<br><span class="hljs-built_in">var</span> n = <span class="hljs-number">1234.56789</span>;<br><span class="hljs-built_in">var</span> s4 = n.toFixed(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">var</span> s5 = n.toExponential(<span class="hljs-number">2</span>); <span class="hljs-comment">// 指数表示</span><br><span class="hljs-built_in">var</span> s6 = n.toPrecision(<span class="hljs-number">2</span>); <span class="hljs-comment">// 有效位数</span><br><br>alert(s4 + <span class="hljs-string">&quot;, &quot;</span> + typeof(s4));<br>alert(s5 + <span class="hljs-string">&quot;, &quot;</span> + typeof(s5));<br>alert(s6 + <span class="hljs-string">&quot;, &quot;</span> + typeof(s6));<br>*/<br><br></code></pre></td></tr></table></figure><h5 id="string-gt-number"><a href="#string-gt-number" class="headerlink" title="string -&gt; number"></a>string -&gt; number</h5><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs q"><br><span class="hljs-comment">// 做除了加法以外的数字运算</span><br>/*<br><span class="hljs-built_in">var</span> s = <span class="hljs-string">&quot;12345&quot;</span>;<br><span class="hljs-built_in">var</span> r = s / <span class="hljs-number">1</span>; <span class="hljs-comment">// s - 0;</span><br>alert(s + <span class="hljs-string">&quot;, &quot;</span> + typeof s);<br>alert(r + <span class="hljs-string">&quot;, &quot;</span> + typeof r);<br>*/<br><br><span class="hljs-comment">// 使用parse系方法</span><br><span class="hljs-comment">// parseInt() parseFloat()</span><br>/*<br><span class="hljs-built_in">var</span> s = <span class="hljs-string">&quot;08&quot;</span>;<br><span class="hljs-built_in">var</span> r = parseInt(s);<br>alert(s + <span class="hljs-string">&quot;, &quot;</span> + typeof s);<br>alert(r + <span class="hljs-string">&quot;, &quot;</span> + typeof r);<br>*/<br><span class="hljs-comment">// parse系方法，只识别一个字符串中开始的数字，如果识别不了就返回NaN</span><br>alert(parseInt(<span class="hljs-string">&quot;a123abc&quot;</span>) + <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 使用Number()函数</span><br><br></code></pre></td></tr></table></figure><h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p><a href="https://pengzhenglong.github.io/2022/03/11/Js%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/">博客</a></p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javaScript之Math常用方法</title>
    <link href="/2022/01/04/javaScript%E4%B9%8BMath%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2022/01/04/javaScript%E4%B9%8BMath%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Math是 JavaScript 的原生对象，提供各种数学功能。Math对象是目前javaScript原生对象里唯一一个不是构造函数，不用实例化，所有的属性和方法都是直接在Math对象上调用。下面是本次分享的Math主要方法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">【一】<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs<span class="hljs-literal">()</span> 返回绝对值<br>【二】<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>ceil<span class="hljs-literal">()</span>,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>floor<span class="hljs-literal">()</span> 向上取整和向下取整<br>【三】<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max<span class="hljs-literal">()</span>,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min<span class="hljs-literal">()</span> 最大值和最小值<br>【四】<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>round<span class="hljs-literal">()</span> 四舍五入<br>【五】<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>random<span class="hljs-literal">()</span> 随机数<br>【六】<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>pow<span class="hljs-literal">()</span> 指数运算<br>【七】<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>sqrt<span class="hljs-literal">()</span> 平方根<br>【八】<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>log<span class="hljs-literal">()</span> 自然对数<br>【九】<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>exp<span class="hljs-literal">()</span> e的指数<br>【十】Math属性<br>【十一】Math三角函数<br></code></pre></td></tr></table></figure><hr><h3 id="1-Math-abs-绝对值"><a href="#1-Math-abs-绝对值" class="headerlink" title="1.Math.abs() 绝对值"></a>1.Math.abs() 绝对值</h3><p>Math.abs()方法，接收一个参数，返回这个参数的绝对值，通俗的讲就是把任何一个有效数字返回一个正数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">abs</span>(<span class="hljs-number">10</span>))   <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 输出 <span class="hljs-number">10</span><br>console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">abs</span>(<span class="hljs-number">-10</span>))  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 输出 <span class="hljs-number">10</span><br><br></code></pre></td></tr></table></figure><h3 id="2-Math-ceil-Math-floor-向上取整和向下取整"><a href="#2-Math-ceil-Math-floor-向上取整和向下取整" class="headerlink" title="2.Math.ceil(),Math.floor() 向上取整和向下取整"></a>2.Math.ceil(),Math.floor() 向上取整和向下取整</h3><p>Math.ceil(),Math.floor()方法是获取整数的方法，接收一个参数，把小数点后面的数向上或者向下取一个整数。Math.ceil()是向上，Math.floor()是向下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">ceil</span>(<span class="hljs-number">10.01</span>))   <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 输出 <span class="hljs-number">11</span><br>console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">floor</span>(<span class="hljs-number">10.01</span>))  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 输出 <span class="hljs-number">10</span><br><br></code></pre></td></tr></table></figure><h3 id="3-Math-max-Math-min-最大值和最小值"><a href="#3-Math-max-Math-min-最大值和最小值" class="headerlink" title="3.Math.max(),Math.min() 最大值和最小值"></a>3.Math.max(),Math.min() 最大值和最小值</h3><p>Math.max(),Math.min()方法接收多个参数，并返回参数里数值最大或者最小的那个数，Math.max()是获取最大，Math.min()是获取最小：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">console</span>.log(Math.max(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>))   // 输出 <span class="hljs-number">9</span><br><span class="hljs-attribute">console</span>.log(Math.min(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>))  // 输出 <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><p>Math.max(),Math.min()也可以用来获取数组里的最大数值和最小数值：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>];<br>// 先看用循环实现方法,采用循环方式的核心思想就是假设法。<br><span class="hljs-built_in">var</span> <span class="hljs-built_in">max</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">min</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">var</span> <span class="hljs-built_in">num</span> of arr) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span> &lt; <span class="hljs-built_in">num</span>) &#123;<br>  <span class="hljs-built_in">max</span> = <span class="hljs-built_in">num</span><br> &#125;<br> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span> &gt; <span class="hljs-built_in">num</span>) &#123;<br>  <span class="hljs-built_in">min</span> = <span class="hljs-built_in">num</span>;<br> &#125;<br>&#125;   // 输出 <span class="hljs-number">9</span>, <span class="hljs-number">1</span>;<br>// 下面是采用<span class="hljs-built_in">apply</span>改变this指向的方式直接获取最大值和最小值<br>console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">max</span>.<span class="hljs-built_in">apply</span>(null, arr))   // 输出 <span class="hljs-number">9</span><br>console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">min</span>.<span class="hljs-built_in">apply</span>(null, arr))  // 输出 <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h3 id="4-Math-round-四舍五入"><a href="#4-Math-round-四舍五入" class="headerlink" title="4.Math.round() 四舍五入"></a>4.Math.round() 四舍五入</h3><p>Math.round()方法接收一个数字参数，对数字小数点后一位的数进行四舍五入处理</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">console</span>.log(Math.round(<span class="hljs-number">3</span>.<span class="hljs-number">87</span>))   // 输出 <span class="hljs-number">4</span><br><span class="hljs-attribute">console</span>.log(Math.round(<span class="hljs-number">3</span>.<span class="hljs-number">39</span>))  // 输出 <span class="hljs-number">3</span><br><br></code></pre></td></tr></table></figure><h3 id="5-Math-random-随机数"><a href="#5-Math-random-随机数" class="headerlink" title="5.Math.random() 随机数"></a>5.Math.random() 随机数</h3><p>Math.random()方法返回一个0到1之间的随机数；</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">random</span>())   <span class="hljs-comment">// 输出 0到1之间的随机数</span><br><br></code></pre></td></tr></table></figure><p>Math.random()是一个应用非常广泛的方法，下面看一个限定范围内的随机数：<br>`<br>function getRandom (min, max) {<br> return Math.round(Math.random()*(max - min))<br>}<br>console.log(getRandom(0, 100)); // 输出0到100的随机整数</p><p><code>基于这个思想，可以做很多事情，比如随机取字符串里的值，随机取数组里的某个当前项等等。</code><br>var ary = [‘red’, ‘orange’, ‘yellow’, ‘blue’, ‘green’]<br>function getRandom (min, max) {<br>   return ary[Math.round(Math.random()*(max - min))]<br> }<br>console.log(getRandom(0, ary.length-1)); // 输出数组里随机的一个当前项</p><p>`</p><h3 id="6-Math-pow-指数运算"><a href="#6-Math-pow-指数运算" class="headerlink" title="6.Math.pow() 指数运算"></a>6.Math.pow() 指数运算</h3><p>Math.pow()方法返回以第一个参数为底数、第二个参数为幂的指数值。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出4</span><br><span class="hljs-comment">// 等同于 2 **2</span><br>console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出8</span><br><span class="hljs-comment">// 等同于 2** 3</span><br><br></code></pre></td></tr></table></figure><h3 id="7-Math-sqrt-平方根"><a href="#7-Math-sqrt-平方根" class="headerlink" title="7.Math.sqrt() 平方根"></a>7.Math.sqrt() 平方根</h3><p>Math.sqrt()方法返回参数值的平方根。如果参数是一个负值，则返回NaN。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">9</span>)); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 输出<span class="hljs-number">3</span><br>console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-9</span>)); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 输出NaN<br></code></pre></td></tr></table></figure><p>`</p><h3 id="8-Math-log"><a href="#8-Math-log" class="headerlink" title="8.Math.log()"></a>8.Math.log()</h3><p>Math.log方法返回以e为底的自然对数值。<br>`<br>console.log(Math.log(10)); // 输出 2.302585092994046</p><p>`</p><h3 id="9-Math-exp"><a href="#9-Math-exp" class="headerlink" title="9.Math.exp()"></a>9.Math.exp()</h3><p>Math.exp()方法返回常数e的参数次方。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">exp</span>(<span class="hljs-number">1</span>)); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 输出 <span class="hljs-number">2.7182818284590455</span><br>console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">exp</span>(<span class="hljs-number">2</span>)); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 输出 <span class="hljs-number">7.38905609893065</span><br><br></code></pre></td></tr></table></figure><p>Math属性</p><p>Math.E：常数e。<br>Math.LN2：2 的自然对数。<br>Math.LN10：10 的自然对数。<br>Math.LOG2E：以 2 为底的e的对数。<br>Math.LOG10E：以 10 为底的e的对数。<br>Math.PI：常数π。<br>Math.SQRT1_2：0.5 的平方根。<br>Math.SQRT2：2 的平方根</p><p>`<br>Math.E // 2.718281828459045<br>Math.LN2 // 0.6931471805599453<br>Math.LN10 // 2.302585092994046<br>Math.LOG2E // 1.4426950408889634<br>Math.LOG10E // 0.4342944819032518<br>Math.PI // 3.141592653589793<br>Math.SQRT1_2 // 0.7071067811865476<br>Math.SQRT2 // 1.4142135623730951</p><p>`<br>注意Math的这些属性都是只读，不可以修改的。</p><p>Math三角函数</p><p>Math.sin()：返回参数的正弦（参数为弧度值）<br>Math.cos()：返回参数的余弦（参数为弧度值）<br>Math.tan()：返回参数的正切（参数为弧度值）<br>Math.asin()：返回参数的反正弦（返回值为弧度值）<br>Math.acos()：返回参数的反余弦（返回值为弧度值）<br>Math.atan()：返回参数的反正切（返回值为弧度值）</p><p>`<br>Math.sin(0) // 0<br>Math.cos(0) // 1<br>Math.tan(0) // 0<br>Math.sin(Math.PI / 2) // 1<br>Math.asin(1) // 1.5707963267948966<br>Math.acos(1) // 0<br>Math.atan(1) // 0.7853981633974483</p><p>`</p><p>结语</p><p>Math对象本身是对js里的数字做数学处理的，里面有不少方法。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844903687932870670">javaScript之Math常用方法</a></p>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 奇怪又实用的姿势又增加了六个</title>
    <link href="/2022/01/03/JavaScript%20%E5%A5%87%E6%80%AA%E5%8F%88%E5%AE%9E%E7%94%A8%E7%9A%84%E5%A7%BF%E5%8A%BF%E5%8F%88%E5%A2%9E%E5%8A%A0%E4%BA%86%E5%85%AD%E4%B8%AA/"/>
    <url>/2022/01/03/JavaScript%20%E5%A5%87%E6%80%AA%E5%8F%88%E5%AE%9E%E7%94%A8%E7%9A%84%E5%A7%BF%E5%8A%BF%E5%8F%88%E5%A2%9E%E5%8A%A0%E4%BA%86%E5%85%AD%E4%B8%AA/</url>
    
    <content type="html"><![CDATA[<p>该文章引用于零一</p><hr><h3 id="一、解构小技巧"><a href="#一、解构小技巧" class="headerlink" title="一、解构小技巧"></a>一、解构小技巧</h3><p>平常我们需要用到一个嵌套多层的对象中某些属性，会将其解构出来使用</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sqf">let obj = &#123;<br>  part1: &#123;<br>    <span class="hljs-built_in">name</span>: <span class="hljs-string">&#x27;零一&#x27;</span>,<br>    age: <span class="hljs-number">23</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 解构</span><br>const &#123; part1: &#123; <span class="hljs-built_in">name</span>, age &#125; &#125; = obj<br><span class="hljs-comment">// 使用</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">name</span>, age)  <span class="hljs-comment">// 零一  23</span><br></code></pre></td></tr></table></figure><p>这种情况下，你把 name 和 age 从 part1 里解构出来了以后，你就无法使用变量 obj 中的 part1 属性了，如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// .... 省略</span><br><br><span class="hljs-keyword">const</span> &#123; part1: &#123; name, age &#125; &#125; = obj<br>console.<span class="hljs-built_in">log</span>(part1)   <span class="hljs-comment">// Uncaught ReferenceError: part1 is not defined</span><br></code></pre></td></tr></table></figure><p>其实你可以多次解构，如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> .... 省略<br><br>const &#123; part1: &#123; name, age &#125;, part1 &#125; = obj<br>console.log(part1)   <span class="hljs-regexp">//</span> &#123;name: <span class="hljs-string">&quot;零一&quot;</span>, age: <span class="hljs-number">23</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、数字分隔符"><a href="#二、数字分隔符" class="headerlink" title="二、数字分隔符"></a>二、数字分隔符</h3><p>有时你会在文件中定义一个数字常量</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> myMoney = <span class="hljs-number">1000000000000</span><br></code></pre></td></tr></table></figure><p>这么多个 0 ，1、2 … 6、7 … 数晕了都，怎么办？</p><p>数字分隔符整起来！</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">const</span> myMoney = <span class="hljs-number">1</span>_<span class="hljs-number">000</span>_<span class="hljs-number">000</span>_<span class="hljs-number">000</span>_<span class="hljs-number">000</span><br><br><span class="hljs-attribute">console</span>.log(myMoney)  // <span class="hljs-number">1000000000000</span><br></code></pre></td></tr></table></figure><p>这样写是没问题的，而且数字分割开后也更直观！！</p><h3 id="三、try…catch…finally-谁厉害？"><a href="#三、try…catch…finally-谁厉害？" class="headerlink" title="三、try…catch…finally 谁厉害？"></a>三、try…catch…finally 谁厉害？</h3><p>普通函数调用中，return 一般会提前结束函数的执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">demo</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我是零一&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(demo())   <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>而在  try…catch…finally 中，return 就不会提前结束执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">demo</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-built_in">console</span>.log(err)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(demo())   <span class="hljs-comment">// 返回什么？？</span><br></code></pre></td></tr></table></figure><p>这个程序会返回什么呢？思考一下</p><p>Tow hours Later~</p><p>答案是：3</p><p>最后得出结论，还是 finally 比较厉害</p><p>那么我们可以搞一些骚操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">demo</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-built_in">console</span>.log(err)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">4</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(demo())  <span class="hljs-comment">// 返回 4</span><br></code></pre></td></tr></table></figure><h3 id="四、获取当前调用栈"><a href="#四、获取当前调用栈" class="headerlink" title="四、获取当前调用栈"></a>四、获取当前调用栈</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> first<span class="hljs-constructor">Function()</span> &#123; second<span class="hljs-constructor">Function()</span>; &#125; <br><span class="hljs-keyword">function</span> second<span class="hljs-constructor">Function()</span> &#123; thrid<span class="hljs-constructor">Function()</span>; &#125; <br><span class="hljs-keyword">function</span> thrid<span class="hljs-constructor">Function()</span> &#123; console.log(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Error()</span>.stack); &#125; <br><br>first<span class="hljs-constructor">Function()</span>;<br><br><span class="hljs-comment">//=&gt; Error </span><br><span class="hljs-comment">//  at thridFunction (&lt;anonymous&gt;:2:17) </span><br><span class="hljs-comment">//  at secondFunction (&lt;anonymous&gt;:5:5) </span><br><span class="hljs-comment">//  at firstFunction (&lt;anonymous&gt;:8:5) </span><br><span class="hljs-comment">//  at &lt;anonymous&gt;:10:1</span><br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Error()</span>.stack 这样就能随时获取到当前代码执行的调用栈信息，也不失一种调试代码的办法<br></code></pre></td></tr></table></figure><h3 id="五、一行代码生成随机字符串"><a href="#五、一行代码生成随机字符串" class="headerlink" title="五、一行代码生成随机字符串"></a>五、一行代码生成随机字符串</h3><p>我最初学js时，想自己实现一个随机生成字符串的函数，是这么搞的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hash</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-keyword">const</span> strs = [<br>    <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <br>    <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <br>    <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <br>    <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <br>    <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>,<br>    <span class="hljs-string">&#x27;9&#x27;</span>,<br>  ]<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    s += strs[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * strs.length)]<br>  &#125;<br>  <span class="hljs-keyword">return</span> s<br>&#125;<br><br>hash()  <span class="hljs-comment">// &#x27;www7v2if9r&#x27;</span><br></code></pre></td></tr></table></figure><p>真麻烦啊！我光写26个字母和10个数字就写了半天（当然也可以用ASCII码来实现，会更方便点）</p><p>接下来介绍一个方法，只需 一行超短代码 即可实现 “随机生成字符串” 的功能</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">const</span> <span class="hljs-built_in">str</span> = Math.<span class="hljs-built_in">random</span>().toString(<span class="hljs-number">36</span>).substr(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>);<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span>);   <span class="hljs-comment">// &#x27;w5jetivt7e&#x27;</span><br></code></pre></td></tr></table></figure><p>我们同样获得了一个10位数的随机字符串，这太酷了😎，跟我写的那个比起来，简直不要太爽</p><p>先是 Math.random() 生成 [0, 1) 的数，也就是 0.123312、0.982931之类的，然后调用 number 的 toString方法将其转换成36进制的，按照MDN的说法，36进制的转换应该是包含了字母 a<del>z 和 数字0</del>9的，因为这样生成的是 0.89kjna21sa 类似这样的，所以要截取一下小数部分，即从索引 2 开始截取10个字符就是我们想要的随机字符串了</p><p>很多开源库都使用此方式为DOM元素创建随机ID。</p><h3 id="六、最快获取dom的方法"><a href="#六、最快获取dom的方法" class="headerlink" title="六、最快获取dom的方法"></a>六、最快获取dom的方法</h3><p>HTML中带有 id 属性的元素，都会被全局的 ID 同名变量所引用</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;zero2one&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>原本获取 dom 是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;zero2one&#x27;</span>)  <br><span class="hljs-built_in">console</span>.log(el)   <span class="hljs-comment">// &lt;div id=&quot;zero2one&quot;&gt;&lt;/div&gt;</span><br></code></pre></td></tr></table></figure><p>现在可以这样</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">console.log(zero2one)   // <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;zero2one&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>是不是很方便 ^-^</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://mp.weixin.qq.com/s/qvTppljF8BL-qzsUzOgB7Q">JavaScript 奇怪又实用的姿势又增加了六个</a></p>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS Grid 网格布局教程(二)</title>
    <link href="/2021/12/27/CSSGrid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B(2)/"/>
    <url>/2021/12/27/CSSGrid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B(2)/</url>
    
    <content type="html"><![CDATA[<hr><h4 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h4><p>grid-row-gap 属性，<br>grid-column-gap 属性，<br>grid-gap 属性<br>grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  grid-row-gap: <span class="hljs-number">20px</span>;<br>  grid-<span class="hljs-attribute">column-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，grid-row-gap用于设置行间距，grid-column-gap用于设置列间距。</p><p><img src="/imageO/gird11.jpg" alt="效果"></p><p>grid-gap属性是grid-column-gap和grid-row-gap的合并简写形式，语法如下。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">grid</span>-gap: &lt;<span class="hljs-built_in">grid</span>-<span class="hljs-built_in">row</span>-gap&gt; &lt;<span class="hljs-built_in">grid</span>-column-gap&gt;;<br></code></pre></td></tr></table></figure><p>因此，上面一段 CSS 代码等同于下面的代码。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel">.<span class="hljs-keyword">container</span> &#123;<br>  <span class="hljs-keyword">grid</span>-gap: <span class="hljs-number">20</span>px <span class="hljs-number">20</span>px;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果grid-gap省略了第二个值，浏览器认为第二个值等于第一个值。</p><h5 id="注"><a href="#注" class="headerlink" title="注"></a>注</h5><ul><li>根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。</li></ul><h4 id="3-4-grid-template-areas-属性"><a href="#3-4-grid-template-areas-属性" class="headerlink" title="3.4 grid-template-areas 属性"></a>3.4 grid-template-areas 属性</h4><p>网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>  grid-template-rows: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>  grid-template-areas: <span class="hljs-string">&#x27;a b c&#x27;</span><br>                       <span class="hljs-string">&#x27;d e f&#x27;</span><br>                       <span class="hljs-string">&#x27;g h i&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。</p><p>多个单元格合并成一个区域的写法如下。</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sml">grid-template-areas: <span class="hljs-symbol">&#x27;a</span> a a&#x27;<br>                     <span class="hljs-symbol">&#x27;b</span> b b&#x27;<br>                     <span class="hljs-symbol">&#x27;c</span> c c&#x27;;<br></code></pre></td></tr></table></figure><p>上面代码将9个单元格分成a、b、c三个区域。</p><p>下面是一个布局实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">grid-<span class="hljs-keyword">template</span>-areas: <span class="hljs-string">&quot;header header header&quot;</span><br>                     <span class="hljs-string">&quot;main main sidebar&quot;</span><br>                     <span class="hljs-string">&quot;footer footer footer&quot;</span>;<br></code></pre></td></tr></table></figure><p>上面代码中，顶部是页眉区域header，底部是页脚区域footer，中间部分则为main和sidebar。</p><p>如果某些区域不需要利用，则使用”点”（.）表示。</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sml">grid-template-areas: <span class="hljs-symbol">&#x27;a</span> . c&#x27;<br>                     <span class="hljs-symbol">&#x27;d</span> . f&#x27;<br>                     <span class="hljs-symbol">&#x27;g</span> . i&#x27;;<br></code></pre></td></tr></table></figure><p>上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。</p><ul><li>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。</li></ul><p>比如，区域名为header，则起始位置的水平网格线和垂直网格线叫做header-start，终止位置的水平网格线和垂直网格线叫做header-end。</p><h4 id="3-5-grid-auto-flow-属性"><a href="#3-5-grid-auto-flow-属性" class="headerlink" title="3.5 grid-auto-flow 属性"></a>3.5 grid-auto-flow 属性</h4><p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。<br><img src="/imageO/gird12.jpg" alt="效果"><br>这个顺序由grid-auto-flow属性决定，默认值是row，即”先行后列”。也可以将它设成column，变成”先列后行”。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">grid-<span class="hljs-attribute">auto</span>-flow: column;<br></code></pre></td></tr></table></figure><p>上面代码设置了column以后，放置顺序就变成了下图。<br><img src="/imageO/gird13.jpg" alt="效果"></p><p>grid-auto-flow属性除了设置成row和column，还可以设成row dense和column dense。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。</p><p>下面的例子让1号项目和2号项目各占据两个单元格，然后在默认的grid-auto-flow: row情况下，会产生下面这样的布局。<br><img src="/imageO/gird14.jpg" alt="效果"></p><p>上图中，1号项目后面的位置是空的，这是因为3号项目默认跟着2号项目，所以会排在2号项目后面。</p><p>现在修改设置，设为row dense，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">grid-<span class="hljs-attribute">auto</span>-flow: row dense;`<br></code></pre></td></tr></table></figure><p>上面代码的效果如下。<br><img src="/imageO/gird15.jpg" alt="效果"><br>上图会先填满第一行，再填满第二行，所以3号项目就会紧跟在1号项目的后面。8号项目和9号项目就会排到第四行。</p><p>如果将设置改为column dense，表示”先列后行”，并且尽量填满空格。</p><p>grid-auto-flow: column dense;<br>上面代码的效果如下。<br><img src="/imageO/gird16.jpg" alt="效果"><br>上图会先填满第一列，再填满第2列，所以3号项目在第一列，4号项目在第二列。8号项目和9号项目被挤到了第四列。</p><h4 id="3-6"><a href="#3-6" class="headerlink" title="3.6"></a>3.6</h4><p>justify-items 属性，<br>align-items 属性，<br>place-items 属性<br>justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coq">.container &#123;<br>  justify-items: start | <span class="hljs-type">end</span> | <span class="hljs-type">center</span> | <span class="hljs-type">stretch</span>;<br>  align-items: start | <span class="hljs-type">end</span> | <span class="hljs-type">center</span> | <span class="hljs-type">stretch</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个属性的写法完全相同，都可以取下面这些值。</p><p>start：对齐单元格的起始边缘。<br>end：对齐单元格的结束边缘。<br>center：单元格内部居中。<br>stretch：拉伸，占满单元格的整个宽度（默认值）。</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs puppet">.<span class="hljs-keyword">container</span> &#123;<br>  justify-items: <span class="hljs-literal">start</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码表示，单元格的内容左对齐，效果如下图。<br><img src="/imageO/gird17.jpg" alt="效果"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">align-items</span>: start;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码表示，单元格的内容头部对齐，效果如下图。<br><img src="/imageO/gird18.jpg" alt="效果"><br>place-items属性是align-items属性和justify-items属性的合并简写形式。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">place-<span class="hljs-built_in">items</span>: &lt;align-<span class="hljs-built_in">items</span>&gt; &lt;justify-<span class="hljs-built_in">items</span>&gt;;<br></code></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">place-items: <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure><p>如果省略第二个值，则浏览器认为与第一个值相等。</p><h4 id="3-7-这里的属性和flex盒子模型中相似"><a href="#3-7-这里的属性和flex盒子模型中相似" class="headerlink" title="3.7   这里的属性和flex盒子模型中相似"></a>3.7   这里的属性和flex盒子模型中相似</h4><p>justify-content 属性，<br>align-content 属性，<br>place-content 属性<br>justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">.container &#123;<br>  justify-content: start | <span class="hljs-keyword">end</span> | center | stretch | <span class="hljs-literal">space</span>-<span class="hljs-keyword">around</span> | <span class="hljs-literal">space</span>-<span class="hljs-keyword">between</span> | <span class="hljs-literal">space</span>-evenly;<br>  align-content: start | <span class="hljs-keyword">end</span> | center | stretch | <span class="hljs-literal">space</span>-<span class="hljs-keyword">around</span> | <span class="hljs-literal">space</span>-<span class="hljs-keyword">between</span> | <span class="hljs-literal">space</span>-evenly;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以justify-content属性为例，align-content属性的图完全一样，只是将水平方向改成垂直方向。）</p><p>start - 对齐容器的起始边框。</p><p>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。<br><img src="/imageO/gird19.jpg" alt="效果"></p><p>place-content属性是align-content属性和justify-content属性的合并简写形式。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">place-<span class="hljs-built_in">content</span>: &lt;align-<span class="hljs-built_in">content</span>&gt; &lt;justify-<span class="hljs-built_in">content</span>&gt;<br></code></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">place-content: <span class="hljs-literal">space</span>-<span class="hljs-keyword">around</span> <span class="hljs-literal">space</span>-evenly;<br></code></pre></td></tr></table></figure><p>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p><h4 id="3-8"><a href="#3-8" class="headerlink" title="3.8"></a>3.8</h4><p>grid-auto-columns 属性，<br>grid-auto-rows 属性<br>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。</p><p>grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p><p>下面的例子里面，划分好的网格是3行 x 3列，但是，8号项目指定在第4行，9号项目指定在第5行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>  grid-template-rows: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>  grid-<span class="hljs-attribute">auto</span>-rows: <span class="hljs-number">50px</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码指定新增的行高统一为50px（原始的行高为100px）。<br><img src="/imageO/gird20.jpg" alt="效果"></p><h4 id="3-9"><a href="#3-9" class="headerlink" title="3.9"></a>3.9</h4><p>grid-template 属性，<br>grid 属性<br>grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。</p><p>grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。</p><p>从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。</p><h3 id="四、项目属性"><a href="#四、项目属性" class="headerlink" title="四、项目属性"></a>四、项目属性</h3><p>下面这些属性定义在项目上面。</p><h4 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h4><p>grid-column-start 属性，<br>grid-column-end 属性，<br>grid-row-start 属性，<br>grid-row-end 属性<br>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>属性：左边框所在的垂直网格线<br>grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>属性：右边框所在的垂直网格线<br>grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>属性：上边框所在的水平网格线<br>grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>属性：下边框所在的水平网格线<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.item<span class="hljs-number">-1</span> &#123;<br>  grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">2</span>;<br>  grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码指定，1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。<br><img src="/imageO/gird21.jpg" alt="效果"><br>上图中，只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。</p><p>除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的grid-auto-flow属性决定，这个属性的默认值是row，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成column、row dense和column dense，看看其他项目的位置发生了怎样的变化。</p><p>下面的例子是指定四个边框位置的效果。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.item<span class="hljs-number">-1</span> &#123;<br>  grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;<br>  grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">3</span>;<br>  grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">2</span>;<br>  grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/imageO/gird22.jpg" alt="效果"></p><p>上面代码中，左边框和右边框的位置，都指定为网格线的名字。</p><p>这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.item<span class="hljs-number">-1</span> &#123;<br>  grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: span <span class="hljs-number">2</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面代码表示，1号项目的左边框距离右边框跨越2个网格。<br><img src="/imageO/gird23.jpg" alt="效果"><br>这与下面的代码效果完全一样。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">.<span class="hljs-built_in">item</span><span class="hljs-number">-1</span> &#123;<br>  grid-column-<span class="hljs-keyword">end</span>: span <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序。</p><h4 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h4><p>grid-column 属性，<br>grid-row 属性<br>grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.item &#123;<br>  grid-<span class="hljs-keyword">column</span>: &lt;<span class="hljs-keyword">start</span>-<span class="hljs-type">line</span>&gt; / &lt;<span class="hljs-keyword">end</span>-<span class="hljs-type">line</span>&gt;;<br>  grid-<span class="hljs-keyword">row</span>: &lt;<span class="hljs-keyword">start</span>-<span class="hljs-type">line</span>&gt; / &lt;<span class="hljs-keyword">end</span>-<span class="hljs-type">line</span>&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.item<span class="hljs-number">-1</span> &#123;<br>  grid-<span class="hljs-keyword">column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>  grid-<span class="hljs-keyword">row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">/* 等同于 */</span><br>.item<span class="hljs-number">-1</span> &#123;<br>  grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;<br>  grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">3</span>;<br>  grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;<br>  grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，项目item-1占据第一行，从第一根列线到第三根列线。</p><p>这两个属性之中，也可以使用span关键字，表示跨越多少个网格。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#b03532</span>;<br>  grid-column: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>  grid-row: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-comment">/* 等同于 */</span><br><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#b03532</span>;<br>  grid-column: <span class="hljs-number">1</span> / span <span class="hljs-number">2</span>;<br>  grid-row: <span class="hljs-number">1</span> / span <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，项目item-1占据的区域，包括第一行 + 第二行、第一列 + 第二列。<br><img src="/imageO/gird24.jpg" alt="效果"></p><p>斜杠以及后面的部分可以省略，默认跨越一个网格。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.item-<span class="hljs-number">1</span> &#123;<br>  <span class="hljs-built_in">grid</span>-column: <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">grid</span>-<span class="hljs-built_in">row</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，项目item-1占据左上角第一个网格。</p><h4 id="4-3-grid-area-属性"><a href="#4-3-grid-area-属性" class="headerlink" title="4.3 grid-area 属性"></a>4.3 grid-area 属性</h4><p>grid-area属性指定项目放在哪一个区域。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">.<span class="hljs-built_in">item</span><span class="hljs-number">-1</span> &#123;<br>  grid-area: e;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，1号项目位于e区域，效果如下图。<br><img src="/imageO/gird25.jpg" alt="效果"><br>grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.item &#123;<br>  grid-area: &lt;<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>&gt; / &lt;<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>&gt; / &lt;<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>&gt; / &lt;<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">.item-1 &#123;<br>  grid-area:<span class="hljs-number"> 1 </span>/<span class="hljs-number"> 1 </span>/<span class="hljs-number"> 3 </span>/ 3;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4"><a href="#4-4" class="headerlink" title="4.4"></a>4.4</h4><p>justify-self 属性，<br>align-self 属性，<br>place-self 属性<br>justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。</p><p>align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coq">.item &#123;<br>  justify-self: start | <span class="hljs-type">end</span> | <span class="hljs-type">center</span> | <span class="hljs-type">stretch</span>;<br>  align-self: start | <span class="hljs-type">end</span> | <span class="hljs-type">center</span> | <span class="hljs-type">stretch</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个属性都可以取下面四个值。</p><p>start：对齐单元格的起始边缘。<br>end：对齐单元格的结束边缘。<br>center：单元格内部居中。<br>stretch：拉伸，占满单元格的整个宽度（默认值）。<br>下面是justify-self: start的例子。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.item-1</span>  &#123;<br>  justify-self: start;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>place-self属性是align-self属性和justify-self属性的合并简写形式。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">place-<span class="hljs-literal">self</span>: &lt;align-<span class="hljs-literal">self</span>&gt; &lt;justify-<span class="hljs-literal">self</span>&gt;;<br></code></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">place-self: <span class="hljs-built_in">center</span> <span class="hljs-built_in">center</span>;<br></code></pre></td></tr></table></figure><p>如果省略第二个值，place-self属性会认为这两个值相等。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">阮一峰—CSS Grid 网格布局教程</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>前端基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS Grid 网格布局教程(一)</title>
    <link href="/2021/12/27/CSSGrid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B(1)/"/>
    <url>/2021/12/27/CSSGrid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B(1)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>网格布局（Grid）是最强大的 CSS 布局方案。</p><p>它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。<br><img src="/imageO/gird1.jpg" alt="效果"></p><p>上图这样的布局，就是 Grid 布局的拿手好戏。</p><p>Grid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。</p><p>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。</p><h3 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h3><p>学习 Grid 布局之前，需要了解一些基本概念。</p><h4 id="2-1-容器和项目"><a href="#2-1-容器和项目" class="headerlink" title="2.1 容器和项目"></a>2.1 容器和项目</h4><p>采用网格布局的区域，称为”容器”（container）。容器内部采用网格定位的子元素，称为”项目”（item）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面代码中，最外层的<code>&lt;div&gt;</code>元素就是容器，内层的三个<code>&lt;div&gt;</code>元素就是项目。</p><p>注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的<code>&lt;p&gt;</code>元素就不是项目。Grid 布局只对项目生效。</p><h4 id="2-2-行和列"><a href="#2-2-行和列" class="headerlink" title="2.2 行和列"></a>2.2 行和列</h4><p>容器里面的水平区域称为”行”（row），垂直区域称为”列”（column）。<br><img src="/imageO/gird2.jpg" alt="效果"></p><p>上图中，水平的深色区域就是”行”，垂直的深色区域就是”列”。</p><h4 id="2-3-单元格"><a href="#2-3-单元格" class="headerlink" title="2.3 单元格"></a>2.3 单元格</h4><p>行和列的交叉区域，称为”单元格”（cell）。</p><p>正常情况下，n行和m列会产生n x m个单元格。比如，3行3列会产生9个单元格。</p><h4 id="2-4-网格线"><a href="#2-4-网格线" class="headerlink" title="2.4 网格线"></a>2.4 网格线</h4><p>划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。</p><p>正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线，比如三行就有四根水平网格线。<br><img src="/imageO/gird3.jpg" alt="效果"></p><p>上图是一个 4 x 4 的网格，共有5根水平网格线和5根垂直网格线。</p><h3 id="三、容器属性"><a href="#三、容器属性" class="headerlink" title="三、容器属性"></a>三、容器属性</h3><p>Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。</p><h4 id="3-1-display-属性"><a href="#3-1-display-属性" class="headerlink" title="3.1 display 属性"></a>3.1 display 属性</h4><p>display: grid指定一个容器采用网格布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/imageO/gird4.jpg" alt="网格"></p><p>上图是display: grid的效果。</p><p>默认情况下，容器元素都是块级元素，但也可以设成行内元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-grid;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码指定div是一个行内元素，该元素内部采用网格布局。</p><p><img src="/imageO/gird5.jpg" alt="行内"><br>上图是display: inline-grid的效果。</p><ul><li>注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</li></ul><h4 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h4><ol><li>grid-template-columns 属性，</li><li>grid-template-rows 属性<br>容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs applescript">  &lt;span&gt;foo&lt;/span&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item item-1&quot;</span>&gt;<span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item item-2&quot;</span>&gt;<span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item item-3&quot;</span>&gt;<span class="hljs-number">3</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item item-4&quot;</span>&gt;<span class="hljs-number">4</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item item-5&quot;</span>&gt;<span class="hljs-number">5</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item item-6&quot;</span>&gt;<span class="hljs-number">6</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item item-7&quot;</span>&gt;<span class="hljs-number">7</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item item-8&quot;</span>&gt;<span class="hljs-number">8</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item item-9&quot;</span>&gt;<span class="hljs-number">9</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;span&gt;bar&lt;/span&gt;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;  <span class="hljs-comment">//列</span><br>  grid-template-rows: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;  <span class="hljs-comment">//行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码指定了一个三行三列的网格，列宽和行高都是100px。</p><p><img src="/imageO/gird6.jpg" alt="行内"></p><p>除了使用绝对单位，也可以使用百分比。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mel">.<span class="hljs-keyword">container</span> &#123;<br>  display: <span class="hljs-keyword">grid</span>;<br>  <span class="hljs-keyword">grid</span>-template-columns: <span class="hljs-number">33.33</span>% <span class="hljs-number">33.33</span>% <span class="hljs-number">33.33</span>%;<br>  <span class="hljs-keyword">grid</span>-template-rows: <span class="hljs-number">33.33</span>% <span class="hljs-number">33.33</span>% <span class="hljs-number">33.33</span>%;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（1）repeat"><a href="#（1）repeat" class="headerlink" title="（1）repeat()"></a>（1）repeat()</h4><p>有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用repeat()函数，简化重复的值。上面的代码用repeat()改写如下。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">33.33%</span>);<br>  grid-template-rows: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">33.33%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>repeat()接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。</p></li><li><p>repeat()重复某种模式也是可以的。</p></li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">grid</span>-template-columns: repeat(<span class="hljs-number">2</span>, <span class="hljs-number">100</span>px <span class="hljs-number">20</span>px <span class="hljs-number">80</span>px);<br></code></pre></td></tr></table></figure><p>上面代码定义了6列，第一列和第四列的宽度为100px，第二列和第五列为20px，第三列和第六列为80px。<br><img src="/imageO/gird7.jpg" alt="repeat"></p><h4 id="（2）auto-fill-关键字"><a href="#（2）auto-fill-关键字" class="headerlink" title="（2）auto-fill 关键字"></a>（2）auto-fill 关键字</h4><p>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-number">100px</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面代码表示每列宽度100px，然后自动填充，直到容器不能放置更多的列。</p><p><img src="/imageO/gird8.jpg" alt="fill"></p><h4 id="（3）fr-关键字"><a href="#（3）fr-关键字" class="headerlink" title="（3）fr 关键字"></a>（3）fr 关键字</h4><p>为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码表示两个相同宽度的列。</p><p><img src="/imageO/gird9.jpg" alt="fr"></p><p>fr可以与绝对长度的单位结合使用，这时会非常方便。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-number">150px</span> <span class="hljs-number">1</span>fr <span class="hljs-number">2</span>fr;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面代码表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。</p><p><img src="/imageO/gird10.jpg" alt="fr"></p><h4 id="（4）minmax"><a href="#（4）minmax" class="headerlink" title="（4）minmax()"></a>（4）minmax()</h4><p>minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">grid</span>-template-columns: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr minmax(<span class="hljs-number">100</span>px, <span class="hljs-number">1</span>fr);<br></code></pre></td></tr></table></figure><p>上面代码中，minmax(100px, 1fr)表示列宽不小于100px，不大于1fr。</p><h4 id="（5）auto-关键字"><a href="#（5）auto-关键字" class="headerlink" title="（5）auto 关键字"></a>（5）auto 关键字</h4><p>auto关键字表示由浏览器自己决定长度。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">grid</span>-template-columns: <span class="hljs-number">100</span>px auto <span class="hljs-number">100</span>px;<br></code></pre></td></tr></table></figure><p>上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度。</p><h4 id="（6）网格线的名称"><a href="#（6）网格线的名称" class="headerlink" title="（6）网格线的名称"></a>（6）网格线的名称</h4><p>grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">.<span class="hljs-keyword">container</span> &#123;<br>  display: grid;<br>  grid-template-columns: <span class="hljs-comment">[c1]</span> 100px <span class="hljs-comment">[c2]</span> 100px <span class="hljs-comment">[c3]</span> auto <span class="hljs-comment">[c4]</span>;<br>  grid-template-rows: <span class="hljs-comment">[r1]</span> 100px <span class="hljs-comment">[r2]</span> 100px <span class="hljs-comment">[r3]</span> auto <span class="hljs-comment">[r4]</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。</p><p>网格布局允许同一根线有多个名字，比如[fifth-line row-5]。</p><h4 id="（7）布局实例"><a href="#（7）布局实例" class="headerlink" title="（7）布局实例"></a>（7）布局实例</h4><p>grid-template-columns属性对于网页布局非常有用。两栏式布局只需要一行代码。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;<br>  display: grid;<br>  grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: <span class="hljs-number">70</span>% <span class="hljs-number">30</span>%;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码将左边栏设为70%，右边栏设为30%。</p><p>传统的十二网格布局，写起来也很容易。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">12</span>, <span class="hljs-number">1</span>fr);<br></code></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">阮一峰—CSS Grid 网格布局教程</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>前端基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三数之和&amp;&amp;最接近的三数之和&amp;&amp;四数之和(排序+头尾双指针)</title>
    <link href="/2021/12/05/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0(3)/"/>
    <url>/2021/12/05/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0(3)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p>三数之和：<br>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。<br>示例 1：<br>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]</p><p>示例 2：<br>输入：nums = []<br>输出：[]</p><p>示例 3：<br>输入：nums = [0]<br>输出：[]</p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><h5 id="1-方法1-暴力求解，对于三个数字，循环3次，分别计算和，时间复杂度O-n-3"><a href="#1-方法1-暴力求解，对于三个数字，循环3次，分别计算和，时间复杂度O-n-3" class="headerlink" title="1. 方法1.暴力求解，对于三个数字，循环3次，分别计算和，时间复杂度O(n^3)"></a>1. 方法1.暴力求解，对于三个数字，循环3次，分别计算和，时间复杂度O(n^3)</h5><h5 id="2-方法2-c-a-b-确定了a和b，那就可以想两数之和一样，在map中寻找-a-b-，减少一层循环，时间复杂度O-n-2-，空间复杂度O-n"><a href="#2-方法2-c-a-b-确定了a和b，那就可以想两数之和一样，在map中寻找-a-b-，减少一层循环，时间复杂度O-n-2-，空间复杂度O-n" class="headerlink" title="2. 方法2.c=-(a+b): 确定了a和b，那就可以想两数之和一样，在map中寻找-(a+b)，减少一层循环，时间复杂度O(n^2)，空间复杂度O(n)"></a>2. 方法2.c=-(a+b): 确定了a和b，那就可以想两数之和一样，在map中寻找-(a+b)，减少一层循环，时间复杂度O(n^2)，空间复杂度O(n)</h5><h5 id="3-方法3-排序然后查找"><a href="#3-方法3-排序然后查找" class="headerlink" title="3. 方法3.排序然后查找"></a>3. 方法3.排序然后查找</h5><p>思路：先排序数组，数组长度必须大于3，循环数组，假如当前循环到了i索引，则定义两个指针L = i+1，和R = nums.length-1,如果和sum=nums[i] + nums[L] + nums[R]小于0，则向右移动左指针，如果sum大于0，则左移右指针，如果sum等于0，则正好找到了这3个数，然后在尝试L++,R–，继续寻找中间是否有三个数之和等于0，注意在循环的过程中遇见相同的三个数需要去重。</p><p>注：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 去重（当前数字等于前一个数字则跳出循环）<br><span class="hljs-regexp">//</span> <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span> || nums[i] !== nums[i - <span class="hljs-number">1</span>]) <br><span class="hljs-regexp">//</span> 如果不加这个判断则输出为：有重复的数组<br><span class="hljs-regexp">//</span> Finished<br><span class="hljs-regexp">//</span> Your Input<br><span class="hljs-regexp">//</span> [-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">4</span>]<br><span class="hljs-regexp">//</span> Output (<span class="hljs-number">64</span> ms)<br><span class="hljs-regexp">//</span> [[-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<br><span class="hljs-regexp">//</span> Expected Answer<br><span class="hljs-regexp">//</span> [[-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">var threeSum = <span class="hljs-keyword">function</span> (nums) &#123;<br>  const result = [];<br>  // 对数组进行升序排序<br>  nums.sort(<span class="hljs-keyword">function</span> (a, b) &#123;<br>    <span class="hljs-keyword">return</span> a - b;<br>  &#125;)<br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>    // 去重（当前数字等于前一个数字则跳出循环）<br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span> || nums[i] !== nums[i - <span class="hljs-number">1</span>]) &#123;<br>      let start = i + <span class="hljs-number">1</span>; end = nums.length - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">start</span> &lt; <span class="hljs-keyword">end</span>) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] + nums[<span class="hljs-keyword">start</span>] + nums[<span class="hljs-keyword">end</span>] === <span class="hljs-number">0</span>) &#123;<br>          // push到数组中<br>          result.push([nums[i], nums[<span class="hljs-keyword">start</span>], nums[<span class="hljs-keyword">end</span>]]);<br>          <span class="hljs-keyword">start</span>++;<br>          <span class="hljs-keyword">end</span><span class="hljs-comment">--;</span><br>          // 去重<br>          <span class="hljs-keyword">while</span> (<span class="hljs-keyword">start</span> &lt; <span class="hljs-keyword">end</span> &amp;&amp; nums[<span class="hljs-keyword">start</span>] === nums[<span class="hljs-keyword">start</span> - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">start</span>++;<br>          &#125;<br>          <span class="hljs-keyword">while</span> (<span class="hljs-keyword">start</span> &lt; <span class="hljs-keyword">end</span> &amp;&amp; nums[<span class="hljs-keyword">end</span>] === nums[<span class="hljs-keyword">end</span> + <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">end</span>++;<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[<span class="hljs-keyword">start</span>] + nums[<span class="hljs-keyword">end</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">start</span>++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">end</span><span class="hljs-comment">--;</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>复杂度分析：时间复杂度O(n^2)，n为数组的长度。空间复杂度O(logn)，即排序所需要的空间</p></blockquote><h3 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和</h3><p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。<br>返回这三个数的和。<br>假定每组输入只存在恰好一个解。<br>示例 1：<br>输入：nums = [-1,2,1,-4], target = 1<br>输出：2<br>解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</p><p>示例 2：<br>输入：nums = [0,0,0], target = 1<br>输出：0</p><h4 id="解法：固定一个数，再双指针-与三数之和解法相似"><a href="#解法：固定一个数，再双指针-与三数之和解法相似" class="headerlink" title="解法：固定一个数，再双指针(与三数之和解法相似)"></a>解法：固定一个数，再双指针(与三数之和解法相似)</h4><p> 思路</p><ol><li>先将数组从小到大排序，便于微调 sum 的大小。</li><li>从左到右遍历，先固定一个数，剩下的部分，用头尾双指针扫描</li><li>如果 sum 大于目标值，就右指针左移，使 sum 变小，否则左指针右移，sum 变大。</li><li>再看 abs(sum - target) 是否比之前更小了，如果是，将当前 sum 更新给 res<br>遍历结束，就有了最接近目标值的 sum</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">var</span> threeSumClosest = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;<br>nums.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>a-b)<br><span class="hljs-keyword">let</span> res  =nums[<span class="hljs-number">0</span>]+nums[<span class="hljs-number">1</span>]+nums[nums.length-<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span>  i=<span class="hljs-number">0</span>;i&lt;nums.length-<span class="hljs-number">2</span>;i++)&#123;<br>  <span class="hljs-keyword">const</span>   n1=nums[i];<br>  <span class="hljs-keyword">let</span>  l=i+<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> r  =nums.length-<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    <span class="hljs-keyword">const</span>  n2  = nums[l]<br>    <span class="hljs-keyword">const</span>   n3  = nums[r]<br>    <span class="hljs-keyword">const</span>   sum  = n1+n2+n3;<br>    <span class="hljs-keyword">if</span>(sum  &gt;target)&#123;<br>      r--<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      l++<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Math</span>.abs(sum-target)&lt;<span class="hljs-built_in">Math</span>.abs(res-target))&#123;<br>      res=sum;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">return</span>   res;<br>&#125;;<br><br></code></pre></td></tr></table></figure><blockquote><p>Math.abs(x) 函数返回指定数字 “x“ 的绝对值。传入一个非数字形式的字符串或者 undefined/empty 变量，将返回 NaN。传入 null 将返回 0。</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(&#x27;-<span class="hljs-number">1</span>&#x27;);     <span class="hljs-comment">// 1</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs<span class="hljs-number">(-2)</span>;       <span class="hljs-comment">// 2</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(null);     <span class="hljs-comment">// 0</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(<span class="hljs-string">&quot;string&quot;</span>); <span class="hljs-comment">// NaN</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs<span class="hljs-literal">()</span>;         <span class="hljs-comment">// NaN</span><br><br></code></pre></td></tr></table></figure><blockquote><p>复杂度分析：时间复杂度O(n^2)，n为数组的长度。空间复杂度O(logn)，即排序所需要的空间</p></blockquote><h3 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h3><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p><p>0 &lt;= a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] == target<br>你可以按 任意顺序 返回答案 。<br>示例 1：<br>输入：nums = [1,0,-1,0,-2,2], target = 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</p><p>示例 2：<br>输入：nums = [2,2,2,2,2], target = 8<br>输出：[[2,2,2,2]]</p><h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><p>思路同三数之和，注意是双重循环，注意如何去重</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> fourSum = function(nums, target) &#123;<br>    nums.<span class="hljs-built_in">sort</span>((a,b)=&gt;a-b);<br>    const  res=[];<br>    // 双层循环，外层循环一次，里面循环执行全部<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">let</span>  i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">length</span>-<span class="hljs-number">3</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">let</span>  j=i+<span class="hljs-number">1</span>;j&lt;nums.<span class="hljs-built_in">length</span>-<span class="hljs-number">2</span>;j++)&#123;<br>            <span class="hljs-built_in">let</span>  low  =j+<span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">let</span>  <span class="hljs-built_in">height</span>=nums.<span class="hljs-built_in">length</span>-<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(low&lt;<span class="hljs-built_in">height</span>)&#123;<br>                    const  <span class="hljs-built_in">sum</span>=nums[i]+nums[j]+nums[low]+nums[<span class="hljs-built_in">height</span>];<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span>===target)&#123;<br>                        res.<span class="hljs-built_in">push</span>([nums[i],nums[j],nums[low],nums[<span class="hljs-built_in">height</span>]])<br>                        <span class="hljs-keyword">while</span>(nums[low]===nums[low+<span class="hljs-number">1</span>]  )  low++;<br>                        <span class="hljs-keyword">while</span>(nums[<span class="hljs-built_in">height</span>]===nums[<span class="hljs-built_in">height</span>-<span class="hljs-number">1</span>])  <span class="hljs-built_in">height</span>--;<br>                        low++;<br>                        <span class="hljs-built_in">height</span>--;<br>                    &#125;<span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span>&lt;target)&#123;<br>                        low++<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-built_in">height</span>--;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">while</span>(nums[j]  ===nums[j+<span class="hljs-number">1</span>] )  j++;<br>        &#125;   <br>        <span class="hljs-keyword">while</span>(nums[i]===nums[i+<span class="hljs-number">1</span>])   i++;<br>    &#125;<br>    <span class="hljs-built_in">return</span>   res;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://leetcode-cn.com/problems/3sum/solution/15-san-shu-zhi-he-by-chen-wei-f-9odz/">LeetCode-Solution–三数之和</a></p>]]></content>
    
    
    <categories>
      
      <category>js算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js算法学习</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寻找两个正序数组的中位数-4(hard)</title>
    <link href="/2021/12/02/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0(2)/"/>
    <url>/2021/12/02/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0(2)/</url>
    
    <content type="html"><![CDATA[<p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。<br>算法的时间复杂度应该为 O(log (m+n)) 。<br>示例 1：<br>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2<br>示例 2：<br>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5<br>示例 3：<br>输入：nums1 = [0,0], nums2 = [0,0]<br>输出：0.00000<br>示例 4：<br>输入：nums1 = [], nums2 = [1]<br>输出：1.00000<br>示例 5：<br>输入：nums1 = [2], nums2 = []<br>输出：2.00000</p><hr><h3 id="方法一：暴力解法"><a href="#方法一：暴力解法" class="headerlink" title="方法一：暴力解法"></a>方法一：暴力解法</h3><p>简单粗暴，先将两个数组合并，两个有序数组的合并也是归并排序中的一部分。然后根据奇数，还是偶数，返回中位数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findMedianSortedArrays = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums1, nums2</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> p1 = nums1;<br>  <span class="hljs-keyword">let</span> p2 = nums2;<br>  <span class="hljs-keyword">let</span> p3 = [...p1, ...p2]; <span class="hljs-comment">//ES6新语法很好用，p3得出来的是拼接后的数组</span><br>  <span class="hljs-keyword">let</span> p4 = p3.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">//进行从小到大排序</span><br>  n = p4.length;<br>  <span class="hljs-keyword">if</span> (!p4) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//若长度不能被2整除则为奇数，去获取他的中位数</span><br>      <span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(n / <span class="hljs-number">2</span>)<br>      <span class="hljs-keyword">return</span> p4[i]<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//若长度为偶数，寻找中间两个数字除2就为答案啦</span><br>      <span class="hljs-keyword">let</span> j = <span class="hljs-built_in">Math</span>.floor(n / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">return</span> ((p4[j] + p4[j + <span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>)<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>时间复杂度：遍历全部数组 (m+n)(m+n),   空间复杂度：开辟了一个数组，保存合并后的两个数组 O(m+n)O(m+n)</p></blockquote><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/">LeetCode-Solution</a></p>]]></content>
    
    
    <categories>
      
      <category>js算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js算法学习</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数之和--暴力解法&amp;&amp;哈希解法</title>
    <link href="/2021/12/01/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0(1)/"/>
    <url>/2021/12/01/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0(1)/</url>
    
    <content type="html"><![CDATA[<p>题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案。<br>示例 1：<br>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<br>示例 2：<br>输入：nums = [3,2,4], target = 6<br>输出：[1,2]<br>示例 3：<br>输入：nums = [3,3], target = 6<br>输出：[0,1]</p><hr><h3 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a>方法一：暴力枚举</h3><p>最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。</p><p>当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。</p><p>我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> twoSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br>      <span class="hljs-keyword">if</span> (nums[i] === target - nums[j]) &#123;<br>        <span class="hljs-keyword">return</span> [i, j]<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> []<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>两次for循环进行遍历，时间复杂度：O（N^2）,空间复杂度:O(1)</p></blockquote><h3 id="方法二：哈希表-map中的has和set-get方法使用"><a href="#方法二：哈希表-map中的has和set-get方法使用" class="headerlink" title="方法二：哈希表(map中的has和set,get方法使用)"></a>方法二：哈希表(map中的has和set,get方法使用)</h3><p>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)O(1)。</p><p>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p><ol><li>Set类似于数组，但是它里面每一项的值是唯一的，没有重复的值，Set是一个构造函数，用来生成set的数据结构</li><li>Map类似于对象，也是键值对的集合，但是“键”的范围不限制于字符串，各种类型的值（包含对象）都可以当作键。Map 也可以接受一个数组作为参数，数组的成员是一个个表示键值对的数组。注意Map里面也不可以放重复的项。let map = new Map([[‘js’,’react’]]);</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">var</span> twoSum = <span class="hljs-keyword">function</span> (nums, target) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">map</span>.has(target - nums[i])) &#123;<br>      <span class="hljs-keyword">return</span> [<span class="hljs-keyword">map</span>.get(target - nums[i]), i]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">map</span>.set(nums[i], i)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> []<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>时间复杂度：O（N），空间复杂度O（N）</p></blockquote><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/">LeetCode-Solution</a></p>]]></content>
    
    
    <categories>
      
      <category>js算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js算法学习</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>源码学习---一行代码统一规范团队包管理器的神器(only-allow)</title>
    <link href="/2021/11/30/%5B%E6%BA%90%E7%A0%81%5D%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0--only-allow(1)/"/>
    <url>/2021/11/30/%5B%E6%BA%90%E7%A0%81%5D%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0--only-allow(1)/</url>
    
    <content type="html"><![CDATA[<p>场景：团队开发项目时，常常需要安装依赖，虽然一般使用文档可以说明。但不是比较强制的约束。(之前遇到一个项目在同事电脑安装依赖能运行，而我电脑安装依赖却跑不起来。后面发现是由于我node和npm的版本引起的安装依赖和运行项目失败了<a href="https://www.cnblogs.com/wangtong111/p/11861055.html">参考解决链接</a>)。假如规定是用的npm,团队中的某个同学使用其他包管理工具进行依赖的安装，且提交了。那么很大可能会直接影响到同时在该分支工作的其他同学，带来不必要的精力损耗。这时候我们可以借助工具(代码)来强制约束。</p><p>其中 Vue3 源码用了 npm 的 preinstall 钩子 约束，只能使用 pnpm 安装依赖。我们接着来看其实现：</p><hr><h3 id="Vue3-源码-amp-amp-npm-命令钩子"><a href="#Vue3-源码-amp-amp-npm-命令钩子" class="headerlink" title="Vue3 源码 &amp;&amp; npm 命令钩子"></a>Vue3 源码 &amp;&amp; npm 命令钩子</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// vue-next/package.json</span><br>&#123;<br>  <span class="hljs-attr">&quot;private&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;3.2.22&quot;</span>,<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;preinstall&quot;</span>: <span class="hljs-string">&quot;node ./scripts/preinstall.js&quot;</span>,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vala">依次执行<br><span class="hljs-meta"># install 之前执行这个脚本</span><br>preinstall<br><span class="hljs-meta"># 执行 install 脚本</span><br>install<br><span class="hljs-meta"># install 之后执行这个脚本</span><br>postinstall<br></code></pre></td></tr></table></figure><p>当然也支持自定义的命令。更多可以查看<a href="https://docs.npmjs.com/cli/v6/using-npm/scripts#pre--post-scripts">官方文档钩子</a></p><ul><li>接着我们来看 <a href="https://github1s.com/vuejs/vue-next/blob/HEAD/scripts/preinstall.js">preinstall</a> 源码。</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> vue-<span class="hljs-keyword">next</span><span class="hljs-regexp">/scripts/</span>preinstall.js<br><br><span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/pnpm/</span>.test(process.env.npm_execpath || <span class="hljs-string">&#x27;&#x27;</span>)) &#123;<br>  console.warn(<br>    `\u001b[<span class="hljs-number">33</span>mThis repository requires using pnpm as the package manager ` +<br>      ` <span class="hljs-keyword">for</span> scripts to work properly.\u001b[<span class="hljs-number">39</span>m\n`<br>  )<br>  process.<span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码也相对简单，校验如果不是 <code>pnpm</code>执行脚本则报错，退出进程。</p><p>关于 process 对象可以查看 阮一峰老师 <a href="http://javascript.ruanyifeng.com/nodejs/process.html">process 对象</a></p><blockquote><p>process.argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是 node，第二个成员是脚本文件名，其余成员是脚本文件的参数。</p></blockquote><p><img src="/imageO/29.png" alt="参考若川文章"></p><h3 id="环境准备：克隆代码"><a href="#环境准备：克隆代码" class="headerlink" title="环境准备：克隆代码"></a>环境准备：克隆代码</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 或者克隆官方仓库</span><br>git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/pnpm/</span>only-allow.git<br>cd only-allow<br><span class="hljs-comment"># npm i -g pnpm    (这行命令也要输入)</span><br>pnpm i<br></code></pre></td></tr></table></figure><p>Tips:开源项目一般先看<a href="https://github.com/pnpm/only-allow">README.md</a>。<br>readme</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs llvm">only-allow<br>Force a specific package manager <span class="hljs-keyword">to</span> be used on a project<br>强制在项目中使用特定的包管理器<br><br>Usage<br>Add a preinstall script <span class="hljs-keyword">to</span> your project&#x27;s package.json.<br><br>If you want <span class="hljs-keyword">to</span> force npm<span class="hljs-punctuation">,</span> <span class="hljs-keyword">add</span>:<br><br>&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;preinstall&quot;</span>: <span class="hljs-string">&quot;npx only-allow npm&quot;</span><br>  &#125;<br>&#125;<br>If you want <span class="hljs-keyword">to</span> force pnpm<span class="hljs-punctuation">,</span> <span class="hljs-keyword">add</span>:<br><br>&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;preinstall&quot;</span>: <span class="hljs-string">&quot;npx only-allow pnpm&quot;</span><br>  &#125;<br>&#125;<br>If you want <span class="hljs-keyword">to</span> force yarn<span class="hljs-punctuation">,</span> <span class="hljs-keyword">add</span>:<br><br>&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;preinstall&quot;</span>: <span class="hljs-string">&quot;npx only-allow yarn&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>目录结构：</p><p><img src="/imageO/28.png" alt="项目目录结构"></p><h3 id="调试源码"><a href="#调试源码" class="headerlink" title="调试源码"></a>调试源码</h3><p>查看 package.json 文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// only-allow/package.json</span><br>&#123;<br>  <span class="hljs-attr">&quot;bin&quot;</span>: <span class="hljs-string">&quot;bin.js&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>确定主入口文件为 only-allow/bin.js。</p><p>在最新版的 VSCode 中，auto attach 功能，默认支持智能调试，如果发现不支持，可以通过快捷键 ctrl + shift + p 查看是否启用。</p><p>于是我们在 only-allow/package.json 文件中，添加如下命令。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// only-allow/package.json</span><br>&#123;<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;preinstall&quot;</span>: <span class="hljs-string">&quot;node bin.js pnpm&quot;</span><br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>可以提前在 only-allow/bin.js 文件打上断点 const usedPM = whichPMRuns()</p><p><img src="/imageO/30.png" alt="打断点"></p><p>然后：<br>输入如下 yarn add release-it -D  (或者  npm  i) 命令，即可调试 only-allow/bin.js。</p><p>安装yarn可直接进入此电脑cmd输入安装命令:(npm install -g yarn)</p><p>查看版本：yarn –version<br><img src="/imageO/31.png" alt="输入命令"></p><h3 id="only-allow-源码"><a href="#only-allow-源码" class="headerlink" title="only-allow 源码"></a>only-allow 源码</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// only-allow/bin.js</span><br>#!/usr/bin/env node<br>const whichPMRuns = require(<span class="hljs-symbol">&#x27;which</span>-pm-runs&#x27;)<br>const boxen = require(<span class="hljs-symbol">&#x27;boxe</span>n&#x27;)<br><br>const argv = process.argv.slice(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">if</span> (argv.length === <span class="hljs-number">0</span>) &#123;<br>  console.log(<span class="hljs-symbol">&#x27;Please</span> specify the wanted <span class="hljs-keyword">package</span> manager: only-allow &lt;npm|pnpm|yarn&gt;&#x27;)<br>  process.exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-comment">// 第一个参数则是 用户传入的希望使用的包管理器</span><br><span class="hljs-comment">// 比如 npx only-allow pnpm </span><br><span class="hljs-comment">// 这里调试是 node bin.js pnpm</span><br>const wantedPM = argv[<span class="hljs-number">0</span>]<br><span class="hljs-comment">// npm pnpm yarn 都不是，则报错</span><br><span class="hljs-keyword">if</span> (wantedPM !== <span class="hljs-symbol">&#x27;np</span>m&#x27; &amp;&amp; wantedPM !== <span class="hljs-symbol">&#x27;pnp</span>m&#x27; &amp;&amp; wantedPM !== <span class="hljs-symbol">&#x27;yar</span>n&#x27;) &#123;<br>  console.log(`<span class="hljs-string">&quot;$&#123;wantedPM&#125;&quot;</span> is not a valid <span class="hljs-keyword">package</span> manager. <span class="hljs-type">Available</span> <span class="hljs-keyword">package</span> managers are: npm, pnpm, or yarn.`)<br>  process.exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-comment">// 使用的包管理器</span><br>const usedPM = whichPMRuns()<br><span class="hljs-comment">// 希望使用的包管理器 不相等，则报错。</span><br><span class="hljs-comment">// - npm  提示使用 npm install</span><br><span class="hljs-comment">// - pnpm 提示使用 pnpm install</span><br><span class="hljs-comment">// - yarn 提示使用 yarn install</span><br><span class="hljs-comment">// 最后退出进程</span><br><span class="hljs-keyword">if</span> (usedPM &amp;&amp; usedPM.name !== wantedPM) &#123;<br>  const boxenOpts = &#123; borderColor: <span class="hljs-symbol">&#x27;re</span>d&#x27;, borderStyle: <span class="hljs-symbol">&#x27;doubl</span>e&#x27;, padding: <span class="hljs-number">1</span> &#125;<br>  switch (wantedPM) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-symbol">&#x27;np</span>m&#x27;:<br>      console.log(boxen(<span class="hljs-symbol">&#x27;Use</span> <span class="hljs-string">&quot;npm install&quot;</span> <span class="hljs-keyword">for</span> installation in <span class="hljs-keyword">this</span> project&#x27;, boxenOpts))<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-symbol">&#x27;pnp</span>m&#x27;:<br>      console.log(boxen(`<span class="hljs-type">Use</span> <span class="hljs-string">&quot;pnpm install&quot;</span> <span class="hljs-keyword">for</span> installation in <span class="hljs-keyword">this</span> project.<br><br><span class="hljs-type">If</span> you don<span class="hljs-symbol">&#x27;t</span> have pnpm, install it via <span class="hljs-string">&quot;npm i -g pnpm&quot;</span>.<br><span class="hljs-type">For</span> more details, go to https:<span class="hljs-comment">//pnpm.js.org/`, boxenOpts))</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-symbol">&#x27;yar</span>n&#x27;:<br>      console.log(boxen(`<span class="hljs-type">Use</span> <span class="hljs-string">&quot;yarn&quot;</span> <span class="hljs-keyword">for</span> installation in <span class="hljs-keyword">this</span> project.<br><br><span class="hljs-type">If</span> you don<span class="hljs-symbol">&#x27;t</span> have <span class="hljs-type">Yarn</span>, install it via <span class="hljs-string">&quot;npm i -g yarn&quot;</span>.<br><span class="hljs-type">For</span> more details, go to https:<span class="hljs-comment">//yarnpkg.com/`, boxenOpts))</span><br>      <span class="hljs-keyword">break</span><br>  &#125;<br>  process.exit(<span class="hljs-number">1</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过本文，我们了解了 npm 的脚本钩子和 process 的简单应用。only-allow 通过获取系统环境运行时的信息，和预设好的参数信息进行对比，来限制预期外包管理器的使用。</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/7033560885050212389?share_token=999a177b-d1e2-4e96-8c8e-c9f5ff186f7c#heading-6">从 vue3 和 vite 源码中，我学到了一行代码统一规范团队包管理器的神器</a></p>]]></content>
    
    
    <categories>
      
      <category>源码学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端进阶</tag>
      
      <tag>源码学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>玩转 Vue 3 全家桶--初始Vue3(1)</title>
    <link href="/2021/11/17/Vue3Study(1)/"/>
    <url>/2021/11/17/Vue3Study(1)/</url>
    
    <content type="html"><![CDATA[<p>2021 年的前端范畴已经今非昔比，从最早的做页面，到现在的工程化、监控、跨端，薪资水涨船高的同时，也对从业者提出了更高的要求：不能只会做页面，而是要全面地拥抱计算机知识体系，比如算法、设计模式、编译原理等计算机专业知识，这也是现在各大厂面试的主要考察点。对于这些考察点，只有一小部分面试者有过系统的学习，大部分面试者都只是零散地学习过其中的某些内容，也就是说前端这个岗位的断层其实非常严重。由于大学计算机专业不教系统性的前端开发课程，所以大部分前端工程师都跟我一样，是由兴趣和爱好驱动</p><p>以下是基于Vue全家桶的学习记录</p><hr><h3 id="现在很多前端工程师进阶困难的痛点就是，没有体系化的学"><a href="#现在很多前端工程师进阶困难的痛点就是，没有体系化的学" class="headerlink" title="现在很多前端工程师进阶困难的痛点就是，没有体系化的学"></a>现在很多前端工程师进阶困难的痛点就是，没有体系化的学</h3><p><strong>为了防止你的顿悟仅仅相当于别人的基础水平</strong>，我们需要体系化和系统化地探索前端开发这座冰山。这就意味着，我们学习的不仅仅是表面的增删改查，而是底层的工程化、框架，还有海底的计算机知识体系。</p><h3 id="为什么要学-Vue-3"><a href="#为什么要学-Vue-3" class="headerlink" title="为什么要学 Vue 3"></a>为什么要学 Vue 3</h3><p>在目前的前端开发中，流行的框架相信你并不陌生。它们的目标都是为了帮助开发者高效地开发 Web 应用，只不过走的路线略显不同，比如 <code>React 注重数据不可变、虚拟 DOM 和运行时；而 Svelte 运行时都非常轻量级，侧重在于编译时的优化；Angular 则在抽象这个维度又走向一个极致，生来就是为了复杂项目。</code></p><p>每个流行框架的内部，都有一大堆的最佳实践。而相比之下，Vue 就简单多了，简单到大部分前端开发者都能学得会。Vue 在每个维度之间，做了非常好的权衡和取舍，算是一个非常中庸且优雅的框架，兼顾响应式、虚拟 DOM、运行时和编译优化。</p><p>而且 Vue 3 作为 Vue 框架最新的版本，有很多优秀的设计相信你会非常喜欢，例如 Composition 组合 API、基于 Proxy 的响应式系统、自定义渲染器等。</p><p>这些设计可以让我们以很轻松的方式，从最熟悉的框架逐渐深入底层。学习 Vue 3 的同时，我们就可以去回顾 Vue 1 和 Vue 2，直观地感受 Vue 框架发展的过程。在此基础上，<strong>我们再去横向对比 Angular、React、Svelte 等框架，最终是可以把学到的知识点串成一个网络的。这不仅是加强记忆那么简单，还能大大开阔你的前端视野。</strong></p><p><img src="/image/vue3.1.png" alt="Vue和React的知识"></p><h3 id="学习Vue3"><a href="#学习Vue3" class="headerlink" title="学习Vue3"></a>学习Vue3</h3><p>全家桶实战篇–我们将主要学习 Vue 3 的⽣态，包括 Vue-cli、Vite、Vuex、Vue-router、Devtools 等生态库，以及实战开发中需要的库，比如 Vue 3 中集成 JSX、单元测试、服务端渲染 SSR。这⼀模块学完，我们就能全副武装，应对复杂的项⽬开发也就不成问题了。<br><img src="/image/vue3.2.png" alt="学习 Vue 3"></p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://time.geekbang.org/column/article/427605">开篇词 | 如何借助Vue 3建构你的前端知识体系？</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript 学习二</title>
    <link href="/2021/08/04/TS%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
    <url>/2021/08/04/TS%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="四、TypeScript-函数"><a href="#四、TypeScript-函数" class="headerlink" title="四、TypeScript 函数"></a>四、TypeScript 函数</h3><ol><li>TypeScript 函数与 JavaScript 函数的区别</li></ol><p><img src="/imageO/26.png" alt="如图"></p><ol start="2"><li>箭头函数</li></ol><p>1.常见语法</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">myBooks.forEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;reading&#x27;</span>));<br><br>myBooks.forEach(title =&gt; <span class="hljs-built_in">console</span>.log(title));<br><br>myBooks.forEach(<span class="hljs-function"><span class="hljs-params">(title, idx, arr)</span> =&gt;</span><br>  <span class="hljs-built_in">console</span>.log(idx + <span class="hljs-string">&#x27;-&#x27;</span> + title);<br>);<br><br>myBooks.forEach(<span class="hljs-function"><span class="hljs-params">(title, idx, arr)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(idx + <span class="hljs-string">&#x27;-&#x27;</span> + title);<br>&#125;);<br></code></pre></td></tr></table></figure><p>2.使用示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 未使用箭头函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Book</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> self = <span class="hljs-built_in">this</span>;<br>  self.publishDate = <span class="hljs-number">2016</span>;<br>  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(self.publishDate);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-comment">// 使用箭头函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Book</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.publishDate = <span class="hljs-number">2016</span>;<br>  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.publishDate);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>参数类型和返回类型</li></ol><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">function</span> createUserId<span class="hljs-built_in">(name</span>:<span class="hljs-built_in"> string</span>,<span class="hljs-built_in"> id</span>:<span class="hljs-built_in"> number</span>):<span class="hljs-built_in"> string</span> &#123;<br>  <span class="hljs-keyword">return</span><span class="hljs-built_in"> name</span> +<span class="hljs-built_in"> id</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>函数类型</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> IdGenerator:<span class="hljs-function"> (<span class="hljs-params">chars</span>: <span class="hljs-params">string</span>, <span class="hljs-params">nums</span>: <span class="hljs-params">number</span>) =&gt;</span> <span class="hljs-built_in">string</span>;<br><br><span class="hljs-keyword">function</span> create<span class="hljs-constructor">UserId(<span class="hljs-params">name</span>: <span class="hljs-params">string</span>, <span class="hljs-params">id</span>: <span class="hljs-params">number</span>)</span>: <span class="hljs-built_in">string</span> &#123;<br>  return name + id;<br>&#125;<br><br>IdGenerator = createUserId;<br></code></pre></td></tr></table></figure><ol start="5"><li>可选参数及默认参数</li></ol><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xquery">// 可选参数<br><span class="hljs-keyword">function</span> createUserId<span class="hljs-built_in">(name</span>:<span class="hljs-built_in"> string</span>,<span class="hljs-built_in"> id</span>:<span class="hljs-built_in"> number</span>, age?:<span class="hljs-built_in"> number</span>):<span class="hljs-built_in"> string</span> &#123;<br>  <span class="hljs-keyword">return</span><span class="hljs-built_in"> name</span> +<span class="hljs-built_in"> id</span>;<br>&#125;<br><br>// 默认参数<br><span class="hljs-keyword">function</span> createUserId(<br> <span class="hljs-built_in"> name</span>:<span class="hljs-built_in"> string</span> = <span class="hljs-string">&quot;Semlinker&quot;</span>,<br> <span class="hljs-built_in"> id</span>:<span class="hljs-built_in"> number</span>,<br>  age?:<span class="hljs-built_in"> number</span><br>):<span class="hljs-built_in"> string</span> &#123;<br>  <span class="hljs-keyword">return</span><span class="hljs-built_in"> name</span> +<span class="hljs-built_in"> id</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在声明函数时，可以通过 ? 号来定义可选参数，比如 age?: number 这种形式。在实际使用时，需要注意的是可选参数要放在普通参数的后面，不然会导致编译错误。</p><ol start="6"><li>剩余参数</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span><span class="hljs-params">(array, <span class="hljs-rest_arg">...items</span>)</span> </span>&#123;<br>  items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(item)</span> </span>&#123;<br>    array.push(item);<br>  &#125;);<br>&#125;<br><br>let a = [];<br>push(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><ol start="7"><li>函数重载</li></ol><p>函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。要解决前面遇到的问题，方法就是为同一个函数提供多个函数类型定义来进行函数重载，编译器会根据这个列表去处理函数的调用。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">add</span>(<span class="hljs-attribute">a</span>: number, <span class="hljs-attribute">b</span>: number): <span class="hljs-selector-tag">number</span>;<br><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">add</span>(<span class="hljs-attribute">a</span>: string, <span class="hljs-attribute">b</span>: string): <span class="hljs-selector-tag">string</span>;<br><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">add</span>(<span class="hljs-attribute">a</span>: string, <span class="hljs-attribute">b</span>: number): <span class="hljs-selector-tag">string</span>;<br><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">add</span>(<span class="hljs-attribute">a</span>: number, <span class="hljs-attribute">b</span>: string): <span class="hljs-selector-tag">string</span>;<br><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">add</span>(<span class="hljs-attribute">a</span>: Combinable, <span class="hljs-attribute">b</span>: Combinable) &#123;<br>  <span class="hljs-selector-tag">if</span> (typeof a === <span class="hljs-string">&quot;string&quot;</span> || typeof b === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.toString</span>() + <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.toString</span>();<br>  &#125;<br>  <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在以上代码中，我们为 add 函数提供了多个函数类型定义，从而实现函数的重载。之后，可恶的错误消息又消失了，因为这时 result 变量的类型是 string 类型。在 TypeScript 中除了可以重载普通函数之外，我们还可以重载类中的成员方法。</p><p>方法重载是指在同一个类中方法同名，参数不同（参数类型不同、参数个数不同或参数个数相同时参数的先后顺序不同），调用时根据实参的形式，选择与它匹配的方法执行操作的一种技术。所以类中成员方法满足重载的条件是：在同一个类中，方法名相同且参数列表不同。下面我们来举一个成员方法重载的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> </span>&#123;<br>  add(a: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;<br>  add(a: <span class="hljs-built_in">string</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;<br>  add(a: <span class="hljs-built_in">string</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>;<br>  add(a: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;<br>  <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">a: Combinable, b: Combinable</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&quot;string&quot;</span> || <span class="hljs-keyword">typeof</span> b === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>      <span class="hljs-keyword">return</span> a.toString() + b.toString();<br>    &#125;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> calculator = <span class="hljs-keyword">new</span> Calculator();<br><span class="hljs-keyword">const</span> result = calculator.add(<span class="hljs-string">&quot;Semlinker&quot;</span>, <span class="hljs-string">&quot; Kakuqo&quot;</span>);<br></code></pre></td></tr></table></figure><p>这里需要注意的是，当 TypeScript 编译器处理函数重载时，它会查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。另外在 Calculator 类中，add(a: Combinable, b: Combinable){ } 并不是重载列表的一部分，因此对于 add 成员方法来说，我们只定义了四个重载方法。</p><ol start="8"><li>ypeScript 数组</li></ol><p>8.1 数组解构</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">number</span>; <span class="hljs-keyword">let</span> y: <span class="hljs-built_in">number</span>; <span class="hljs-keyword">let</span> z: <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">let</span> five_array = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br>[x,y,z] = five_array;<br></code></pre></td></tr></table></figure><p>8.2 数组展开运算符</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">two_array</span> = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">five_array</span> = [...two_array, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br></code></pre></td></tr></table></figure><p>8.3 数组遍历</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> colors: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> i of colors) &#123;<br>  console.<span class="hljs-built_in">log</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="9"><li>TypeScript 对象</li></ol><p>9.1 对象解构</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">let</span> person = &#123;<br> <span class="hljs-built_in"> name</span>: <span class="hljs-string">&quot;Semlinker&quot;</span>,<br>  gender: <span class="hljs-string">&quot;Male&quot;</span>,<br>&#125;;<br><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-built_in"> name</span>, gender &#125; = person;<br></code></pre></td></tr></table></figure><p>9.2 对象展开运算符</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">let</span> person = &#123;<br>  name: <span class="hljs-string">&quot;Semlinker&quot;</span>,<br>  gender: <span class="hljs-string">&quot;Male&quot;</span>,<br>  address: <span class="hljs-string">&quot;Xiamen&quot;</span>,<br>&#125;;<br><br><span class="hljs-comment">// 组装对象</span><br><span class="hljs-keyword">let</span> personWithAge = &#123; <span class="hljs-params">...</span>person, age: <span class="hljs-number">33</span> &#125;;<br><br><span class="hljs-comment">// 获取除了某些项外的其它项</span><br><span class="hljs-keyword">let</span> &#123; name, <span class="hljs-params">...</span>rest &#125; = person;<br></code></pre></td></tr></table></figure><h3 id="五、TypeScript-接口"><a href="#五、TypeScript-接口" class="headerlink" title="五、TypeScript 接口"></a>五、TypeScript 接口</h3><p>在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。</p><p>TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。</p><p>10.1 对象的形状</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts">interface <span class="hljs-class">Person </span>&#123;<br><span class="hljs-symbol">  name:</span> string;<br><span class="hljs-symbol">  age:</span> number;<br>&#125;<br><br>let Semlinker: Person = &#123;<br><span class="hljs-symbol">  name:</span> <span class="hljs-string">&quot;Semlinker&quot;</span>,<br><span class="hljs-symbol">  age:</span> <span class="hljs-number">33</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>10.2 可选 | 只读属性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Person &#123;<br>  <span class="hljs-keyword">readonly</span> name: <span class="hljs-built_in">string</span>;<br>  age?: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScript 还提供了 ReadonlyArray<T> 类型，它与 Array<T> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">let a: number[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>let ro: ReadonlyArray&lt;number&gt; = a;<br>ro[<span class="hljs-number">0</span>] = <span class="hljs-number">12</span>; <span class="hljs-regexp">//</span> error!<br>ro.push(<span class="hljs-number">5</span>); <span class="hljs-regexp">//</span> error!<br>ro.length = <span class="hljs-number">100</span>; <span class="hljs-regexp">//</span> error!<br>a = ro; <span class="hljs-regexp">//</span> error!<br><br></code></pre></td></tr></table></figure><h3 id="六、TypeScript-类"><a href="#六、TypeScript-类" class="headerlink" title="六、TypeScript 类"></a>六、TypeScript 类</h3><p>11.1 类的属性与方法<br>在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。</p><p>在 TypeScript 中，我们可以通过 Class 关键字来定义一个类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeter</span> </span>&#123;<br>  <span class="hljs-comment">// 静态属性</span><br>  <span class="hljs-keyword">static</span> cname: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;Greeter&quot;</span>;<br>  <span class="hljs-comment">// 成员属性</span><br>  greeting: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-comment">// 构造函数 - 执行初始化操作</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.greeting = message;<br>  &#125;<br><br>  <span class="hljs-comment">// 静态方法</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getClassName</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Class name is Greeter&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 成员方法</span><br>  <span class="hljs-function"><span class="hljs-title">greet</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-built_in">this</span>.greeting;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> greeter = <span class="hljs-keyword">new</span> Greeter(<span class="hljs-string">&quot;world&quot;</span>);<br></code></pre></td></tr></table></figure><p>那么成员属性与静态属性，成员方法与静态方法有什么区别呢？这里无需过多解释，我们直接看一下以下编译生成的 ES5 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">var</span> Greeter = <span class="hljs-comment">/** <span class="hljs-doctag">@class </span>*/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 构造函数 - 执行初始化操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeter</span>(<span class="hljs-params">message</span>) </span>&#123;<br>        <span class="hljs-built_in">this</span>.greeting = message;<br>    &#125;<br>    <span class="hljs-comment">// 静态方法</span><br>    Greeter.getClassName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Class name is Greeter&quot;</span>;<br>    &#125;;<br>    <span class="hljs-comment">// 成员方法</span><br>    Greeter.prototype.greet = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-built_in">this</span>.greeting;<br>    &#125;;<br>    <span class="hljs-comment">// 静态属性</span><br>    Greeter.cname = <span class="hljs-string">&quot;Greeter&quot;</span>;<br>    <span class="hljs-keyword">return</span> Greeter;<br>&#125;());<br><span class="hljs-keyword">var</span> greeter = <span class="hljs-keyword">new</span> Greeter(<span class="hljs-string">&quot;world&quot;</span>);<br></code></pre></td></tr></table></figure><p>11.2 访问器<br>在 TypeScript 中，我们可以通过 getter 和 setter 方法来实现数据的封装和有效性校验，防止出现异常数据。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> passcode = <span class="hljs-string">&quot;Hello TypeScript&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> _fullName: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">fullName</span>(): <span class="hljs-title">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._fullName;<br>  &#125;<br><br>  <span class="hljs-keyword">set</span> <span class="hljs-title">fullName</span>(<span class="hljs-params">newName: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (passcode &amp;&amp; passcode == <span class="hljs-string">&quot;Hello TypeScript&quot;</span>) &#123;<br>      <span class="hljs-built_in">this</span>._fullName = newName;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Error: Unauthorized update of employee!&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> employee = <span class="hljs-keyword">new</span> Employee();<br>employee.fullName = <span class="hljs-string">&quot;Semlinker&quot;</span>;<br><span class="hljs-keyword">if</span> (employee.fullName) &#123;<br>  <span class="hljs-built_in">console</span>.log(employee.fullName);<br>&#125;<br></code></pre></td></tr></table></figure><p>11.3 类的继承<br>继承 (Inheritance) 是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。</p><p>继承是一种 is-a 关系：</p><p>在 TypeScript 中，我们可以通过 extends 关键字来实现继承：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  <br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = theName;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-title">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Snake</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name);<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-title">move</span>(<span class="hljs-params">distanceInMeters = <span class="hljs-number">5</span></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Slithering...&quot;</span>);<br>    <span class="hljs-built_in">super</span>.move(distanceInMeters);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> sam = <span class="hljs-keyword">new</span> Snake(<span class="hljs-string">&quot;Sammy the Python&quot;</span>);<br>sam.move();<br></code></pre></td></tr></table></figure><p>11.4 ECMAScript 私有字段<br>在 TypeScript 3.8 版本就开始支持ECMAScript 私有字段，使用方式如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  #name: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.#name = name;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">greet</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.#name&#125;</span>!`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> semlinker = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Semlinker&quot;</span>);<br><br>semlinker.#name;<br><span class="hljs-comment">//     ~~~~~</span><br><span class="hljs-comment">// Property &#x27;#name&#x27; is not accessible outside class &#x27;Person&#x27;</span><br><span class="hljs-comment">// because it has a private identifier.</span><br></code></pre></td></tr></table></figure><p>与常规属性（甚至使用 private 修饰符声明的属性）不同，私有字段要牢记以下规则：</p><ul><li>私有字段以 # 字符开头，有时我们称之为私有名称；</li><li>每个私有字段名称都唯一地限定于其包含的类；</li><li>不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）；</li><li>私有字段不能在包含的类之外访问，甚至不能被检测到。</li></ul><h3 id="七、TypeScript-泛型"><a href="#七、TypeScript-泛型" class="headerlink" title="七、TypeScript 泛型"></a>七、TypeScript 泛型</h3><p>软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p><blockquote><p>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p></blockquote><p>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。</p><p>泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。</p><p>12.1 泛型接口</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span> <span class="hljs-symbol">GenericIdentityFn</span>&lt;<span class="hljs-symbol">T</span>&gt; &#123;<br>  (arg: T): T;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>12.2 泛型类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericNumber</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  zeroValue: T;<br>  add: <span class="hljs-function">(<span class="hljs-params">x: T, y: T</span>) =&gt;</span> T;<br>&#125;<br><br><span class="hljs-keyword">let</span> myGenericNumber = <span class="hljs-keyword">new</span> GenericNumber&lt;<span class="hljs-built_in">number</span>&gt;();<br>myGenericNumber.zeroValue = <span class="hljs-number">0</span>;<br>myGenericNumber.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br></code></pre></td></tr></table></figure><p>12.3 泛型变量</p><p>对刚接触 TypeScript 泛型的小伙伴来说，看到 T 和 E，还有 K 和 V 这些泛型变量时，估计会一脸懵逼。其实这些大写字母并没有什么本质的区别，只不过是一个约定好的规范而已。也就是说使用大写字母 A-Z 定义的类型变量都属于泛型，把 T 换成 A，也是一样的。下面我们介绍一下一些常见泛型变量代表的意思：</p><ul><li>在T（Type）：表示一个 TypeScript 类型</li><li>K（Key）：表示对象中的键类型</li><li>V（Value）：表示对象中的值类型</li><li>E（Element）：表示元素类型</li></ul><p>12.4 泛型工具类型<br>为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。出于篇幅考虑，这里我们只简单介绍 Partial 工具类型。不过在具体介绍之前，我们得先介绍一些相关的基础知识，方便读者自行学习其它的工具类型。</p><p>1.typeof</p><p>在 TypeScript 中，typeof 操作符可以用来获取一个变量声明或对象的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Person &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  age: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> sem: Person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;semlinker&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br><span class="hljs-keyword">type</span> Sem= <span class="hljs-keyword">typeof</span> sem; <span class="hljs-comment">// -&gt; Person</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toArray</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">Array</span>&lt;<span class="hljs-title">number</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">return</span> [x];<br>&#125;<br><br><span class="hljs-keyword">type</span> Func = <span class="hljs-keyword">typeof</span> toArray; <span class="hljs-comment">// -&gt; (x: number) =&gt; number[]</span><br></code></pre></td></tr></table></figure><p>2.keyof</p><p>keyof 操作符可以用来一个对象中的所有 key 值：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">interface Person &#123;<br>    name: <span class="hljs-keyword">string</span>;<br>    age: <span class="hljs-keyword">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> K1 = keyof Person; // <span class="hljs-string">&quot;name&quot;</span> | <span class="hljs-string">&quot;age&quot;</span><br><span class="hljs-keyword">type</span> K2 = keyof Person[]; // <span class="hljs-string">&quot;length&quot;</span> | <span class="hljs-string">&quot;toString&quot;</span> | <span class="hljs-string">&quot;pop&quot;</span> | <span class="hljs-string">&quot;push&quot;</span> | <span class="hljs-string">&quot;concat&quot;</span> | <span class="hljs-string">&quot;join&quot;</span><br><span class="hljs-keyword">type</span> K3 = keyof &#123; [x: <span class="hljs-keyword">string</span>]: Person &#125;;  // <span class="hljs-keyword">string</span> | <span class="hljs-keyword">number</span><br></code></pre></td></tr></table></figure><p>3.in</p><p>in 用来遍历枚举类型：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">type</span> <span class="hljs-type">Keys</span> = <span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-string">&quot;c&quot;</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-type">Obj</span> =  &#123;<br>  [p <span class="hljs-keyword">in</span> <span class="hljs-type">Keys</span>]: <span class="hljs-built_in">any</span><br>&#125; // -&gt; &#123; a: <span class="hljs-built_in">any</span>, b: <span class="hljs-built_in">any</span>, c: <span class="hljs-built_in">any</span> &#125;<br></code></pre></td></tr></table></figure><p>4.infer</p><p>在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">type</span> ReturnType&lt;T&gt; = T <span class="hljs-keyword">extends</span> (<br>  ...args: <span class="hljs-built_in">any</span>[]<br>) =&gt; infer R ? R : <span class="hljs-built_in">any</span>;<br></code></pre></td></tr></table></figure><p>以上代码中 infer R 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。</p><p>5.extends</p><p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">interface</span> ILengthwise &#123;<br>  length: <span class="hljs-keyword">number</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span></span> loggingIdentity&lt;T <span class="hljs-keyword">extends</span> ILengthwise&gt;(arg: T): T &#123;<br>  console.<span class="hljs-built_in">log</span>(arg.length);<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">loggingIdentity</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// Error, number doesn&#x27;t have a .length property</span><br></code></pre></td></tr></table></figure><p>这时我们需要传入符合约束类型的值，必须包含必须的属性：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">logging<span class="hljs-constructor">Identity(&#123;<span class="hljs-params">length</span>: 10, <span class="hljs-params">value</span>: 3&#125;)</span>;<br></code></pre></td></tr></table></figure><p>6.Partial</p><p>Partial<T> 的作用就是将某个类型里的属性全部变为可选项 ?。</p><p>定义：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs elm">/**<br><br>* node_modules/typescript/lib/lib.es5.d.ts<br>* <span class="hljs-type">Make</span> all properties <span class="hljs-keyword">in</span> <span class="hljs-type">T</span> optional<br> */<br><span class="hljs-keyword">type</span> <span class="hljs-type">Partial</span>&lt;<span class="hljs-type">T</span>&gt; = &#123;<br>  [<span class="hljs-type">P</span> in keyof <span class="hljs-type">T</span>]?: <span class="hljs-type">T</span>[<span class="hljs-type">P</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>在以上代码中，首先通过 keyof T 拿到 T 的所有属性名，然后使用 in 进行遍历，将值赋给 P，最后通过 T[P] 取得相应的属性值。中间的 ? 号，用于将所有属性变为可选。</p><p>示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Todo &#123;<br>  title: <span class="hljs-built_in">string</span>;<br>  description: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateTodo</span>(<span class="hljs-params">todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123; ...todo, ...fieldsToUpdate &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> todo1 = &#123;<br>  title: <span class="hljs-string">&quot;organize desk&quot;</span>,<br>  description: <span class="hljs-string">&quot;clear clutter&quot;</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> todo2 = updateTodo(todo1, &#123;<br>  description: <span class="hljs-string">&quot;throw out trash&quot;</span>,<br>&#125;);<br><br>在上面的 updateTodo 方法中，我们利用 Partial&lt;T&gt; 工具类型，定义 fieldsToUpdate 的类型为 Partial&lt;Todo&gt;，即：<br><br>&#123;<br>   title?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;<br>   description?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="八、TypeScript-装饰器"><a href="#八、TypeScript-装饰器" class="headerlink" title="八、TypeScript 装饰器"></a>八、TypeScript 装饰器</h3><p>13.1 装饰器是什么</p><ul><li>它是一个表达式</li><li>该表达式被执行后，返回一个函数</li><li>函数的入参分别为 target、name 和 descriptor</li><li>执行该函数后，可能返回 descriptor 对象，用于配置 target 对象</li></ul><p>13.2 装饰器的分类</p><ul><li>类装饰器（Class decorators）</li><li>属性装饰器（Property decorators）</li><li>方法装饰器（Method decorators）</li><li>参数装饰器（Parameter decorators）</li></ul><p>13.3 类装饰器<br>类装饰器声明：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">declare</span> type ClassDecorator = &lt;TFunction <span class="hljs-keyword">extends</span> <span class="hljs-function"><span class="hljs-keyword">Function</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  target: TFunction</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) =&gt;</span> TFunction | <span class="hljs-keyword">void</span>;<br></code></pre></td></tr></table></figure><p>类装饰器顾名思义，就是用来装饰类的。它接收一个参数：</p><ul><li>target: TFunction - 被装饰的类<br>看完第一眼后，是不是感觉都不好了。没事，我们马上来个例子：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeter</span>(<span class="hljs-params">target: <span class="hljs-built_in">Function</span></span>): <span class="hljs-title">void</span> </span>&#123;<br>  target.prototype.greet = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello Semlinker!&quot;</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-meta">@Greeter</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeting</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 内部实现</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> myGreeting = <span class="hljs-keyword">new</span> Greeting();<br>myGreeting.greet(); <span class="hljs-comment">// console output: &#x27;Hello Semlinker!&#x27;;</span><br></code></pre></td></tr></table></figure><p>上面的例子中，我们定义了 Greeter 类装饰器，同时我们使用了 @Greeter 语法糖，来使用装饰器。</p><blockquote><p>友情提示：读者可以直接复制上面的代码，在 TypeScript Playground 中运行查看结果。</p></blockquote><p>有的读者可能想问，例子中总是输出 Hello Semlinker! ，能自定义输出的问候语么 ？这个问题很好，答案是可以的。</p><p>具体实现如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeter</span>(<span class="hljs-params">greeting: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target: <span class="hljs-built_in">Function</span></span>) </span>&#123;<br>    target.prototype.greet = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(greeting);<br>    &#125;;<br>  &#125;;<br>&#125;<br><br><span class="hljs-meta">@Greeter</span>(<span class="hljs-string">&quot;Hello TS!&quot;</span>)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeting</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 内部实现</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> myGreeting = <span class="hljs-keyword">new</span> Greeting();<br>myGreeting.greet(); <span class="hljs-comment">// console output: &#x27;Hello TS!&#x27;;</span><br></code></pre></td></tr></table></figure><p>13.4 属性装饰器<br>属性装饰器声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">type</span> PropertyDecorator = (target:<span class="hljs-built_in">Object</span>,<br>  propertyKey: <span class="hljs-built_in">string</span> | symbol ) =&gt; <span class="hljs-built_in">void</span>;<br></code></pre></td></tr></table></figure><p>属性装饰器顾名思义，用来装饰类的属性。它接收两个参数：</p><p>target: Object - 被装饰的类<br>propertyKey: string | symbol - 被装饰类的属性名<br>趁热打铁，马上来个例子热热身：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logProperty</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, key: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">delete</span> target[key];<br><br>  <span class="hljs-keyword">const</span> backingField = <span class="hljs-string">&quot;_&quot;</span> + key;<br><br>  <span class="hljs-built_in">Object</span>.defineProperty(target, backingField, &#123;<br>    writable: <span class="hljs-literal">true</span>,<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span><br>  &#125;);<br><br>  <span class="hljs-comment">// property getter</span><br>  <span class="hljs-keyword">const</span> getter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">this</span>: <span class="hljs-built_in">any</span></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> currVal = <span class="hljs-built_in">this</span>[backingField];<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Get: <span class="hljs-subst">$&#123;key&#125;</span> =&gt; <span class="hljs-subst">$&#123;currVal&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> currVal;<br>  &#125;;<br><br>  <span class="hljs-comment">// property setter</span><br>  <span class="hljs-keyword">const</span> setter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">this</span>: <span class="hljs-built_in">any</span>, newVal: <span class="hljs-built_in">any</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Set: <span class="hljs-subst">$&#123;key&#125;</span> =&gt; <span class="hljs-subst">$&#123;newVal&#125;</span>`</span>);<br>    <span class="hljs-built_in">this</span>[backingField] = newVal;<br>  &#125;;<br><br>  <span class="hljs-comment">// Create new property with getter and setter</span><br>  <span class="hljs-built_in">Object</span>.defineProperty(target, key, &#123;<br>    get: getter,<br>    set: setter,<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span><br>  &#125;);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-meta">@logProperty</span><br>  <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name : <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;semlinker&quot;</span>);<br>p1.name = <span class="hljs-string">&quot;kakuqo&quot;</span>;<br></code></pre></td></tr></table></figure><p>以上代码我们定义了一个 logProperty 函数，来跟踪用户对属性的操作，当代码成功运行后，在控制台会输出以下结果：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Set: <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> semlinker<br>Set: <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> kakuqo<br></code></pre></td></tr></table></figure><p>13.5 方法装饰器<br>方法装饰器声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">type</span> MethodDecorator = &lt;T&gt;(target:<span class="hljs-built_in">Object</span>, <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span> | symbol,<br>  descriptor: TypePropertyDescript&lt;T&gt;) =&gt; TypedPropertyDescriptor&lt;T&gt; | <span class="hljs-built_in">void</span>;<br></code></pre></td></tr></table></figure><p>方法装饰器顾名思义，用来装饰类的方法。它接收三个参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs typescript">target: <span class="hljs-built_in">Object</span> - 被装饰的类<br>propertyKey: <span class="hljs-built_in">string</span> | symbol - 方法名<br>descriptor: TypePropertyDescript - 属性描述符<br>废话不多说，直接上例子：<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LogOutput</span>(<span class="hljs-params">tarage: <span class="hljs-built_in">Function</span>, key: <span class="hljs-built_in">string</span>, descriptor: <span class="hljs-built_in">any</span></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> originalMethod = descriptor.value;<br>  <span class="hljs-keyword">let</span> newMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>): <span class="hljs-title">any</span> </span>&#123;<br>    <span class="hljs-keyword">let</span> result: <span class="hljs-built_in">any</span> = originalMethod.apply(<span class="hljs-built_in">this</span>, args);<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.loggedOutput) &#123;<br>      <span class="hljs-built_in">this</span>.loggedOutput = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;();<br>    &#125;<br>    <span class="hljs-built_in">this</span>.loggedOutput.push(&#123;<br>      method: key,<br>      parameters: args,<br>      output: result,<br>      timestamp: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>    &#125;);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br>  descriptor.value = newMethod;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> </span>&#123;<br>  <span class="hljs-meta">@LogOutput</span><br>  double (num: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> num * <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> calc = <span class="hljs-keyword">new</span> Calculator();<br>calc.double(<span class="hljs-number">11</span>);<br><span class="hljs-comment">// console ouput: [&#123;method: &quot;double&quot;, output: 22, ...&#125;]</span><br><span class="hljs-built_in">console</span>.log(calc.loggedOutput);<br><br>下面我们来介绍一下参数装饰器。<br></code></pre></td></tr></table></figure><p>13.6 参数装饰器<br>参数装饰器声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">type</span> ParameterDecorator = (target: <span class="hljs-built_in">Object</span>, <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span> | symbol,<br>  parameterIndex: <span class="hljs-built_in">number</span> ) =&gt; <span class="hljs-built_in">void</span><br></code></pre></td></tr></table></figure><p>参数装饰器顾名思义，是用来装饰函数参数，它接收三个参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript">target: <span class="hljs-built_in">Object</span> - 被装饰的类<br>propertyKey: <span class="hljs-built_in">string</span> | symbol - 方法名<br>parameterIndex: <span class="hljs-built_in">number</span> - 方法中参数的索引值<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Log</span>(<span class="hljs-params">target: <span class="hljs-built_in">Function</span>, key: <span class="hljs-built_in">string</span>, parameterIndex: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> functionLogged = key || target.prototype.constructor.name;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`The parameter in position <span class="hljs-subst">$&#123;parameterIndex&#125;</span> at <span class="hljs-subst">$&#123;functionLogged&#125;</span> has</span><br><span class="hljs-string"> been decorated`</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeter</span> </span>&#123;<br>  greeting: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-meta">@Log</span> phrase: <span class="hljs-built_in">string</span></span>)</span> &#123;<br> <span class="hljs-built_in">this</span>.greeting = phrase;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// console output: The parameter in position 0</span><br><span class="hljs-comment">// at Greeter has been decorated</span><br></code></pre></td></tr></table></figure><p>介绍完 TypeScript 入门相关的基础知识，猜测很多刚入门的小伙伴已有 “从入门到放弃” 的想法，最后我们来简单介绍一下编译上下文。</p><h3 id="九、编译上下文"><a href="#九、编译上下文" class="headerlink" title="九、编译上下文"></a>九、编译上下文</h3><p>14.1 tsconfig.json 的作用</p><ul><li>用于标识 TypeScript 项目的根路径；</li><li>用于配置 TypeScript 编译器；</li><li>用于指定编译的文件。</li></ul><p>14.2 tsconfig.json 重要字段</p><ul><li>files - 设置要编译的文件的名称；</li><li>include - 设置需要进行编译的文件，支持路径模式匹配；</li><li>exclude - 设置无需进行编译的文件，支持路径模式匹配；</li><li>compilerOptions - 设置与编译流程相关的选项。</li></ul><p>14.3 compilerOptions 选项</p><p>compilerOptions 支持很多选项，常见的有 baseUrl、 target、baseUrl、 moduleResolution 和 lib 等。</p><p>compilerOptions 每个选项的详细说明如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span>: &#123;<br><br>    <span class="hljs-comment">/* 基本选项 */</span><br>    <span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;es5&quot;</span>,                       <span class="hljs-comment">// 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES6&#x27;/&#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span><br>    <span class="hljs-attr">&quot;module&quot;</span>: <span class="hljs-string">&quot;commonjs&quot;</span>,                  <span class="hljs-comment">// 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span><br>    <span class="hljs-attr">&quot;lib&quot;</span>: [],                             <span class="hljs-comment">// 指定要包含在编译中的库文件</span><br>    <span class="hljs-attr">&quot;allowJs&quot;</span>: <span class="hljs-literal">true</span>,                       <span class="hljs-comment">// 允许编译 javascript 文件</span><br>    <span class="hljs-attr">&quot;checkJs&quot;</span>: <span class="hljs-literal">true</span>,                       <span class="hljs-comment">// 报告 javascript 文件中的错误</span><br>    <span class="hljs-attr">&quot;jsx&quot;</span>: <span class="hljs-string">&quot;preserve&quot;</span>,                     <span class="hljs-comment">// 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span><br>    <span class="hljs-attr">&quot;declaration&quot;</span>: <span class="hljs-literal">true</span>,                   <span class="hljs-comment">// 生成相应的 &#x27;.d.ts&#x27; 文件</span><br>    <span class="hljs-attr">&quot;sourceMap&quot;</span>: <span class="hljs-literal">true</span>,                     <span class="hljs-comment">// 生成相应的 &#x27;.map&#x27; 文件</span><br>    <span class="hljs-attr">&quot;outFile&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 将输出文件合并为一个文件</span><br>    <span class="hljs-attr">&quot;outDir&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                        <span class="hljs-comment">// 指定输出目录</span><br>    <span class="hljs-attr">&quot;rootDir&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 用来控制输出目录结构 --outDir.</span><br>    <span class="hljs-attr">&quot;removeComments&quot;</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 删除编译后的所有的注释</span><br>    <span class="hljs-attr">&quot;noEmit&quot;</span>: <span class="hljs-literal">true</span>,                        <span class="hljs-comment">// 不生成输出文件</span><br>    <span class="hljs-attr">&quot;importHelpers&quot;</span>: <span class="hljs-literal">true</span>,                 <span class="hljs-comment">// 从 tslib 导入辅助工具函数</span><br>    <span class="hljs-attr">&quot;isolatedModules&quot;</span>: <span class="hljs-literal">true</span>,               <span class="hljs-comment">// 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span><br><br>    <span class="hljs-comment">/* 严格的类型检查选项 */</span><br>    <span class="hljs-attr">&quot;strict&quot;</span>: <span class="hljs-literal">true</span>,                        <span class="hljs-comment">// 启用所有严格类型检查选项</span><br>    <span class="hljs-attr">&quot;noImplicitAny&quot;</span>: <span class="hljs-literal">true</span>,                 <span class="hljs-comment">// 在表达式和声明上有隐含的 any类型时报错</span><br>    <span class="hljs-attr">&quot;strictNullChecks&quot;</span>: <span class="hljs-literal">true</span>,              <span class="hljs-comment">// 启用严格的 null 检查</span><br>    <span class="hljs-attr">&quot;noImplicitThis&quot;</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span><br>    <span class="hljs-attr">&quot;alwaysStrict&quot;</span>: <span class="hljs-literal">true</span>,                  <span class="hljs-comment">// 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span><br><br>    <span class="hljs-comment">/* 额外的检查 */</span><br>    <span class="hljs-attr">&quot;noUnusedLocals&quot;</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 有未使用的变量时，抛出错误</span><br>    <span class="hljs-attr">&quot;noUnusedParameters&quot;</span>: <span class="hljs-literal">true</span>,            <span class="hljs-comment">// 有未使用的参数时，抛出错误</span><br>    <span class="hljs-attr">&quot;noImplicitReturns&quot;</span>: <span class="hljs-literal">true</span>,             <span class="hljs-comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span><br>    <span class="hljs-attr">&quot;noFallthroughCasesInSwitch&quot;</span>: <span class="hljs-literal">true</span>,    <span class="hljs-comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span><br><br>    <span class="hljs-comment">/* 模块解析选项 */</span><br>    <span class="hljs-attr">&quot;moduleResolution&quot;</span>: <span class="hljs-string">&quot;node&quot;</span>,            <span class="hljs-comment">// 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span><br>    <span class="hljs-attr">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 用于解析非相对模块名称的基目录</span><br>    <span class="hljs-attr">&quot;paths&quot;</span>: &#123;&#125;,                           <span class="hljs-comment">// 模块名到基于 baseUrl 的路径映射的列表</span><br>    <span class="hljs-attr">&quot;rootDirs&quot;</span>: [],                        <span class="hljs-comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span><br>    <span class="hljs-attr">&quot;typeRoots&quot;</span>: [],                       <span class="hljs-comment">// 包含类型声明的文件列表</span><br>    <span class="hljs-attr">&quot;types&quot;</span>: [],                           <span class="hljs-comment">// 需要包含的类型声明文件名列表</span><br>    <span class="hljs-attr">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 允许从没有设置默认导出的模块中默认导入。</span><br><br>    <span class="hljs-comment">/* Source Map Options */</span><br>    <span class="hljs-attr">&quot;sourceRoot&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                    <span class="hljs-comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span><br>    <span class="hljs-attr">&quot;mapRoot&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span><br>    <span class="hljs-attr">&quot;inlineSourceMap&quot;</span>: <span class="hljs-literal">true</span>,               <span class="hljs-comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span><br>    <span class="hljs-attr">&quot;inlineSources&quot;</span>: <span class="hljs-literal">true</span>,                 <span class="hljs-comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span><br><br>    <span class="hljs-comment">/* 其他选项 */</span><br>    <span class="hljs-attr">&quot;experimentalDecorators&quot;</span>: <span class="hljs-literal">true</span>,        <span class="hljs-comment">// 启用装饰器</span><br>    <span class="hljs-attr">&quot;emitDecoratorMetadata&quot;</span>: <span class="hljs-literal">true</span>          <span class="hljs-comment">// 为装饰器提供元数据的支持</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h4><p><a href="https://juejin.cn/post/6844904182843965453#heading-28">1.2W字 | 了不起的 TypeScript 入门教程</a></p>]]></content>
    
    
    <categories>
      
      <category>TS学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>TS学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript 入门</title>
    <link href="/2021/08/03/TS%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/08/03/TS%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>ts的优缺点</p><p>1、优点<br>代码的可读性和可维护性：举个🌰看后端某个接口返回值，一般需要去network看or去看接口文档，才知道返回数据结构，而正确用了ts后，编辑器会提醒接口返回值的类型，这点相当实用。</p><p>在编译阶段就发现大部分错误，避免了很多线上bug</p><p>增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等</p><p>2、缺点<br>有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念</p><p>会增加一些开发成本，当然这是前期的，后期维护更简单了</p><p>一些JavaScript库需要兼容，提供声明文件，像vue2，底层对ts的兼容就不是很好。</p><p>ts编译是需要时间的，这就意味着项目大了以后，开发环境启动和生产环境打包的速度就成了考验<br>可以看看<a href="https://www.infoq.cn/article/u72qtztgazttfazzihbz">Deno 内部代码将停用 TypeScript，并公布五项具体理由</a></p><hr><h3 id="Typescript-是什么？"><a href="#Typescript-是什么？" class="headerlink" title="Typescript 是什么？"></a>Typescript 是什么？</h3><p><img src="/imageO/23.png" alt="如图"></p><ul><li>Typescript 是 JavaScript 的超集，两者是所属关系。</li><li>Typescript 是 JavaScript 的增强，包含 JavaScript 的最新特性，非常适合创建大型项目</li><li>Typescript 是静态语言与动态语言 JavaScript 不同，TS 是和 JS 都是弱类型语言</li><li>Typescript 也是前端的趋势，各大著名的前端框架都使用了 TS 重构，如 Vue, React 等</li></ul><h3 id="下载安装及使用"><a href="#下载安装及使用" class="headerlink" title="下载安装及使用"></a>下载安装及使用</h3><ul><li>本地环境需要先下载 node vscode，随后打开 vscode 终端，使用 npm install -g typescript 即可</li><li>tsc -v 查看版本号，这份教程是最新的 typescript 4.0</li><li>建议安装 TSlint 插件规范代码</li><li>编写 TS 文件代码，使用 tsc xx.ts 命令运行 ts 文件，运行 ts 文件后会生成相应的 js 文件，这个 js 文件时 tsc 将 xx.ts 代码编译成 xx.js的代码</li><li>tsc  –watch  xx.ts 自动监测编译代码</li></ul><h3 id="动态语言和静态语言的差别"><a href="#动态语言和静态语言的差别" class="headerlink" title="动态语言和静态语言的差别"></a>动态语言和静态语言的差别</h3><ul><li>静态语言在编写代码的时候就能发现潜在的错误.</li><li>静态语言更容易读懂代码，像上面的data参数静态语言能直接读出里面的属性 x, y，但是动态语言参数 data 显然不能直接读出里面包含什么属性。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// TS</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tsFunc</span> (<span class="hljs-params">data: &#123;x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>&#125;</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;demo ts&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.sqrt(data.x ** <span class="hljs-number">2</span> + data.y ** <span class="hljs-number">2</span>)<br>&#125;<br><br><span class="hljs-comment">// tsFunc()  // 没有传入参数，这里的代码 vscode 会提示错误,这就是静态语言在编写代码的时候就可以知道有错误。</span><br>tsFunc(&#123;<span class="hljs-attr">x</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">4</span>&#125;)  <span class="hljs-comment">//需要将参数代码一起写入。</span><br><br><span class="hljs-comment">// 再比如传入参数的个数，ts 能直接检测，但是生成的 js 文件不能检测</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">param</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> param<br>&#125;<br><br>get(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><br>get(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// error: 应有 1 个参数，但获得 2 个</span><br></code></pre></td></tr></table></figure><p>编写代码时静态语言能识别到可能使用到的属性等,但动态语言不一定能提示的正确。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 静态类型和动态类型的差别，静态类型在编写代码时就可以发现错误像C++,Java等，动态类型的语言则需要代码运行时才可以知道错误，像JavaScript，python。<br><span class="hljs-regexp">//</span> js-code<br><br><span class="hljs-keyword">function</span> jsFunc (data) &#123;<br>    return Math.sqrt(x ** <span class="hljs-number">2</span> + y ** <span class="hljs-number">2</span>)<br>&#125;<br><br>jsFunc()  <span class="hljs-regexp">//</span> 没有传入参数，但这里的代码 vscode不会提示错误，但实际运行会发生报错。<br><br></code></pre></td></tr></table></figure><h3 id="二-静态类型"><a href="#二-静态类型" class="headerlink" title="二. 静态类型"></a>二. 静态类型</h3><h4 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h4><h6 id="就像前面看到的那样静态类型可以是基础类型-number-string-null-undefined-symbol-boolean-void-enum-还可以是对象类型-Object，Array-class-function，还可以是自定义类型-interface-或任何类型-any-等详情-typescript官网"><a href="#就像前面看到的那样静态类型可以是基础类型-number-string-null-undefined-symbol-boolean-void-enum-还可以是对象类型-Object，Array-class-function，还可以是自定义类型-interface-或任何类型-any-等详情-typescript官网" class="headerlink" title="就像前面看到的那样静态类型可以是基础类型 number string null undefined symbol boolean void enum 还可以是对象类型 Object，Array, class, function，还可以是自定义类型 interface 或任何类型 any 等详情 typescript官网"></a>就像前面看到的那样静态类型可以是基础类型 number string null undefined symbol boolean void enum 还可以是对象类型 Object，Array, class, function，还可以是自定义类型 interface 或任何类型 any 等详情 typescript官网</h6><ul><li>定义为相应类型后可以直接使用对应类型的方法或属性如 number,vscode 直接提示</li></ul><p><img src="/imageO/24.png" alt="如图"></p><p>类型属性提示</p><p>. 基础类型 number string null undefined symbol boolean any void never。。。</p><ul><li>number 类型</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">const</span> num: <span class="hljs-built_in">number</span> = <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><ul><li>string 类型</li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">const</span> <span class="hljs-keyword">Name</span>: <span class="hljs-keyword">string</span> = <span class="hljs-string">&#x27;LinYY&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>boolean 类型</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">const</span> <span class="hljs-keyword">boolean</span>: <span class="hljs-keyword">Boolean</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ul><li>null 类型 。null 类型不可以赋值给 undefined 类型和 联合类型（后面介绍）</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> n: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><ul><li>undefined 类型</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> u: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><p>undefined 类型。可以作用到可选类型，因为可选的类型默认会有一个undefined 类型</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">interface</span> <span class="hljs-string">E</span> &#123;<br>    <span class="hljs-attr">b:</span> <span class="hljs-string">number</span><br>    <span class="hljs-string">c?:</span> <span class="hljs-string">number</span><br>&#125;<br><br><span class="hljs-attr">let e:</span> <span class="hljs-string">E</span> <span class="hljs-string">=</span> &#123;<span class="hljs-attr">b:</span> <span class="hljs-number">12</span>, <span class="hljs-attr">c:</span> <span class="hljs-number">12</span>&#125;<br><br><span class="hljs-string">e</span> <span class="hljs-string">=</span> &#123;<span class="hljs-attr">b:</span> <span class="hljs-number">23</span>, <span class="hljs-attr">c:</span> <span class="hljs-string">undefined</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>any 类型。已经定义变量的类型不能再修改，否则报错。<br>注意 any 类型，any 类型定义后可以修改为其他的类型</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// any 类型可以修改成其他任何类型，TS 不对 any 类型作类型检测</span><br><span class="hljs-keyword">let</span> not: <span class="hljs-built_in">any</span><br>not = <span class="hljs-number">2</span><br>not = <span class="hljs-string">&#x27;2&#x27;</span><br>not = <span class="hljs-literal">true</span><br><br><span class="hljs-comment">// 处理不确定的数组类型 any 比较合适。</span><br><span class="hljs-keyword">let</span> listArr: <span class="hljs-built_in">any</span>[] = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>]<br></code></pre></td></tr></table></figure><ul><li>void 类型 和 any 类型相反，表示没有任何类型</li></ul><blockquote><p>void 类型 通常作用在函数中代表没有返回值，虽然也可以作为其他变量的类型，但只能赋值成 undefined。换一个方向想函数总是有返回值的，如果不是一个确定的值那么就是 undefined 值，所以 void 其实是属于 undefined 的，所以一个变量类型是 void 时，值只能 undefined 值。但是 不能将类型“void”分配给类型“undefined”详情看例子</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// void 空类型，一般用于函数，</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noReturn</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;no value return&#x27;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;<br>    <span class="hljs-comment">// Error</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>  &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn5</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;<br>&#125;<br><span class="hljs-keyword">let</span> un: <span class="hljs-literal">undefined</span> = fn5(); <span class="hljs-comment">// Error 不能将类型“void”分配给类型“undefined”</span><br><br><span class="hljs-keyword">let</span> voidValue: <span class="hljs-keyword">void</span> = <span class="hljs-literal">undefined</span><br><span class="hljs-keyword">let</span> voidValue2: <span class="hljs-keyword">void</span> = <span class="hljs-literal">null</span>   <span class="hljs-comment">// 不能将类型“null”分配给类型“void”</span><br></code></pre></td></tr></table></figure><ul><li>never 一个特殊类型。简单的说如果函数是一个永远不会执行完的函数，返回值就是 never 类型，像函数 errorFunc，abs。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// never 类型，不会执行结束的函数类型</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">errorFunc</span>(<span class="hljs-params"></span>): <span class="hljs-title">never</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>()<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;never&#x27;</span>)    <span class="hljs-comment">// 抛出错误后 这段代码不打印。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">abs</span>(<span class="hljs-params"></span>): <span class="hljs-title">never</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;never&#x27;</span>)    <span class="hljs-comment">// 上面的代码永远是true 这段代码不打印。</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对象类型 object type。object {}，array [], class {}， function</li></ul><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">let</span> person: &#123;<br>   <span class="hljs-built_in"> name</span>:<span class="hljs-built_in"> string</span>,<br>    age:<span class="hljs-built_in"> number</span><br>&#125; = &#123;<br>   <span class="hljs-built_in"> name</span>: <span class="hljs-string">&#x27;LinYY&#x27;</span>,<br>    age: <span class="hljs-number">12</span><br>&#125;<br><br>// 或 (不推荐写法)<br><span class="hljs-keyword">let</span> personB:<span class="hljs-built_in">&#123;name</span>:<span class="hljs-built_in"> string</span>&#125; &amp; &#123;age:<span class="hljs-built_in"> number</span>&#125; = &#123;<br>   <span class="hljs-built_in"> name</span>: <span class="hljs-string">&#x27;LinYY&#x27;</span>,<br>    age: <span class="hljs-number">12</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>数组类型 也是对象类型，下面声明number型数组只能写入数字来初始化，写入字符串将会报错。</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">const</span> list: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">12</span>, <span class="hljs-number">23</span>, <span class="hljs-number">34</span>]<br><br>//等同于，下面的数组泛型，泛型是什么之后会讲，先留一个印象。<br><span class="hljs-keyword">const</span> listA: Array&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br>// <span class="hljs-keyword">const</span> listB: <span class="hljs-built_in">number</span>[] = [<span class="hljs-string">&#x27;12&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-number">34</span>]<br></code></pre></td></tr></table></figure><ul><li>class类 类型</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;&#125;<br>const LinYY: <span class="hljs-type">Person  </span>= <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>()<br></code></pre></td></tr></table></figure><ul><li>function 函数类型, 下面的函数类型要求返回值是 number 数字类型，写成其他类型如 string 会报错。</li></ul><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">const <span class="hljs-name">getNumber</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> number = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    // <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;LinYY&#x27;</span>   报错<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">123</span><br>&#125;<br><br>// 要求返回值是<span class="hljs-built_in">string</span> 字符类型<br>const <span class="hljs-name">getString</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">string</span> = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;LinYY&#x27;</span><br>    // <span class="hljs-keyword">return</span> <span class="hljs-number">123</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>interface 自定义类型，也就是接口</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts">interface <span class="hljs-class">Point </span>&#123;<br><span class="hljs-symbol">    x:</span> number,<br><span class="hljs-symbol">    y:</span> number<br>&#125;<br><br>const point: Point = &#123;<br><span class="hljs-symbol">    x:</span> <span class="hljs-number">2</span>,<br><span class="hljs-symbol">    y:</span> <span class="hljs-number">4</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>多类型。变量的类型可以有多个，比如可以是 number 或 string类型</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">// 变量的类型可以有多个，比如可以是<span class="hljs-keyword">number</span>或<span class="hljs-keyword">string</span>类型。<br>let temp: <span class="hljs-keyword">number</span> | <span class="hljs-keyword">string</span> = <span class="hljs-number">23</span><br>temp = &#x27;<span class="hljs-number">23</span>&#x27;<br><br><span class="hljs-keyword">type</span> alias 类型别名，类型别名不是 TS 的基本数据类型，类型别名常用于提取公共类型，下面 interface 接口会详细介绍<br><span class="hljs-keyword">type</span> <span class="hljs-keyword">User</span> <span class="hljs-title">= &#123; name</span>: <span class="hljs-keyword">string</span>, age: <span class="hljs-keyword">number</span> &#125;<br>let male: <span class="hljs-keyword">User</span> <span class="hljs-title">= &#123;name</span>: &#x27;LinYY&#x27;, age: <span class="hljs-number">18</span>&#125;<br>let famale: <span class="hljs-keyword">User</span> <span class="hljs-title">= &#123;name</span>: &#x27;nana&#x27;, age: <span class="hljs-number">18</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="小-tip"><a href="#小-tip" class="headerlink" title="小 tip"></a>小 tip</h4><p>注释小技巧tip: 使用 /** */ 可以给类型添加更友好的提示</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// 注释</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* this is good Per</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-symbol">Per</span> &#123;<br>    name: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">const</span> p: Per =&#123;<br>    name: <span class="hljs-string">&#x27;LinYY&#x27;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>在 typescript 里面 name 是一个预留关键字，不能直接当变量来用</p></blockquote><h3 id="三-类型注解和类型推断"><a href="#三-类型注解和类型推断" class="headerlink" title="三.类型注解和类型推断"></a>三.类型注解和类型推断</h3><h4 id="type-annotation-类型注解"><a href="#type-annotation-类型注解" class="headerlink" title="type annotation 类型注解"></a>type annotation 类型注解</h4><ul><li>直接声明的类型，告诉TS变量是什么类型。比如这里的 count 是 number 类型</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">// <span class="hljs-built_in">type</span> annotation 类型注解。<br><span class="hljs-keyword">let</span> coun<span class="hljs-variable">t:</span> <span class="hljs-keyword">number</span><br><span class="hljs-built_in">count</span> = <span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><h4 id="type-inference-类型推断"><a href="#type-inference-类型推断" class="headerlink" title="type inference 类型推断"></a>type inference 类型推断</h4><p>没有直接声明类型，TS 会尝试去分析变量类型，如这里的 countB，推断是 number 类型。（此处加图说明）<br><img src="/imageO/25.png" alt="如图"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">countB</span> = <span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><ul><li>但是声明的变量没有直接在一行赋值 TS 将默认变量为 any 类型，如这里的变量 countC，鼠标箭头移动到 countC 上方就可以看到类型。正确写法是加上类型注解。</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">let countC <span class="hljs-regexp">//</span> any 类型<br>countC = <span class="hljs-number">233</span><br></code></pre></td></tr></table></figure><h4 id="TS-并不能所有的类型都能推断出来，那么什么时候使用类型注解呢？具体情况需要具体分析"><a href="#TS-并不能所有的类型都能推断出来，那么什么时候使用类型注解呢？具体情况需要具体分析" class="headerlink" title="TS 并不能所有的类型都能推断出来，那么什么时候使用类型注解呢？具体情况需要具体分析"></a>TS 并不能所有的类型都能推断出来，那么什么时候使用类型注解呢？具体情况需要具体分析</h4><ul><li>一般简单的变量声明可以不写类型注解。如这里的 num1 num2 sum。TS 能直接判断。</li><li>一般函数的参数需要类型注解，返回值可以不用写类型注解，TS 能自动判断</li><li>已经有未确定的 any 类型，需要加类型注解，如 total 显示为 any,原因是类型 a b 不确定。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> num2 = <span class="hljs-number">2</span><br><span class="hljs-keyword">let</span> sum = num1 + num2 <span class="hljs-comment">// TS 推断出 sum 是 number 类型</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    name: <span class="hljs-string">&#x27;LinYY&#x27;</span>,<br>    age: <span class="hljs-number">18</span><br>&#125;<br><br><span class="hljs-comment">// obj.name = 23 // TS 推断出来的类型 同样不能再修改</span><br><br><span class="hljs-comment">// 需要类型注解</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSum</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-keyword">const</span> total = getSum(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h4 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h4><p><a href="https://juejin.cn/post/6927452747218288654#heading-7">【林一一】2021一份热乎的万字 TypeScript 教程(含4.0)</a></p>]]></content>
    
    
    <categories>
      
      <category>TS学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>TS学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器的回流与重绘</title>
    <link href="/2021/07/24/%E9%87%8D%E7%BB%98%E5%9B%9E%E6%B5%81/"/>
    <url>/2021/07/24/%E9%87%8D%E7%BB%98%E5%9B%9E%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="什么是回流？"><a href="#什么是回流？" class="headerlink" title="什么是回流？"></a>什么是回流？</h3><p>当一个元素自身的宽高，布局，显示或隐藏，或元素内部的文字结构发生变化，导致需要重新构建页面的时候，就产生了回流</p><h3 id="什么是重绘？"><a href="#什么是重绘？" class="headerlink" title="什么是重绘？"></a>什么是重绘？</h3><p>当一个元素自身的宽高，布局，及显示或隐藏没有改变，而只是改变了元素的外观风格的时候，就产生了重绘</p><h3 id="注意：回流一定会触发重绘，而重绘不一定会回流"><a href="#注意：回流一定会触发重绘，而重绘不一定会回流" class="headerlink" title="注意：回流一定会触发重绘，而重绘不一定会回流"></a>注意：回流一定会触发重绘，而重绘不一定会回流</h3><h3 id="什么时候会进行回流？"><a href="#什么时候会进行回流？" class="headerlink" title="什么时候会进行回流？"></a>什么时候会进行回流？</h3><ol><li><p>添加或者删除可见的DOM元素的时候</p></li><li><p>元素的位置发生改变</p></li><li><p>元素的尺寸发生改变</p></li><li><p>内容改变</p></li><li><p>页面第一次渲染的时候</p></li></ol><p>列举一些相关的CSS样式：width、height、line-height、padding、margin、diaplay、border、top、position、float、font-size、overflow等</p><h3 id="什么时候会进行重绘？"><a href="#什么时候会进行重绘？" class="headerlink" title="什么时候会进行重绘？"></a>什么时候会进行重绘？</h3><p>列举一些相关的CSS样式：color、background、background-size、visibility、box-shadow</p><h3 id="如何进行性能优化？"><a href="#如何进行性能优化？" class="headerlink" title="如何进行性能优化？"></a>如何进行性能优化？</h3><ol><li><p>用transform 代替 top，left ，margin-top， margin-left… 这些位移属性</p></li><li><p>不要使用 js 代码对dom 元素设置多条样式，选择用一个 className 代替之</p></li><li><p>不要在循环内获取dom 的样式例如：offsetWidth, offsetHeight, clientWidth, clientHeight等。浏览器有一个回流的缓冲机制，获取这些属性时会产生回流</p></li><li><p>避免设置多层内联样式，写个外部类这样只回流一次</p></li><li><p>让多次回流的元素脱离文档流比如动画，使用 position 属性的 fixed 值或 absolute 值</p></li><li><p>一起变化（同时修改所有需要变化的属性）</p></li></ol><h3 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h3><p>CSS</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><br>避免使用table布局。<br>尽可能在DOM树的最末端改变<span class="hljs-keyword">class</span>。<br>避免设置多层内联样式。<br>将动画效果应用到<span class="hljs-symbol">position</span>属性为<span class="hljs-symbol">absolute</span>或<span class="hljs-symbol">fixed</span>的元素上。<br>避免使用<span class="hljs-symbol">CSS</span>表达式（例如：<span class="hljs-symbol">calc</span>()）。<br></code></pre></td></tr></table></figure><p>JavaScript</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为<span class="hljs-keyword">class</span>并一次性更改<span class="hljs-symbol">class</span>属性。<br>避免频繁操作<span class="hljs-symbol">DOM</span>，创建一个<span class="hljs-symbol">documentFragment</span>，在它上面应用所有<span class="hljs-symbol">DOM</span>操作，最后再把它添加到文档中。<br>也可以先为元素设置<span class="hljs-symbol">display: <span class="hljs-symbol">none</span></span>，操作结束后再把它显示出来。因为在<span class="hljs-symbol">display</span>属性为<span class="hljs-symbol">none</span>的元素上进行的<span class="hljs-symbol">DOM</span>操作不会引发回流和重绘。<br>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。<br>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。<br></code></pre></td></tr></table></figure><h5 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h5><p><a href="https://juejin.cn/post/6844903569087266823#heading-2">掘金</a><br><a href="https://www.zhihu.com/search?type=content&q=%E9%87%8D%E7%BB%98%E5%9B%9E%E6%B5%81">知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>前端基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP协议</title>
    <link href="/2021/07/09/TCP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2021/07/09/TCP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>引言<br>网络协议是每个前端工程师都必须要掌握的知识，TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP，本文将介绍下这两者以及它们之间的区别。</p><hr><h3 id="一、TCP-IP网络模型"><a href="#一、TCP-IP网络模型" class="headerlink" title="一、TCP/IP网络模型"></a>一、TCP/IP网络模型</h3><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。<br>TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。<br>TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p><p>链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。<br>网络层：负责路由以及把分组报文发送给目标网络或主机。<br>传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。<br>应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。<br><img src="/imageO/XY.jpg" alt="TCP/IP"></p><p>在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。接下去介绍TCP/IP 中有两个具有代表性的传输层协议—-TCP 和 UDP。</p><h3 id="二、UDP"><a href="#二、UDP" class="headerlink" title="二、UDP"></a>二、UDP</h3><p>UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。<br>它有以下几个特点：</p><h4 id="1-面向无连接"><a href="#1-面向无连接" class="headerlink" title="1. 面向无连接"></a>1. 面向无连接</h4><p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。<br>具体来说就是：</p><ol><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ol><h4 id="2-有单播，多播，广播的功能"><a href="#2-有单播，多播，广播的功能" class="headerlink" title="2. 有单播，多播，广播的功能"></a>2. 有单播，多播，广播的功能</h4><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p><h4 id="3-UDP是面向报文的"><a href="#3-UDP是面向报文的" class="headerlink" title="3. UDP是面向报文的"></a>3. UDP是面向报文的</h4><p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p><h4 id="4-不可靠性"><a href="#4-不可靠性" class="headerlink" title="4. 不可靠性"></a>4. 不可靠性</h4><p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。<br>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。<br>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p><h4 id="5-头部开销小，传输数据报文时是很高效的"><a href="#5-头部开销小，传输数据报文时是很高效的" class="headerlink" title="5. 头部开销小，传输数据报文时是很高效的"></a>5. 头部开销小，传输数据报文时是很高效的</h4><p>UDP 头部包含了以下几个数据：</p><ol><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li></ol><p>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</p><h3 id="三、TCP"><a href="#三、TCP" class="headerlink" title="三、TCP"></a>三、TCP</h3><p>当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。<br>TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。</p><h4 id="1-TCP连接过程"><a href="#1-TCP连接过程" class="headerlink" title="1. TCP连接过程"></a>1. TCP连接过程</h4><h4 id="2-三次握手-四次挥手"><a href="#2-三次握手-四次挥手" class="headerlink" title="2.三次握手-四次挥手"></a>2.三次握手-四次挥手</h4><h5 id="3-TCP协议的特点"><a href="#3-TCP协议的特点" class="headerlink" title="3. TCP协议的特点"></a>3. TCP协议的特点</h5><ol><li><p>面向连接<br>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p></li><li><p>仅支持单播传输</p></li></ol><p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p><ol start="3"><li>面向字节流</li></ol><p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p><ol start="4"><li><p>可靠传输<br>对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p></li><li><p>提供拥塞控制</p></li></ol><p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p><ol start="6"><li>TCP提供全双工通信</li></ol><p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p><h3 id="四、TCP和UDP的比较"><a href="#四、TCP和UDP的比较" class="headerlink" title="四、TCP和UDP的比较"></a>四、TCP和UDP的比较</h3><ol><li>对比</li></ol><p><img src="/imageO/TCPUDP.jpg" alt="TCP/UDP"></p><h4 id="五、TCP-和-UDP-应用场景"><a href="#五、TCP-和-UDP-应用场景" class="headerlink" title="五、TCP 和 UDP 应用场景"></a>五、TCP 和 UDP 应用场景</h4><ol><li><p>UDP的应用场景：即时通信。面向数据报方式；网络数据大多为短消息；拥有大量客户端；对数据安全性无特殊要求；网络负担重但对响应速度要求高的场景。eg: IP电话、实时视频会议等。</p></li><li><p>TCP的应用场景：对数据准确性要求高，速度可以相对较慢的。eg: 文件传输、邮件的发送与接收等。</p></li></ol><h4 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h4><p>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。<br>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为<br>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6992743999756845087#heading-2">深度剖析TCP与UDP的区别</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何获取页面出现次数最多的 HTML 标签</title>
    <link href="/2021/07/08/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%20HTML%20%E6%A0%87%E7%AD%BE/"/>
    <url>/2021/07/08/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%20HTML%20%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<p>相同点：</p><p>递归和迭代都是循环的一种。</p><p>不同点：</p><p>1、程序结构不同</p><p>递归是重复调用函数自身实现循环。迭代是函数内某段代码实现循环。 其中，迭代与普通循环的区别是：迭代时，循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。</p><p>2、算法结束方式不同</p><p>递归循环中，遇到满足终止条件的情况时逐层返回来结束。迭代则使用计数器结束循环。 当然很多情况都是多种循环混合采用，这要根据具体需求。</p><p>3、效率不同</p><p>在循环的次数较大的时候，迭代的效率明显高于递归</p><hr><p>这是一道前端基础与编程功底具备的面试题：</p><p>如果你前端基础强会了解 document.querySelector(*) 能够列出页面内所有标签<br>如果你编程能力强能够用递归/正则快速实现同等的效果<br>有三种 API 可以列出页面所有标签：</p><ol><li>document.querySelector(‘*’)，标准规范实现</li><li>$$(‘*’)，devtools 实现</li><li>document.all，非标准规范实现</li></ol><blockquote><p>document.querySelectorAll(‘*’)</p></blockquote><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&lt; NodeList(<span class="hljs-number">593</span>) <span class="hljs-meta">[</span>html, head, meta, meta, meta, meta, meta, meta, meta, title, <span class="hljs-keyword">link</span>#favicon, <span class="hljs-keyword">link</span>, <span class="hljs-keyword">link</span>#MainCss, <span class="hljs-keyword">link</span>#mobile<span class="hljs-params">-style</span>, <span class="hljs-keyword">link</span>, <span class="hljs-keyword">link</span>, <span class="hljs-keyword">link</span>, script, script, script, script, script, script, script, <span class="hljs-keyword">link</span>, script, <span class="hljs-keyword">link</span>, <span class="hljs-keyword">link</span>, script, input#_w_brink, body, a, div#home, div#header, div#blogTitle, a#lnkBlogLogo, img#blogLogo, h1, a#Header1_HeaderTitle.headermaintitle.HeaderMainTitle, h2, div#navigator, ul#navList, li, a#blog_nav_sitehome.menu, li, a#blog_nav_myhome.menu, li, a#blog_nav_newpost.menu, li, a#blog_nav_contact.menu, li, a#blog_nav_rss.menu, li, a#blog_nav_admin.menu, div.blogStats, span#stats_post_count, span#stats_article_count, span#stats<span class="hljs-params">-comment_count</span>, div#main, div#mainContent, div.forFlow, div#post_detail, div#topics, div.post, h1.postTitle, a#cb_post_title_url.postTitle2.vertical<span class="hljs-params">-middle</span>, span, div.clear, div.postBody, div#cnblogs_post_body.blogpost<span class="hljs-params">-body</span>, p, p, strong, p, p, p, strong, div.cnblogs_code, pre, span, span, span, span, span, p, span, strong, pre, strong, span, strong, br, br, br, div.cnblogs_code, pre, span, span, p, p, …<span class="hljs-meta">]</span><br><span class="hljs-meta">[</span><span class="hljs-number">0</span> … <span class="hljs-number">99</span><span class="hljs-meta">]</span><br><span class="hljs-meta">[</span><span class="hljs-number">100</span> … <span class="hljs-number">199</span><span class="hljs-meta">]</span><br><span class="hljs-meta">[</span><span class="hljs-number">200</span> … <span class="hljs-number">299</span><span class="hljs-meta">]</span><br><span class="hljs-meta">[</span><span class="hljs-number">300</span> … <span class="hljs-number">399</span><span class="hljs-meta">]</span><br><span class="hljs-meta">[</span><span class="hljs-number">400</span> … <span class="hljs-number">499</span><span class="hljs-meta">]</span><br><span class="hljs-meta">[</span><span class="hljs-number">500</span> … <span class="hljs-number">592</span><span class="hljs-meta">]</span><br>__proto__: NodeList<br></code></pre></td></tr></table></figure><p>使用 document.querySelectorAll 实现如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 实现一个 maxBy 方便找出出现次数最多的 HTML 标签</span><br><span class="hljs-keyword">const</span> maxBy = <span class="hljs-function">(<span class="hljs-params">list, keyBy</span>) =&gt;</span> list.reduce(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> keyBy(x) &gt; keyBy(y) ? x : y)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFrequentTag</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> tags = [...document.querySelectorAll(<span class="hljs-string">&#x27;*&#x27;</span>)].map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.tagName).reduce(<span class="hljs-function">(<span class="hljs-params">o, tag</span>) =&gt;</span> &#123;<br>    o[tag] = o[tag] ? o[tag] + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> o<br>  &#125;, &#123;&#125;)<br>  <span class="hljs-keyword">return</span> maxBy(<span class="hljs-built_in">Object</span>.entries(tags), <span class="hljs-function"><span class="hljs-params">tag</span> =&gt;</span> tag[<span class="hljs-number">1</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 element.children 递归迭代如下 (最终结果多一个 document)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAllTags</span>(<span class="hljs-params">el = <span class="hljs-built_in">document</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> children = <span class="hljs-built_in">Array</span>.from(el.children).reduce(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> [...x, ...getAllTags(y)], [])<br>  <span class="hljs-keyword">return</span> children<br>&#125;<br><br><span class="hljs-comment">// 或者通过 flatMap 实现</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAllTags</span>(<span class="hljs-params">el = <span class="hljs-built_in">document</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> children = <span class="hljs-built_in">Array</span>.prototype.flatMap.call(el.children, <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> getAllTags(x))<br>  <span class="hljs-keyword">return</span> [el, ...children]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://q.shanyue.tech/fe/js/418.html">如何获取页面出现次数最多的 HTML 标签</a></p>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 组件传参的八种方式总结</title>
    <link href="/2021/07/08/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <url>/2021/07/08/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="一、props-传参"><a href="#一、props-传参" class="headerlink" title="一、props 传参"></a>一、props 传参</h3><p>子组件定义 props 有三种方式:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// 第一种数组方式</span><br><span class="hljs-symbol">props:</span> [xxx, xxx, xxx]<br><br><span class="hljs-comment">// 第二种对象方式</span><br><span class="hljs-symbol">props:</span> &#123; xxx: Number, xxx: String&#125;<br><br><span class="hljs-comment">// 第三种对象嵌套对象方式</span><br><span class="hljs-symbol">props:</span> &#123;<br><span class="hljs-symbol">    xxx:</span> &#123;<br>        <span class="hljs-comment">//类型不匹配会警告</span><br><span class="hljs-symbol">        type:</span> Number,<br><span class="hljs-symbol">        default:</span> <span class="hljs-number">0</span>,<br><span class="hljs-symbol">        required:</span> true,<br>        <span class="hljs-comment">// 返回值不是 true,会警告</span><br>        validator(val) &#123; return val === <span class="hljs-number">10</span>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第三种对象默认支持 4 种属性，并且都是非必填的。可以随意使用</p><h4 id="父组件传参的俩种方式"><a href="#父组件传参的俩种方式" class="headerlink" title="父组件传参的俩种方式"></a>父组件传参的俩种方式</h4><h5 id="第一种静态属性传参"><a href="#第一种静态属性传参" class="headerlink" title="第一种静态属性传参"></a>第一种静态属性传参</h5><p>注意：</p><p>在不定义 props 类型的情况下 props 接受到的均为 String。<br>当 props 属性指定为 Boolean时，并且只有属性 key 没有值 value 时接受到的是 true</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--props 接受到的均为 String --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">children</span> <span class="hljs-attr">xxx</span>=<span class="hljs-string">&quot;123&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">children</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 有只有属性没有值, 这种情况 props 指定类型是 Boolean 则接收到的是 true --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">children</span> <span class="hljs-attr">xxx</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">children</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="第二种动态属性传参"><a href="#第二种动态属性传参" class="headerlink" title="第二种动态属性传参"></a>第二种动态属性传参</h5><p>注意：</p><p>需要区分非简写形式传入的值是对象，则会对应 props 中多个值<br>会保留传入值的类型<br>如果是表达式则获取到的是表达式的计算结果</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!-- prop 接收到 Number 类型的 123--&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">children</span> <span class="hljs-attr">:xxx</span>=<span class="hljs-string">&quot;123&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">children</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-comment">&lt;!-- prop 接收到 Array 类型的 [1, 2, 3]--&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">children</span> <span class="hljs-attr">v-bind:xxx</span>=<span class="hljs-string">&quot;[1, 2, 3]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">children</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-comment">&lt;!-- prop 会接收到 xxx1 和 xxx2 俩个参数。这种不支持简写形式--&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">children</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;xxx1: 1, xxx2: 2&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">children</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="二、attrs-和listeners"><a href="#二、attrs-和listeners" class="headerlink" title="二、attrs 和listeners"></a>二、attrs 和listeners</h3><p>$attrs</p><p>$attrs 会获取到 props 中未定义的属性（class 和 style 属性除外）,支持响应式。常用的场景有俩种：</p><ol><li>组件嵌套组件时可以使用 $attrs 来支持过多的属性支持。比如 elementUI 的 table 组件。支持的属性十几个，而平常封装的时候用的最多的也就一俩个。</li><li>属性默认是添加在父组件上的，有时候想把多余的属性添加在子组件上（可以结合 inheritAttrs: false 属性，让父属性不接受多余的属性）</li></ol><p>$listeners 定义的事件都在子组件的根元素上，有时候想加到其他元素上。就可以使用 $listerners。它包含了父组件中的事件监听器(除了带有 .native 修饰符的监听器)</p><h3 id="三、-emit-通知"><a href="#三、-emit-通知" class="headerlink" title="三、$emit 通知"></a>三、$emit 通知</h3><p>Vue 默认有 $on $emit $once $off 几种方法来实现发布订阅模式，这也应用在了组件传参上。在组件上添加的特殊方法 @abc=”methods” 就相当于使用了 $on 来监听这个方法。因此组件内可以使用 $emit 来进行通知。</p><p>这里有一道考题: for 循环的时候如何拿到子组件的传值和 for 中循环的值</p><p>答案有俩种，一是 $event, 二是 闭包。只是需要注意 $event 只能获取到第一个值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in [1, 2, 3]&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">children</span> @<span class="hljs-attr">abc</span>=<span class="hljs-string">&quot;((val, val2) =&gt; getValue(val, item))&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">children</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="四、v-model"><a href="#四、v-model" class="headerlink" title="四、v-model"></a>四、v-model</h3><p>这个其实是一种通过 emit，on 的组合方式。优点再于同步值方便,写法优雅。下面三种写法其实是一个意思</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 写法 1</span><br>&lt;children v-model=<span class="hljs-string">&quot;a&quot;</span>&gt;&lt;/children&gt;<br>&#123;<br>    model: &#123;<br>        prop: <span class="hljs-string">&#x27;value&#x27;</span>,<br>        event: <span class="hljs-string">&#x27;update:a&#x27;</span>,<br>    &#125;,<br>    methods: &#123;<br>        <span class="hljs-function"><span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;update:a&#x27;</span>, <span class="hljs-number">1</span>)&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 写法 2</span><br>&lt;children :a=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-meta">@update</span>:a=<span class="hljs-string">&quot;a = $event&quot;</span>&gt;&lt;/children&gt;<br>&#123;<br>    props: [<span class="hljs-string">&#x27;a&#x27;</span>]<br>    methods: &#123;<br>        <span class="hljs-function"><span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;update:a&#x27;</span>, <span class="hljs-number">1</span>)&#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 写法 3</span><br><span class="hljs-comment">// 1. 事件名必须是 update: + 属性名</span><br><span class="hljs-comment">// 2. 参数不能是表达式，最好是 data 里面的属性</span><br>&lt;children :a.sync=<span class="hljs-string">&quot;a&quot;</span>&gt;&lt;/children&gt;<br>&#123;<br>    props: [<span class="hljs-string">&#x27;a&#x27;</span>]<br>    methods: &#123;<br>        <span class="hljs-function"><span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;update:a&#x27;</span>, <span class="hljs-number">1</span>)&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="五、插槽"><a href="#五、插槽" class="headerlink" title="五、插槽"></a>五、插槽</h3><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!--默认插槽--&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!--另一种默认插槽的写法--&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;default&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!--具名插槽--&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!--传参插槽--&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">v-bind:user</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-comment">&lt;!--使用--&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">children</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!--跑到默认插槽中去--&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!--另一种默认插槽的写法--&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!--跑到具名插槽 footer 中去--&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!--缩写形式--&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!--获取子组件的值--&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>=<span class="hljs-string">&quot;slot&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">slot.user</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!--结构插槽值--&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>=<span class="hljs-string">&quot;&#123;user: person&#125;&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">person</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!--老式写法，可以写到具体的标签上面--&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;footer&quot;</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;scope&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">children</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="六、-refs-root-parent-children"><a href="#六、-refs-root-parent-children" class="headerlink" title="六、$refs, $root, $parent, $children"></a>六、$refs, $root, $parent, $children</h3><p>$root 获取根组件<br>$parent 获取父组件<br>$children 获取子组件(所有的子组件，不保证顺序)<br>$refs 组件获取组件实例，元素获取元素<br>七、project / inject<br>注意：注入的值是非响应的</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!--父组件 提供--&gt;</span></span><br><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    project() &#123;</span><br><span class="hljs-template-variable">        return &#123;</span><br><span class="hljs-template-variable">            parent: this</span><br><span class="hljs-template-variable">        &#125;</span><br><span class="xml">    &#125;</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-comment">&lt;!--子组件 注入--&gt;</span></span><br><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    // 写法一</span><br><span class="hljs-template-variable">    inject: [&#x27;parent&#x27;]</span><br><span class="hljs-template-variable">    // 写法二</span><br><span class="hljs-template-variable">    inject: &#123; parent: &#x27;parent&#x27; &#125;</span><br><span class="xml">    // 写法三</span><br><span class="xml">    inject: </span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">        parent: &#123;</span><br><span class="hljs-template-variable">            from: &#x27;parent&#x27;,</span><br><span class="hljs-template-variable">            <span class="hljs-keyword">default</span>: 222</span><br><span class="hljs-template-variable">        &#125;</span><br><span class="xml">    &#125;</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="八、Vuex"><a href="#八、Vuex" class="headerlink" title="八、Vuex"></a>八、Vuex</h3><p>介绍</p><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态， 并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension， 提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p><p>优缺点</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>解决了多层组件之间繁琐的事件传播。<br>解决了多组件依赖统同一状态的问题。<br>单向数据流<br>为Vue量身定做，学习成本不高</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>不能做数据持久化，刷新页面就要重制，要做数据持久化可以考虑使用localstorage。<br>增加额外的代码体积，简单的业务场景不建议使用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。</p><ol><li>props / $emit 适用 父子组件通信</li></ol><p>这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。</p><ol start="2"><li>ref 与 $parent / $children 适用 父子组件通信</li></ol><p>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例<br>$parent / $children：访问父 / 子实例<br>3. EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信</p><p>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</p><ol start="4"><li>$attrs/$listeners 适用于 隔代组件通信</li></ol><p>$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=”$attrs” 传入内部组件。通常配合 inheritAttrs 选项一起使用。<br>$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件<br>5. provide / inject 适用于 隔代组件通信</p><p>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p><ol start="6"><li>Vuex 适用于 父子、隔代、兄弟组件通信</li></ol><h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p><p>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p><p>（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p><p>主要包括以下几个模块：</p><p>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。<br>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。<br>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。<br>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。<br>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844904080540712967#heading-2">Vue 组件传参的八种方式总结</a><br><a href="https://juejin.cn/post/6844903736356126734#heading-1">几种常见的Vue组件间的传参方式</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css实现两栏固定中间自适应</title>
    <link href="/2021/07/06/Css%E5%B8%83%E5%B1%80/"/>
    <url>/2021/07/06/Css%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="css实现两栏固定中间自适应"><a href="#css实现两栏固定中间自适应" class="headerlink" title="css实现两栏固定中间自适应"></a>css实现两栏固定中间自适应</h3><h4 id="1、利用绝对定位和margin"><a href="#1、利用绝对定位和margin" class="headerlink" title="1、利用绝对定位和margin"></a>1、利用绝对定位和margin</h4><blockquote><p>此方法的原理说将左右两侧进行定位，让其脱离文档流。 中心区域自然流动到它们下面，再为其设置margin值</p></blockquote><p>此方法页面元素结构可以顺序可以随意变动， 注意top值需要进行处理，不然可能会出现对不齐现象</p><p>HTML</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">&lt;<span class="hljs-keyword">div</span> id=<span class="hljs-string">&#x27;container&#x27;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&#x27;left&#x27;</span>&gt;左侧&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&#x27;center&#x27;</span>&gt;中间&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&#x27;right&#x27;</span>&gt;右侧&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>CSS</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.left</span>, <span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.center</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span> <span class="hljs-number">210px</span>;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、利用浮动和margin"><a href="#2、利用浮动和margin" class="headerlink" title="2、利用浮动和margin"></a>2、利用浮动和margin</h3><p>此方法的原理说将左右两侧进行float 浮动让其脱离文档流，中心部分处于正常文档流，再为其设置margin值</p><blockquote><p>此方法一定要将center中间部分放到最后，当窗口特别小时右侧会被挤下来</p></blockquote><p>HTML</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">&lt;<span class="hljs-keyword">div</span> id=<span class="hljs-string">&#x27;container&#x27;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&#x27;left&#x27;</span>&gt;左侧&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&#x27;right&#x27;</span>&gt;右侧&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&#x27;center&#x27;</span>&gt;中间&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>CSS</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.left</span>, <span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">float</span>: right;<br>&#125;<br><span class="hljs-selector-class">.center</span> &#123;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span> <span class="hljs-number">210px</span>;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、CSS3-flex"><a href="#3、CSS3-flex" class="headerlink" title="3、CSS3 flex"></a>3、CSS3 flex</h3><p>HTML</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">&lt;<span class="hljs-keyword">div</span> id=<span class="hljs-string">&#x27;container&#x27;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&#x27;left&#x27;</span>&gt;左侧&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&#x27;center&#x27;</span>&gt;中间&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&#x27;right&#x27;</span>&gt;右侧&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>CSS</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><span class="hljs-selector-class">.left</span>, <span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">500px</span>;<br>&#125;<br><span class="hljs-selector-class">.center</span> &#123;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/imageO/21.png" alt="效果"></p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844903727204139022#heading-0">css实现两栏固定中间自适应</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>前端基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP报文&amp;HTTP的优缺点</title>
    <link href="/2021/07/05/Http%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/07/05/Http%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="HTTP-报文结构是怎样的？"><a href="#HTTP-报文结构是怎样的？" class="headerlink" title="HTTP 报文结构是怎样的？"></a>HTTP 报文结构是怎样的？</h3><p>对于 TCP 而言，在传输的时候分为两个部分:TCP头和数据部分。</p><p>而 HTTP 类似，也是header + body的结构，具体而言:</p><blockquote><p>起始行 + 头部 + 空行 + 实体</p></blockquote><p>由于 http 请求报文和响应报文是有一定区别，因此我们分开介绍。</p><p>起始行<br>对于请求报文来说，起始行类似下面这样:</p><blockquote><p>GET /home HTTP/1.1</p></blockquote><p>也就是方法 + 路径 + http版本。</p><p>对于响应报文来说，起始行一般张这个样:</p><blockquote><p>HTTP/1.1 200 OK</p></blockquote><p>响应报文的起始行也叫做状态行。由http版本、状态码和原因三部分组成。</p><p>值得注意的是，在起始行中，每两个部分之间用空格隔开，最后一个部分后面应该接一个换行，严格遵循ABNF语法规范。</p><h4 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h4><p>展示一下请求头和响应头在报文中的位置:</p><p>不管是请求头还是响应头，其中的字段是相当多的，而且牵扯到http非常多的特性，这里就不一一列举的，重点看看这些头部字段的格式：</p><p>字段名不区分大小写<br>字段名不允许出现空格，不可以出现下划线_<br>字段名后面必须紧接着:</p><h4 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h4><p>很重要，用来区分开头部和实体。</p><p>问: 如果说在头部中间故意加一个空行会怎么样？</p><p>那么空行后的内容全部被视为实体。</p><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><p>就是具体的数据了，也就是body部分。请求报文对应请求体, 响应报文对应响应体。</p><h3 id="如何理解-URI？"><a href="#如何理解-URI？" class="headerlink" title="如何理解 URI？"></a>如何理解 URI？</h3><p><strong>URI</strong>, 全称为(Uniform Resource Identifier), 也就是<strong>统一资源标识符</strong>，它的作用很简单，就是区分互联网上不同的资源。</p><blockquote><p>但是，它并不是我们常说的网址, 网址指的是URL, 实际上URI包含了URN和URL两个部分，由于 URL 过于普及，就默认将 URI 视为 URL 了。</p></blockquote><p>URI 的结构<br>URI 真正最完整的结构是这样的。</p><p>可能你会有疑问，好像跟平时见到的不太一样啊！先别急，我们来一一拆解。</p><p><strong>scheme</strong> 表示协议名，比如http, https, file等等。后面必须和://连在一起。</p><p><strong>user:passwd@</strong> 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。</p><p><strong>host:port</strong>表示主机名和端口。</p><p><strong>path</strong>表示请求路径，标记资源所在位置。</p><p><strong>query</strong>表示查询参数，为key=val这种形式，多个键值对之间用&amp;隔开。</p><p><strong>fragment</strong>表示 URI 所定位的资源内的一个锚点，浏览器可以根据这个锚点跳转到对应的位置。</p><p>举个例子:</p><p><code>&lt;https://www.baidu.com/s?wd=HTTP&amp;rsv_spt=1&gt;</code><br>复制代码<br>这个 URI 中，https即scheme部分，<code>www.baidu.com</code>为host:port部分（注意，http 和 https 的默认端口分别为80、443），/s为path部分，而wd=HTTP&amp;rsv_spt=1就是query部分。</p><h3 id="如何理解-HTTP-状态码？"><a href="#如何理解-HTTP-状态码？" class="headerlink" title="如何理解 HTTP 状态码？"></a>如何理解 HTTP 状态码？</h3><p>RFC 规定 HTTP 的状态码为三位数，被分为五类:</p><p>1xx: 表示目前是协议处理的中间状态，还需要后续操作。<br>2xx: 表示成功状态。<br>3xx: 重定向状态，资源位置发生变动，需要重新请求。<br>4xx: 请求报文有误。<br>5xx: 服务器端发生错误。</p><h3 id="简要概括一下-HTTP-的特点？HTTP-有哪些缺点？"><a href="#简要概括一下-HTTP-的特点？HTTP-有哪些缺点？" class="headerlink" title="简要概括一下 HTTP 的特点？HTTP 有哪些缺点？"></a>简要概括一下 HTTP 的特点？HTTP 有哪些缺点？</h3><h4 id="HTTP-特点"><a href="#HTTP-特点" class="headerlink" title="HTTP 特点"></a>HTTP 特点</h4><p>HTTP 的特点概括如下:</p><ol><li><p>灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</p></li><li><p>可靠传输。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。</p></li></ol><p>请求-应答。也就是一发一收、有来有回， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。</p><ol start="3"><li>无状态。这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。</li></ol><h4 id="TTP-缺点"><a href="#TTP-缺点" class="headerlink" title="TTP 缺点"></a>TTP 缺点</h4><h5 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h5><p>所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的无状态。</p><p>在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。</p><p>但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。</p><h4 id="明文传输"><a href="#明文传输" class="headerlink" title="明文传输"></a>明文传输</h4><p>即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。</p><p>这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。WIFI陷阱就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。</p><h4 id="队头阻塞问题"><a href="#队头阻塞问题" class="headerlink" title="队头阻塞问题"></a>队头阻塞问题</h4><p>当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的队头阻塞问题。接下来会有一小节讨论这个问题。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844904100035821575#heading-15">（建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue router钩子函数</title>
    <link href="/2021/07/05/Vue%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90/"/>
    <url>/2021/07/05/Vue%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="路由钩子函数就是在发生路由跳转时，在每个时机调用的函数"><a href="#路由钩子函数就是在发生路由跳转时，在每个时机调用的函数" class="headerlink" title="路由钩子函数就是在发生路由跳转时，在每个时机调用的函数"></a>路由钩子函数就是在发生路由跳转时，在每个时机调用的函数</h2><h3 id="路由的钩子函数总结有6个"><a href="#路由的钩子函数总结有6个" class="headerlink" title="路由的钩子函数总结有6个"></a>路由的钩子函数总结有6个</h3><p>全局的路由钩子函数：beforeEach、afterEach</p><p>单个的路由钩子函数：beforeEnter</p><p>组件内的路由钩子函数：beforeRouteEnter、beforeRouteLeave、beforeRouteUpdate</p><h3 id="模块一：全局导航钩子函数"><a href="#模块一：全局导航钩子函数" class="headerlink" title="模块一：全局导航钩子函数"></a>模块一：全局导航钩子函数</h3><h4 id="1、vue-router-beforeEach（全局前置守卫）"><a href="#1、vue-router-beforeEach（全局前置守卫）" class="headerlink" title="1、vue router.beforeEach（全局前置守卫）"></a>1、vue router.beforeEach（全局前置守卫）</h4><p>beforeEach的钩子函数，它是一个全局的before 钩子函数，</p><p>（beforeEach）意思是在 每次每一个路由改变的时候都得执行一遍。</p><p>它的三个参数：</p><p>to: (Route路由对象) 即将要进入的目标 路由对象 to对象下面的属性： path params query hash fullPath matched name meta（在matched下，但是本例可以直接用）</p><p>from: (Route路由对象) 当前导航正要离开的路由</p><p>next: (Function函数) 一定要调用该方法来 resolve 这个钩子。 调用方法：next(参数或者空) ***必须调用</p><p>next(无参数的时候): 进行管道中的下一个钩子，如果走到最后一个钩子函数，那么 导航的状态就是 confirmed （确认的）</p><p>next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。</p><p>应用场景：可进行一些页面跳转前处理，例如判断需要登录的页面进行拦截，做登录跳转！！</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">router.beforeEach((to, from, <span class="hljs-keyword">next</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (to.meta.requireAuth) &#123;<br>        <span class="hljs-regexp">//</span>判断该路由是否需要登录权限<br>        <span class="hljs-keyword">if</span> (cookies(<span class="hljs-string">&#x27;token&#x27;</span>)) &#123;<br>            <span class="hljs-regexp">//</span>通过封装好的cookies读取token，如果存在，name接下一步如果不存在，那跳转回登录页<br>            <span class="hljs-keyword">next</span>()<span class="hljs-regexp">//</span>不要在<span class="hljs-keyword">next</span>里面加<span class="hljs-string">&quot;path:/&quot;</span>,会陷入死循环<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">next</span>(&#123;<br>                path: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>                query: &#123;redirect: to.fullPath&#125;<span class="hljs-regexp">//</span>将跳转的路由path作为参数，登录成功后跳转到该路由<br>            &#125;)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">next</span>()<br>    &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>应用场景，进入页面登录判断、管理员权限判断、浏览器判断</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>使用钩子函数对路由进行权限跳转<br>router.beforeEach((to, from, <span class="hljs-keyword">next</span>) =&gt; &#123;<br>    const role = localStorage.getItem(<span class="hljs-string">&#x27;ms_username&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(!role &amp;&amp; to.path !== <span class="hljs-string">&#x27;/login&#x27;</span>)&#123;<br>        <span class="hljs-keyword">next</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(to.meta.permission)&#123;<br>        <span class="hljs-regexp">//</span> 如果是管理员权限则可进入，这里只是简单的模拟管理员权限而已<br>        role === <span class="hljs-string">&#x27;admin&#x27;</span> ? <span class="hljs-keyword">next</span>() : <span class="hljs-keyword">next</span>(<span class="hljs-string">&#x27;/403&#x27;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-regexp">//</span> 简单的判断IE10及以下不进入富文本编辑器，该组件不兼容<br>        <span class="hljs-keyword">if</span>(navigator.userAgent.indexOf(<span class="hljs-string">&#x27;MSIE&#x27;</span>) &gt; -<span class="hljs-number">1</span> &amp;&amp; to.path === <span class="hljs-string">&#x27;/editor&#x27;</span>)&#123;<br>            Vue.prototype.<span class="hljs-variable">$alert</span>(<span class="hljs-string">&#x27;vue-quill-editor组件不兼容IE10及以下浏览器，请使用更高版本的浏览器查看&#x27;</span>, <span class="hljs-string">&#x27;浏览器不兼容通知&#x27;</span>, &#123;<br>                confirmButtonText: <span class="hljs-string">&#x27;确定&#x27;</span><br>            &#125;);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">next</span>();<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="2、vue-router-afterEach（全局后置守卫）"><a href="#2、vue-router-afterEach（全局后置守卫）" class="headerlink" title="2、vue router.afterEach（全局后置守卫）"></a>2、vue router.afterEach（全局后置守卫）</h4><p>router.beforeEach 是页面加载之前，相反router.afterEach是页面加载之后</p><h3 id="模块二：路由独享的守卫-路由内钩子"><a href="#模块二：路由独享的守卫-路由内钩子" class="headerlink" title="模块二：路由独享的守卫(路由内钩子)"></a>模块二：路由独享的守卫(路由内钩子)</h3><p>你可以在路由配置上直接定义 beforeEnter 守卫：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  routes: [<br>    &#123;<br>      path: <span class="hljs-string">&#x27;/foo&#x27;</span>,<br>      component: Foo,<br>      beforeEnter: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>      &#125;<br>    &#125;<br>  ]<br><br></code></pre></td></tr></table></figure><p>这些守卫与全局前置守卫的方法参数是一样的。</p><h3 id="模块三：组件内的守卫-组件内钩子"><a href="#模块三：组件内的守卫-组件内钩子" class="headerlink" title="模块三：组件内的守卫(组件内钩子)"></a>模块三：组件内的守卫(组件内钩子)</h3><p>1、beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">const Foo = &#123;<br>  template: `...`,<br>  beforeRouteEnter (to, from, <span class="hljs-keyword">next</span>) &#123;<br>    <span class="hljs-regexp">//</span> 在渲染该组件的对应路由被 confirm 前调用<br>    <span class="hljs-regexp">//</span> 不！能！获取组件实例 `this`<br>    <span class="hljs-regexp">//</span> 因为当钩子执行前，组件实例还没被创建<br>  &#125;,<br>  beforeRouteUpdate (to, from, <span class="hljs-keyword">next</span>) &#123;<br>    <span class="hljs-regexp">//</span> 在当前路由改变，但是该组件被复用时调用<br>    <span class="hljs-regexp">//</span> 举例来说，对于一个带有动态参数的路径 <span class="hljs-regexp">/foo/</span>:id，在 <span class="hljs-regexp">/foo/</span><span class="hljs-number">1</span> 和 <span class="hljs-regexp">/foo/</span><span class="hljs-number">2</span> 之间跳转的时候，<br>    <span class="hljs-regexp">//</span> 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。<br>    <span class="hljs-regexp">//</span> 可以访问组件实例 `this`<br>  &#125;,<br>  beforeRouteLeave (to, from, <span class="hljs-keyword">next</span>) &#123;<br>    <span class="hljs-regexp">//</span> 导航离开该组件的对应路由时调用<br>    <span class="hljs-regexp">//</span> 可以访问组件实例 `this`<br><br>  &#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>路由钩子在实际开发中的应用场景<br>(一) 清除当前组件中的定时器</li></ol><p>当一个组件中有一个定时器时, 在路由进行切换的时候, 可使用beforeRouteLeave将定时器进行清楚, 以免占用内存:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta">beforeRouteLeave (to, <span class="hljs-keyword">from</span>, <span class="hljs-keyword">next</span>) &#123;  <br> window.clearInterval(<span class="hljs-keyword">this</span>.timer) <span class="hljs-comment">//清楚定时器   </span><br> <span class="hljs-keyword">next</span>()<br> &#125;<br></code></pre></td></tr></table></figure><p>(二) 当页面中有未关闭的窗口, 或未保存的内容时, 阻止页面跳转</p><p>如果页面内有重要的信息需要用户保存后才能进行跳转, 或者有弹出框的情况. 应该阻止用户跳转，结合vuex状态管理（dialogVisibility是否有保存）</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs axapta">beforeRouteLeave (to, <span class="hljs-keyword">from</span>, <span class="hljs-keyword">next</span>) &#123;<br> <span class="hljs-comment">//判断是否弹出框的状态和保存信息与否</span><br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.dialogVisibility === <span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">this</span>.dialogVisibility = <span class="hljs-literal">false</span> <span class="hljs-comment">//关闭弹出框</span><br>    <span class="hljs-keyword">next</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">//回到当前页面, 阻止页面跳转</span><br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.saveMessage === <span class="hljs-literal">false</span>) &#123;<br>    alert(<span class="hljs-string">&#x27;请保存信息后退出!&#x27;</span>) <span class="hljs-comment">//弹出警告</span><br>    <span class="hljs-keyword">next</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">//回到当前页面, 阻止页面跳转</span><br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">next</span>() <span class="hljs-comment">//否则允许跳转</span><br>  &#125;<br><br></code></pre></td></tr></table></figure><p>(三) 保存相关内容到Vuex中或Session中</p><p>当用户需要关闭页面时, 可以将公用的信息保存到session或Vuex中</p><p> beforeRouteLeave (to, from, next) {<br>    localStorage.setItem(name, content); //保存到localStorage中<br>    next()<br>}</p><h4 id="全局路由钩子函数"><a href="#全局路由钩子函数" class="headerlink" title="全局路由钩子函数"></a>全局路由钩子函数</h4><p>每次路由跳转，都会执行beforeEach和afterEach，一般写在main.js可以做权限控制</p><p>例如：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">router.beforeEach(<span class="hljs-function"><span class="hljs-params">(to, <span class="hljs-keyword">from</span>, <span class="hljs-built_in">next</span>)</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (to.matched.length === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">from</span>.name ? <span class="hljs-built_in">next</span>(&#123; name : <span class="hljs-keyword">from</span>.name &#125;) : <span class="hljs-built_in">next</span>(<span class="hljs-string">&#x27;/&#x27;</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">next</span>()<br>  &#125;<br>&#125;)<br>router.afterEach(<span class="hljs-function"><span class="hljs-params">(to,<span class="hljs-keyword">from</span>)</span> =&gt;</span> &#123;<br>  console.log(to);//到达的路由<br>  console.log(<span class="hljs-keyword">from</span>);//离开的路由<br>&#125;)<br> <br>单个路由钩子函数<br><br>beforeEnter有三个参数：to/<span class="hljs-keyword">from</span>/<span class="hljs-built_in">next</span><br><br>  <span class="hljs-name">routes</span>: [<br>    &#123;<br>      <span class="hljs-name">path</span>: <span class="hljs-string">&#x27;/foo&#x27;</span>,<br>      <span class="hljs-name">component</span>: Foo,<br>      <span class="hljs-name">beforeEnter</span>: <span class="hljs-function"><span class="hljs-params">(to, <span class="hljs-keyword">from</span>, <span class="hljs-built_in">next</span>)</span> =&gt;</span> &#123;<br>        // ...<br>      &#125;<br>    &#125;<br>  ]<br></code></pre></td></tr></table></figure><p>组件内路由钩子函数</p><p>三个参数：to/from/next</p><p>beforeRouteEnter：进入这个组建路由之前</p><p>beforeRouteLeave：离开这个组建路由</p><p>beforeRouteUpdate：再本路由的下级路由切换才会触发beforeRouteUpdate</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk">beforeRouteEnter (to, from, <span class="hljs-keyword">next</span>) &#123;<br>  console.log(<span class="hljs-string">&#x27;1111&#x27;</span>)<br>  <span class="hljs-keyword">next</span>()<br>  <span class="hljs-regexp">//</span> 在渲染该组件的对应路由被 confirm 前调用<br>  <span class="hljs-regexp">//</span> 不！能！获取组件实例 `this`<br>  <span class="hljs-regexp">//</span> 因为当钩子执行前，组件实例还没被创建<br>&#125;,<br>beforeRouteUpdate (to, from, <span class="hljs-keyword">next</span>) &#123;<br>   console.log(<span class="hljs-string">&#x27;222&#x27;</span>)<br>  <span class="hljs-regexp">//</span> 在当前路由改变，但是该组件被复用时调用<br>  <span class="hljs-regexp">//</span> 举例来说，对于一个带有动态参数的路径 <span class="hljs-regexp">/foo/</span>:id，在 <span class="hljs-regexp">/foo/</span><span class="hljs-number">1</span> 和 <span class="hljs-regexp">/foo/</span><span class="hljs-number">2</span> 之间跳转的时候，<br>  <span class="hljs-regexp">//</span> 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。<br>  <span class="hljs-regexp">//</span> 可以访问组件实例 `this`<br>&#125;,<br>beforeRouteLeave (to, from, <span class="hljs-keyword">next</span>) &#123;<br>  <span class="hljs-regexp">//</span> 导航离开该组件的对应路由时调用<br>  <span class="hljs-regexp">//</span> 可以访问组件实例 `this`<br>  alert(<span class="hljs-string">&quot;3sdsss&quot;</span>)<br>  <span class="hljs-keyword">next</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.zhihu.com/search?type=content&q=ue%20router%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0">知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 响应式原理</title>
    <link href="/2021/07/04/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <url>/2021/07/04/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="Vue-初始化"><a href="#Vue-初始化" class="headerlink" title="Vue 初始化"></a>Vue 初始化</h3><p>先从最简单的一段 Vue 代码开始：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">message</span> &#125;&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">new Vue(&#123;</span><br><span class="xml">  data() &#123;</span><br><span class="xml">    return &#123;</span><br><span class="xml">      message: &quot;hello world&quot;,</span><br><span class="xml">    &#125;;</span><br><span class="xml">  &#125;,</span><br><span class="xml">&#125;);</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这段代码很简单，最终会在页面上打印一个 hello world，它是如何实现的呢？</p><p>我们从源头：new Vue 的地方开始分析。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 执行 new Vue 时会依次执行以下方法</span><br><span class="hljs-comment">// 1. Vue.prototype._init(option)</span><br><span class="hljs-comment">// 2. initState(vm)</span><br><span class="hljs-comment">// 3. observe(vm._data)</span><br><span class="hljs-comment">// 4. new Observer(data)</span><br><br><span class="hljs-comment">// 5. 调用 walk 方法，遍历 data 中的每一个属性，监听数据的变化。</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">walk</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(obj);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) &#123;<br>    defineReactive(obj, keys[i]);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 6. 执行 defineProperty 监听数据读取和设置。</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">obj, key, val</span>) </span>&#123;<br>  <span class="hljs-comment">// 为每个属性创建 Dep（依赖搜集的容器，后文会讲）</span><br>  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep();<br>  <span class="hljs-comment">// 绑定 get、set</span><br>  <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;<br>    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">const</span> value = val;<br>      <span class="hljs-comment">// 如果有 target 标识，则进行依赖搜集</span><br>      <span class="hljs-keyword">if</span> (Dep.target) &#123;<br>        dep.depend();<br>      &#125;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newVal</span>)</span> &#123;<br>      val = newVal;<br>      <span class="hljs-comment">// 修改数据时，通知页面重新渲染</span><br>      dep.notify();<br>    &#125;,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>…</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>从 new Vue 开始，首先通过 get、set 监听 Data 中的数据变化，同时创建 Dep 用来搜集使用该 Data 的 Watcher。</p></li><li><p>编译模板，创建 Watcher，并将 Dep.target 标识为当前 Watcher。</p></li><li><p>编译模板时，如果使用到了 Data 中的数据，就会触发 Data 的 get 方法，然后调用 Dep.addSub 将 Watcher 搜集起来。</p></li><li><p>数据更新时，会触发 Data 的 set 方法，然后调用 Dep.notify 通知所有使用到该 Data 的 Watcher 去更新 DOM。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 中的 router 实现原理如何&amp;SPA页面优缺点</title>
    <link href="/2021/07/04/Vue-Router%E5%8E%9F%E7%90%86/"/>
    <url>/2021/07/04/Vue-Router%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="后端路由简介"><a href="#后端路由简介" class="headerlink" title="后端路由简介"></a>后端路由简介</h3><p>路由这个概念最先是后端出现的。在以前用模板引擎开发页面时，经常会看到这样</p><p><code>&lt;http://www.xxx.com/login&gt;</code></p><p>大致流程可以看成这样：</p><p>浏览器发出请求</p><p>服务器监听到80端口（或443）有请求过来，并解析url路径</p><p>根据服务器的路由配置，返回相应信息（可以是 html 字串，也可以是 json 数据，图片等）</p><p>浏览器根据数据包的 Content-Type 来决定如何解析数据</p><p>简单来说路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能。</p><h4 id="说说你对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#说说你对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="说说你对 SPA 单页面的理解，它的优缺点分别是什么？"></a>说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h4><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li><li>基于上面一点，SPA 相对对服务器压力小；</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ol><h3 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h3><h3 id="1-hash-模式"><a href="#1-hash-模式" class="headerlink" title="1. hash 模式"></a>1. hash 模式</h3><p>随着 ajax 的流行，异步数据请求交互运行在不刷新浏览器的情况下进行。而异步交互体验的更高级版本就是 SPA —— 单页应用。单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。 类似于服务端路由，前端路由实现起来其实也很简单，就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容。但是这样存在一个问题，就是 url 每次变化的时候，都会造成页面的刷新。那解决问题的思路便是在改变 url 的情况下，保证页面的不刷新。在 2014 年之前，大家是通过 hash 来实现路由，url hash 就是类似于：</p><p><code>&lt;http://www.xxx.com/#/login&gt;</code><br>复制代码<br>这种 #。后面 hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外每次 hash 值的变化，还会触发hashchange 这个事件，通过这个事件我们就可以知道 hash 值发生了哪些变化。然后我们便可以监听hashchange来实现更新页面部分内容的操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchAndUpdate</span> (<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-comment">// todo 匹配 hash 做 dom 更新操作</span><br>&#125;<br><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;hashchange&#x27;</span>, matchAndUpdate)<br></code></pre></td></tr></table></figure><h3 id="2-history-模式"><a href="#2-history-模式" class="headerlink" title="2. history 模式"></a>2. history 模式</h3><p>14年后，因为HTML5标准发布。多了两个 API，pushState 和 replaceState，通过这两个 API 可以改变 url 地址且不会发送请求。同时还有popstate 事件。通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。用了 HTML5 的实现，单页路由的 url 就不会多出一个#，变得更加美观。但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchAndUpdate</span> (<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-comment">// todo 匹配路径 做 dom 更新操作</span><br>&#125;<br><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;popstate&#x27;</span>, matchAndUpdate)<br></code></pre></td></tr></table></figure><h3 id="前端路由实现的本质是监听url变化，实现方式有两种：Hash模式和History模式无需刷新页面就能重新加载相应的页面"><a href="#前端路由实现的本质是监听url变化，实现方式有两种：Hash模式和History模式无需刷新页面就能重新加载相应的页面" class="headerlink" title="前端路由实现的本质是监听url变化，实现方式有两种：Hash模式和History模式无需刷新页面就能重新加载相应的页面"></a>前端路由实现的本质是监听url变化，实现方式有两种：Hash模式和History模式无需刷新页面就能重新加载相应的页面</h3><p>Hash url的格式为<code>www.a.com/#/</code>，当#后的哈希值发生变化时，通过hashchange事件监听，然后页面跳转。 History url通过history.pushState和history.replaceState改变url。 两种模式的区别：</p><ol><li>hash只能改变#后的值，而history模式可以随意设置同源url；</li><li>hash只能添加字符串类的数据，而history可以通过API添加多种类型的数据；</li><li>hash的历史记录只显示之前的<code>www.a.com</code>而不会显示hash值，而history的每条记录都会进入到历史记录；</li><li>hash无需后端配置且兼容性好，而history需要配置index.html用于匹配不到资源的情况。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这一次，彻底弄懂 JavaScript 执行机制</title>
    <link href="/2021/07/03/Js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/07/03/Js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>因为javascript是一门单线程语言，javascript是按照语句出现的顺序执行的</p><hr><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>正因为js是一行一行执行的，所以我们以为js都是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;1&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(a);<br><br><span class="hljs-keyword">let</span> b = <span class="hljs-string">&#x27;2&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(b);<br><br></code></pre></td></tr></table></figure><p>然而实际上js是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;定时器开始啦&#x27;</span>)<br>&#125;);<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;马上执行for循环啦&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;<br>        i == <span class="hljs-number">99</span> &amp;&amp; resolve();<br>    &#125;<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;执行then函数啦&#x27;</span>)<br>&#125;);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;代码执行结束&#x27;</span>);<br></code></pre></td></tr></table></figure><p>依照js是按照语句出现的顺序执行这个理念，自信的写下输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-string">&quot;定时器开始啦&quot;</span><br><span class="hljs-regexp">//</span><span class="hljs-string">&quot;马上执行for循环啦&quot;</span><br><span class="hljs-regexp">//</span><span class="hljs-string">&quot;执行then函数啦&quot;</span><br><span class="hljs-regexp">//</span><span class="hljs-string">&quot;代码执行结束&quot;</span><br></code></pre></td></tr></table></figure><p>去chrome上验证下，结果完全不对，瞬间懵了，说好的一行一行执行的呢？</p><p>我们真的要彻底弄明白javascript的执行机制了。</p><h3 id="关于javascript"><a href="#关于javascript" class="headerlink" title="关于javascript"></a>关于javascript</h3><p>javascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！</p><h3 id="javascript事件循环"><a href="#javascript事件循环" class="headerlink" title="javascript事件循环"></a>javascript事件循环</h3><p>既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类：</p><blockquote><p>同步任务<br>异步任务<br>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。</p></blockquote><p><img src="/imageO/19.png" alt="如图"></p><p>导图要表达的内容用文字来表述的话：</p><ul><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ul><p>我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p><p>说了这么多文字，不如直接一段代码更直白：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">let data = [];<br>$.ajax(&#123;<br>    url:www.javascript.com,<br>    data:data,<br>    success:<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;发送成功!&#x27;</span>);<br>    &#125;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;代码执行结束&#x27;</span>);<br></code></pre></td></tr></table></figure><p>上面是一段简易的ajax请求代码：</p><ul><li>ajax进入Event Table，注册回调函数success。</li><li>执行console.log(‘代码执行结束’)。</li><li>ajax事件完成，回调函数success进入Event Queue。</li><li>主线程从Event Queue读取回调函数success并执行。</li></ul><h3 id="事件循环Event-Loop是js实现异步的一种方法，也是js的执行机制"><a href="#事件循环Event-Loop是js实现异步的一种方法，也是js的执行机制" class="headerlink" title="事件循环Event Loop是js实现异步的一种方法，也是js的执行机制"></a>事件循环Event Loop是js实现异步的一种方法，也是js的执行机制</h3><p>首先要知道，JS分为同步任务和异步任务<br>同步任务都在主线程(这里的主线程就是JS引擎线程)上执行，会形成一个执行栈<br>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放一个事件回调<br>一旦执行栈中的所有同步任务执行完毕(也就是JS引擎线程空闲了)，系统就会读取任务队列，将可运行的异步任务(任务队列中的事件回调，只要任务队列中有事件回调，就说明可以执行)添加到执行栈中，开始执行</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>javascript是一门单线程语言<br>Event Loop是javascript的执行机制</p><h3 id="宏任务-macrotask-amp-微任务-microtask"><a href="#宏任务-macrotask-amp-微任务-microtask" class="headerlink" title="宏任务(macrotask) &amp; 微任务(microtask)"></a>宏任务(macrotask) &amp; 微任务(microtask)</h3><h4 id="宏任务-macrotask"><a href="#宏任务-macrotask" class="headerlink" title="宏任务(macrotask)"></a>宏任务(macrotask)</h4><p>在ECMAScript中，macrotask也被称为task</p><p>我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)， 每一个宏任务会从头到尾执行完毕，不会执行其他</p><p>由于JS引擎线程和GUI渲染线程是互斥的关系，浏览器为了能够使宏任务和DOM任务有序的进行，会在一个宏任务执行结果后，在下一个宏任务执行前，GUI渲染线程开始工作，对页面进行渲染</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">宏任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...<br></code></pre></td></tr></table></figure><p>常见的宏任务</p><ul><li>主代码块</li><li>setTimeout</li><li>setInterval</li><li>setImmediate ()-Node</li><li>requestAnimationFrame ()-浏览器</li></ul><p>微任务(microtask)<br>ES6新引入了Promise标准，同时浏览器实现上多了一个microtask微任务概念，在ECMAScript中，microtask也被称为jobs</p><p>我们已经知道宏任务结束后，会执行渲染，然后执行下一个宏任务， 而微任务可以理解成在当前宏任务执行后立即执行的任务</p><p>当一个宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">宏任务 -&gt; 微任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...<br></code></pre></td></tr></table></figure><p>常见微任务</p><ul><li>process.nextTick ()-Node</li><li>Promise.then()</li><li>catch</li><li>finally</li><li>Object.observe</li><li>MutationObserver</li></ul><h3 id="微任务宏任务注意点"><a href="#微任务宏任务注意点" class="headerlink" title="微任务宏任务注意点"></a>微任务宏任务注意点</h3><ul><li><p>浏览器会先执行一个宏任务，紧接着执行当前执行栈产生的微任务，再进行渲染，然后再执行下一个宏任务</p></li><li><p>微任务和宏任务不在一个任务队列，不在一个任务队列</p></li></ul><ol><li>例如setTimeout是一个宏任务，它的事件回调在宏任务队列，Promise.then()是一个微任务，它的事件回调在微任务队列，二者并不是一个任务队列</li><li>以Chrome 为例，有关渲染的都是在渲染进程中执行，渲染进程中的任务（DOM树构建，js解析…等等）需要主线程执行的任务都会在主线程中执行，而浏览器维护了一套事件循环机制，主线程上的任务都会放到消息队列中执行，主线程会循环消息队列，并从头部取出任务进行执行，如果执行过程中产生其他任务需要主线程执行的，渲染进程中的其他线程会把该任务塞入到消息队列的尾部，消息队列中的任务都是宏任务</li><li>微任务是如何产生的呢？当执行到script脚本的时候，js引擎会为全局创建一个执行上下文，在该执行上下文中维护了一个微任务队列，当遇到微任务，就会把微任务回调放在微队列中，当所有的js代码执行完毕，在退出全局上下文之前引擎会去检查该队列，有回调就执行，没有就退出执行上下文，这也就是为什么微任务要早于宏任务，也是大家常说的，每个宏任务都有一个微任务队列（由于定时器是浏览器的API，所以定时器是宏任务，在js中遇到定时器会也是放入到浏览器的队列中）</li></ol><h4 id="图解宏任务和微任务"><a href="#图解宏任务和微任务" class="headerlink" title="图解宏任务和微任务"></a>图解宏任务和微任务</h4><p><img src="/imageO/Hong.jpg" alt="如图"><br>首先执行一个宏任务，执行结束后判断是否存在微任务</p><p>有微任务先执行所有的微任务，再渲染，没有微任务则直接渲染</p><p>然后再接着执行下一个宏任务</p><h3 id="图解完整的Event-Loop"><a href="#图解完整的Event-Loop" class="headerlink" title="图解完整的Event Loop"></a>图解完整的Event Loop</h3><p><img src="/imageO/20.png" alt="如图"><br>首先，整体的script(作为第一个宏任务)开始执行的时候，会把所有代码分为同步任务、异步任务两部分</p><p>同步任务会直接进入主线程依次执行</p><p>异步任务会再分为宏任务和微任务</p><p>宏任务进入到Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中</p><p>微任务也会进入到另一个Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中</p><p>当主线程内的任务执行完毕，主线程为空时，会检查微任务的Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务</p><p>上述过程会不断重复，这就是Event Loop，比较完整的事件循环</p><h3 id="关于Promise"><a href="#关于Promise" class="headerlink" title="关于Promise"></a>关于Promise</h3><p>new Promise(() =&gt; {}).then() ，我们来看这样一个Promise代码<br>前面的<strong>new Promise() 这一部分是一个构造函数，这是一个同步任务<br>后面的 .then() 才是一个异步微任务</strong> ，这一点是非常重要的</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve)</span> =&gt;</span> &#123;<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>  resolve()<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>上面代码输出<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="关于-async-await-函数"><a href="#关于-async-await-函数" class="headerlink" title="关于 async/await 函数"></a>关于 async/await 函数</h3><p>async/await本质上还是基于Promise的一些封装，而Promise是属于微任务的一种<br>所以在使用await关键字与Promise.then效果类似</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>))<br><br><span class="hljs-keyword">async</span> function test() &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve()<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>&#125;<br>test()<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>上述代码输出1 2 3 4<br>可以理解为，await 以前的代码，相当于与 new Promise 的同步代码，await 以后的代码相当于 Promise.then的异步</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844904050543034376#heading-1">「硬核JS」一次搞懂JS运行机制</a></p><p><a href="https://juejin.cn/post/6844904072240201736#heading-1">JavaScript运行机制</a></p><p><a href="https://juejin.cn/post/6844903512845860872#heading-2">这一次，彻底弄懂 JavaScript 执行机制</a></p>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈一谈你对 nextTick 的理解？</title>
    <link href="/2021/07/03/Vue&amp;$nextTick%E7%90%86%E8%A7%A3/"/>
    <url>/2021/07/03/Vue&amp;$nextTick%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="什么是nextTick呢？"><a href="#什么是nextTick呢？" class="headerlink" title="什么是nextTick呢？"></a>什么是nextTick呢？</h3><p>vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。</p><p>官方文档：</p><blockquote><p>在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。</p></blockquote><p>nextTick，我可以理解为next是下一个的意思，在事件循环中，每进行一次循环操作称为 tick</p><p>就是下一个事件循环操作，也就是下一个宏任务</p><h3 id="nextTick实现原理"><a href="#nextTick实现原理" class="headerlink" title="nextTick实现原理"></a>nextTick实现原理</h3><h4 id="异步更新"><a href="#异步更新" class="headerlink" title="异步更新"></a>异步更新</h4><p>  我们发现上述两个问题的发生，不管子组件还是父组件，都是在给data中赋值后立马去查看数据导致的。由于“查看数据”这个动作是同步操作的，而且都是在赋值之后；因此我们猜测一下，给数据赋值操作是一个异步操作，并没有马上执行，Vue官网对数据操作是这么描述的：</p><blockquote><p>可能你还没有注意到，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。</p></blockquote><p>  也就是说我们在设置this.msg = ‘xiaoming’的时候，Vue并没有马上去更新DOM数据，而是将这个操作放进一个队列中；如果我们重复执行的话，队列还会进行去重操作；等待同一事件循环中的所有数据变化完成之后，会将队列中的事件拿出来处理。<br>  这样做主要是为了提升性能，因为如果在主线程中更新DOM，循环100次就要更新100次DOM；但是如果等事件循环完成之后更新DOM，只需要更新1次。</p><p>直接上代码看效果</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;views__home&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;xiaoming&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">message</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">export default &#123;</span><br><span class="xml">    data() &#123;</span><br><span class="xml">        return &#123;</span><br><span class="xml">            message: &#x27;test&#x27;</span><br><span class="xml">        &#125;;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    mounted() &#123;</span><br><span class="xml">        this.message = &#x27;xiaoming&#x27;;</span><br><br><span class="xml">        console.log(&#x27;first&#x27;, this.$refs.xiaoming.innerHTML);</span><br><br><span class="xml">        this.$nextTick(() =&gt; &#123;</span><br><span class="xml">            console.log(&#x27;second&#x27;, this.$refs.xiaoming.innerHTML);</span><br><span class="xml">        &#125;);</span><br><span class="xml">    &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/imageO/18.png" alt="如图"></p><h4 id="为什么会这样呢？"><a href="#为什么会这样呢？" class="headerlink" title="为什么会这样呢？"></a>为什么会这样呢？</h4><p>当你执行this.message = ‘xiaoming’的时候，只是把xiaoming赋值给了一个变量，dom实际上还没有更新呢</p><h3 id="那么为什么在this-nextTick里面却可以拿到dom更新后的值呢？"><a href="#那么为什么在this-nextTick里面却可以拿到dom更新后的值呢？" class="headerlink" title="那么为什么在this.$nextTick里面却可以拿到dom更新后的值呢？"></a>那么为什么在this.$nextTick里面却可以拿到dom更新后的值呢？</h3><p>一般来说nextTick，就是在dom渲染完了之后才会执行</p><h3 id="我们要知道vue里面有一个虚拟dom，页面上所有的操作都是先改变虚拟dom，最后再把虚拟dom更新到实际的页面dom上，这个时候就会涉及到到一个问题，什么时候才是最后？"><a href="#我们要知道vue里面有一个虚拟dom，页面上所有的操作都是先改变虚拟dom，最后再把虚拟dom更新到实际的页面dom上，这个时候就会涉及到到一个问题，什么时候才是最后？" class="headerlink" title="我们要知道vue里面有一个虚拟dom，页面上所有的操作都是先改变虚拟dom，最后再把虚拟dom更新到实际的页面dom上，这个时候就会涉及到到一个问题，什么时候才是最后？"></a>我们要知道vue里面有一个虚拟dom，页面上所有的操作都是先改变虚拟dom，最后再把虚拟dom更新到实际的页面dom上，这个时候就会涉及到到一个问题，什么时候才是最后？</h3><p>这个时候就会涉及到JS事件执行机制中的宏任务和微任务</p><p>1、执行完当前宏任务script，立即执行微任务</p><p>2、微任务执行完毕后进行页面渲染</p><p>3、页面渲染完毕，开始执行$nextTick</p><h3 id="为什么用Vue-nextTick"><a href="#为什么用Vue-nextTick" class="headerlink" title="为什么用Vue.nextTick()"></a>为什么用Vue.nextTick()</h3><p>首先来了解一下JS的运行机制。</p><p>JS运行机制（Event Loop）</p><p>JS执行是单线程的，它是基于事件循环的。</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈。</li><li>主线程之外，会存在一个任务队列，只要异步任务有了结果，就在任务队列中放置一个事件。</li><li>当执行栈中的所有同步任务执行完后，就会读取任务队列。那些对应的异步任务，会结束等待状态，进入执行栈。<br>主线程不断重复第三步。</li><li>这里主线程的执行过程就是一个tick，而所有的异步结果都是通过任务队列来调度。Event Loop 分为宏任务和微任务，无论是执行宏任务还是微任务，完成后都会进入到一下tick，并在两个tick之间进行UI渲染。</li></ol><blockquote><p>由于Vue DOM更新是异步执行的，即修改数据时，视图不会立即更新，而是会监听数据变化，并缓存在同一事件循环中，等同一数据循环中的所有数据变化完成之后，再统一进行视图更新。为了确保得到更新后的DOM，所以设置了 Vue.nextTick()方法。</p></blockquote><h3 id="Vue-使用了-nextTick-进行统一更新"><a href="#Vue-使用了-nextTick-进行统一更新" class="headerlink" title="Vue 使用了 nextTick 进行统一更新"></a>Vue 使用了 nextTick 进行统一更新</h3><p>你应该知道，即使在 Vue 中多么频繁地修改数据，最后 Vue 页面只会更新一次</p><p>这是 Vue 和 nextTick 合作产生的结果，但又并不只是 nextTick 起作用</p><p>根据响应式原理，你我都知道</p><p>响应式原理</p><p>比如</p><p>数据 name 被 页面引用，name 会收集到 页面的 watcher</p><p>name 被修改时，会通知所有收集到的 watcher 进行更新（watcher.update）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">this.name</span> = <span class="hljs-number">2</span><br><br><span class="hljs-attr">this.name</span> = <span class="hljs-number">3</span><br><br><span class="hljs-attr">this.name</span> = <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>如果</p><p>name 一时间被修改三次时，按道理应该会通知三次 watcher 更新，那么页面会更新三次</p><p>但是最后只会更新一次</p><p>就是因为他们的合作</p><p>设置 nextTick 回调 + 过滤 watcher</p><p>当数据变化后，把 watcher.update  函数存放进 nextTick 的 回调数组中，并且会做过滤。</p><p>通过 watcher.id 来判断 回调数组 中是否已经存在这个 watcher 的更新函数</p><p>不存在，才 push</p><p>之后 nextTick 遍历回调数组，便会执行了更新</p><p>所以</p><p>当三次修改数据的时候，会准备 push进 回调数组 三个 watcher.update，但是只有第一次是 push 成功的，其他的会被过滤掉</p><p>所以，不管你修改多少次数据，nextTick 的回调数组中只存在唯一一个 watcher.update，从而页面只会更新一次</p><h3 id="nextTick源码分析"><a href="#nextTick源码分析" class="headerlink" title="nextTick源码分析"></a>nextTick源码分析</h3><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p>  Vue把nextTick的源码单独抽到一个文件中，/src/core/util/next-tick.js，删掉注释也就大概六七十行的样子，让我们逐段来分析。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> callbacks = []<br><span class="hljs-keyword">let</span> pending = <span class="hljs-literal">false</span><br><span class="hljs-keyword">let</span> timerFunc<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextTick</span> (<span class="hljs-params">cb?: <span class="hljs-built_in">Function</span>, ctx?: <span class="hljs-built_in">Object</span></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> _resolve<br>  callbacks.push(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (cb) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        cb.call(ctx)<br>      &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        handleError(e, ctx, <span class="hljs-string">&#x27;nextTick&#x27;</span>)<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_resolve) &#123;<br>      _resolve(ctx)<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">if</span> (!pending) &#123;<br>    pending = <span class="hljs-literal">true</span><br>    timerFunc()<br>  &#125;<br>  <span class="hljs-comment">// $flow-disable-line</span><br>  <span class="hljs-keyword">if</span> (!cb &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>      _resolve = resolve<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 我们首先找到nextTick这个函数定义的地方，看看它具体做了什么操作；看到它在外层定义了三个变量，有一个变量看名字就很熟悉：callbacks，就是我们上面说的队列；在nextTick的外层定义变量就形成了一个闭包，所以我们每次调用$nextTick的过程其实就是在向callbacks新增回调函数的过程。<br>  callbacks新增回调函数后又执行了timerFunc函数，pending用来标识同一个时间只能执行一次。那么这个timerFunc函数是做什么用的呢，我们继续来看代码：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">export</span> let isUsingMicroTask = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="hljs-built_in">Promise</span>)) &#123;<br>  <span class="hljs-regexp">//</span>判断<span class="hljs-number">1</span>：是否原生支持<span class="hljs-built_in">Promise</span><br>  const p = <span class="hljs-built_in">Promise</span>.resolve()<br><span class="hljs-function">  <span class="hljs-title">timerFunc</span> = <span class="hljs-params">()</span> =&gt;</span> &#123;<br>    p.<span class="hljs-keyword">then</span>(flushCallbacks)<br>    <span class="hljs-keyword">if</span> (isIOS) <span class="hljs-built_in">setTimeout</span>(noop)<br>  &#125;<br>  isUsingMicroTask = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isIE &amp;&amp; <span class="hljs-keyword">typeof</span> MutationObserver !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; (<br>  isNative(MutationObserver) ||<br>  MutationObserver.toString() === <span class="hljs-string">&#x27;[object MutationObserverConstructor]&#x27;</span><br>)) &#123;<br>  <span class="hljs-regexp">//</span>判断<span class="hljs-number">2</span>：是否原生支持MutationObserver<br>  let counter = <span class="hljs-number">1</span><br>  const observer = <span class="hljs-keyword">new</span> MutationObserver(flushCallbacks)<br>  const textNode = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-built_in">String</span>(counter))<br>  observer.observe(textNode, &#123;<br>    characterData: <span class="hljs-literal">true</span><br>  &#125;)<br><span class="hljs-function">  <span class="hljs-title">timerFunc</span> = <span class="hljs-params">()</span> =&gt;</span> &#123;<br>    counter = (counter + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span><br>    textNode.data = <span class="hljs-built_in">String</span>(counter)<br>  &#125;<br>  isUsingMicroTask = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setImmediate !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;<br>  <span class="hljs-regexp">//</span>判断<span class="hljs-number">3</span>：是否原生支持setImmediate<br><span class="hljs-function">  <span class="hljs-title">timerFunc</span> = <span class="hljs-params">()</span> =&gt;</span> &#123;<br>    setImmediate(flushCallbacks)<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-regexp">//</span>判断<span class="hljs-number">4</span>：上面都不行，直接用<span class="hljs-built_in">setTimeout</span><br><span class="hljs-function">  <span class="hljs-title">timerFunc</span> = <span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(flushCallbacks, <span class="hljs-number">0</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里出现了好几个isNative函数，这是用来判断所传参数是否在当前环境原生就支持；例如某些浏览器不支持Promise，虽然我们使用了垫片(polify)，但是isNative(Promise)还是会返回false。<br>  可以看出这边代码其实是做了四个判断，对当前环境进行不断的降级处理，尝试使用原生的Promise.then、MutationObserver和setImmediate，上述三个都不支持最后使用setTimeout；降级处理的目的都是将flushCallbacks函数放入微任务(判断1和判断2)或者宏任务(判断3和判断4)，等待下一次事件循环时来执行。MutationObserver是Html5的一个新特性，用来监听目标DOM结构是否改变，也就是代码中新建的textNode；如果改变了就执行MutationObserver构造函数中的回调函数，不过是它是在微任务中执行的。<br>  那么最终我们顺藤摸瓜找到了最终的大boss：flushCallbacks；nextTick不顾一切的要把它放入微任务或者宏任务中去执行，它究竟是何方神圣呢？让我们来一睹它的真容：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix">  <span class="hljs-attr">pending</span> = <span class="hljs-literal">false</span><br>  const <span class="hljs-attr">copies</span> = callbacks.slice(<span class="hljs-number">0</span>)<br>  callbacks.<span class="hljs-attr">length</span> = <span class="hljs-number">0</span><br>  for (<span class="hljs-keyword">let</span> <span class="hljs-attr">i</span> = <span class="hljs-number">0</span>; i &lt; copies.length; i++) &#123;<br>    copies[i]()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  本来以为有多复杂的flushCallbacks，居然不过短短的8行。它所做的事情也非常的简单，把callbacks数组复制一份，然后把callbacks置为空，最后把复制出来的数组中的每个函数依次执行一遍；所以它的作用仅仅是用来执行callbacks中的回调函数。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  到这里，整体nextTick的代码都分析完毕了，总结一下它的流程就是：</p><ol><li>把回调函数放入callbacks等待执行</li><li>将执行函数放到微任务或者宏任务中</li><li>事件循环到了微任务或者宏任务，执行函数依次执行callbacks中的回调</li></ol><p>  再回到我们开头说的setTimeout，可以看出来nextTick是对setTimeout进行了多种兼容性的处理，宽泛的也可以理解为将回调函数放入setTimeout中执行；不过nextTick优先放入微任务执行，而setTimeout是宏任务，因此nextTick一般情况下总是先于setTimeout执行，我们可以在浏览器中尝试一下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>&#125;)<br><span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>&#125;)<br><span class="hljs-regexp">//</span>运行结果 <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p> 最后验证猜想，当前宏任务执行完成后，优先执行两个微任务，最后再执行宏任务。</p><h5 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://www.zhihu.com/search?type=content&q=$nexttick%E8%A7%A3%E9%87%8A">知乎</a><br><a href="https://juejin.cn/post/6844904147804749832">Vue中$nextTick源码解析</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript new 操作符具体干了什么呢？如何实现？</title>
    <link href="/2021/07/02/JS%20new%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/"/>
    <url>/2021/07/02/JS%20new%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>JavaScript new 操作符具体干了什么呢？如何实现？</p><hr><h3 id="new-操作符具体干了什么？"><a href="#new-操作符具体干了什么？" class="headerlink" title="new 操作符具体干了什么？"></a>new 操作符具体干了什么？</h3><p>// （1）首先创建了一个新的空对象<br>// （2）设置原型，将对象的原型设置为函数的 prototype 对象。<br>// （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）<br>// （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p><p>new共经历了四个过程。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">var</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> = <span class="hljs-title">function</span> (<span class="hljs-params"></span>) </span>&#123; &#125;;<br><span class="hljs-keyword">var</span> fnObj = <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">fn</span>(<span class="hljs-params"></span>)</span>;<br><br></code></pre></td></tr></table></figure><p>1、创建了一个空对象</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br></code></pre></td></tr></table></figure><p>2、设置原型链</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">obj._proto_</span> = fn.prototype<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>3、让fn的this指向obj，并执行fn的函数体</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">var</span> <span class="hljs-literal">result</span> = fn.call(obj);<br></code></pre></td></tr></table></figure><p>4、判断fn的返回值类型，如果是值类型，返回obj。如果是引用类型，就返回这个引用类型的对象。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-function"><span class="hljs-title">typeof</span>(<span class="hljs-variable"><span class="hljs-class">result</span></span>) == <span class="hljs-string">&quot;object&quot;</span>)&#123;  </span><br><span class="hljs-function">    <span class="hljs-variable">fnObj</span> = <span class="hljs-variable"><span class="hljs-class">result</span></span>;  </span><br><span class="hljs-function">&#125; <span class="hljs-variable"><span class="hljs-keyword">else</span></span> &#123;  </span><br><span class="hljs-function">    <span class="hljs-variable">fnObj</span> = <span class="hljs-variable">obj</span>;</span><br><span class="hljs-function">&#125;  </span><br></code></pre></td></tr></table></figure><p>// 实现:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFactory</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-literal">null</span>,<br>    <span class="hljs-title">constructor</span> = <span class="hljs-title">Array</span>.<span class="hljs-title">prototype</span>.<span class="hljs-title">shift</span>.<span class="hljs-title">call</span>(<span class="hljs-params"><span class="hljs-built_in">arguments</span></span>),<br>    <span class="hljs-title">result</span> = <span class="hljs-title">null</span>;<br><br>  <span class="hljs-comment">// 参数判断</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title">constructor</span> !== &quot;<span class="hljs-title">function</span>&quot;) &#123;<br>    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;type error&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br>  newObject = <span class="hljs-built_in">Object</span>.create(<span class="hljs-title">constructor</span>.<span class="hljs-title">prototype</span>);<br><br>  <span class="hljs-comment">// 将 this 指向新建对象，并执行函数</span><br>  result = <span class="hljs-title">constructor</span>.<span class="hljs-title">apply</span>(<span class="hljs-params">newObject, <span class="hljs-built_in">arguments</span></span>);<br><br>  <span class="hljs-comment">// 判断返回对象</span><br>  <span class="hljs-keyword">let</span> flag =<br>    result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;function&quot;</span>);<br><br>  <span class="hljs-comment">// 判断返回结果</span><br>  <span class="hljs-keyword">return</span> flag ? result : newObject;<br>&#125;<br><br><span class="hljs-comment">// 使用方法</span><br><span class="hljs-comment">// objectFactory(构造函数, 初始化参数);</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 原型，原型链？ 有什么特点？js 获取原型的方法？</title>
    <link href="/2021/07/02/JavaScript%20%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F%20%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F&amp;%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2021/07/02/JavaScript%20%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F%20%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F&amp;%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>JavaScript 原型，原型链？ 有什么特点？js 获取原型的方法？</p><hr><h3 id="JavaScript-原型，原型链？-有什么特点？"><a href="#JavaScript-原型，原型链？-有什么特点？" class="headerlink" title="JavaScript 原型，原型链？ 有什么特点？"></a>JavaScript 原型，原型链？ 有什么特点？</h3><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><ul><li><p>在js中，我们通常会使用构造函数来创建一个对象，每一个构造函数的内部都有一个prototype属性，这个属性对应的值是一个对象，这个对象它包含了可以由该构造函数的所有实例都共享的属性和方法，我们把它称为原型。</p></li><li><p>原型分为显示原型和隐式原型，一般称prototype为显示原型，__proto__称为隐式原型。<br>一般而言，__proto__这个指针我们应该获取这个值，但是浏览器中都实现了<code>__proto__</code>属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。<br>ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对象的原型。</p></li></ul><p>举个例子:</p><ul><li>为什么我们新建的对象可以使用toString()方法，这是因为我们访问一个对象的属性时，首先会在这个对象身上找，如果没有的话，我们会通过这个对象的__proto__找到该对象的原型，然后在这个原型对象中找，这个原型对象又没有的话，就这样子通过一直找下去，这也就是原型链概念。直到找到原型链的尽头也就是Object.prototype。</li></ul><p><img src="/imageO/proto.png" alt="原型链"></p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 <strong>Object.prototype</strong> 所以这就是我们新建的对象为什么能够使用 toString() 等方法的原因。</p><p>特点：</p><p>JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p><h3 id="js-获取原型的方法？"><a href="#js-获取原型的方法？" class="headerlink" title="js 获取原型的方法？"></a>js 获取原型的方法？</h3><ol><li>p.<code>__proto__</code></li><li>p.constructor.prototype</li><li>Object.getPrototypeOf(p)</li></ol><h3 id="在-js-中不同进制数字的表示方式"><a href="#在-js-中不同进制数字的表示方式" class="headerlink" title="在 js 中不同进制数字的表示方式"></a>在 js 中不同进制数字的表示方式</h3><p>以 0X、0x 开头的表示为十六进制。</p><p>以 0、0O、0o 开头的表示为八进制。</p><p>以 0B、0b 开头的表示为二进制格式。</p>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS数据类型&amp;&amp;堆栈&amp;&amp;JS的基本规范</title>
    <link href="/2021/07/01/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&amp;&amp;%E5%A0%86%E6%A0%88&amp;&amp;JS%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83/"/>
    <url>/2021/07/01/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&amp;&amp;%E5%A0%86%E6%A0%88&amp;&amp;JS%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<p>JS数据类型&amp;&amp;堆栈&amp;&amp;JS的基本规范</p><hr><h3 id="介绍-js-的基本数据类型"><a href="#介绍-js-的基本数据类型" class="headerlink" title="介绍 js 的基本数据类型"></a>介绍 js 的基本数据类型</h3><p>js 一共有六种基本数据类型，分别是 <code>Undefined、Null、Boolean、Number、String</code>，还有在 ES6 中新增的 Symbol 和 ES10 中新增的 BigInt 类型。</p><p>Symbol 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的<strong>全局变量冲突的问题</strong>。</p><p>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以<strong>安全地存储和操作大整数</strong>，即使这个数已经超出了 Number 能够表示的安全整数范围。</p><h3 id="JavaScript-有几种类型的值？你能画一下他们的内存图吗？"><a href="#JavaScript-有几种类型的值？你能画一下他们的内存图吗？" class="headerlink" title="JavaScript 有几种类型的值？你能画一下他们的内存图吗？"></a>JavaScript 有几种类型的值？你能画一下他们的内存图吗？</h3><p>涉及知识点：</p><ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><p>两种类型的区别是：存储位置不同。<br>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</p><p>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p><h4 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h4><p>js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。</p><p>基本数据类型 <code>Undefined、Null、Boolean、Number、String</code></p><p>复杂数据类型指的是 Object 类型，所有其他的如 Array、Date 等数据类型都可以理解为 Object 类型的子类。</p><p>两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值。</p><p><img src="/imageO/16.png" alt="栈"></p><p><img src="/imageO/17.png" alt="堆"></p><h3 id="什么是堆？什么是栈？它们之间有什么区别和联系？"><a href="#什么是堆？什么是栈？它们之间有什么区别和联系？" class="headerlink" title="什么是堆？什么是栈？它们之间有什么区别和联系？"></a>什么是堆？什么是栈？它们之间有什么区别和联系？</h3><p>堆和栈的概念存在于数据结构中和操作系统内存中。</p><p>在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全<br>二叉树是堆的一种实现方式。</p><p>在操作系统中，内存被分为栈区和堆区。</p><p>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p><p>堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。</p><h3 id="说几条写-JavaScript-的基本规范？"><a href="#说几条写-JavaScript-的基本规范？" class="headerlink" title="说几条写 JavaScript 的基本规范？"></a>说几条写 JavaScript 的基本规范？</h3><p>在平常项目开发中，我们遵守一些这样的基本规范，比如说：</p><p>（1）一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 var 声明，不允许出现两个连续的 var 声明，声明时<br>    如果变量没有值，应该给该变量赋值对应类型的初始值，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。</p><p>（2）代码中出现地址、时间等字符串时需要使用常量代替。</p><p>（3）在进行比较的时候吧，尽量使用’===’, ‘!==’代替’==’, ‘!=’。</p><p>（4）不要在内置对象的原型上添加方法，如 Array, Date。</p><p>（5）switch 语句必须带有 default 分支。</p><p>（6）for 循环必须使用大括号。</p><p>（7）if 语句必须使用大括号。</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://blog.csdn.net/jiangjuanjaun/article/details/80327342">JavaScript有几种类型的值？能否画一下它们的内存图；</a></p>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS绘制三角形—border法</title>
    <link href="/2021/06/27/CSS%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2%E2%80%94border%E6%B3%95/"/>
    <url>/2021/06/27/CSS%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2%E2%80%94border%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="1-画三角形"><a href="#1-画三角形" class="headerlink" title="1. 画三角形"></a>1. 画三角形</h3><p>利用元素的 border 绘制三角形，先来看一下宽高均为 0，border 有宽度的效果是啥样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">0px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">0px</span>;</span><br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">50px</span> solid transparent;</span><br><span class="css">    <span class="hljs-attribute">border-color</span>: red blue chartreuse black;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="/imageO/10.png" alt="如图"></p><p>然后我们可以通过给任意三边的颜色设置为 transparent 即可分别实现任一方向的三角形。<br>通过设置某条边的宽度比其它边宽，来调整三角形的高度。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">border</span>-<span class="hljs-built_in">color</span>: <span class="hljs-built_in">transparent</span> <span class="hljs-built_in">transparent</span> chartreuse <span class="hljs-built_in">transparent</span>;<br></code></pre></td></tr></table></figure><h4 id="向上的箭头"><a href="#向上的箭头" class="headerlink" title="向上的箭头"></a>向上的箭头</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">  <span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/* 上 ，左右  下 */</span><br>        <span class="hljs-attribute">border-width</span>: <span class="hljs-number">0</span>  <span class="hljs-number">50px</span>  <span class="hljs-number">50px</span>;<br>        <span class="hljs-attribute">border-style</span>: solid;<br>        <span class="hljs-attribute">border-color</span>: transparent  transparent chartreuse;    <br>  &#125;<br>&lt;/style&gt;<br>&lt;<span class="hljs-selector-tag">div</span>&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure><p><img src="/imageO/11.png" alt="如图"></p><h4 id="向右的箭头"><a href="#向右的箭头" class="headerlink" title="向右的箭头"></a>向右的箭头</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">border-width</span>: <span class="hljs-number">50px</span> <span class="hljs-number">0</span> <span class="hljs-number">50px</span> <span class="hljs-number">50px</span>;<br>      <span class="hljs-attribute">border-style</span>: solid;<br>      <span class="hljs-attribute">border-color</span>: transparent chartreuse transparent;    <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/imageO/12.png" alt="如图"></p><h4 id="向下的箭头"><a href="#向下的箭头" class="headerlink" title="向下的箭头"></a>向下的箭头</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>       <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>       <span class="hljs-attribute">border-width</span>: <span class="hljs-number">50px</span>  <span class="hljs-number">50px</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-attribute">border-style</span>: solid;<br>       <span class="hljs-attribute">border-color</span>:chartreuse transparent  transparent;    <br> &#125;<br></code></pre></td></tr></table></figure><p><img src="/imageO/13.png" alt="如图"></p><h4 id="向左的箭头"><a href="#向左的箭头" class="headerlink" title="向左的箭头"></a>向左的箭头</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">border-width</span>:  <span class="hljs-number">50px</span>  <span class="hljs-number">50px</span>  <span class="hljs-number">50px</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">border-style</span>: solid;<br>      <span class="hljs-attribute">border-color</span>: transparent chartreuse transparent;    <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/imageO/14.png" alt="如图"></p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.cnblogs.com/lou-0820/p/10558799.html">博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>前端基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue中的scoped坑点&amp;</title>
    <link href="/2021/06/23/Vue-scoped%E7%9A%84%E5%9D%91%E7%82%B9/"/>
    <url>/2021/06/23/Vue-scoped%E7%9A%84%E5%9D%91%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>上午遇到一个scoped的坑，在覆盖elementUI的走马灯(轮播图)组件，就是无法覆盖组件原有的样式。最后想要改变标签样式，唯有去掉scoped了</p><p>尤大的话：</p><p>scoped设计的初衷就是不能让当前组件的样式修改其他任何地方的样式，因为设计如此</p><p>scoped 会给当前组件的模块中的所有的元素都添加一个随机的属性</p><p>scoped会给当前组件中的所有的样式页添加一个随机的属性选择器</p><p>深度选择器  scss  ::v-deep  less  /deep/  stylus  &gt;&gt;&gt;</p><hr><h3 id="何为scoped？"><a href="#何为scoped？" class="headerlink" title="何为scoped？"></a>何为scoped？</h3><p>在vue文件中的style标签上，有一个特殊的属性：scoped。当一个style标签拥有scoped属性时，它的CSS样式就只能作用于当前的组件，也就是说，该样式只能适用于当前组件元素。通过该属性，可以使得组件之间的样式不互相污染。如果一个项目中的所有style标签全部加上了scoped，相当于实现了样式的模块化。</p><h3 id="scoped的实现原理"><a href="#scoped的实现原理" class="headerlink" title="scoped的实现原理"></a>scoped的实现原理</h3><p>vue中的scoped属性的效果主要通过PostCSS转译实现，如下是转译前的vue代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br>.example &#123;<br><span class="css">  <span class="hljs-attribute">color</span>: red;</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span>hi<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>转译后：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css"><span class="hljs-selector-class">.example</span><span class="hljs-selector-attr">[data-v-5558831a]</span> &#123;</span><br><span class="css">  <span class="hljs-attribute">color</span>: red;</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example&quot;</span> <span class="hljs-attr">data-v-5558831a</span>&gt;</span>hi<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>即：PostCSS给一个组件中的所有dom添加了一个独一无二的动态属性，然后，给CSS选择器额外添加一个对应的属性选择器来选择该组件中dom，这种做法使得样式只作用于含有该属性的dom——组件内部dom。</p><h3 id="为什么需要穿透scoped？"><a href="#为什么需要穿透scoped？" class="headerlink" title="为什么需要穿透scoped？"></a>为什么需要穿透scoped？</h3><p>scoped看起来很美，但是，在很多项目中，会出现这么一种情况，即：引用了第三方组件，需要在组件中局部修改第三方组件的样式，而又不想去除scoped属性造成组件之间的样式污染。此时只能通过特殊的方式，穿透scoped。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="xml">    外层 &gt;&gt;&gt; 第三方组件 </span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">        样式</span><br><span class="hljs-template-variable">    &#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>通过 &gt;&gt;&gt; 可以使得在使用scoped属性的情况下，穿透scoped，修改其他组件的值。</p><h3 id="曲线救国的方法"><a href="#曲线救国的方法" class="headerlink" title="曲线救国的方法"></a>曲线救国的方法</h3><p>其实，还拥有一种曲线救国的方法，即在定义一个含有scoped属性的style标签之外，再定义一个不含有scoped属性的style标签，即在一个vue组件中定义一个全局的style标签，一个含有作用域的style标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css"><span class="hljs-comment">/* global styles */</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="css"><span class="hljs-comment">/* local styles */</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面是给vue组件的根元素加个id，然后这个id是每个组件唯一的，通过这种方式在全局style修改第三方组件样式。</p><p>可以在全局style里只改第三方的，其他的还是放到scoped的style里面，稍微方便点</p><h5 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h5><p><a href="https://www.cnblogs.com/karthuslorin/p/9038854.html">博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>offsetHeight、scrollHeight、clientHeight</title>
    <link href="/2021/06/20/offsetHeight%E3%80%81scrollHeight%E3%80%81clientHeight/"/>
    <url>/2021/06/20/offsetHeight%E3%80%81scrollHeight%E3%80%81clientHeight/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="offsetXXX"><a href="#offsetXXX" class="headerlink" title="offsetXXX"></a>offsetXXX</h3><blockquote><p>offsetWidth/offsetHeight 是指一个元素的 CSS 「标准宽高」，它包含了边框、内边距、元素内容以及滚动条（如果存在的话）。</p></blockquote><p>借助 MDN 上的图片可以看到元素的 offsetWidth，这就是这个元素在页面中「实际占用的空间」，同时当元素的形状发生变化时（比如说放大或缩小），offsetWidth 就表示元素的布局宽高，并不代表实际渲染出来的宽高，如需获取渲染的宽高请使用 getBoundingClientRect() 方法计算得到真正的 offsetWidth</p><p><img src="/imageO/6.png" alt="offsewidth"></p><h3 id="clientXXX"><a href="#clientXXX" class="headerlink" title="clientXXX"></a>clientXXX</h3><blockquote><p>clientWidth/clientHeight 就表示一个元素的「内容宽高」，包含元素内容以及内边距</p></blockquote><p>也就是说如果你只想要获取「显示内容区域的大小」就是用 clientWidth</p><p><img src="/imageO/6.png" alt="clientwidth"></p><h3 id="scrollXXX"><a href="#scrollXXX" class="headerlink" title="scrollXXX"></a>scrollXXX</h3><blockquote><p>scrollWidth/scrollHeight 表示一个元素内容区域的实际大小，包括不在页面中的可滚动部分（内容和内边距）</p></blockquote><p>它可以理解为 clientXXX 的增强版，是整个内容的大小</p><p><img src="/imageO/8.png" alt="scrollxxx"></p><h3 id="xxxTop"><a href="#xxxTop" class="headerlink" title="xxxTop"></a>xxxTop</h3><ol><li><p>offsetTop 是当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系</p></li><li><p>scrollTop 在有滚动条的情况下，为元素可视区域距离元素顶部的像素，也就是已经滚动了多少距离</p></li></ol><p><img src="/imageO/9.png" alt="xxxtop"></p><h4 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h4><ol><li>offsetXXX 可以看作是 clientXXX + 外边框 border + 滚动条（有的话）</li><li>scrollXXX 可以看作是 clientXXX + 隐藏区域大小（如果有滚动的话）</li></ol>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>前端基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axios拦截器</title>
    <link href="/2021/06/17/Vue&amp;&amp;axios%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <url>/2021/06/17/Vue&amp;&amp;axios%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>首先要知道登录不仅仅是拿着用户名和密码通过接口发给后端就大功告成了,要从几个方面考虑</p><ul><li>异步登录，通过登录接口拿到token</li><li>利用vuex的state管理token、用户信息等</li><li>利用axios拦截器，拦截每一次请求/响应来处理token</li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">token</span>是用户登录成功的标识，每一次请求数据时都要发送<span class="hljs-built_in">token</span>给后端验证 &amp; 接收后端返回状态码判断当前用户登录状态<br><br></code></pre></td></tr></table></figure><h4 id="登录的基本实现"><a href="#登录的基本实现" class="headerlink" title="登录的基本实现"></a>登录的基本实现</h4><p>点击按钮触发事件Login.vue文件中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript">methods: &#123;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">submitHandler</span>(<span class="hljs-params">e</span>)</span> &#123;<br>    e.preventDefault();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.$http.get(<span class="hljs-string">&quot;/api/login&quot;</span>, &#123;<br>        params: <span class="hljs-built_in">this</span>.model,<br>      &#125;);<br>     <span class="hljs-keyword">if</span>(result.code==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>       <span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;settoken&#x27;</span>,result.token)<br>       <span class="hljs-built_in">window</span>.localStorage.setItem(<span class="hljs-string">&#x27;token&#x27;</span>,result.token)<br>     &#125;<span class="hljs-keyword">else</span>&#123;<br>       alert(result.messages)<br>     &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-built_in">console</span>.log(error);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>Vuex中 store中代码</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pf">export <span class="hljs-keyword">default</span> new Vuex.Store(&#123;<br>  <span class="hljs-keyword">state</span>: &#123;<br>    token: &#x27;&#x27;<br>  &#125;,<br>  mutations: &#123;<br>    // 设置vuex的token<br>    settoken(<span class="hljs-keyword">state</span>, token) &#123;<br>      <span class="hljs-keyword">state</span>.token = token<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a>axios拦截器</h4><p>我的拦截器目录是 src\setaxios.js</p><p>main.js中全局注册使用</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import  setaxios  from  <span class="hljs-string">&#x27;./setaxios&#x27;</span><br><span class="hljs-function"><span class="hljs-title">setaxios</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>setaxios.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span>  axios  <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">import</span>  store  <span class="hljs-keyword">from</span>  <span class="hljs-string">&#x27;./store/index&#x27;</span><br><span class="hljs-keyword">import</span>  router  <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router/index&#x27;</span><br><br><span class="hljs-comment">// http全局拦截</span><br><span class="hljs-comment">// token要放在我们请求的header上面带回去的后端</span><br><br><br><span class="hljs-keyword">export</span>  <span class="hljs-keyword">default</span>  <span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">setAxios</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-comment">// 请求拦截</span><br>  axios.interceptors.request.use(<br>    config=&gt;&#123;<br>      <span class="hljs-keyword">if</span>(store.state.token)&#123;<br>        config.headers.token=store.state.token;<br>      &#125;<br>      <span class="hljs-keyword">return</span>  config<br>    &#125;<br>)<br><span class="hljs-comment">// 每次的请求都是有返回的，都是先经过这个拦截器的</span><br>axios.interceptors.response.use(<br>  response=&gt;&#123;<br>    <span class="hljs-keyword">if</span>(response.status==<span class="hljs-number">200</span>)&#123;<br>      <span class="hljs-keyword">const</span>  data=response.data<br>      <span class="hljs-keyword">if</span>(data.code==-<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">// 登录过期  需要重新登录，清空vuex的token和localstorage的token</span><br>        store.commit(<span class="hljs-string">&#x27;settoken&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-built_in">localStorage</span>.removeItem(<span class="hljs-string">&#x27;token&#x27;</span>)<br>        <span class="hljs-comment">// 跳转到login页面</span><br>        router.replace(&#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/login&#x27;</span>&#125;)<br>      &#125;<br>      <span class="hljs-keyword">return</span>  data<br>    &#125;<br>    <span class="hljs-keyword">return</span>  response<br>  &#125;<br>)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/imageO/5.png" alt="token存储成功"></p><h4 id="为什么要使用vuex"><a href="#为什么要使用vuex" class="headerlink" title="为什么要使用vuex"></a>为什么要使用vuex</h4><p>因为通过登录得到的用户信息在多个组件中都会用到，使用vuex直接通过state或getter访问变量很方便。但不要为了使用vuex而使用vuex</p><h4 id="既然用了vuex为什么还要将token存放到localStorage-sessionStorage-cookie中去"><a href="#既然用了vuex为什么还要将token存放到localStorage-sessionStorage-cookie中去" class="headerlink" title="既然用了vuex为什么还要将token存放到localStorage/sessionStorage/cookie中去"></a>既然用了vuex为什么还要将token存放到localStorage/sessionStorage/cookie中去</h4><p>因为刷新会导致vuex的state中的变量重置为初始值（「变量值会丢失」）</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cookie、localStorage、sessionStorage&amp;&amp;token</title>
    <link href="/2021/06/16/cookie%E3%80%81localStorage%E3%80%81sessionStorage&amp;token/"/>
    <url>/2021/06/16/cookie%E3%80%81localStorage%E3%80%81sessionStorage&amp;token/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="什么是认证（Authentication）"><a href="#什么是认证（Authentication）" class="headerlink" title="什么是认证（Authentication）"></a>什么是认证（Authentication）</h3><p>通俗地讲就是验证当前用户的身份，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功）</p><p>互联网中的认证：</p><ol><li>用户名密码登录</li><li>邮箱发送登录链接</li><li>手机号接收验证码</li><li>只要你能收到邮箱/验证码，就默认你是账号的主人</li></ol><h3 id="什么是授权（Authorization）"><a href="#什么是授权（Authorization）" class="headerlink" title="什么是授权（Authorization）"></a>什么是授权（Authorization）</h3><p>用户授予第三方应用访问该用户某些资源的权限</p><p>你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限）</p><p>你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）</p><blockquote><p>实现授权的方式有：cookie、session、token、OAuth</p></blockquote><h3 id="cookie、localStorage、sessionStorage"><a href="#cookie、localStorage、sessionStorage" class="headerlink" title="cookie、localStorage、sessionStorage"></a>cookie、localStorage、sessionStorage</h3><h4 id="相同点：都保存在浏览器端"><a href="#相同点：都保存在浏览器端" class="headerlink" title="相同点：都保存在浏览器端"></a>相同点：都保存在浏览器端</h4><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol><li>传递方式不同</li></ol><ul><li>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。</li><li>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li></ul><ol start="2"><li>数据大小不同</li></ol><ul><li>（cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。）  存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。</li><li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li></ul><ol start="3"><li>数据有效期不同</li></ol><ul><li>sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；</li><li>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；</li><li>cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。</li></ul><ol start="4"><li>作用域不同</li></ol><ul><li>sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</li><li>localStorage在所有同源窗口中都是共享的；</li><li>cookie也是在所有同源窗口中都是共享的。</li></ul><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p><strong>Token的引入</strong>：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。</p><p><strong>Token的定义</strong>：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。</p><p><strong>使用Token的目的</strong>：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p><p><strong>Token 是在服务端产生的</strong>。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位</p><h4 id="为什么要用-Token？"><a href="#为什么要用-Token？" class="headerlink" title="为什么要用 Token？"></a>为什么要用 Token？</h4><p>可以解决哪些问题呢？</p><ol><li><p>Token 完全由应用管理，所以它可以避开同源策略</p></li><li><p>Token 可以避免 CSRF 攻击(<a href="http://dwz.cn/7joLzx">http://dwz.cn/7joLzx</a>)</p></li><li><p>Token 可以是无状态的，可以在多个服务间共享</p></li></ol><h4 id="基于-Token-的身份验证"><a href="#基于-Token-的身份验证" class="headerlink" title="基于 Token 的身份验证"></a>基于 Token 的身份验证</h4><p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li><li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li></ol><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6844904009061367821#heading-7">一文彻底搞懂Cookie、Session、Token到底是什么</a></p><p><a href="https://juejin.cn/post/6844904034181070861#heading-6">傻傻分不清之 Cookie、Session、Token、JWT</a></p><p><a href="https://www.cnblogs.com/xuxinstyle/p/9675541.html">深入理解token</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Css单位px，rem，em，vw，vh的区别</title>
    <link href="/2021/06/16/Css%E5%8D%95%E4%BD%8Dpx%EF%BC%8Crem%EF%BC%8Cem%EF%BC%8Cvw%EF%BC%8Cvh%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/06/16/Css%E5%8D%95%E4%BD%8Dpx%EF%BC%8Crem%EF%BC%8Cem%EF%BC%8Cvw%EF%BC%8Cvh%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="px"><a href="#px" class="headerlink" title="px"></a>px</h3><p>px就是pixel像素的缩写，相对长度单位，网页设计常用的基本单位。像素px是相对于显示器屏幕分辨率而言的</p><h3 id="em"><a href="#em" class="headerlink" title="em"></a>em</h3><p>em是相对长度单位。相对于当前对象内文本的字体尺寸（参考物是父元素的font-size）</p><p>如当前父元素的字体尺寸未设置，则相对于浏览器的默认字体尺寸</p><p>特点：</p><ol><li><p>em的值并不是固定的；</p></li><li><p>em会继承父级元素的字体大小</p></li></ol><h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>rem是CSS3新增的一个相对单位，rem是相对于HTML根元素的字体大小（font-size）来计算的长度单位</p><p>如果你没有设置html的字体大小，就会以浏览器默认字体大小，一般是16px</p><p>优点是，只需要设置根目录的大小就可以把整个页面的成比例的调好</p><p>rem兼容性：除了IE8及更早版本外，所有浏览器均已支持rem</p><p>em与rem的区别：</p><blockquote><p>rem是相对于根元素（html）的字体大小，而em是相对于其父元素的字体大小</p></blockquote><p>两者使用规则：</p><p>如果这个属性根据它的font-size进行测量，则使用em<br>其他的一切事物属性均使用rem<br>这里提供了一个px、em、rem单位的转换工具：<a href="http://pxtoem.com/">http://pxtoem.com/</a></p><h3 id="vw、vh"><a href="#vw、vh" class="headerlink" title="vw、vh"></a>vw、vh</h3><p>vw、vh、vmax、vmin这四个单位都是基于视口</p><p>vw是相对视口（viewport）的宽度而定的，长度等于视口宽度的1/100</p><p>假如浏览器的宽度为200px，那么1vw就等于2px（200px/100）</p><p>vh是相对视口（viewport）的高度而定的，长度等于视口高度的1/100</p><p>假如浏览器的高度为500px，那么1vh就等于5px（500px/100）</p><p>vmin和vmax是相对于视口的高度和宽度两者之间的最小值或最大值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">如果浏览器的高为300px、宽为500px，那么1vmin就是3px，1vmax就是5px；如果浏览器的高为800px，宽为1080px，那么1vmin也是8px，1vmax也是10.8px<br></code></pre></td></tr></table></figure><h4 id="其他单位"><a href="#其他单位" class="headerlink" title="其他单位"></a>其他单位</h4><p>%（百分比）</p><p>一般来说就是相对于父元素</p><p>1、对于普通定位元素就是我们理解的父元素</p><p>2、对于position: absolute;的元素是相对于已定位的父元素</p><p>3、对于position: fixed;的元素是相对于ViewPort（可视窗口）</p><h4 id="vm"><a href="#vm" class="headerlink" title="vm"></a>vm</h4><p>css3新单位，相对于视口的宽度或高度中较小的那个</p><p>其中最小的那个被均分为100单位的vm</p><p>比如：浏览器高度900px，宽度1200px，取最小的浏览器高度，1 vm = 900px/100 = 9 px</p><p>缺点：兼容性差</p><h4 id="参考链接博客圆"><a href="#参考链接博客圆" class="headerlink" title="参考链接博客圆"></a>参考链接<a href="https://www.cnblogs.com/theblogs/p/10516098.html">博客圆</a></h4>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>前端基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue&amp; 使用axios的多种方式</title>
    <link href="/2021/06/15/Vue&amp;&amp;axios%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/06/15/Vue&amp;&amp;axios%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="vue中使用axios的多种方式"><a href="#vue中使用axios的多种方式" class="headerlink" title="vue中使用axios的多种方式"></a>vue中使用axios的多种方式</h3><p>axios<br>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端</p><p>它本身具有以下特征：</p><ul><li>从浏览器中创建 XMLHttpRequest</li><li>从 node.js 发出 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>客户端支持防止 CSRF/XSRF</li></ul><h3 id="axios默认是不让ajax请求头部携带cookie的"><a href="#axios默认是不让ajax请求头部携带cookie的" class="headerlink" title="axios默认是不让ajax请求头部携带cookie的"></a>axios默认是不让ajax请求头部携带cookie的</h3><p>axios 解决跨域cookie丢失问题</p><p>设置 axios.defaults.withCredentials = true 即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ：">axios.defaults.withCredentials &#x3D; true;<br>var param &#x3D; new URLSearchParams();<br>param.append(&quot;vCode&quot;,vcode);<br>axios.post(&#39;http:&#x2F;&#x2F;localhost&#39;,param)<br>.then(function(res) &#123;<br>var rs&#x3D;res.data;<br>console.log(rs.data);<br>&#125;)<br>.catch(function(err) &#123;<br>console.log(err);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="配合vue"><a href="#配合vue" class="headerlink" title="配合vue"></a>配合vue</h3><p>目前主流的 Vue 项目，都选择 axios 来完成 ajax 请求</p><p>Axios 是一个基于 promise 的 HTTP 库</p><p>axios并没有install 方法，所以是不能使用vue.use()方法的。<br>那么难道每个文件都要来引用一次？解决方法有很多种：</p><ol><li><p>结合 vue-axios使用</p></li><li><p>axios 改写为 Vue 的原型属性</p></li><li><p>结合 Vuex的action</p></li></ol><h4 id="结合-vue-axios使用"><a href="#结合-vue-axios使用" class="headerlink" title="结合 vue-axios使用"></a>结合 vue-axios使用</h4><p>vue-axios</p><p>用于将axios集成到Vuejs的小包装器</p><p>github: <a href="https://github.com/axios/axios">https://github.com/axios/axios</a></p><p>安装： npm install –save axios vue-axios</p><p>vue-axios是按照vue插件的方式去写的。那么结合vue-axios，就可以去使用vue.use方法了</p><p>首先在主入口文件main.js中引用</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><span class="hljs-keyword">import</span> VueAxios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-axios&#x27;</span><br><br>Vue.use(VueAxios,axios);<br></code></pre></td></tr></table></figure><p>之后就可以使用了，在组件文件中的methods里去使用了</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">getNewsList()&#123;<br>      <span class="hljs-built_in">this</span>.axios.get(<span class="hljs-string">&#x27;api/getNewsList&#x27;</span>).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(response)</span>=&gt;</span>&#123;<br>        <span class="hljs-built_in">this</span>.newsList=response.data.data;<br>      &#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(response)</span>=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(response);<br>      &#125;)<br><br><br>    &#125;,<br></code></pre></td></tr></table></figure><blockquote><p>方法2： axios 改写为 Vue 的原型属性<br>首先在主入口文件main.js中引用，之后挂在vue的原型链上</p></blockquote><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br>Vue.prototype.$axios= axios<br><br>在组件中使用<br><br><br><span class="hljs-built_in">this</span>.$axios.get(<span class="hljs-string">&#x27;api/getNewsList&#x27;</span>).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(response)</span>=&gt;</span>&#123;<br>        <span class="hljs-built_in">this</span>.newsList=response.data.data;<br>      &#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(response)</span>=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(response);<br>      &#125;)<br></code></pre></td></tr></table></figure><p>方法3：结合vuex(待学)</p><h5 id="参考链接简书"><a href="#参考链接简书" class="headerlink" title="参考链接简书"></a>参考链接<a href="https://www.jianshu.com/p/4a872643f5ea">简书</a></h5>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何实现路由懒加载？</title>
    <link href="/2021/06/10/Vue%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <url>/2021/06/10/Vue%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p><p>结合 Vue 的异步组件 (opens new window)和 Webpack 的代码分割功能 (opens new window)，轻松实现路由组件的懒加载。</p><blockquote><p>vue-router路由懒加载（解决vue项目首次加载慢）</p></blockquote><p>也叫延迟加载，即在需要的时候进行加载，随用随载。</p><p>为什么需要懒加载？</p><p>像vue这种单页面应用，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，时间过长，会出啊先长时间的白屏，即使做了loading也是不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时</p><p>简单的说就是：进入首页不用一次加载过多资源造成用时过长！！！</p><blockquote><p>把不同路由对应的组件分割成不同的代码块，然后当路由被访问时才加载对应的组件即为路由的懒加载，可以加快项目的加载速度，提高效率</p></blockquote><p>写法一：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const router = <span class="hljs-built_in">new</span> VueRouter(&#123;<br>  routes: [<br>    &#123;<br>      <span class="hljs-type">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>      <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;Home&#x27;</span>，<br>      component:() = <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/home&#x27;</span>)<br>  &#125;<br>  ]<br>&#125;)<br><br></code></pre></td></tr></table></figure><blockquote><p>使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</p></blockquote><p>写法二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// r就是resolve</span><br><span class="hljs-keyword">const</span> List = <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-built_in">require</span>.ensure([], <span class="hljs-function">() =&gt;</span> r(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@/components/list&#x27;</span>)), <span class="hljs-string">&#x27;list&#x27;</span>);<br><span class="hljs-comment">// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 </span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> Router(&#123;<br>  routes: [<br>  &#123;<br>    path: <span class="hljs-string">&#x27;/list&#x27;</span>,<br>    component: List,<br>    name: <span class="hljs-string">&#x27;list&#x27;</span><br>  &#125;<br> ]<br>&#125;))<br></code></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html#%E6%8A%8A%E7%BB%84%E4%BB%B6%E6%8C%89%E7%BB%84%E5%88%86%E5%9D%97">路由懒加载</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue单向数据流与双向数据绑定的理解</title>
    <link href="/2021/05/29/Vue%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%8E%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2021/05/29/Vue%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%8E%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<hr><h4 id="一：单向数据流"><a href="#一：单向数据流" class="headerlink" title="一：单向数据流"></a>一：单向数据流</h4><p>单向数据流的意思是指数据的改变只能从一个方向修改。</p><p>举个栗子：如一个父组件有两个子组件，分别为1和2。父组件向子组件传递数据，两个组件都接收到了父组件传递过来的数据，在组件1中修改父组件传递过来的数据，子组件2和父组件的值不会发生变化。这就是单向的数据流，子组件不能直接改变父组件的状态。但是如果父组件改变相应的数据，两个子组件的数据也会发生相应的改变。</p><h4 id="二：双向数据绑定"><a href="#二：双向数据绑定" class="headerlink" title="二：双向数据绑定"></a>二：双向数据绑定</h4><p>由MVVM框架实现，MVVM的组成：View，ViewModel，Model。其中View 和 Model不能直接通信，要通过ViewModel来进行通信。</p><p>举个栗子：例如，当Model部分数据发生改变时，由于vue中Data Binding将底层数据和Dom层进行了绑定，ViewModel通知View层更新视图；当在视图 View数据发生变化也会同步到Model中。View和Model之间的同步完全是自动的，不需要人手动的操作DOM。</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://zhuanlan.zhihu.com/p/70538875">知乎</a></p><p><a href="https://juejin.cn/post/6844903504834740232">掘金</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git冲突与解决方法</title>
    <link href="/2021/05/28/Git%E5%86%B2%E7%AA%81%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2021/05/28/Git%E5%86%B2%E7%AA%81%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="Git冲突与解决方法"><a href="#Git冲突与解决方法" class="headerlink" title="Git冲突与解决方法"></a>Git冲突与解决方法</h3><h4 id="1-git冲突的场景"><a href="#1-git冲突的场景" class="headerlink" title="1. git冲突的场景"></a>1. git冲突的场景</h4><p><strong>情景一：多个分支代码合并到一个分支时；</strong></p><p><strong>情景二：多个分支向同一个远端分支推送代码时；</strong></p><p>实际上，push操作即是将本地代码merge到远端库分支上。</p><p>关于push和pull其实就分别是用本地分支合并到远程分支 和 将远程分支合并到本地分支</p><p>所以这两个过程中也可能存在冲突。</p><p>git的合并中产生冲突的具体情况：</p><h5 id="lt-1-gt-两个分支中修改了同一个文件（不管什么地方）"><a href="#lt-1-gt-两个分支中修改了同一个文件（不管什么地方）" class="headerlink" title="　&lt;1&gt; 两个分支中修改了同一个文件（不管什么地方）"></a><strong>　&lt;1&gt; 两个分支中修改了同一个文件</strong>（不管什么地方）</h5><h5 id="lt-2-gt-两个分支中修改了同一个文件的名称"><a href="#lt-2-gt-两个分支中修改了同一个文件的名称" class="headerlink" title="　&lt;2&gt;两个分支中修改了同一个文件的名称"></a><strong>　&lt;2&gt;两个分支中修改了同一个文件的名称</strong></h5><p>两个分支中分别修改了不同文件中的部分，不会产生冲突，可以直接将两部分合并。</p><h4 id="2-冲突解决方法"><a href="#2-冲突解决方法" class="headerlink" title="2. 冲突解决方法"></a>2. 冲突解决方法</h4><ol><li>情景一：在当前分支上，直接修改冲突代码—&gt;add—&gt;commit。</li><li>情景二：在本地当前分支上，修改冲突代码—&gt;add—&gt;commit—&gt;push</li></ol><p> 注：借用vim或者IDE或者直接找到冲突文件，修改。</p><h4 id="3、实战演示"><a href="#3、实战演示" class="headerlink" title="3、实战演示"></a>3、实战演示</h4><p>（1）情景</p><p>　　本地库中两个不同分支，修改同一个文件同一代码块，两分支先后将修改合并到master分支上，master在合并第二个分支代码时，报错：合并冲突。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.cnblogs.com/gavincoder/p/9071959.html">Git冲突与解决方法</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ajax常见面试题</title>
    <link href="/2021/05/28/ajax%E9%9D%A2%E8%AF%95/"/>
    <url>/2021/05/28/ajax%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="什么是ajax？ajax作用是什么？"><a href="#什么是ajax？ajax作用是什么？" class="headerlink" title="什么是ajax？ajax作用是什么？"></a>什么是ajax？ajax作用是什么？</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">异步的javascript和<span class="hljs-keyword">xml</span>  <span class="hljs-title">AJAX</span> 是一种用于创建快速动态网页的技术。  ajax用来与后台交互<br></code></pre></td></tr></table></figure><h3 id="原生js-ajax请求有几个步骤？分别是什么"><a href="#原生js-ajax请求有几个步骤？分别是什么" class="headerlink" title="原生js ajax请求有几个步骤？分别是什么"></a>原生js ajax请求有几个步骤？分别是什么</h3><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-comment">//创建 XMLHttpRequest 对象</span><br><span class="hljs-keyword">var</span> ajax = <span class="hljs-keyword">new</span> XMLHttpRequest();<br><span class="hljs-comment">//规定请求的类型、URL 以及是否异步处理请求。</span><br>ajax.open(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-built_in">url</span>,<span class="hljs-literal">true</span>);<br><span class="hljs-comment">//发送信息至服务器时内容编码类型</span><br>ajax.setRequestHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>); <br><span class="hljs-comment">//发送请求</span><br>ajax.send(<span class="hljs-literal">null</span>);  <br><span class="hljs-comment">//接受服务器响应数据</span><br>ajax.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (obj.readyState == <span class="hljs-number">4</span> &amp;&amp; (obj.status == <span class="hljs-number">200</span> || obj.status == <span class="hljs-number">304</span>)) &#123; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="ajax几种请求方式？他们的优缺点？"><a href="#ajax几种请求方式？他们的优缺点？" class="headerlink" title="ajax几种请求方式？他们的优缺点？"></a>ajax几种请求方式？他们的优缺点？</h3><p>常用的post,get,delete。不常用copy、head、link等等。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Get</span><br><span class="hljs-keyword">GET</span>请求的数据会附加在URL之后，用问号分割，多个参数用&amp;进行连接。<br><span class="hljs-keyword">GET</span>请求的数据会暴露在地址栏中。<br><span class="hljs-keyword">GET</span>请求URL的编码格式采用的是ASCII编码，而不是Unicode编码。<br><span class="hljs-keyword">GET</span>请求传输大小有限制，大小在<span class="hljs-number">2</span>KB。<br><span class="hljs-keyword">GET</span>相对安全性较差，会被浏览器主动缓存。<br><span class="hljs-keyword">GET</span>产生一个TCP数据包，head和data一起发送。<br><span class="hljs-keyword">GET</span>浏览器回退无害。<br><br><br>POST<br>POST请求会把数据放置在HTTP请求包的包体中，不会直接暴露给用户。<br>POST请求，理论上大小是不会限制的，但是实际上各个服务器会规定POST提交数据大小。<br>POST相对<span class="hljs-keyword">Get</span>更安全，因为参数不会保存浏览器立式或者是web服务器日志中。<br>POST产生两个TCP数据包，<span class="hljs-keyword">header</span>先发送，服务器响应<span class="hljs-number">100</span>ms然后继续，发送data，服务器<span class="hljs-number">200</span>然后返回数据。<br>POST浏览器回退重新请求。<br></code></pre></td></tr></table></figure><h3 id="什么情况造成跨域？"><a href="#什么情况造成跨域？" class="headerlink" title="什么情况造成跨域？"></a>什么情况造成跨域？</h3><p>同源策略限制 不同源会造成跨域。以下任意一种情况不同，都是不同源。</p><p><img src="/imageO/2.png" alt="图片"></p><h3 id="跨域解决方案有哪些？"><a href="#跨域解决方案有哪些？" class="headerlink" title="跨域解决方案有哪些？"></a>跨域解决方案有哪些？</h3><p>跨域，指的是浏览器不能执行其他网站的脚本。浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。<br>解决办法：</p><ol><li>JSONP：注意JSONP只支持GET请求，不支持POST请求。( 只能解决get跨域(问的最多))<br>原理：ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。 —   callback</li></ol><p>步骤：</p><ol><li>去创建一个script标签</li><li>script的src属性设置接口地址</li><li>接口参数,必须要带一个自定义函数名 要不然后台无法返回数据。</li><li>通过定义函数名去接收后台返回数据</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>去创建一个script标签<br>var  script = document.createElement(<span class="hljs-string">&quot;script&quot;</span>);<br><span class="hljs-regexp">//</span>script的src属性设置接口地址 并带一个callback回调函数名称<br>script.src = <span class="hljs-string">&quot;http://127.0.0.1:8888/index.php?callback=jsonpCallback&quot;</span>;<br><span class="hljs-regexp">//</span>插入到页面<br>document.head.appendChild(script);<br><span class="hljs-regexp">//</span>通过定义函数名去接收后台返回数据<br><span class="hljs-keyword">function</span> jsonpCallback(data)&#123;<br>    <span class="hljs-regexp">//</span>注意  jsonp返回的数据是json对象可以直接使用<br>    <span class="hljs-regexp">//</span>ajax  取得数据是json字符串需要转换成json对象才可以使用。<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>代理：写后端接口，在后端调用页面拿到返回值返回给html文件。相当于绕过了浏览器，就不会存在跨域问题。例；(nigx反向代理)</p></li><li><p>CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</p></li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin:*&#x27;</span>);<span class="hljs-comment">//允许所有来源访问</span><br><span class="hljs-selector-tag">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Method:POST,GET&#x27;</span>);<span class="hljs-comment">//允许访问的方式</span><br></code></pre></td></tr></table></figure><ol start="4"><li>proxy代理 目前常用方式,通过服务器设置代理</li><li>window.postMessage() 利用h5新特性window.postMessage()</li></ol><h4 id="http常见状态码有哪些？"><a href="#http常见状态码有哪些？" class="headerlink" title="http常见状态码有哪些？"></a>http常见状态码有哪些？</h4><p>一: 2开头状态码</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span>xx (成功)表示成功处理了请求的状态代码<br><span class="hljs-symbol">200 </span>(成功) 服务器已成功处理了请求。 通常。<br></code></pre></td></tr></table></figure><p>二: 3开头状态码</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span>xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。<br><span class="hljs-symbol">304 </span>(未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br></code></pre></td></tr></table></figure><p>三: 4开头状态码</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">4</span>xx<span class="hljs-comment">(请求错误)</span> 这些状态代码表示请求可能出错，妨碍了服务器的处理<br><span class="hljs-number">1</span>:<span class="hljs-number">400</span> <span class="hljs-comment">(错误请求)</span> 服务器不理解请求的语法。<br> <br><span class="hljs-number">2</span>:<span class="hljs-number">403</span> <span class="hljs-comment">(禁止)</span> 服务器拒绝请求。<br><br><span class="hljs-number">3</span>:<span class="hljs-number">404</span> <span class="hljs-comment">(未找到)</span> 服务器找不到请求的网页。<br></code></pre></td></tr></table></figure><p>四: 5开头状态码</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span>xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错<br><span class="hljs-symbol">500 </span>(服务器内部错误) 服务器遇到错误，无法完成请求。<br><br><span class="hljs-symbol">501 </span>(尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br><br><span class="hljs-symbol">502 </span>(错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。<br><br><span class="hljs-symbol">503 </span>(服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。<br><br><span class="hljs-symbol">504 </span>(网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br><br><span class="hljs-symbol">505 </span>(HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。<br><br></code></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844903573529034759">ajax常见面试题</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从输入URL到浏览器显示页面过程中都发生了什么？</title>
    <link href="/2021/05/27/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%BF%87%E7%A8%8B%E9%9D%A2%E8%AF%95/"/>
    <url>/2021/05/27/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%BF%87%E7%A8%8B%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="URL的输入到浏览器解析的一系列事件"><a href="#URL的输入到浏览器解析的一系列事件" class="headerlink" title="URL的输入到浏览器解析的一系列事件"></a>URL的输入到浏览器解析的一系列事件</h3><ol><li>浏览器根据请求的url交给DNS域名解析</li><li>发起TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束。</li></ol><blockquote><p>简单说说，浏览器根据请求的url交给dns域名解析，查找真正的ip地址，向服务器发起请求；服务器交给后台处理后，返回数据，浏览器会接收到文件数据，比如，html,js，css，图像等；然后浏览器会对加载到的资源进行语法解析，建立相应的内部数据结构；载入解析到得资源文件，渲染页面，完成显示页面效果。</p></blockquote><p>不够清楚明白吗？</p><h4 id="那就再次详细一下，从浏览器接收url，开始进行网络请求线程，发出一个完整的HTTP请求，从服务器端接收请求到对应的后台接收到请求，然后是后台和前台的http交互；其中的缓存问题（http的缓存），浏览器接收到http数据包后的解析流程，css的可视化格式模型，js引擎解析过程等；其他呈现页面效果"><a href="#那就再次详细一下，从浏览器接收url，开始进行网络请求线程，发出一个完整的HTTP请求，从服务器端接收请求到对应的后台接收到请求，然后是后台和前台的http交互；其中的缓存问题（http的缓存），浏览器接收到http数据包后的解析流程，css的可视化格式模型，js引擎解析过程等；其他呈现页面效果" class="headerlink" title="那就再次详细一下，从浏览器接收url，开始进行网络请求线程，发出一个完整的HTTP请求，从服务器端接收请求到对应的后台接收到请求，然后是后台和前台的http交互；其中的缓存问题（http的缓存），浏览器接收到http数据包后的解析流程，css的可视化格式模型，js引擎解析过程等；其他呈现页面效果"></a>那就再次详细一下，从浏览器接收url，开始进行网络请求线程，发出一个完整的HTTP请求，从服务器端接收请求到对应的后台接收到请求，然后是后台和前台的http交互；其中的缓存问题（http的缓存），浏览器接收到http数据包后的解析流程，css的可视化格式模型，js引擎解析过程等；其他呈现页面效果</h4><p>这里就需要你对浏览器内核的理解：其中主要的渲染引擎和JS引擎，这里了解一下你对浏览器内核的理解。</p><ol><li><p>渲染引擎，是负责取得网页的内容，整理信息，以及计算网页的显示方式，然后输出到显示器上。</p></li><li><p>JS引擎是用于解析和执行javascript来实现网页的动态效果。</p></li></ol><blockquote><p>浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。其实最开始渲染引擎和JS引擎是没有区分明确的，不过后来JS引擎越来越独立，so，内核就倾向于渲染引擎。</p></blockquote><blockquote><p>对于资源请求/获取,资源响应/页面渲染，会给网络带宽和设备资源带来压力，这个时候就会考虑到web的性能优化。</p></blockquote><h4 id="通过DNS解析域名的实际IP地址"><a href="#通过DNS解析域名的实际IP地址" class="headerlink" title="通过DNS解析域名的实际IP地址"></a>通过DNS解析域名的实际IP地址</h4><p>发送至 DNS 服务器并获得域名对应的 WEB 服务器的 ip 地址。</p><p>DNS 解析首先会从你的浏览器的缓存中去寻找是否有这个网址对应的 IP 地址，如果没有就向OS系统的 DNS 缓存中寻找，如果没有就是路由器的 DNS 缓存， 如果没有就是 ISP 的DNS 缓存中寻找。 所以，缓存的寻找过程就是： 浏览器 -&gt; 系统 -&gt; 路由器 -&gt; ISP。 如果在某一个缓存中找到的话，就直接跳到下一步。 如果都没有找到的话，就会向 ISP 或者公共的域名解析服务发起 DNS 查找请求。这个查找的过程还是一个递归查询的过程。</p><h5 id="检查浏览器是否有缓存"><a href="#检查浏览器是否有缓存" class="headerlink" title="检查浏览器是否有缓存"></a>检查浏览器是否有缓存</h5><p>通过Cache-Control和Expires来检查是否命中强缓存，命中则直接取本地磁盘的html（状态码为200 from disk(or memory) cache，内存or磁盘）；</p><p>如果没有命中强缓存，则会向服务器发起请求（先进行下一步的TCP连接），服务器通过Etag和Last-Modify来与服务器确认返回的响应是否被更改（协商缓存），若无更改则返回状态码（304 Not Modified）,浏览器取本地缓存；</p><p>若强缓存和协商缓存都没有命中则返回请求结果。</p><h4 id="与-WEB-服务器建立-TCP-连接"><a href="#与-WEB-服务器建立-TCP-连接" class="headerlink" title="与 WEB 服务器建立 TCP 连接"></a>与 WEB 服务器建立 TCP 连接</h4><p>TCP 协议通过三次握手建立连接。</p><p>客户端通过 SYN 报文段发送连接请求，确定服务端是否开启端口准备连接。状态设置为 SYN_SEND;</p><p>服务器如果有开着的端口并且决定接受连接，就会返回一个 SYN+ACK 报文段给客户端，状态设置为 SYN_RECV；</p><p>客户端收到服务器的 SYN+ACK 报文段，向服务器发送 ACK 报文段表示确认。此时客户端和服务器都设置为 ESTABLISHED 状态。连接建立，可以开始数据传输了。</p><p>翻译成大白话就是：</p><p>客户端：你能接收到我的消息吗？</p><p>服务端：可以的，那你能接收到我的回复吗？</p><p>客户端：可以，那我们开始聊正事吧。</p><p>为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人。</p><p>为什么不是4次？：3次够了第四次浪费</p><h4 id="浏览器发送HTTP请求"><a href="#浏览器发送HTTP请求" class="headerlink" title="浏览器发送HTTP请求"></a>浏览器发送HTTP请求</h4><p>首先科补一个小知识，HTTP的端口为80/8080，而HTTPS的端口为443</p><p>发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口 请求报文由请求行，请求抱头，请求正文组成。</p><p>请求行<br>请求行的格式为Method Request-URL HTTP-Version CRLF eg: GET index.html HTTP/1.1 常用的方法有: GET,POST, PUT, DELETE, OPTIONS, HEAD。</p><p>常见的请求方法区别<br>这里主要展示GET和POST的区别</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">Get</span><br><span class="hljs-keyword">GET</span>请求的数据会附加在URL之后，用问号分割，多个参数用&amp;进行连接。<br><br><span class="hljs-keyword">GET</span>请求的数据会暴露在地址栏中。<br><br><span class="hljs-keyword">GET</span>请求URL的编码格式采用的是ASCII编码，而不是<span class="hljs-keyword">Unicode</span>编码。<br><br><span class="hljs-keyword">GET</span>请求传输大小有限制，大小在<span class="hljs-number">2</span>KB。<br><br><span class="hljs-keyword">GET</span>相对安全性较差，会被浏览器主动缓存。<br><br><span class="hljs-keyword">GET</span>产生一个TCP数据包，head和data一起发送。<br><br><span class="hljs-keyword">GET</span>浏览器回退无害。<br></code></pre></td></tr></table></figure><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">POST</span><br><span class="hljs-keyword">POST</span>请求会把数据放置在HTTP请求包的包体中，不会直接暴露给用户。<br><br><span class="hljs-keyword">POST</span>请求，理论上大小是不会限制的，但是实际上各个服务器会规定<span class="hljs-keyword">POST</span>提交数据大小。<br><br><span class="hljs-keyword">POST</span>相对Get更安全，因为参数不会保存浏览器立式或者是web服务器日志中。<br><br><span class="hljs-keyword">POST</span>产生两个TCP数据包，header先发送，服务器响应100ms然后继续，发送data，服务器200然后返回数据。<br><br><span class="hljs-keyword">POST</span>浏览器回退重新请求。<br></code></pre></td></tr></table></figure><h4 id="服务器处理请求并返回HTTP报文"><a href="#服务器处理请求并返回HTTP报文" class="headerlink" title="服务器处理请求并返回HTTP报文"></a>服务器处理请求并返回HTTP报文</h4><p>它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，分成三份，状态码 ，响应报头和响应报文(你从服务器请求的HTML,CSS,JS文件就放在这里面)</p><h4 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h4><p>解析HTML形成DOM树</p><p>解析CSS形成CSSOM 树</p><p>合并DOM树和CSSOM树形成（Render Tree）渲染树  </p><p>浏览器开始渲染并绘制页面 这个过程涉及两个比较重要的概念回流和重绘，<strong>DOM结点都是以盒模型形式存在，需要浏览器去计算位置和宽度等，这个过程就是回流。等到页面的宽高，大小，颜色等属性确定下来后，浏览器开始绘制内容，这个过程叫做重绘</strong>。浏览器刚打开页面一定要经过这两个过程的，但是这个过程非常非常非常消耗性能，所以我们应该尽量减少页面的回流和重绘</p><h4 id="CSS阻塞情况以及优化"><a href="#CSS阻塞情况以及优化" class="headerlink" title="CSS阻塞情况以及优化"></a>CSS阻塞情况以及优化</h4><p>1、<strong>style</strong>标签中的样式：由HTML解析器进行解析，<strong>不会</strong>阻塞浏览器渲染(可能会产生“闪屏现象”)，不会阻塞DOM解析</p><p>2、<strong>link</strong>引入的CSS样式：由CSS解析器进行解析，<strong>会</strong>阻塞浏览器渲染，会阻塞后面的js语句执行，不阻塞DOM的解析</p><p>3、优化：使用CDN节点进行外部资源加速，对CSS进行压缩，优化CSS代码(不要使用太多层选择器)</p><h4 id="JS阻塞问题"><a href="#JS阻塞问题" class="headerlink" title="JS阻塞问题"></a>JS阻塞问题</h4><p>1、js会阻塞后续DOM的解析，原因是：浏览器不知道后续脚本的内容，如果先去解析了下面的DOM，而随后的js删除了后面所有的DOM，那么浏览器就做了无用功，浏览器无法预估脚本里面具体做了什么操作，例如像document.write这种操作，索性全部停住，等脚本执行完了，浏览器再继续向下解析DOM<br>2、js会阻塞页面渲染，原因是：js中也可以给DOM设置样式，浏览器等该脚本执行完毕，渲染出一个最终结果，避免做无用功。<br>3、js会阻塞后续js的执行，原因是维护依赖关系，例如：必须先引入jQuery再引入bootstrap</p><h4 id="资源加载阻塞"><a href="#资源加载阻塞" class="headerlink" title="资源加载阻塞"></a>资源加载阻塞</h4><p>无论css阻塞，还是js阻塞，都不会阻塞浏览器加载外部资源（图片、视频、样式、脚本等）<br>原因：浏览器始终处于一种：“先把请求发出去”的工作模式，只要是涉及到网络请求的内容，无论是：图片、样式、脚本，都会先发送请求去获取资源，至于资源到本地之后什么时候用，由浏览器自己协调。这种做法效率很高。</p><h4 id="为什么CSS解析顺序从右到左"><a href="#为什么CSS解析顺序从右到左" class="headerlink" title="为什么CSS解析顺序从右到左"></a>为什么CSS解析顺序从右到左</h4><p>如果是从左到右的话：</p><p>1、第一次从爷节点 -&gt; 子节点 -&gt; 孙节点1<br>2、第一次从爷节点 -&gt; 子节点 -&gt; 孙节点2<br>3、第一次从爷节点 -&gt; 子节点 -&gt; 孙节点3</p><p>如果三次都匹配不到的话，那至少也得走三次：爷节点 -&gt; 子节点 -&gt; 孙节点，这就做了很多无用功啊</p><p>如果是从右到左的话：</p><p>1、第一次从孙节点1，找不到，停止<br>2、第一次从孙节点2，找不到，停止<br>3、第一次从孙节点3，找不到，停止<br>这样的话，尽早发现找不到，尽早停止，可以少了很多无用功。</p><h4 id="什么是重绘回流"><a href="#什么是重绘回流" class="headerlink" title="什么是重绘回流"></a>什么是重绘回流</h4><p>1、重绘：重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。<br>2、回流：渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排，或回流<br>3、”重绘”不一定需要”重排”，比如改变某个网页元素的颜色，就只会触发”重绘”，不会触发”重排”，因为布局没有改变。<br>4、”重排”大多数情况下会导致”重绘”，比如改变一个网页元素的位置，就会同时触发”重排”和”重绘”，因为布局改变了。</p><h4 id="浏览器缓存分类"><a href="#浏览器缓存分类" class="headerlink" title="浏览器缓存分类"></a>浏览器缓存分类</h4><h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5><p>不会向服务器发送请求，直接从本地缓存中获取数据<br>请求资源的的状态码为: 200 ok(from memory cache)<br>优先级：cache-control &gt; expires</p><h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><p>向服务器发送请求，服务器会根据请求头的资源判断是否命中协商缓存<br>如果命中，则返回304状态码通知浏览器从缓存中读取资源<br>优先级：Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6850037263116533773#heading-4">从浏览器地址栏输入url到显示页面的步骤</a></p><p><a href="https://juejin.cn/post/6844903832435032072#heading-0">URL的输入到浏览器解析的一系列事件</a><br><a href="https://juejin.cn/post/6986416221323264030#heading-7">「自我检验」输入URL发生了啥？希望你顺便懂这15个知识点</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebSocket和Socket.io介绍以及聊天室功能实现</title>
    <link href="/2021/05/22/socket%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    <url>/2021/05/22/socket%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>在介绍 Socket.io 之前，首先需要说一说什么是 WebSocket。</p><p>详细了解参考：</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">MDN上的介绍</a></p><p><a href="https://www.zhihu.com/question/20215561">知乎上的介绍</a></p><p><a href="http://www.cnblogs.com/mazg/p/5467960.html">WebSocket 与 Socket.io 介绍</a><br>为什么需要WebSocket</p><p>我们知道，在 HTML5 之前，客户端和服务器通过 HTTP 协议交换数据，但是，HTTP 协议具有两个特点：</p><ul><li><p><strong>HTTP 协议是一种单向的网络协议</strong>。在建立连接后，它只允许客户端 Browser/UA (User Agent) 向服务器 WebServer 发送请求后，WebServer 才能返回相应的数据。而 WebServer 不能主动推送数据给 Browser/UA。</p></li><li><p><strong>HTTP 协议是无状态的</strong>。客户端向服务器发送连接请求中会包含 identity info（鉴别信息），每次当一个连接结束时，服务器就会将这些鉴别信息丢掉，客户端再次发送 HTTP 请求时，就需要重新发送这些信息。</p></li></ul><p>现在，假设我们需要开发一个基于 Web 的应用程序，需要获取服务器的实时数据，比如股票的实时行情、聊天室的聊天内容等，这就需要客户端和服务器之间反复进行 HTTP 通信，客户端不断发送请求，去获取当前的实时数据。下面介绍两种常见的方式：</p><ul><li><strong>ajax 轮询</strong></li></ul><p>ajax 轮询的原理非常简单，就是让浏览器定时（隔几秒）向服务器发送一次请求，询问是否有新的数据，如果有就返回最新数据，浏览器接收到后将最新数据显示出来，然后重复这一过程。</p><ul><li><strong>Long Polling</strong></li></ul><p>Long Polling 的原理与 ajax 轮询的原理差不多，都是采用轮询的方式，它是 Polling 的一种改进。客户端发送请求到服务器后，服务器并不立即响应客户端，而是保持住这次连接，当有新的数据时，才返回给客户端，客户端接收到数据，进行展示，再立即发送一个新的请求给服务器，并重复这个过程。如果服务器的数据长期没有更新，一段时间后，这个请求就会超时，客户端收到超时消息后，再立即发送一个新的请求给服务器。</p><p>从上面可以看出，这两种方式都<strong>需要不断的建立 HTTP 连接，然后等待服务器处理。</strong></p><p>在这样的情况下，假如客户端能有一种新的网络协议，可以支持客户端和服务器的双向通信的就好了。于是，WebSocket 应运而生。</p><h3 id="Websocket是什么样的协议，具体有什么优点"><a href="#Websocket是什么样的协议，具体有什么优点" class="headerlink" title="Websocket是什么样的协议，具体有什么优点"></a>Websocket是什么样的协议，具体有什么优点</h3><p>Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。</p><p>首先Websocket是基于HTTP协议的，或者说借用了HTTP的协议来完成一部分握手。在握手阶段是一样的</p><h4 id="WebSocket-协议"><a href="#WebSocket-协议" class="headerlink" title="WebSocket 协议"></a>WebSocket 协议</h4><p>WebSocket 是 HTML5 新增的一种通信协议。<strong>WebSocket 协议是一种持久化的双向通信协议，它建立在TCP之上，同 HTTP 一样通过 TCP 来传输数据</strong>，但是它和 HTTP 最大的不同有两点：</p><p>WebSocket 是一种双向通信协议，在建立连接后，WebSocket 服务器和 Browser/UA(浏览器) 都能主动的向对方发送或接收数据，就像 Socket 一样，不同的是 WebSocket 是一种建立在 Web 基础上的一种简单模拟 Socket 的协议。</p><p>WebSocket 需要通过握手连接，类似于 TCP 它也需要客户端和服务器端进行握手连接，连接成功后才能相互通信。</p><h4 id="WebSocket-工作流程"><a href="#WebSocket-工作流程" class="headerlink" title="WebSocket 工作流程"></a>WebSocket 工作流程</h4><p>浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。因为 WebSocket 连接本质上就是一个 TCP 连接，所以在数据传输的稳定性和数据传输量的大小方面，和传统轮询以技术比较，具有很大的性能优势。</p><p>为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息 “Upgrade: WebSocket” 表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p><h3 id="基于-nodeJs-的-webSocket-框架-socket-io"><a href="#基于-nodeJs-的-webSocket-框架-socket-io" class="headerlink" title="基于 nodeJs 的 webSocket 框架 socket.io"></a>基于 nodeJs 的 webSocket 框架 socket.io</h3><p>socket.io 是这篇文章的主角，因为它对 webSocket 做了一个非常完善的封装， 并且提出了 多房间  多命名空间的 概念，让多聊天室同时存在不再是一个问题，所以，下面就会详细的来介绍下 socket.io 这个框架</p><p>Socket.io 是一个完全由 JavaScript 实现、基于 Node.js、支持 WebSocket 协议的用于实时通信、跨平台的开源框架，它包括了客户端的 JavaScript 和服务器端的 Node.js。</p><p>Socket.io 设计的目标是支持任何的浏览器，任何 Mobile 设备。支持主流的 PC 浏览器 (IE,Safari,Chrome,Firefox,Opera等)，Mobile 浏览器(iphone Safari/ipad Safari/Android WebKit/WebOS WebKit等)。</p><p>但是，WebSocket 协议是 HTML5 新推出的协议，浏览器对它的支持并不完善，由此可以看出，Socket.io 不可能仅仅是对 WebSocket 的实现，它还支持其他的通信方式，如上面介绍过的 ajax 轮询和 Long Polling。根据浏览器的支持程度，自主选择使用哪种方式进行通讯。</p><p>Socket.io 支持的通信方式：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs smali">WebSocket<br>Adobe Flash Socket<br>AJAX long-polling<br>AJAX multipart streaming<br>Forever IFrame<br>JSONP polling<br></code></pre></td></tr></table></figure><h3 id="Socket-io-的使用"><a href="#Socket-io-的使用" class="headerlink" title="Socket.io 的使用"></a>Socket.io 的使用</h3><p>node 端使用 express 框架</p><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>服务器端：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save socket.io</span><br></code></pre></td></tr></table></figure><p>浏览器端（引入本地文件）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/socket.io/socket.io.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>浏览器端（CDN 加速）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="创建-io-服务器"><a href="#创建-io-服务器" class="headerlink" title="创建 io 服务器"></a>创建 io 服务器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)();<br><span class="hljs-keyword">var</span> server = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>).Server(app);<br><span class="hljs-keyword">var</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;socket.io&#x27;</span>)(server);<br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>&#123;<br>    res.sendFile(__dirname + <span class="hljs-string">&#x27;/index.html&#x27;</span>);<br>&#125;);<br><br>server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;App listening on port 3000!&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>Socket.IO 提供了默认事件（如：connect, message, disconnect）。另外，Socket.IO允许发送并接收自定义事件。</p><blockquote><p>监听客户端连接，回调函数会传递本次连接的socket</p></blockquote><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">io.<span class="hljs-keyword">on</span>(‘connection’,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(socket)</span><span class="hljs-comment">&#123; &#125;</span>);</span><br></code></pre></td></tr></table></figure><blockquote><p>给所有客户端广播消息</p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">io</span>.sockets.emit(‘<span class="hljs-type">String</span>’,<span class="hljs-class"><span class="hljs-keyword">data</span>);</span><br></code></pre></td></tr></table></figure><blockquote><p>给指定的客户端发送自定义事件</p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">socket</span>.emit(‘<span class="hljs-type">String</span>’, <span class="hljs-class"><span class="hljs-keyword">data</span>);</span><br><span class="hljs-title">io</span>.sockets.socket(socketid).emit(‘<span class="hljs-type">String</span>’, <span class="hljs-class"><span class="hljs-keyword">data</span>);</span><br></code></pre></td></tr></table></figure><blockquote><p>接收客户端发送的自定义事件</p></blockquote><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">socket.<span class="hljs-keyword">on</span>(‘<span class="hljs-keyword">String</span>’,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span>);</span><br></code></pre></td></tr></table></figure><blockquote><p>给除了自己以外的客户端广播消息</p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">socket</span>.broadcast.emit(“msg”, <span class="hljs-class"><span class="hljs-keyword">data</span>);</span><br></code></pre></td></tr></table></figure><h4 id="房间"><a href="#房间" class="headerlink" title="房间"></a>房间</h4><p>房间是 Socket.IO 提供的一个非常好用的功能。房间相当于为指定的一些客户端提供了一个命名空间，所有在房间里的广播和通信都不会影响到房间以外的客户端。</p><p>使用 join() 方法将 socket 加入房间：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">io.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-keyword">function</span>(socket)&#123;<br>    socket.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;group1&#x27;</span>, <span class="hljs-keyword">function</span> (data) &#123;<br>        socket.<span class="hljs-keyword">join</span>(<span class="hljs-string">&#x27;group1&#x27;</span>);<br>    &#125;);<br>    socket.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;group2&#x27;</span>,<span class="hljs-keyword">function</span>(data)&#123;<br>        socket.<span class="hljs-keyword">join</span>(<span class="hljs-string">&#x27;group2&#x27;</span>);<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>使用 leave() 方法离开房间：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">socket.leave(‘<span class="hljs-built_in">some</span> <span class="hljs-built_in">room</span>’);<br></code></pre></td></tr></table></figure><p>向房间中除了当前 socket 的其他 socket 发送消息</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">socket.broadcast.to<span class="hljs-comment">(‘group1’)</span>.emit<span class="hljs-comment">(‘event_name’, data)</span>;<br></code></pre></td></tr></table></figure><p>broadcast方法允许当前socket client不在该分组内</p><p>向房间中所有的 socket 发送消息</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">io</span>.sockets.<span class="hljs-keyword">in</span>(‘group1’).emit(‘event_name’, <span class="hljs-class"><span class="hljs-keyword">data</span>);</span><br></code></pre></td></tr></table></figure><p>获取连接的客户端 socket</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">io</span><span class="hljs-selector-class">.sockets</span><span class="hljs-selector-class">.clients</span>()<span class="hljs-selector-class">.forEach</span>(function (socket) &#123;<br>    <span class="hljs-comment">//.....</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>获取所有房间（分组）信息</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">io<span class="hljs-selector-class">.sockets</span><span class="hljs-selector-class">.manager</span>.rooms<br></code></pre></td></tr></table></figure><p>来获取此socketid进入的房间信息</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">io<span class="hljs-selector-class">.sockets</span><span class="hljs-selector-class">.manager</span><span class="hljs-selector-class">.roomClients</span><span class="hljs-selector-attr">[socket.id]</span><br></code></pre></td></tr></table></figure><p>获取particular room中的客户端，返回所有在此房间的socket实例</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">io<span class="hljs-selector-class">.sockets</span><span class="hljs-selector-class">.clients</span>(‘particular room’)<br></code></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/socket.io/socket.io.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> socket = io();</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样就加载了 socket.io-client。 socket.io-client 暴露了一个 io 全局变量，然后连接服务器。</p><p>请注意我们在调用 io() 时没有指定任何 URL，因为它默认将尝试连接到提供当前页面的主机。</p><blockquote><p>监听服务器消息</p></blockquote><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso">socket.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;msg&#x27;</span>,function(<span class="hljs-built_in">data</span>)&#123;<br>    console.<span class="hljs-keyword">log</span>(<span class="hljs-built_in">data</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>socket.on(“String”,function(data){}) 监听服务端发送的消息, String 参数与服务器端 socket.emit(‘String’, data) 第一个参数 String 相同。</p><blockquote><p>向服务器发送消息</p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">socket</span>.emit(‘msg’, <span class="hljs-class"><span class="hljs-keyword">data</span>);</span><br></code></pre></td></tr></table></figure><blockquote><p>监听 socket 断开与重连</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">socket.on(<span class="hljs-string">&#x27;disconnect&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;与服务器断开&quot;</span>);<br>&#125;);<br><br>socket.on(<span class="hljs-string">&#x27;reconnect&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;重新连接到服务器&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>客户端 socket.on() 监听的事件</p><ul><li>connect：连接成功</li><li>connecting：正在连接</li><li>disconnect：断开连接</li><li>connect_failed：连接失败</li><li>error：错误发生，并且无法被其他事件类型所处理</li><li>message：同服务器端message事件</li><li>anything：同服务器端anything事件</li><li>reconnect_failed：重连失败</li><li>reconnect：成功重连</li><li>reconnecting：正在重连</li></ul><h3 id="聊天室"><a href="#聊天室" class="headerlink" title="聊天室"></a>聊天室</h3><p>流程：</p><ol><li>创建 socket 服务器</li><li>浏览器建立 socket 连接</li><li>页面输入聊天内容，点击 “发送” 按钮，向自定义 socket 事件 “chat” 发送聊天信息</li><li>服务器监听浏览器 “chat” 事件，当接收到浏览器发来的聊天信息时，将信息发送给所有连接了 socket 的浏览器</li><li>浏览器监听服务器发来的 “chat” 事件，接收到聊天信息时，在页面上显示</li></ol><h4 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h4><p><a href="http://mengyujing.com/socket-io%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%81%8A%E5%A4%A9%E5%AE%A4%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/">WebSocket和Socket.io介绍以及聊天室功能实现</a><br><a href="https://www.bilibili.com/video/BV17i4y1t71B">聊天室</a></p>]]></content>
    
    
    <categories>
      
      <category>聊天室</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WebSocket</tag>
      
      <tag>Socket.io</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数的防抖与节流</title>
    <link href="/2021/05/16/JS&amp;%E9%98%B2%E6%8A%96&amp;%E8%8A%82%E6%B5%81/"/>
    <url>/2021/05/16/JS&amp;%E9%98%B2%E6%8A%96&amp;%E8%8A%82%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>函数防抖和节流，都是控制事件触发频率的方法。应用场景有很多，输入框持续输入，将输入内容远程校验、多次触发点击事件、onScroll等等。</p><hr><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>函数防抖，这里的抖动就是执行的意思，而一般的抖动都是持续的，多次的。假设函数持续多次执行，我们希望让它冷静下来再执行。也就是当持续触发事件的时候，函数是完全不执行的，等最后一次触发结束的一段时间之后，再去执行。</p><p>分解一下需求：</p><h4 id="持续触发不执行"><a href="#持续触发不执行" class="headerlink" title="持续触发不执行"></a>持续触发不执行</h4><h4 id="不触发的一段时间-最后一次点击-之后再执行"><a href="#不触发的一段时间-最后一次点击-之后再执行" class="headerlink" title="不触发的一段时间(最后一次点击)之后再执行"></a>不触发的一段时间(最后一次点击)之后再执行</h4><p>那么怎么实现上述的目标呢？我们先看这一点：在不触发的一段时间之后再执行，那就需要个定时器呀，定时器里面调用我们要执行的函数，将arguments传入。</p><p>封装一个函数，让持续触发的事件监听是我们封装的这个函数，将目标函数作为回调（func）传进去，等待一段时间过后执行目标函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func, delay</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      func.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)<br>    &#125;, delay)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二点实现了，再看第一点：持续触发不执行。我们先思考一下，是什么让我们的函数执行了呢？是上边的setTimeout。OK，那现在的问题就变成了持续触发，不能有setTimeout。这样直接在事件持续触发的时候，清掉定时器就好了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func, delay</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timeout<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timeout) <span class="hljs-comment">// 如果持续触发，那么就清除定时器，定时器的回调就不会执行。</span><br>    timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      func.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)<br>    &#125;, delay)<br>  &#125;<br>&#125;<br>用法：<br><br>  box.onmousemove = debounce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>    box.innerHTML = <span class="hljs-string">`<span class="hljs-subst">$&#123;e.clientX&#125;</span>, <span class="hljs-subst">$&#123;e.clientY&#125;</span>`</span><br>  &#125;, <span class="hljs-number">1000</span>)<br><br></code></pre></td></tr></table></figure><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>节流的意思是让函数有节制地执行，而不是毫无节制的触发一次就执行一次。什么叫有节制呢？就是在一段时间内，只执行一次。</p><p>同样，我们分解一下：</p><h4 id="持续触发并不会执行多次"><a href="#持续触发并不会执行多次" class="headerlink" title="持续触发并不会执行多次"></a>持续触发并不会执行多次</h4><h4 id="第一次执行之后-到一定时间再去执行"><a href="#第一次执行之后-到一定时间再去执行" class="headerlink" title="(第一次执行之后)到一定时间再去执行"></a>(第一次执行之后)到一定时间再去执行</h4><p>思考一下，持续触发，并不会执行，但是到时间了就会执行。抓取一个关键的点：就是执行的时机。要做到控制执行的时机，我们可以通过一个开关，与定时器setTimeout结合完成。</p><p>函数执行的前提条件是开关打开，持续触发时，持续关闭开关，等到setTimeout到时间了，再把开关打开，函数就会执行了。</p><p>我们看一下代码怎么实现：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">function <span class="hljs-title">throttle</span><span class="hljs-params">(func, delay)</span> </span>&#123;<br>    let run = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">function</span> () &#123;<br>      <span class="hljs-keyword">if</span> (!run) &#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-comment">// 如果开关关闭了，那就直接不执行下边的代码</span><br>      &#125;<br>      run = <span class="hljs-literal">false</span> <span class="hljs-comment">// 持续触发的话，run一直是false，就会停在上边的判断那里</span><br>      <span class="hljs-built_in">setTimeout</span>(() =&gt; &#123;<br>        func.<span class="hljs-built_in">apply</span>(<span class="hljs-keyword">this</span>, arguments)<br>        run = <span class="hljs-literal">true</span> <span class="hljs-comment">// 定时器到时间之后，会把开关打开，我们的函数就会被执行</span><br>      &#125;, delay)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>调用的时候：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">box.onmousemove = throttle(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  box.innerHTML = <span class="hljs-string">`<span class="hljs-subst">$&#123;e.clientX&#125;</span>, <span class="hljs-subst">$&#123;e.clientY&#125;</span>`</span><br>&#125;, <span class="hljs-number">1000</span>)<br><br></code></pre></td></tr></table></figure><p>这样，就实现了节流，节流还可以用时间间隔去控制，就是记录上一次函数的执行时间，与当前时间作比较，如果当前时间与上次执行时间的时间差大于一个值，就执行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>防抖和节流巧妙地用了setTimeout，来控制函数执行的时机，优点很明显，可以节约性能，不至于多次触发复杂的业务逻辑而造成页面卡顿。</p><h3 id="介绍节流防抖原理、区别以及应用"><a href="#介绍节流防抖原理、区别以及应用" class="headerlink" title="介绍节流防抖原理、区别以及应用"></a>介绍节流防抖原理、区别以及应用</h3><h4 id="防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如-1-秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待-1-秒，直到能最终执行"><a href="#防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如-1-秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待-1-秒，直到能最终执行" class="headerlink" title="防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行"></a>防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行</h4><h4 id="节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次"><a href="#节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次" class="headerlink" title="节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次"></a>节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次</h4><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>防抖：搜索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染。<br>节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 防抖函数  一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>fn要被节流的函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>delay规定的时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>    <span class="hljs-comment">//记录上一次的延时器</span><br>    <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>       <span class="hljs-comment">//清除上一次的演示器</span><br>        <span class="hljs-built_in">clearTimeout</span>(timer);<br>        <span class="hljs-comment">//重新设置新的延时器</span><br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-comment">//修正this指向问题</span><br>            fn.apply(<span class="hljs-built_in">this</span>);<br>        &#125;, delay); <br>    &#125;<br>&#125;<br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>).onclick = debounce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;按钮被点击了&#x27;</span> + <span class="hljs-built_in">Date</span>.now());<br>&#125;, <span class="hljs-number">1000</span>);<br>* 节流函数 一个函数执行一次后，只有大于设定的执行周期才会执行第二次。有个需要频繁触发的函数，出于优化性能的角度，在规定时间内，只让函数触发的第一次生效，后面的不生效。<br><br><br> * <span class="hljs-meta">@param</span> fn要被节流的函数<br> * <span class="hljs-meta">@param</span> delay规定的时间<br> */<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>    <span class="hljs-comment">//记录上一次函数触发的时间</span><br>    <span class="hljs-keyword">var</span> lastTime = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">//记录当前函数触发的时间</span><br>        <span class="hljs-keyword">var</span> nowTime = <span class="hljs-built_in">Date</span>.now();<br>        <span class="hljs-keyword">if</span>(nowTime - lastTime &gt; delay)&#123;<br>            <span class="hljs-comment">//修正this指向问题</span><br>            fn.call(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-comment">//同步执行结束时间</span><br>            lastTime = nowTime;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">document</span>.onscroll = throttle(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;scllor事件被触发了&#x27;</span> + <span class="hljs-built_in">Date</span>.now());<br>&#125;, <span class="hljs-number">200</span>); <br><br><br></code></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/72923073?utm_source=qq&utm_medium=social&utm_oi=993958266707247104">参考文章：函数的防抖和节流是个啥？？？</a><br><a href="https://juejin.cn/post/7016593221815910408#heading-53">介绍节流防抖原理、区别以及应用</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS&amp;call&amp;apply&amp;bind的用法和区别</title>
    <link href="/2021/05/14/Js&amp;call&amp;apply&amp;bind/"/>
    <url>/2021/05/14/Js&amp;call&amp;apply&amp;bind/</url>
    
    <content type="html"><![CDATA[<p>call和bind它们最主要的作用，是改变 this 的指向。在平时的工作中，除了在写一些基础类，或者公用库方法的时候会用到它们，其他时候 call 和 apply 的应用场景并不多。</p><p>不过，突然遇到的时候，需要想一下才能转过弯来。所以今天，就让我们好好地探究一下，这两个方法的区别以及一些妙用。最后，还会介绍与之用法相似的 bind 的方法。</p><hr><h3 id="call-和-apply-的共同点"><a href="#call-和-apply-的共同点" class="headerlink" title="call 和 apply 的共同点"></a>call 和 apply 的共同点</h3><p>它们的共同点是，<strong>都能够改变函数执行时的上下文</strong>，将一个对象的方法交给另一个对象来执行，并且是立即执行的。</p><p>为何要改变执行上下文？举一个生活中的小例子：平时没时间做饭的我，周末想给孩子炖个腌笃鲜尝尝。但是没有适合的锅，而我又不想出去买。所以就问邻居借了一个锅来用，这样既达到了目的，又节省了开支，一举两得。</p><p>改变执行上下文也是一样的，A 对象有一个方法，而 B 对象因为某种原因，也需要用到同样的方法，那么这时候我们是单独为 B 对象扩展一个方法呢，还是借用一下 A 对象的方法呢？当然是借用 A 对象的啦，既完成了需求，又减少了内存的占用。</p><p>另外，它们的写法也很类似，<strong>调用 call 和 apply 的对象，必须是一个函数 Function</strong>。接下来，就会说到具体的写法，那也是它们区别的主要体现。</p><h3 id="call-和-apply-的区别"><a href="#call-和-apply-的区别" class="headerlink" title="call 和 apply 的区别"></a>call 和 apply 的区别</h3><p>它们的区别，主要体现在参数的写法上。先来看一下它们各自的具体写法。</p><ol><li>call 的写法<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Function.call(obj,<span class="hljs-comment">[param1<span class="hljs-comment">[,param2<span class="hljs-comment">[,…<span class="hljs-comment">[,paramN]</span>]</span>]</span>]</span>)<br></code></pre></td></tr></table></figure></li></ol><p>需要注意以下几点：</p><p>调用 call 的对象，必须是个函数 Function。<br>call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。</p><p>第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">function</span> <span class="hljs-keyword">func</span> (a,b,c) &#123;&#125;<br><br><span class="hljs-keyword">func</span>.call(obj, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-regexp">//</span> <span class="hljs-keyword">func</span> 接收到的参数实际上是 <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br><br><span class="hljs-keyword">func</span>.call(obj, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br><span class="hljs-regexp">//</span> <span class="hljs-keyword">func</span> 接收到的参数实际上是 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],undefined,undefined<br></code></pre></td></tr></table></figure><ol start="2"><li>apply 的写法</li></ol><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">Function</span>.<span class="hljs-built_in">apply</span>(obj[,argArray])<br></code></pre></td></tr></table></figure><p>需要注意的是：</p><p>它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。</p><p>第二个参数，必须<code>是数组或者类数组</code>，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">func</span>.apply(obj, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br><span class="hljs-regexp">//</span> <span class="hljs-keyword">func</span> 接收到的参数实际上是 <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br><br><span class="hljs-keyword">func</span>.apply(obj, &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-number">3</span>,<br>    length: <span class="hljs-number">3</span><br>&#125;)<br><span class="hljs-regexp">//</span> <span class="hljs-keyword">func</span> 接收到的参数实际上是 <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="什么是类数组？"><a href="#什么是类数组？" class="headerlink" title="什么是类数组？"></a>什么是类数组？</h4><p>先说数组，这我们都熟悉。它的特征有：可以通过角标调用，如 array[0]；具有长度属性length；可以通过 for 循环或forEach方法，进行遍历。</p><p>那么，类数组是什么呢？顾名思义，就是具备与数组特征类似的对象。比如，下面的这个对象，就是一个类数组。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">let</span> <span class="hljs-string">arrayLike = &#123;</span><br>    <span class="hljs-attr">0</span>: <span class="hljs-string">1,</span><br>    <span class="hljs-attr">1</span>: <span class="hljs-string">2,</span><br>    <span class="hljs-attr">2</span>: <span class="hljs-string">3,</span><br>    <span class="hljs-attr">length</span>: <span class="hljs-string">3</span><br><span class="hljs-attr">&#125;;</span><br></code></pre></td></tr></table></figure><p>类数组 arrayLike 可以通过角标进行调用，具有length属性，同时也可以通过 for 循环进行遍历。</p><p>类数组，还是比较常用的，只是我们平时可能没注意到。比如，我们获取 DOM 节点的方法，返回的就是一个类数组。再比如，在一个方法中使用 arguments 获取到的所有参数，也是一个类数组。</p><p>但是需要注意的是：类数组无法使用 forEach、splice、push 等数组原型链上的方法，毕竟它不是真正的数组。</p><h4 id="call-和-apply-的用途"><a href="#call-和-apply-的用途" class="headerlink" title="call 和 apply 的用途"></a>call 和 apply 的用途</h4><p>下面会分别列举 call 和 apply 的一些使用场景。声明：例子中没有哪个场景是必须用 call 或者必须用 apply 的，只是个人习惯这么用而已。</p><p>call 的使用场景<br>1、对象的继承。如下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">superClass</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.a = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">this</span>.print = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subClass</span> (<span class="hljs-params"></span>) </span>&#123;<br>    superClass.call(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">this</span>.print();<br>&#125;<br><br>subClass();<br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>subClass 通过 call 方法，继承了 superClass 的 print 方法和 a 变量。此外，subClass 还可以扩展自己的其他方法。</p><p>2、借用方法。还记得刚才的类数组么？如果它想使用 Array 原型链上的方法，可以这样：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> domNodes = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>prototype.slice.call(document.get<span class="hljs-constructor">ElementsByTagName(<span class="hljs-string">&quot;*&quot;</span>)</span>);<br></code></pre></td></tr></table></figure><p>这样，domNodes 就可以应用 Array 下的所有方法了。</p><h4 id="bind-的使用"><a href="#bind-的使用" class="headerlink" title="bind 的使用"></a>bind 的使用</h4><p>最后来说说 bind。在 MDN 上的解释是：bind() 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。</p><p>它的语法如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Function.bind(thisArg<span class="hljs-comment">[, arg1<span class="hljs-comment">[, arg2<span class="hljs-comment">[, ...]</span>]</span>]</span>)<br></code></pre></td></tr></table></figure><p>bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是，bind 方法的返回值是函数，并且需要稍后调用，才会执行。而 apply 和 call 则是立即调用。</p><p>来看下面这个例子：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl">function add (a, b) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br>function <span class="hljs-function"><span class="hljs-keyword">sub</span> (<span class="hljs-title">a</span>, <span class="hljs-title">b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a - b;<br>&#125;<br><br>add.bind(<span class="hljs-function"><span class="hljs-keyword">sub</span>, 5, 3)</span>; // 这时，并不会返回 <span class="hljs-number">8</span><br>add.bind(<span class="hljs-function"><span class="hljs-keyword">sub</span>, 5, 3)</span>(); // 调用后，返回 <span class="hljs-number">8</span><br><br></code></pre></td></tr></table></figure><p>如果 bind 的第一个参数是 null 或者 undefined，this 就指向全局对象 window。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。</p><p>bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844903768132157447#heading-1">「干货」细说 call、apply 以及 bind 的区别和用法</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP 方法get和post的区别</title>
    <link href="/2021/05/13/get&amp;post/"/>
    <url>/2021/05/13/get&amp;post/</url>
    
    <content type="html"><![CDATA[<p>前景<br>现在在前端面试中还有一些面试官会问get和post的区别。对于目前我们能了解get和post在什么场景下使用，使用方式有什么区别，以及如何提交数据这些基本上就可以了。</p><hr><h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><p>GET请求的数据会附加在URL之后，用问号分割，多个参数用&amp;进行连接。</p><p>GET请求的数据会暴露在地址栏中。</p><p>GET请求URL的编码格式采用的是ASCII编码，而不是Unicode编码。</p><p>GET请求传输大小有限制，大小在2KB。</p><p>GET相对安全性较差，会被浏览器主动缓存。</p><p>GET产生一个TCP数据包，head和data一起发送。</p><p>GET浏览器回退无害。</p><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>POST请求会把数据放置在HTTP请求包的包体中，不会直接暴露给用户。</p><p>POST请求，理论上大小是不会限制的，但是实际上各个服务器会规定POST提交数据大小。</p><p>POST相对Get更安全，因为参数不会保存浏览器立式或者是web服务器日志中。</p><p>POST产生两个TCP数据包，header先发送，服务器响应100ms然后继续，发送data，服务器200然后返回数据。</p><p>POST浏览器回退重新请求。</p><h4 id="其他http方法"><a href="#其他http方法" class="headerlink" title="其他http方法"></a>其他http方法</h4><p>PUT 方法<br>PUT 用于将数据发送到服务器来创建/更新资源。</p><p>POST 和 PUT之间的区别在于 PUT 请求是幂等的（idempotent）。也就是说，多次调用相同的 PUT 请求将始终产生相同的结果。相反，重复调用POST请求具有多次创建相同资源的副作用。</p><p>HEAD 方法<br>HEAD 与 GET 几乎相同，但没有响应主体。</p><p>换句话说，如果 GET /users 返回用户列表，那么 HEAD /users 将发出相同的请求，但不会返回用户列表。<br>HEAD 请求对于在实际发出 GET 请求之前（例如在下载大文件或响应正文之前）检查 GET 请求将返回的内容很有用。</p><p>DELETE 方法<br>DELETE 方法删除指定的资源。</p><p>OPTIONS 方法<br>OPTIONS 方法描述目标资源的通信选项。</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://juejin.cn/post/6854573213523902477">这年头还有面试问get和post的区别？</a></p><p><a href="https://www.w3school.com.cn/tags/html_ref_httpmethods.asp">HTML 请求方法</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>get&amp;post</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS&amp;this指向</title>
    <link href="/2021/05/12/JS&amp;this%E6%8C%87%E5%90%91/"/>
    <url>/2021/05/12/JS&amp;this%E6%8C%87%E5%90%91/</url>
    
    <content type="html"><![CDATA[<hr><h4 id="谈谈-This-对象的理解。"><a href="#谈谈-This-对象的理解。" class="headerlink" title="谈谈 This 对象的理解。"></a>谈谈 This 对象的理解。</h4><p>在 ES5 中，其实 this 的指向，始终坚持一个原理：<strong>this 永远指向最后调用它的那个对象&gt;</strong>，来，跟着我朗读三遍：this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象。记住这句话，this 你已经了解一半了。</p><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模<br>式来判断。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span><br>谈一谈你对<span class="hljs-keyword">this</span>的理解，以及在各种环境下的<span class="hljs-keyword">this</span><br>在浏览器里，在全局范围内<span class="hljs-keyword">this</span>指向window对象<br>在函数中，<span class="hljs-keyword">this</span>永远指向最后调用他的那个对象(箭头函数除外)。<br>在构造函数中，<span class="hljs-keyword">this</span>指向new出来的新对象。<br>call、apply、bind中的<span class="hljs-keyword">this</span>被强绑定在指定的那个对象上。<br>箭头函数<span class="hljs-keyword">this</span>为父作用域的<span class="hljs-keyword">this</span>，不是调用时的<span class="hljs-keyword">this</span>。<br></code></pre></td></tr></table></figure><p>在我之前的一篇文章你不知道的执行上下文中有提到过 this，对那篇文章进行概括就是：</p><ol><li>上下文是在函数调用的时候被创建的。</li><li>this 是组成上下文的一部分。<br>因此每次函数被调用的时候就会产生一个新的 this。具体的分为下面几种。</li></ol><h4 id="作为普通函数在全局环境中被调用"><a href="#作为普通函数在全局环境中被调用" class="headerlink" title="作为普通函数在全局环境中被调用"></a>作为普通函数在全局环境中被调用</h4><p>在全局环境里面，this 永远指向 window，因此在全局环境里作为普通函数被调用的时候，this 也是指向 window(这里仅指在浏览器环境下，不考虑Node)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Abby&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//window</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name); <span class="hljs-comment">//Abby</span><br>&#125;<br><br>fn();<br></code></pre></td></tr></table></figure><p>这里，fn 其实是作为 window 的一个方法被调用的，而 name 也是 window 的一个属性，因此 fn() 实际上就是 window.fn()。</p><h4 id="作为对象的属性被调用"><a href="#作为对象的属性被调用" class="headerlink" title="作为对象的属性被调用"></a>作为对象的属性被调用</h4><p>如果函数作为一个对象的属性方法，并且被调用的时候，this 就指向这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Jane&#x27;</span>;<br><span class="hljs-keyword">var</span> person = &#123;<br>    name: <span class="hljs-string">&#x27;Abby&#x27;</span>,<br>    sayName: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;<br>&#125;;<br><span class="hljs-keyword">var</span> sayNameWin = person.sayName;<br><br>person.sayName(); <span class="hljs-comment">//Abby</span><br>sayNameWin(); <span class="hljs-comment">//Jane   作为 window 的方法被调用的</span><br></code></pre></td></tr></table></figure><p>在这里，sayName 方法是作为 person 的一个属性方法被调用的，因此指向 person，但是 sayNameWin 方法却是作为 window 的一个属性方法被调用的，因此 console.log 的值是 Jane。我们再看一个变形。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person1 = &#123;<br>    name: <span class="hljs-string">&#x27;Jane&#x27;</span>,<br>    sayName: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> person2 = &#123;<br>    name: <span class="hljs-string">&#x27;Abby&#x27;</span>,<br>    sayName: person1.sayName<br>&#125;<br><br>person2.sayName(); <span class="hljs-comment">//Abby  作为 person2 的属性方法被调用</span><br></code></pre></td></tr></table></figure><p>但是当在在对象方法中再定义函数，这时候 this 又是 window 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Jane&#x27;</span>;<br><span class="hljs-keyword">var</span> person = &#123;<br>    name: <span class="hljs-string">&#x27;Abby&#x27;</span>,<br>    sayName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);      <span class="hljs-comment">//window</span><br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);    <span class="hljs-comment">//Jane</span><br>        &#125;<br>        fn();<br>    &#125;<br>&#125;<br><br>person.sayName();<br></code></pre></td></tr></table></figure><p>如果想让 this 指向 person 的话，只需要用 that 保存下来 this 的值即可，也可以使用 apply 等改变 this。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Jane&#x27;</span>;<br><span class="hljs-keyword">var</span> person = &#123;<br>    name: <span class="hljs-string">&#x27;Abby&#x27;</span>,<br>    sayName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(that);      <span class="hljs-comment">//Object &#123;name: &quot;Abby&quot;&#125;</span><br>            <span class="hljs-built_in">console</span>.log(that.name);    <span class="hljs-comment">//Abby</span><br>        &#125;<br>        fn();<br>    &#125;<br>&#125;<br><br>person.sayName();<br></code></pre></td></tr></table></figure><h4 id="作为构造函数被调用"><a href="#作为构造函数被调用" class="headerlink" title="作为构造函数被调用"></a>作为构造函数被调用</h4><p>作为构造函数被调用的时候，this 代表它即将 new 出来的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">//Person &#123;name: &quot;Abby&quot;&#125;</span><br>&#125;<br><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;Abby&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(person.name);  <span class="hljs-comment">//Abby</span><br>如果不加 <span class="hljs-keyword">new</span>,表示即作为普通函数调用，指向 <span class="hljs-built_in">window</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">//window</span><br>&#125;<br><br>Person(<span class="hljs-string">&#x27;Jane&#x27;</span>); <br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.name); <span class="hljs-comment">//Jane</span><br></code></pre></td></tr></table></figure><h4 id="作为-call-apply-bind-方法的调用"><a href="#作为-call-apply-bind-方法的调用" class="headerlink" title="作为 call/apply/bind 方法的调用"></a>作为 call/apply/bind 方法的调用</h4><p>作为 call/apply/bind 方法被调用的时候指向传入的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>    name: <span class="hljs-string">&#x27;Abby&#x27;</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//Object &#123;name: &quot;Abby&quot;&#125;</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name); <span class="hljs-comment">//Abby</span><br>&#125;<br><br>fn.apply(person);<br></code></pre></td></tr></table></figure><h4 id="严格模式下面"><a href="#严格模式下面" class="headerlink" title="严格模式下面"></a>严格模式下面</h4><p>在严格模式下，在全局环境中执行函数调用的时候 this 并不会指向 window 而是会指向 undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">person</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//undefined</span><br>&#125;;<br>person();<br></code></pre></td></tr></table></figure><h4 id="setTimeout、setInterval中的this"><a href="#setTimeout、setInterval中的this" class="headerlink" title="setTimeout、setInterval中的this"></a>setTimeout、setInterval中的this</h4><p>《 javascript 高级程序设计》中写到：“超时调用的代码都是在全局执行域中执行的”。setTimeout/setInterval 执行的时候，this 默认指向 window 对象，除非手动改变 this 的指向。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Jane&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;Abby&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.sayName=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//window</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name); <span class="hljs-comment">//Jane</span><br>        &#125;;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-built_in">this</span>.sayName, <span class="hljs-number">10</span>);<br>    &#125;<br><br><span class="hljs-keyword">var</span> person=<span class="hljs-keyword">new</span> Person();<br></code></pre></td></tr></table></figure><p>在这里如果想改变 this，可是使用 apply/call/bind 等，也可以使用 that 保存 this.</p><p>setTimeout 中的回调函数在严格模式下也指向 window 而不是 undefined (是个坑)</p><p>因为 setTimeout 的回调函数如果没有指定的 this ，会做一个隐式的操作，将全局上下文注入进去，不管是在严格还是非严格模式下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">person</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">//window</span><br>&#125;<br><span class="hljs-built_in">setTimeout</span>(person, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h4 id="构造函数-prototype-属性"><a href="#构造函数-prototype-属性" class="headerlink" title="构造函数 prototype 属性"></a>构造函数 prototype 属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Jane&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;Abby&#x27;</span>;<br>&#125;<br>Person.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);        <span class="hljs-comment">// Person &#123;name: &quot;Abby&quot;&#125;</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);      <span class="hljs-comment">// Abby</span><br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br>person.sayName();<br></code></pre></td></tr></table></figure><p>在 Person.prototype.sayName 函数中，this 指向的 person 对象。即便是在整个原型链中,this 也代表当前对象的值。</p><ol start="8"><li><p>Eval函数<br>在 Eval 中，this 指向当前作用域的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Jane&#x27;</span>;<br><span class="hljs-keyword">var</span> person = &#123;<br>    name: <span class="hljs-string">&#x27;Abby&#x27;</span>,<br>    getName: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;console.log(this.name)&quot;</span>);<br>    &#125;<br>&#125;<br>person.getName();  <span class="hljs-comment">//Abby</span><br>    <br><span class="hljs-keyword">var</span> getNameWin=person.getName;<br>getNameWin();  <span class="hljs-comment">//Jane</span><br></code></pre></td></tr></table></figure><p>在这里，和不使用 Eval ，作为对象的方法调用的时候得出的结果是一样的。</p></li><li><p>箭头函数</p></li></ol><p>箭头函数里面 this 始终指向外部对象，因为箭头函数没有 this，因此它自身不能进行new实例化，同时也不能使用 call, apply, bind 等方法来改变 this 的指向。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>    name: <span class="hljs-string">&#x27;Abby&#x27;</span>,<br>    sayName: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> fn = <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);   <span class="hljs-comment">//Object &#123;name: &quot;Abby&quot;&#125;</span><br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name); <span class="hljs-comment">//Abby</span><br>            &#125;<br>        &#125;<br>        fn()();<br>    &#125;<br>&#125;<br><br>person.sayName();<br></code></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://zhuanlan.zhihu.com/p/26766112?utm_source=qq&utm_medium=social&utm_oi=993958266707247104">十分钟读懂 JavaScript 中的 this</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-Symbol&amp;promise、generator、async/await&amp;rest参数</title>
    <link href="/2021/05/11/Es6async&amp;await/"/>
    <url>/2021/05/11/Es6async&amp;await/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="ES6-Symbol"><a href="#ES6-Symbol" class="headerlink" title="ES6 Symbol"></a>ES6 Symbol</h3><p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。</p><p>基本用法<br>Symbol 函数栈不能用 new 命令，因为 Symbol 是原始数据类型，不是对象。可以接受一个字符串作为参数，为新创建的 Symbol 提供描述，用来显示在控制台或者作为字符串的时候使用，便于区分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sy = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;KK&quot;</span>);<br><span class="hljs-built_in">console</span>.log(sy);   <span class="hljs-comment">// Symbol(KK)</span><br><span class="hljs-keyword">typeof</span>(sy);        <span class="hljs-comment">// &quot;symbol&quot;</span><br> <br><span class="hljs-comment">// 相同参数 Symbol() 返回的值不相等</span><br><span class="hljs-keyword">let</span> sy1 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;kk&quot;</span>); <br>sy === sy1;       <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="Symbol-类型的注意点？"><a href="#Symbol-类型的注意点？" class="headerlink" title="Symbol 类型的注意点？"></a>Symbol 类型的注意点？</h4><ol><li>Symbol 函数前不能使用 new 命令，否则会报错。</li><li>Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</li><li>Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。</li><li>Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</li><li>Symbol.for 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</li><li>Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。</li></ol><h3 id="promise、generator、async-await"><a href="#promise、generator、async-await" class="headerlink" title="promise、generator、async/await"></a>promise、generator、async/await</h3><h4 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h4><p>优点：解决了回调地狱的问题<br>缺点：无法取消 Promise ，错误需要通过回调函数来捕获</p><h4 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h4><p>生成器内部的代码是以自然的同步 / 顺序方式表达任务的一系列步骤</p><h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><p>优点：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题</p><p>缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。</p><ol><li>async 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。</li></ol><p>await 关键字仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testAwait</span>(<span class="hljs-params"></span>)</span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>       <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;testAwait&quot;</span>);<br>          resolve();<br>       &#125;, <span class="hljs-number">1000</span>);<br>   &#125;);<br>&#125;<br> <br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">helloAsync</span>(<span class="hljs-params"></span>)</span>&#123;<br>   <span class="hljs-keyword">await</span> testAwait();<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;helloAsync&quot;</span>);<br> &#125;<br>helloAsync();<br><span class="hljs-comment">// testAwait</span><br><span class="hljs-comment">// helloAsync</span><br></code></pre></td></tr></table></figure><h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><ol><li>ES6引入rest 参数，用于获取函数的实参，用来代替arguments</li></ol><p>使用…rest形式设置剩余形参，支持无限参数<br>// 剩余参数，转化成数组</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> restParams = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>    console.log(args.toString());<span class="hljs-comment">//1, 2, 3, 4, 5</span><br>&#125;<br><br>restParams(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><ol start="2"><li><p>rest 参数必须要放到参数最后</p></li><li><p>[…]扩展运算符能将[数组] 转换为都好分隔的参数序列</p></li><li><p>数组的合并</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">&lt;script&gt;<br>    const A = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>];<br>    const B = [<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>];<br>    <span class="hljs-regexp">//</span> const C = A.concat(B); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>]<br>    const C = [...A, ...B]; <span class="hljs-regexp">//</span>[<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>] 能展开<br>    console.log(C);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ol start="5"><li>数组的克隆  </li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> A = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>];<br><span class="hljs-keyword">const</span> C = [...A]; <span class="hljs-comment">//[&quot;a&quot;, &quot;b&quot;]</span><br>console.<span class="hljs-built_in">log</span>(C);<br></code></pre></td></tr></table></figure><ol start="6"><li>将伪数组转为真正的数组</li></ol><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">const divs = document.<span class="hljs-keyword">query</span>SelectorAll(<span class="hljs-string">&quot;div&quot;</span>);<br>const <span class="hljs-keyword">div</span>Arr = [...divs];<br>console.log(<span class="hljs-keyword">div</span>Arr); //[<span class="hljs-keyword">div</span>, <span class="hljs-keyword">div</span>, <span class="hljs-keyword">div</span>]<br></code></pre></td></tr></table></figure><h4 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h4><p>之所以叫「语法」糖，不只是因为加糖后的代码功能与加糖前保持一致，更重要的是，<code>糖在不改变其所在位置的语法结构的前提下，实现了运行时等价</code>。可以简单理解为，加糖后的代码编译后跟加糖前一毛一样。</p><p>之所以叫语法「糖」，是因为加糖后的代码写起来很爽，包括但不限于：<code>代码更简洁流畅，代码更语义自然...</code> 写得爽，看着爽，就像吃了糖。效率高，错误少</p><p>PS: 据说还有一种叫做「语法盐」的东西，主要目的是通过反人类的语法，让你更痛苦的写代码。其实它同样能达到避免代码书写错误的效果，但编程效率应该是降低了，毕竟提高了语法学习门槛，让人咸到忧伤…</p><p>我觉着 js 里的对象原型继承有点「咸」，不然 ES6 也不会急着加糖（纯吐槽）</p><p>最基本的，for循环就是一个语法糖：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">for <span class="hljs-params">(var <span class="hljs-attr">i</span> = 0; i &lt; 5; i++)</span>&#123;<br>    <span class="hljs-string">...</span> <br>&#125;<br></code></pre></td></tr></table></figure><p>而这个实际上跟while没啥区别：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">var</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>)&#123;<br>    <span class="hljs-params">...</span><br>    i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单说，语法糖就是为了避免coder出现错误并提高效率的语法层面的一种优雅的解决方案。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844904121380667399#heading-26">promise、generator、async/await</a></p><p><a href="https://www.runoob.com/w3cnote/es6-async.html">ES6 async 函数</a></p><p><a href="https://www.zhihu.com/question/20651624?sort=created">什么是语法糖？</a></p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFC--块级格式化上下文</title>
    <link href="/2021/05/10/BFC/"/>
    <url>/2021/05/10/BFC/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><blockquote><p>BFC是Block Formatting Context，也就是块级格式化上下文，是用于布局块级盒子的一块渲染区域。</p></blockquote><blockquote><p>简单来说就是，BFC是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。那么怎么使用BFC呢，BFC可以看做是一个CSS元素属性</p></blockquote><p>文档流其实分为<code>普通流</code>、<code>定位流</code>和<code>浮动流</code>三种，普通流其实就是指BFC中的FC，也即格式化上下文。</p><p>普通流：元素按照其在 HTML 中的先后位置从上到下、从左到右布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行。</p><p>格式化上下文：页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用</p><h3 id="BFC的几条规则："><a href="#BFC的几条规则：" class="headerlink" title="BFC的几条规则："></a>BFC的几条规则：</h3><ol><li><p>BFC 区域内的元素外边距会发生重叠。</p></li><li><p>BFC 区域内的元素不会与浮动元素重叠。</p></li><li><p>计算 BFC 区域的高度时，浮动元素也参与计算。</p></li><li><p>BFC 区域就相当于一个容器，内部的元素不会影响到外部，同样外部的元素也不会影响到内部。</p></li></ol><h3 id="BFC的应用："><a href="#BFC的应用：" class="headerlink" title="BFC的应用："></a>BFC的应用：</h3><ol><li>清除浮动：父元素设置overflow: hidden触发BFC实现清除浮动，防止父元素高度塌陷，后面的元素被覆盖，实现文字环绕等等。</li></ol><ol start="2"><li>消除相邻元素垂直方向的边距重叠：第二个子元素套一层，并设置overflow: hidden，构建BFC使其不影响外部元素。</li></ol><ol start="3"><li>消除父子元素边距重叠，父元素设置overflow: hidden</li></ol><h3 id="触发BFC的方式："><a href="#触发BFC的方式：" class="headerlink" title="触发BFC的方式："></a>触发BFC的方式：</h3><ol><li>float 不为 none，浮动元素所在的区域就是一个 BFC 区域。</li><li>position 的值不是 static 或 relative 的元素所在的区域就是一个 BFC 区域</li><li>display为 table-cell 的表格单元格元素所在的区域也是一个 BFC 区域</li><li>overflow 不为 visible 的元素所在的区域也是一个 BFC 区域</li></ol><p>这里简单列举几个触发BFC使用的CSS属性</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">overflow: hidden<br>display: <span class="hljs-keyword">inline</span>-block<br>position: absolute<br>position: fixed<br>display: table-cell<br>display: flex<br></code></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2MDM1Mzg1MA==&mid=2247495021&idx=1&sn=186ac3b00483aed484cf45c06135da2b&chksm=ea685738dd1fde2e71d24f6964223437281536ab34f40dc30a9097327c45858cfb65c1c32494&mpshare=1&scene=23&srcid=0508lZZ1YlHc5VKp7BtD81qU&sharer_sharetime=1620473387155&sharer_shareid=06281d72abe265bef7cbe940688c4d2b#rd">前端面经</a></p><p><a href="https://juejin.cn/post/6950082193632788493#heading-0">面试官：请说说什么是BFC？大白话讲清楚</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>前端基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详情页&amp;对全局事件解绑&amp;递归组件实现详情页</title>
    <link href="/2021/05/08/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%B9%9D)/"/>
    <url>/2021/05/08/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%B9%9D)/</url>
    
    <content type="html"><![CDATA[<p><a href="https://gitee.com/Pengzhenglong/Travel">项目地址</a><br><a href="https://www.bilibili.com/video/BV1654y1576K/">视频演示地址</a></p><hr><h3 id="详情页动态路由及banner布局"><a href="#详情页动态路由及banner布局" class="headerlink" title="详情页动态路由及banner布局"></a>详情页动态路由及banner布局</h3><p>实现点击以下能够进入详情页</p><p><img src="/image1/34.png" alt="点击进入详情页"></p><p>src\pages\home\components\Recommend.vue中router-link</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">&lt;router-link</span><br><span class="xml">  tag=&quot;li&quot;</span><br><span class="xml">  class=&quot;item border-bottom&quot;</span><br><span class="xml">  v-for=&quot;item of list&quot;</span><br><span class="xml">  :key=&quot;item.id&quot;</span><br><span class="xml">  :to=&quot;/detail/ + item.id&quot;</span><br><span class="xml">&gt;</span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-img&quot;</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;item.imgUrl&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span></span><br><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-info&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-title&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.title</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-desc&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.desc</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-button&quot;</span>&gt;</span>查看详情<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>src\router\index.js路由配置</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span>  Detail  <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/pages/detail/Detail&#x27;</span><br>Vue.use(Router)<br><br>export <span class="hljs-keyword">default</span> <span class="hljs-built_in">new</span> Router(&#123;<br>  routes: [<br>    &#123;<br>      <span class="hljs-type">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>      <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;Home&#x27;</span>,<br>      component: Home<br>    &#125;,&#123;<br>      <span class="hljs-type">path</span>:<span class="hljs-string">&#x27;/city&#x27;</span>,<br>      <span class="hljs-type">name</span>:<span class="hljs-string">&#x27;City&#x27;</span>,<br>      component:City<br>    &#125;,&#123;<br>      <span class="hljs-type">path</span>:<span class="hljs-string">&#x27;/detail/:id&#x27;</span>,<br>      <span class="hljs-type">name</span>:<span class="hljs-string">&#x27;Detail&#x27;</span>,<br>      component:Detail<br>    &#125;<br>  ]<br>&#125;) <br><br></code></pre></td></tr></table></figure><p>src\pages\detail\Detail.vue</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">detail-banner</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">detail-banner</span>&gt;</span></span><br><span class="xml">    </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">detail-header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">detail-header</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">import DetailBanner from &quot;./components/Banner&quot;;</span><br><span class="xml">import DetailHeader from &quot;./components/Header&quot;;</span><br><span class="xml">export default </span><span class="xquery">&#123;</span><br><span class="xquery"> <span class="hljs-built_in"> name</span>: <span class="hljs-string">&quot;Detail&quot;</span>,</span><br><span class="xquery">  components: &#123;</span><br><span class="xquery">    DetailBanner,</span><br><span class="xquery">    DetailHeader</span><br><span class="xquery">  &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/image1/35.png" alt="实现效果"></p><h4 id="详情页对全局事件解绑"><a href="#详情页对全局事件解绑" class="headerlink" title="详情页对全局事件解绑"></a>详情页对全局事件解绑</h4><p>全局事件<br>详情页绑定了一个全局事件，当我在详情页面中滚动，这个样写没有问题，但是当我去到其他页面，在滚动时，你就会发现，刚刚你绑定在详情页中的滚动事件，在这个页面也被执行了，这肯定是有问题的。</p><p>其实在我们使用了keep-alive标签后，会有两个生命周期函数分别是：activated、deactivated</p><p>activated：页面展示的时候被执行        </p><p>deactivated：页面被隐藏或者页面即将被替换成新的页面时被执行           </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">activated <span class="hljs-literal">()</span> &#123;<br>    window.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">scroll</span>&#x27;, <span class="hljs-params">this</span>.<span class="hljs-params">handleScroll</span>)</span><br>&#125;,<br>deactivated <span class="hljs-literal">()</span> &#123;<br>    window.remove<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">scroll</span>&#x27;, <span class="hljs-params">this</span>.<span class="hljs-params">handleScroll</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是页面被展示的执行scroll，页面被隐藏的时候移除scroll事件</p><p>src\pages\detail\components\Header.vue部分代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;div&quot;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header-abs&quot;</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;showAbs&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont header-abs-back&quot;</span>&gt;</span><span class="hljs-symbol">&amp;#xe624;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header-fixed&quot;</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;!showAbs&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;opacityStyle&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont header-fixed-back&quot;</span>&gt;</span><span class="hljs-symbol">&amp;#xe624;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>      景点详情<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;DetailHeader&quot;</span>,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      showAbs: <span class="hljs-literal">true</span>,</span><br>      opacityStyle: 0<br>    &#125;;<br>  &#125;,<br>  methods: &#123;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">handleScroll</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-keyword">const</span> top = <span class="hljs-built_in">document</span>.documentElement.scrollTop;</span><br>      if (top &gt; 60) &#123;<br><span class="javascript">        <span class="hljs-keyword">let</span> opacity = top / <span class="hljs-number">140</span>;</span><br>        opacity = opacity &gt; 1 ? 1 : opacity;<br><span class="javascript">        <span class="hljs-built_in">this</span>.opacityStyle = &#123; opacity &#125;;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.showAbs = <span class="hljs-literal">false</span>;</span><br><span class="javascript">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.showAbs = <span class="hljs-literal">true</span>;</span><br>      &#125;<br>    &#125;<br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">activated</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-comment">//绑定了一个scroll事件，一旦它被执行，this.handleScroll方法会被执行</span></span><br><span class="javascript">    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;scroll&quot;</span>, <span class="hljs-built_in">this</span>.handleScroll);</span><br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">deactivated</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&quot;scroll&quot;</span>, <span class="hljs-built_in">this</span>.handleScroll);</span><br>  &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="递归组件实现详情页"><a href="#递归组件实现详情页" class="headerlink" title="递归组件实现详情页"></a>递归组件实现详情页</h3><p>递归组件的意思就是在组件自身调用组件自身。</p><p>数据 detail.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;ret&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;data&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;sightName&quot;</span>: <span class="hljs-string">&quot;大连圣亚海洋世界(AAAA景区)&quot;</span>,<br>    <span class="hljs-attr">&quot;bannerImg&quot;</span>: <span class="hljs-string">&quot;http://img1.qunarzz.com/sight/p0/201404/23/04b92c99462687fa1ba45c1b5ba4ad77.jpg_600x330_bf9c4904.jpg&quot;</span>,<br>    <span class="hljs-attr">&quot;gallaryImgs&quot;</span>: [<span class="hljs-string">&quot;http://img1.qunarzz.com/sight/p0/201404/23/04b92c99462687fa1ba45c1b5ba4ad77.jpg_800x800_70debc93.jpg&quot;</span>, <span class="hljs-string">&quot;http://img1.qunarzz.com/sight/p0/1709/76/7691528bc7d7ad3ca3.img.png_800x800_9ef05ee7.png&quot;</span>],<br>    <span class="hljs-attr">&quot;categoryList&quot;</span>: [&#123;<br>        <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;成人票&quot;</span>,<br>        <span class="hljs-attr">&quot;children&quot;</span>: [&#123;<br>          <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;成人三馆联票&quot;</span>,<br>          <span class="hljs-attr">&quot;children&quot;</span>: [&#123;<br>            <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;成人三馆联票 - 某一连锁店销售&quot;</span><br>          &#125;]<br>        &#125;,&#123;<br>          <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;成人五馆联票&quot;</span><br>        &#125;]<br>      &#125;, &#123;<br>        <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;学生票&quot;</span><br>      &#125;, &#123;<br>        <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;儿童票&quot;</span><br>      &#125;, &#123;<br>        <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;特惠票&quot;</span><br>      &#125;]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>src\pages\detail\components\List.vue</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) of list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-title  border-bottom&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-title-icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">        </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.title</span> &#125;&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;item.children&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-children&quot;</span>&gt;</span></span><br><span class="xml">        //使用递归组件</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">detail-list</span> <span class="hljs-attr">:list</span>=<span class="hljs-string">&quot;item.children&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">detail-list</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">import Detail from &quot;../Detail.vue&quot;;</span><br><span class="xml">export default &#123;</span><br><span class="xml">  components: &#123; Detail &#125;,</span><br><span class="xml">  name: &quot;DetailList&quot;,</span><br><span class="xml">  props: &#123;</span><br><span class="xml">    list: Array</span><br><span class="xml">  &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;stylus&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="xml">.item-title-icon</span><br><span class="xml">    position: relative</span><br><span class="xml">    left: .06rem</span><br><span class="xml">    top: .06rem</span><br><span class="xml">    display: inline-block</span><br><span class="xml">    width: .36rem</span><br><span class="xml">    height: .36rem</span><br><span class="xml">    background: url(http://s.qunarzz.com/piao/image/touch/sight/detail.png) 0 -.45rem no-repeat</span><br><span class="xml">    margin-right: .1rem</span><br><span class="xml">    background-size: .4rem 3rem</span><br><span class="xml">.item-title</span><br><span class="xml">    line-height :.8rem</span><br><span class="xml">    font-size: 0.32rem</span><br><span class="xml">    padding : 0 .2rem</span><br><span class="xml">.item-children</span><br><span class="xml">    padding:0 .2rem</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><p>上面代码中，在 list-children 这个元素下，先做了一个判断，当 item.children 下有值的时候，调用一下自身，也就是 detail-list 这个组件，这个组件也是通过属性的形式，传一个 list，因为在 list.vue 中已经通过 props 接收到 list 了，而且外层已经循环过 list 了，现在要获取 list 下的 children 中的数据，所以直接让这个 list 属性等于 item.children 就可以了。因为数据存在层级关系，可以通过添加样式呈现出来，效果如下图：</p><p><img src="/image1/36.png" alt="效果"></p><h4 id="keep-alive不缓存"><a href="#keep-alive不缓存" class="headerlink" title="keep-alive不缓存"></a>keep-alive不缓存</h4><p>在Detail.vue页面中，当我点击了其他景点后，它也是不会发送请求的，那么Detail页面就不会重新渲染了。</p><p>可以使用keep-alive的exclude属性，给它默认设置为Detail，用途是每次进入Detail页面都会发送请求</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">keep</span>-alive exclude=<span class="hljs-string">&quot;Detail&quot;</span>&gt;   <span class="hljs-comment">//使用 exclude 属性，可以设置不需要缓存的页面</span><br>   &lt;router-<span class="hljs-keyword">view</span>/&gt;<br>&lt;/<span class="hljs-keyword">keep</span>-alive&gt;<br></code></pre></td></tr></table></figure><h4 id="页面路由切换回到最顶部"><a href="#页面路由切换回到最顶部" class="headerlink" title="页面路由切换回到最顶部"></a>页面路由切换回到最顶部</h4><p><img src="/image1/37.png" alt="代码添加"></p><p>让页面切换后始终回到页面最顶部</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">scrollBehavior (<span class="hljs-keyword">to</span>, <span class="hljs-keyword">from</span>, savedPosition) &#123;<br><span class="hljs-built_in">      return</span> &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span> &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="在项目中加入基础动画"><a href="#在项目中加入基础动画" class="headerlink" title="在项目中加入基础动画"></a>在项目中加入基础动画</h3><p>让图片点击时有若影若现的效果</p><p>新建一个组件，通过插槽的方式传递<br>src\common\fade\FadeAnimation.vue</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;FadeAnimation&quot;</span></span><br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;stylus&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><br>.v-enter, .v-leave-to<br><span class="css">    <span class="hljs-attribute">opacity</span> :<span class="hljs-number">0</span></span><br>.v-enter-activate, .v-leave-activate<br><span class="css">  <span class="hljs-attribute">transition</span> :opacity  .<span class="hljs-number">5s</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>src\pages\detail\components\Banner.vue中使用,部分代码</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xquery">    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">fade-animation</span>&gt;</span></span><br><span class="xml">      &lt;common-gallary</span><br><span class="xml">        :imgs=&quot;bannerImgs&quot;</span><br><span class="xml">        v-show=&quot;showGallary&quot;</span><br><span class="xml">        @close=&quot;handleGallaryClose&quot;</span><br><span class="xml">      &gt;&lt;/common-gallary</span><br><span class="xml">    &gt;<span class="hljs-tag">&lt;/<span class="hljs-name">fade-animation</span>&gt;</span></span><br><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">import CommonGallary from &quot;common/gallary/Gallary&quot;;</span><br><span class="xml">import FadeAnimation from &quot;common/fade/FadeAnimation&quot;;</span><br><span class="xml">export default </span><span class="xquery">&#123;</span><br><span class="xquery"> <span class="hljs-built_in"> name</span>: <span class="hljs-string">&quot;DetailBanner&quot;</span>,</span><br><span class="xquery">  components: &#123;</span><br><span class="xquery">    CommonGallary,</span><br><span class="xquery">    FadeAnimation</span><br><span class="xquery">  &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>至此，项目基本完结…</p>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三次握手和四次挥手</title>
    <link href="/2021/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <url>/2021/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="TCP-协议三次握手"><a href="#TCP-协议三次握手" class="headerlink" title="TCP 协议三次握手"></a>TCP 协议三次握手</h3><p>客户端-发送带有SYN标致的数据包-一次握手–服务端</p><p>服务端-发送带有SYN/ACK标致的数据包-二次握手-客户端</p><p>客户端-发送带有ACK的数据包-三次握手-服务端</p><h4 id="目的：-建立可靠的通信通道-，数据的发送和接收（双方正常）"><a href="#目的：-建立可靠的通信通道-，数据的发送和接收（双方正常）" class="headerlink" title="目的：    建立可靠的通信通道 ，数据的发送和接收（双方正常）"></a>目的：    建立可靠的通信通道 ，数据的发送和接收（双方正常）</h4><blockquote><p>翻译成大白话就是： 客户端：你能接收到我的消息吗？ 服务端：可以的，那你能接收到我的回复吗？ 客户端：可以，那我们开始聊正事吧。</p></blockquote><h4 id="为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人-为什么不是4次？：3次够了第四次浪费"><a href="#为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人-为什么不是4次？：3次够了第四次浪费" class="headerlink" title="为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人 为什么不是4次？：3次够了第四次浪费"></a>为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人 为什么不是4次？：3次够了第四次浪费</h4><p><img src="/image/25.png" alt="三次握手"></p><h3 id="TCP-协议四次挥手"><a href="#TCP-协议四次挥手" class="headerlink" title="TCP 协议四次挥手"></a>TCP 协议四次挥手</h3><p>客户端-发送一个FIN,用来关闭客户端到服务器的数据传输<br>服务器-收到这个FIN,它发回一个ACK，确认序号为收到的序号加1.和SYN一样，一个FIN将占用一个序号<br>服务器-关闭与客户端的连接，发送一个FIN给客户端<br>客户端-发回ACK报文确认，并将确认序号设置为收到序号加1             </p><p><img src="/image/26.png" alt="四次挥手"></p><ol><li>为什么不是两次？              </li></ol><p>两次情况客户端说完结束就立马断开不再接收，无法确认服务端是否接收到断开消息，但且服务端可能还有消息未发送完。<br>2. 为什么不是三次？    </p><p>3次情况服务端接收到断开消息，向客户端发送确认接受消息，客户端未给最后确认断开的回复。</p><ol start="3"><li>为什么要四次挥手</li></ol><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p><h4 id="TCP作为一种可靠的传输控制协议，其核心思想就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求。"><a href="#TCP作为一种可靠的传输控制协议，其核心思想就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求。" class="headerlink" title="TCP作为一种可靠的传输控制协议，其核心思想就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求。"></a>TCP作为一种可靠的传输控制协议，其核心思想就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求。</h4>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>TCP 协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue&amp;Vuex</title>
    <link href="/2021/05/07/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%B8%83)/"/>
    <url>/2021/05/07/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%B8%83)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="Vuex介绍"><a href="#Vuex介绍" class="headerlink" title="Vuex介绍"></a>Vuex介绍</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化. Vuex 解决了<strong>多个视图依赖于同一状态</strong>和<strong>来自不同视图的行为需要变更同一状态</strong>的问题，将开发者的精力聚焦于数据的更新而不是数据在组件之间的传递上</p><ol><li>多个视图依赖于同一状态。</li><li>来自不同视图的行为需要变更同一状态。</li></ol><p>对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。</p><p>因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！</p><p><img src="/image1/33.png" alt="Vuex"></p><h3 id="怎么使用vuex"><a href="#怎么使用vuex" class="headerlink" title="怎么使用vuex"></a>怎么使用vuex</h3><p>第一步安装</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install vuex <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>第二步创建store</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;<br>Vue.use(Vuex);<br><span class="hljs-comment">//不是在生产环境debug为true</span><br><span class="hljs-keyword">const</span> debug = process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span>;<br><span class="hljs-comment">//创建Vuex实例对象</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>    strict:debug,<span class="hljs-comment">//在不是生产环境下都开启严格模式</span><br>    state:&#123;<br>    &#125;,<br>    getters:&#123;<br>    &#125;,<br>    mutations:&#123;<br>    &#125;,<br>    actions:&#123;<br>    &#125;<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure><p>第三步注入vuex</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span>;<br><span class="hljs-built_in">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  router,<br>  store,<br>  components: &#123; App &#125;,<br>  <span class="hljs-keyword">template</span>: <span class="hljs-string">&#x27;&lt;App/&gt;&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="Vuex各个模块"><a href="#Vuex各个模块" class="headerlink" title="Vuex各个模块"></a>Vuex各个模块</h3><ol><li>state：用于数据的存储，是store中的唯一数据源</li><li>getters：如vue中的计算属性一样，基于state数据的二次包装，常用于数据的筛选和多个数据的相关性计算</li><li>mutations：类似函数，改变state数据的唯一途径，且不能用于处理异步事件</li><li>actions：类似于mutation，用于提交mutation来改变状态，而不直接变更状态，可以包含任意异步操作</li><li>modules：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护</li></ol><h3 id="Vuex实例应用"><a href="#Vuex实例应用" class="headerlink" title="Vuex实例应用"></a>Vuex实例应用</h3><p>// 父组件</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ChildA</span>/&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ChildB</span>/&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  import ChildA from &#x27;./components/ChildA&#x27; // 导入A组件</span><br><span class="xml">  import ChildB from &#x27;./components/ChildB&#x27; // 导入B组件</span><br><br><span class="xml">  export default </span><span class="xquery">&#123;</span><br><span class="xquery">   <span class="hljs-built_in"> name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,</span><br><span class="xquery">    components: &#123;ChildA, ChildB&#125;</span><span class="xml"> // 注册A、B组件</span><br><span class="xml">  &#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>// 子组件childA</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;childA&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是A组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;transform&quot;</span>&gt;</span>点我让B组件接收到数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>因为你点了B，所以我的信息发生了变化：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">BMessage</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  export default &#123;</span><br><span class="xml">    data() &#123;</span><br><span class="xml">      return &#123;</span><br><span class="xml">        AMessage: &#x27;Hello，B组件，我是A组件&#x27;</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    computed: &#123;</span><br><span class="xml">      BMessage() &#123;</span><br><span class="xml">        // 这里存储从store里获取的B组件的数据</span><br><span class="xml">        return this.$store.state.BMsg</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    methods: &#123;</span><br><span class="xml">      transform() &#123;</span><br><span class="xml">        // 触发receiveAMsg，将A组件的数据存放到store里去</span><br><span class="xml">        this.$store.commit(&#x27;receiveAMsg&#x27;, &#123;</span><br><span class="xml">          AMsg: this.AMessage</span><br><span class="xml">        &#125;)</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>// 子组件 childB</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;childB&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是B组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;transform&quot;</span>&gt;</span>点我让A组件接收到数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>因为你点了A，所以我的信息发生了变化：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">AMessage</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  export default &#123;</span><br><span class="xml">    data() &#123;</span><br><span class="xml">      return &#123;</span><br><span class="xml">        BMessage: &#x27;Hello，A组件，我是B组件&#x27;</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    computed: &#123;</span><br><span class="xml">      AMessage() &#123;</span><br><span class="xml">        // 这里存储从store里获取的A组件的数据</span><br><span class="xml">        return this.$store.state.AMsg</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    methods: &#123;</span><br><span class="xml">      transform() &#123;</span><br><span class="xml">        // 触发receiveBMsg，将B组件的数据存放到store里去</span><br><span class="xml">        this.$store.commit(&#x27;receiveBMsg&#x27;, &#123;</span><br><span class="xml">          BMsg: this.BMessage</span><br><span class="xml">        &#125;)</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>vuex的store,js</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs pf">import Vue <span class="hljs-keyword">from</span> &#x27;vue&#x27;<br>import Vuex <span class="hljs-keyword">from</span> &#x27;vuex&#x27;<br>Vue.use(Vuex)<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">state</span> = &#123;<br>  // 初始化A和B组件的数据，等待获取<br>  AMsg: &#x27;&#x27;,<br>  BMsg: &#x27;&#x27;<br>&#125;<br><br><span class="hljs-keyword">const</span> mutations = &#123;<br>  receiveAMsg(<span class="hljs-keyword">state</span>, payload) &#123;<br>    // 将A组件的数据存放于<span class="hljs-keyword">state</span><br>    <span class="hljs-keyword">state</span>.AMsg = payload.AMsg<br>  &#125;,<br>  receiveBMsg(<span class="hljs-keyword">state</span>, payload) &#123;<br>    // 将B组件的数据存放于<span class="hljs-keyword">state</span><br>    <span class="hljs-keyword">state</span>.BMsg = payload.BMsg<br>  &#125;<br>&#125;<br><br>export <span class="hljs-keyword">default</span> new Vuex.Store(&#123;<br>  <span class="hljs-keyword">state</span>,<br>  mutations<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://vuex.vuejs.org/zh/">Vue官方文档</a></p><p><a href="https://juejin.cn/post/6844903887162310669#heading-16">vue中8种组件通信方式, 值得收藏!</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Vuex的实现数据共享&amp;localStorage&amp;keep-alive</title>
    <link href="/2021/05/07/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E5%85%AB)/"/>
    <url>/2021/05/07/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E5%85%AB)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="使用Vuex的实现数据共享"><a href="#使用Vuex的实现数据共享" class="headerlink" title="使用Vuex的实现数据共享"></a>使用Vuex的实现数据共享</h3><p>需求：我们点击城市页时首页的城市也能改变</p><p>City.vue和Home.vue是没有一个共用的父级组价的，这样两个页面是没有一个共用的父级组件进行中转。方法一：使用Bus总线(比较麻烦)</p><p>方法二：Vuex(数据框架)<br>main.js引入store</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span>  store  <span class="hljs-keyword">from</span>  <span class="hljs-string">&#x27;./store&#x27;</span><br><span class="hljs-built_in">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  router,<br>  store,<br>  components: &#123; App &#125;,<br>  <span class="hljs-keyword">template</span>: <span class="hljs-string">&#x27;&lt;App/&gt;&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>src\store\index.js 代码：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pf">import Vue <span class="hljs-keyword">from</span> &#x27;vue&#x27;<br>import Vuex <span class="hljs-keyword">from</span> &#x27;vuex&#x27;<br>import  <span class="hljs-keyword">state</span>  <span class="hljs-keyword">from</span>  &#x27;./<span class="hljs-keyword">state</span>&#x27;<br>import  mutations <span class="hljs-keyword">from</span>  &#x27;./mutation&#x27;<br>Vue.use(Vuex)<br>export <span class="hljs-keyword">default</span>  new  Vuex.Store(&#123;<br>    <span class="hljs-keyword">state</span>,<br>    mutations<br>&#125;)<br></code></pre></td></tr></table></figure><p>src\store\mutation.js</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pf">export <span class="hljs-keyword">default</span>&#123;<br>        changeCity(<span class="hljs-keyword">state</span>,city)&#123;<br>            <span class="hljs-keyword">state</span>.city=city<br>            try&#123;<br>                localStorage.city=city<br>            &#125;catch(e)&#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>src\store\state.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span>  defaultCity  =<span class="hljs-string">&#x27;北京&#x27;</span><br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">localStorage</span>.city)&#123;<br>        defaultStatus=<span class="hljs-built_in">localStorage</span>.city<br>    &#125;<br>&#125;<span class="hljs-keyword">catch</span>(e)&#123;&#125;<br><span class="hljs-keyword">export</span>  <span class="hljs-keyword">default</span>&#123;<br>        city: defaultCity<br><br>&#125;<br></code></pre></td></tr></table></figure><p>src\pages\city\components\List.vue使用部分代码其他页面修改同理</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gradle">    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;&#123;&#123; <span class="hljs-keyword">this</span>.currentCity &#125;&#125;&lt;/<span class="hljs-keyword">div</span>&gt;<br>      &lt;<span class="hljs-keyword">div</span><br>            <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;item  border-bottom&quot;</span><br>            v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;innerItem of item&quot;</span><br>            :key=<span class="hljs-string">&quot;innerItem.id&quot;</span><br>            @click=<span class="hljs-string">&quot;handleCityClick(innerItem.name)&quot;</span><br>          &gt;<br>            &#123;&#123; innerItem.name &#125;&#125;<br>          &lt;/<span class="hljs-keyword">div</span>&gt;<br><br><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;&#123;&#123; <span class="hljs-keyword">this</span>.$store.state.city &#125;&#125;&lt;/<span class="hljs-keyword">div</span>&gt;<br>  methods: &#123;<br>    handleCityClick(city) &#123;<br>      <span class="hljs-keyword">this</span>.$store.commit(<span class="hljs-string">&quot;changeCity&quot;</span>, city); <br>      <span class="hljs-comment">//页面跳转--编程式导航push</span><br>      <span class="hljs-keyword">this</span>.$router.<span class="hljs-keyword">push</span>(<span class="hljs-string">&quot;/&quot;</span>);<br>    &#125;<br>  &#125;,<br></code></pre></td></tr></table></figure><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>刚开始在实现首页右上角城市定位显示的时候，src 目录下新建了一个 store 目录，存储了 Vuex 中的默认数据，city 直接设置成了“北京”，但是其实这样去写，是有问题的，点击城市，会改变这个 city，但是当页面刷新了，就又变回了北京。      </p><p>考虑到在真实的项目中，如果你这次选中了一个城市，下次再打开这个网页的时候，上次选的城市还应该在的，怎么解决这个问题呢？         </p><p>这时可以借助 HTML5 中提供了一个新的 api，叫做 localStorage，它可以实现本地存储，在这里也就是实现保存城市的功能。         </p><p>store/index.js中，这样去写代码，当用户尝试去改变城市的时候，我不但把 state 中的 city 改了，同时还去存一个 localStorage，直接写 localStorage.city = city 就可以了。然后让 stare 中 city 的默认值是 localStorage.city || “北京”，就可以了。也就是 city 的值我默认先去 localStorage 中取，如果取不到，才用默认的 “北京”。</p><p>store/index.js中，这样去写代码，当用户尝试去改变城市的时候，我不但把 state 中的 city 改了，同时还去存一个 localStorage，直接写 localStorage.city = city 就可以了。然后让 stare 中 city 的默认值是 localStorage.city || “北京”，就可以了。也就是 city 的值我默认先去 localStorage 中取，如果取不到，才用默认的 “北京”。</p><p>store/index.js</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pf">import Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br>import Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span>;<br>Vue.use(Vuex);<br>export <span class="hljs-keyword">default</span> new Vuex.Store(&#123;<br>    <span class="hljs-keyword">state</span>: &#123;<br>        city: localStorage.city || <span class="hljs-string">&quot;北京&quot;</span><br>    &#125;,<br>    mutations: &#123;<br>        changeCity(<span class="hljs-keyword">state</span>, city) &#123;<br>            <span class="hljs-keyword">state</span>.city = city;<br>            localStorage.city = city;<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>这个时候打开页面，当用户选择一个城市，然后刷新页面，可以看到上次选择的城市还在。但是当使用 localStorage 的时候，建议在外层包裹一个 try{ }catch(e){ }，因为在某些浏览器，如果用户关闭了本地存储这样的功能，或者使用隐身模式，使用 localStorage 可能导致浏览器直接抛出异常，代码就运行不了了，为了避免这种问题，建议在外层加一个 try{ }catch(e){ }，怎么加呢？</p><p>先定义一个默认的 defaultCity 等于“北京”，然后写一个 try{ }catch(e){ }，这样写：如果有 localStorage.city，default.city 就等于 localStorage.city，下边 state 中的 city 就可以等于 defaultCity 了，同样在 mutations 的 changeCity 中也要写一个 try{ }catch(e)：</p><p>store/index.js</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs pf">import Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br>import Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span>;<br>Vue.use(Vuex);<br><br>let <span class="hljs-keyword">default</span>City = <span class="hljs-string">&quot;北京&quot;</span><br>try &#123;<br>    if (localStorage.city) &#123;<br>        <span class="hljs-keyword">default</span>City = localStorage.city;<br>    &#125;<br>&#125; catch (e) &#123; &#125;<br><br>export <span class="hljs-keyword">default</span> new Vuex.Store(&#123;<br>    <span class="hljs-keyword">state</span>: &#123;<br>        city: <span class="hljs-keyword">default</span>City<br>    &#125;,<br>    mutations: &#123;<br>        changeCity(<span class="hljs-keyword">state</span>, city) &#123;<br>            <span class="hljs-keyword">state</span>.city = city;<br>            try &#123;<br>                localStorage.city = city;<br>            &#125; catch (e) &#123; &#125;<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>现在我们看到 store/index.js 这个文件慢慢的变得复杂起来了，实际上，在真正的项目开发和之中，会做进一步的拆分，也就是把这个文件拆分为 State、Actions、Mutations，在 store 中创建一个文件叫 state.js（只存储公用数据），然后把设置默认数据的这块代码放进去，并通过 export 导出，内容就是在 index.js 中定义的 state 对象里的内容：代<br>码见上面方法二中：</p><p>这样，我们就将 vuex 的代码拆分成了 State、Actions、Mutations 这几个部分，未来它的维护性也会得到比较大的提高。</p><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>使用 keep-alive 优化网页性能</p><p>当写完城市列表响应代码，启动服务，打开页面，这样看不存在什么问题，基本的一些业务逻辑都已经实现了，但是在控制台中打开 Network 网络这个选项，选择 XHR，当初次进入首页的时候，请求了一个 index.json 的文件，然后切换到列表页，又请求了一个 city.json，然后再回到首页，index.json 又请求了一次，再次去列表页，city.json 又请求了一次，也就是，每一次路由发生变化的时候，Ajax 都会重新的被发送。</p><p><img src="/image1/29.png" alt="ajax"></p><p>思考是什么原因导致这样的问题呢，打开 Home.vue 首页这个组件，每一次打开这个首页的时候，都会被重新的渲染，所以 mounted 这个钩子就会被重新的执行，那么这个 Ajax 数据就会被重新获取，那么这么能让它只获取一次呢？</p><p>打开 main.js，可以看到入口组件是 App 这个组件，再打开 App.vue，router-view 显示的是当前地址所对应的内容，我们可以在外层包裹一个 keep-alive 的一个标签，他是 Vue 自带的一个标签，他的意思就是我的路由的内容被加载一次后，我就把路由中的内容放到内存之中，下一次再进入这个路由的时候，不需要重新渲染这个组件，去重新执行钩子函数，只要去内存里把以前的内容拿出来就可以。</p><p><img src="/image1/30.png" alt="keep-alive"></p><p>这个时候，回到页面上，再打开 Network，进入到列表页，选择城市再返回首页，就不会再去加载 index.json 了，同样再进入列表页，也不会再去加载 city.json 了，他直接会从内存中调数据，而不会重新去法 Ajax 请求了。</p><p><img src="/image1/31.png" alt="keep-alive"></p><p>这样还是存在逻辑上的问题的，当我在“北京”的时候，首页显示的是“北京”的内容，当切换为“上海”时，首页就应该显示“上海”的内容，所以城市发生改变的时候，首页还需要重新发一次 Ajax 请求，来获取不同城市的数据信息，我们对这一块做一个调整。</p><p>打开 Home.vue 组件，改一下 axios 请求地址这里，在他的后面带一个参数，让他等于 Vuex 中存的当前的城市，所以还需要在 Home.vue 组件中引用 Vuex，import { mapState } from “vuex”，然后再加一个计算属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">computed:&#123;<br>    ...<span class="hljs-built_in">mapState</span>([<span class="hljs-string">&#x27;city&#x27;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>获取到城市对应的内容，然后就可以在发 Ajax 的时候，把 city 放在请求的参数里面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">axios.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;/api/index.json?city=&quot;</span> + <span class="hljs-keyword">this</span>.city)<br>.then(<span class="hljs-keyword">this</span>.getHomeInfoSucc);<br></code></pre></td></tr></table></figure><p>这个时候，我们打开页面，可以看到请求参数里已经携带了当前的城市：</p><p>但是，例如当你切换了城市“桂林”，回到首页，并没有重新发 Ajax 请求，虽然上面的城市变成了“桂林”，但是底下的内容还是“北京”的内容，我们希望底下的内容跟着变，该怎么做呢？</p><p>当我们在 App.vue 中用了 keep-alive 的时候，这块的内容已经被缓存起来了，他直接取得是缓存里的数据，那如何去改变缓存里的数据呢？当你使用 keep-alive 的时候，组件中会多出一个生命周期函数 activted，</p><p><img src="/image1/32.png" alt="active"></p><p>可以在 mounted 和 activated 两个生命周期函数下打印一些内容，到浏览器上看一下他俩的执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;mounted&quot;</span>);<br>    <span class="hljs-built_in">this</span>.getHomeInfo();<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">activated</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;activted&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>打开页面，可以看到，mounted 和 activated 都会执行，当切换了城市，再回到首页的时候，组件的 mounted 就不会执行了，就只有 activated 会被执行，那么我们借助 activated 这个生命周期函数就可以实现我们想要的功能了。</p><p>首先在页面被挂载的时候，也就是 mounted 中一定会去发一个 Ajax 请求，当页面重新被显示的时候，activated 一定会被重新的执行，那么我们就可以在页面每次重新显示的时候，可以判断当前页面上的城市和上次页面上显示的城市是否是相同的，如果不相同的，就再发一次 Ajax 请求。</p><p>先在 data 中设置一个数据 lastCity，默认值是空，接着当页面被挂载的时候，让它等于 this.city，对上一次的城市做一个保存：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">mounted() &#123;<br>    <span class="hljs-keyword">this</span>.lastCity = <span class="hljs-keyword">this</span>.city<br>    <span class="hljs-keyword">this</span>.getHomeInfo();<br>&#125;<br></code></pre></td></tr></table></figure><p>当页面被重新激活的时候，我们在 activted 中这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">activated() &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.lastCity != <span class="hljs-keyword">this</span>.city)&#123;<br>        <span class="hljs-keyword">this</span>.lastCity = <span class="hljs-keyword">this</span>.city<br>        <span class="hljs-keyword">this</span>.getHomeInfo();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果上一次的城市 lastCity 不等于当前城市的时候，就重新发一个 Ajax 请求，直接调用上面 getHomeInfo 方法就可以了。当上次的 city 和这次的 city 不一样时，还需要让他等于这次的 city。回到页面上，可以看到当切换的城市和上次的城市一样时，Ajax 就不会请求 city.json 了，当不一样时，才会去请求 city.json。</p><p>回到代码里面，通过 activted 这样一个 keep-alive 新增的生命周期函数，结合 lastCity 这样一个临时缓存变量，就实现了首页代码性能优化的调整。</p>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue去哪儿项目&amp;搜索功能实现</title>
    <link href="/2021/05/06/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%B8%83)/"/>
    <url>/2021/05/06/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%B8%83)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="搜索功能实现"><a href="#搜索功能实现" class="headerlink" title="搜索功能实现"></a>搜索功能实现</h3><p><img src="/image1/28.png" alt="效果图"></p><p>src\pages\city\components\Search.vue部分代码</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs maxima">&lt;div class=<span class="hljs-string">&quot;search-content&quot;</span> ref=<span class="hljs-string">&quot;search&quot;</span> v-<span class="hljs-built_in">show</span>=<span class="hljs-string">&quot;keyword&quot;</span>&gt;<br>&lt;ul&gt;<br>    &lt;<span class="hljs-built_in">li</span><br>    class=<span class="hljs-string">&quot;search-item  border-bottom&quot;</span><br>    v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;item of list&quot;</span><br>    :<span class="hljs-built_in">key</span>=<span class="hljs-string">&quot;item.id&quot;</span><br>    &gt;<br>    &#123;&#123; item.name &#125;&#125;<br>    &lt;/<span class="hljs-built_in">li</span>&gt;<br>    &lt;<span class="hljs-built_in">li</span> class=<span class="hljs-string">&quot;search-item  border-bottom&quot;</span> v-<span class="hljs-built_in">show</span>=<span class="hljs-string">&quot;hasNoData&quot;</span>&gt;<br>    没有找到匹配数据<br>    &lt;/<span class="hljs-built_in">li</span>&gt;<br>&lt;/ul&gt;<br>&lt;/div&gt;<br><br> .search-<span class="hljs-built_in">content</span><br>          z-index:<span class="hljs-number">1</span><br>          overflow :hidden<br>          <span class="hljs-built_in">position</span>:absolute<br>          top: <span class="hljs-number">1.</span>58<span class="hljs-built_in">rem</span><br>          right:<span class="hljs-number">0</span><br>          left:<span class="hljs-number">0</span><br>          bottom:<span class="hljs-number">0</span><br>          <span class="hljs-built_in">background</span>:#eee<br>          .search-item<br>            line-<span class="hljs-built_in">height</span> :.62<span class="hljs-built_in">rem</span><br>            padding-left :.2<span class="hljs-built_in">rem</span><br>            <span class="hljs-built_in">color</span>:#<span class="hljs-number">666</span><br>            <span class="hljs-built_in">background</span>:#fff<br></code></pre></td></tr></table></figure><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;search&quot;</span>&gt;</span></span><br><span class="xml">      &lt;input</span><br><span class="xml">        v-model=&quot;keyword&quot;</span><br><span class="xml">        class=&quot;search-input&quot;</span><br><span class="xml">        type=&quot;text&quot;</span><br><span class="xml">        placeholder=&quot;输入城市名或拼音&quot;</span><br><span class="xml">      /&gt;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;search-content&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;search&quot;</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;keyword&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">          &lt;li</span><br><span class="xml">            class=&quot;search-item  border-bottom&quot;</span><br><span class="xml">            v-for=&quot;item of list&quot;</span><br><span class="xml">            :key=&quot;item.id&quot;</span><br><span class="xml">          &gt;</span><br><span class="xml">            </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.name</span> &#125;&#125;</span><br><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;search-item  border-bottom&quot;</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;hasNoData&quot;</span>&gt;</span></span><br><span class="xml">            没有找到匹配数据</span><br><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">import Bscroll from &quot;better-scroll&quot;;</span><br><span class="xml">export default &#123;</span><br><span class="xml">  name: &quot;CitySearch&quot;,</span><br><span class="xml">  props: &#123;</span><br><span class="xml">    cities: Object</span><br><span class="xml">  &#125;,</span><br><span class="xml">  data() &#123;</span><br><span class="xml">    return &#123;</span><br><span class="xml">      keyword: &quot;&quot;,</span><br><span class="xml">      list: [],</span><br><span class="xml">      timer: null</span><br><span class="xml">    &#125;;</span><br><span class="xml">  &#125;,</span><br><span class="xml">  computed: &#123;</span><br><span class="xml">    hasNoData() &#123;</span><br><span class="xml">      return !this.list.length;</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;,</span><br><span class="xml">  watch: &#123;</span><br><span class="xml">    keyword() &#123;</span><br><span class="xml">      if (this.timer) &#123;</span><br><span class="xml">        clearTimeout(this.timer);</span><br><span class="xml">      &#125;</span><br><span class="xml">      if (!this.keyword) &#123;</span><br><span class="xml">        this.list = [];</span><br><span class="xml">        return;</span><br><span class="xml">      &#125;</span><br><span class="xml">      //防抖节流函数</span><br><span class="xml">      this.timer = setTimeout(() =&gt; &#123;</span><br><span class="xml">        const result = [];</span><br><span class="xml">        for (let i in this.cities) &#123;</span><br><span class="xml">          this.cities[i].forEach(value =&gt; &#123;</span><br><span class="xml">            if (</span><br><span class="xml">              value.spell.indexOf(this.keyword) &gt; -1 ||</span><br><span class="xml">              value.name.indexOf(this.keyword) &gt; -1</span><br><span class="xml">            ) &#123;</span><br><span class="xml">              result.push(value);</span><br><span class="xml">            &#125;</span><br><span class="xml">          &#125;);</span><br><span class="xml">        &#125;</span><br><span class="xml">        this.list = result;</span><br><span class="xml">      &#125;, 100);</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;,</span><br><span class="xml">  mounted() &#123;</span><br><span class="xml">    this.scroll = new Bscroll(this.$refs.search);</span><br><span class="xml">  &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>【性能优化–节流】<br>函数节流：通过设定一个时间周期，只要在这个周期内函数就不执行。</p><p>【防抖】<br>写一个侦听器 watch，在里边监听 keyword 的改变，考虑到性能优化，使用防抖的方式来实现，先在 data 中定义一个 timer 定时器，默认值为 null，然后在监听 keyword 的方法中，判断，当 timer 不为 null 时，清除这个定时器。下面写这个定时器的方法，当延时 100ms 的时候，箭头函数会被执行。</p>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue去哪儿项目&amp;兄弟组件间联动&amp;节流</title>
    <link href="/2021/05/05/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E5%85%AD)/"/>
    <url>/2021/05/05/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E5%85%AD)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="兄弟组件间联动-重要"><a href="#兄弟组件间联动-重要" class="headerlink" title="兄弟组件间联动(重要)"></a>兄弟组件间联动(重要)</h3><p>实现功能：点击城市列表页面右侧的字母，列表选项会滚动到对应的字母区域。</p><blockquote><p>兄弟组件的传值，可以通过 bus 总线的形式来传值。但是因为我们现在这个非父子组件比较简单，可以让 Alphabet.vue 组件将值传递给父组件 City.vue 组件，然后 City.vue 组件再将值转发给 List.vue 组件，这样就实现了兄弟组件的传值。【子组件给父组件，父组件再转给另一个子组件】。这样，在 Alphabet.vue 中点击右侧字母，会获取到对应的字母。</p></blockquote><p>src\pages\city\components\Alphabet.vue</p><p>在循环的元素上加一个点击事件，例如 handleLetterClick，然后在 methods 中写这个事件方法：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span></span><br><span class="xml">    &lt;li</span><br><span class="xml">      class=&quot;item&quot;</span><br><span class="xml">      v-for=&quot;item of letters&quot;</span><br><span class="xml">      :key=&quot;item&quot;</span><br><span class="xml">      :ref=&quot;item&quot;</span><br><span class="xml">      @click=&quot;handleLetterClick&quot;</span><br><span class="xml">    &gt;</span><br><span class="xml">      </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item</span>&#125;&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">methods: &#123;</span><br><span class="xml">    handleLetterClick(e) &#123;</span><br><span class="xml">        this.$emit(&quot;change&quot;, e.target.innerHTML);</span><br><span class="xml">    &#125;</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>首先在父组件 City.vue 里的 data 中定义一个 letter，默认值是空，在 handleLetterClick 方法中，当接受到外部传来的 letter 的时候，让 this.letter = letter。</p><p>City.vue部分代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;city-list :cities=<span class="hljs-string">&quot;cities&quot;</span> :hot=<span class="hljs-string">&quot;hotCities&quot;</span> :letter=<span class="hljs-string">&quot;letter&quot;</span>&gt;&lt;/city-list&gt;<br>&lt;city-alphabet :cities=<span class="hljs-string">&quot;cities&quot;</span> @change=<span class="hljs-string">&quot;handLetterChange&quot;</span>&gt;&lt;/city-alphabet&gt;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  name: <span class="hljs-string">&quot;City&quot;</span>,<br>  components: &#123;<br>    CityHeader,<br>    CitySearch,<br>    CityList,<br>    CityAlphabet<br>  &#125;,<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">handLetterChange</span>(<span class="hljs-params">letter</span>)</span> &#123;<br>      <span class="hljs-comment">// console.log(letter);</span><br>      <span class="hljs-built_in">this</span>.letter = letter;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 存放数据</span><br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      cities: &#123;&#125;,<br>      hotCities: [],<br>      letter: <span class="hljs-string">&quot;&quot;</span><br>    &#125;;<br>  &#125;,<br><br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>接下来，将父组件接收到的这个数据转发给子组件 List.vue，父组件是通过属性props向子组件传值的。</p><p>最后只需要把 letter 传递给子组件 List.vue 就可以了，在 City.vue 组件的模板 city-list 中通过 :letter=”letter” 向子组件 List 传值，在 props 中接收这个 letter，并且验证类型为 String 类型。</p><p>List.vue</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">props:</span> &#123;<br><span class="hljs-symbol">    hot:</span> Array,<br><span class="hljs-symbol">    cities:</span> Object,<br><span class="hljs-symbol">    letter:</span> String<br>  &#125;<br></code></pre></td></tr></table></figure><p>这样就实现了兄弟组件的传值。</p><h4 id="【项目难点】"><a href="#【项目难点】" class="headerlink" title="【项目难点】"></a>【项目难点】</h4><p>接下来要做的是，当 List.vue 发现 letter 有改变的时候，就需要让组件显示的列表项跟 letter 相同的首字母的列表项要显示出来，怎么做呢？</p><ol><li>这个时候就要借助一个侦听器，监听letter的变化；</li></ol><p>better-scroll 给提供了这样一个接口，scroll.scorllToElement，如果 letter 不为空的时候，就调用 this.scroll.scrollToElement() 这个方法，可以让滚动区自动滚到某一个元素上，那么怎么传这个元素呢？在循环城市这一块中，给循环项加一个 ref 引用来获取当前 Dom 元素，等于 key，然后回到侦听器的 letter 中，定义一个 element，它就等于通过 ref 获取到的元素：</p><p>src\pages\city\components\List.vue</p><p>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;area&quot;</span> v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(item, key) of cities&quot;</span> :key=<span class="hljs-string">&quot;key&quot;</span> :ref=<span class="hljs-string">&quot;key&quot;</span>&gt;<br><br>watch: &#123;<br><span class="hljs-function"><span class="hljs-title">letter</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// console.log(this.letter);</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.letter) &#123;<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-built_in">this</span>.$refs[<span class="hljs-built_in">this</span>.letter][<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">this</span>.scroll.scrollToElement(element);<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候就可以通过字母获取到对应的区域，然后把 element 传入 scrollToElement 里，注意，上边代码最后加了一个 [0]，这是因为如果不加，通过 ref 或的内容就是一个数组，这个数组里的第一个元素才是真正的 DOM 元素，这个时候，点击右侧字母表，就可以跳到对应的字母下的城市列表了。</p><p>点击跳转的功能实现了</p><ol start="2"><li>接下来再实现一下滑动右侧字母表，左侧城市列表切换的效果。</li></ol><p>知识补充</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">touchstart</span>事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。<br><br><span class="hljs-variable">touchmove</span>事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用<span class="hljs-function"><span class="hljs-title">preventDefault</span>()事件可以阻止滚动。</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-variable">touchend</span>事件：当手指从屏幕上离开的时候触发。</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-variable">touchcancel</span>事件：当系统停止跟踪触摸的时候触发。关于这个事件的确切出发时间，文档中并没有具体说明，咱们只能去猜测了。</span><br></code></pre></td></tr></table></figure><p>src\pages\city\components\Alphabet.vue部分代码</p><p>思路：绑定三个新的事件， @touchstart @touchmove @touchend，然后定义一个标识位，    touchStatus: false,开始@touchstart=true,结束@touchend=false</p><p>首先我们要知道我们滑动的是第几个字母–思路：先获得A字母到顶部的高度，然后滑动后获得当前位置距离顶部的高度，做一个差值就能算出当前位置距离A的高度了，除以每个字母的高度就能得到当前是第几个字母了，然后去取对应的字母触发一个change事件给外部。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span></span><br><span class="xml">    &lt;li</span><br><span class="xml">      class=&quot;item&quot;</span><br><span class="xml">      v-for=&quot;item of letters&quot;</span><br><span class="xml">      :key=&quot;item&quot;</span><br><span class="xml">      :ref=&quot;item&quot;</span><br><span class="xml">      @touchstart=&quot;handleTouchStart&quot;</span><br><span class="xml">      @touchmove=&quot;handleTouchMove&quot;</span><br><span class="xml">      @touchend=&quot;handleTouchEnd&quot;</span><br><span class="xml">      @click=&quot;handleLetterClick&quot;</span><br><span class="xml">    &gt;</span><br><span class="xml">      </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item</span> &#125;&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">export default &#123;</span><br><span class="xml">  name: &quot;CityAlphabet&quot;,</span><br><span class="xml">  props: &#123;</span><br><span class="xml">    cities: Object</span><br><span class="xml">  &#125;,</span><br><span class="xml">//计算属性得到一个字母数组[&#x27;A&#x27;,&#x27;B&#x27;,......]</span><br><span class="xml">  computed: &#123;</span><br><span class="xml">    letters() &#123;</span><br><span class="xml">      const letters = [];</span><br><span class="xml">      for (let i in this.cities) &#123;</span><br><span class="xml">        letters.push(i);</span><br><span class="xml">      &#125;</span><br><span class="xml">      return letters;</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;,</span><br><span class="xml">  data() &#123;</span><br><span class="xml">    return &#123;</span><br><span class="xml">      touchStatus: false,</span><br><span class="xml">    &#125;;</span><br><span class="xml">  &#125;,</span><br><span class="xml">  methods: &#123;</span><br><span class="xml">    handleLetterClick(e) &#123;</span><br><span class="xml">      // console.log(e.target.innerText);</span><br><span class="xml">      this.$emit(&quot;change&quot;, e.target.innerText);</span><br><span class="xml">    &#125;,</span><br><span class="xml">    handleTouchStart() &#123;</span><br><span class="xml">      this.touchStatus = true;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    handleTouchMove(e) &#123;</span><br><span class="xml">      if (this.touchStatus) &#123;</span><br><span class="xml">        //startY 计算的是A的顶部距离上沿的距离  </span><br><span class="xml">        //HTMLElement.offsetTop 为只读属性，它返回当前元素相对于其 offsetParent 元素的顶部内边距的距离。</span><br><span class="xml">        const startY = this.$refs[&quot;A&quot;][0].offsetTop;//74</span><br><span class="xml">        //clientY 事件属性clientY 事件属性返回当事件被触发时鼠标指针向对于浏览器页面（客户区）的垂直坐标。 客户区指的是当前窗口。</span><br><span class="xml">        const touchY = e.touches[0].clientY - 79;</span><br><span class="xml">        const index = Math.floor((touchY - startY) / 20); //20为每个字母的高度，index计算出来为每个字母的下标0，1，2，3，4...</span><br><span class="xml">        if (index &gt;= 0 &amp;&amp; index &lt; this.letters.length) &#123;</span><br><span class="xml">          this.$emit(&quot;change&quot;, this.letters[index]);</span><br><span class="xml">        &#125;</span><br><span class="xml">      &#125;</span><br><br><span class="xml">    &#125;,</span><br><span class="xml">    handleTouchEnd() &#123;</span><br><span class="xml">      this.touchStatus = false;</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="列表切换性能优化"><a href="#列表切换性能优化" class="headerlink" title="列表切换性能优化"></a>列表切换性能优化</h3><h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><p>手指在城市字母表中滑动时，会触发无数次handleTouchMove这个函数，这就对性能影响很大。</p><p>函数节流：通过设定一个时间周期，只要在这个周期内函数就不执行。</p><p>实现方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br>      <span class="hljs-comment">// if (this.touchStatus) &#123;</span><br>      <span class="hljs-comment">//   const startY = this.$refs[&quot;A&quot;][0].offsetTop;</span><br>      <span class="hljs-comment">//   const touchY = e.touches[0].clientY - 79;</span><br>      <span class="hljs-comment">//   const index = Math.floor((touchY - startY) / 20); //20为每个字母的高度</span><br>      <span class="hljs-comment">//   if (index &gt;= 0 &amp;&amp; index &lt; this.letters.length) &#123;</span><br>      <span class="hljs-comment">//     this.$emit(&quot;change&quot;, this.letters[index]);</span><br>      <span class="hljs-comment">//   &#125;</span><br>      <span class="hljs-comment">// &#125;  </span><br><span class="hljs-comment">//节流   </span><br>handleTouchMove(e) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.touchStatus) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.timer) &#123;<br>          clearTimeout(<span class="hljs-keyword">this</span>.timer);<br>        &#125;<br>        <span class="hljs-keyword">this</span>.timer = setTimeout(() =&gt; &#123;<br>          <span class="hljs-keyword">const</span> touchY = e.touches[<span class="hljs-number">0</span>].clientY - <span class="hljs-number">79</span>;<br>          <span class="hljs-keyword">const</span> index = Math.floor((touchY - <span class="hljs-keyword">this</span>.startY) / <span class="hljs-number">20</span>); <span class="hljs-comment">//20为每个字母的高度</span><br>          <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; <span class="hljs-keyword">this</span>.letters.length) &#123;<br>            <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">&quot;change&quot;</span>, <span class="hljs-keyword">this</span>.letters[index]);<br>          &#125;<br>        &#125;, <span class="hljs-number">16</span>);<br>      &#125;<br>    &#125;,<br></code></pre></td></tr></table></figure><p>这里设置的周期是16ms，16ms这个代码只会执行一次，大大优化了性能</p><ol><li>offsetTop的值是固定的，我们每一次去执行这个方法就会去运算一次，性能很低</li></ol><p>解决： data()中 先定义startY: 0,分析：页面刚加载的时候，Alphabet.vue中什么都不会显示出来，当City.vue中ajax获取数据后，Citys的值才发生变化，Alphabet才被渲染出来。当往Alphabet中传入的数据发生变化时，Alphabet才会被重新渲染，当Alphabet重新渲染之后，updated() 这个生命周期就会被执行，这个时候页面已经展示了城市字母列表的所有内容，这个时候我们去计算offsetTop就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>   <span class="hljs-keyword">return</span> &#123;<br>     touchStatus: <span class="hljs-literal">false</span>,<br>     startY: <span class="hljs-number">0</span>,<br>     timer: <span class="hljs-literal">null</span><br>   &#125;;<br> &#125;,<br> <span class="hljs-function"><span class="hljs-title">updated</span>(<span class="hljs-params"></span>)</span> &#123;<br>   <span class="hljs-built_in">this</span>.startY = <span class="hljs-built_in">this</span>.$refs[<span class="hljs-string">&quot;A&quot;</span>][<span class="hljs-number">0</span>].offsetTop;<br> &#125;,<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue&amp;v-for循环6种技巧</title>
    <link href="/2021/05/04/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E5%85%AD)/"/>
    <url>/2021/05/04/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E5%85%AD)/</url>
    
    <content type="html"><![CDATA[<hr><p>在最基本的用法中，它们的用法如下。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&#x27;product in products&#x27;</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">product.name</span> &#125;&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br></code></pre></td></tr></table></figure><hr><h3 id="1-始终在v-for循环中使用key"><a href="#1-始终在v-for循环中使用key" class="headerlink" title="1.始终在v-for循环中使用key"></a>1.始终在v-for循环中使用key</h3><p>首先，我们将讨论大多数Vue开发人员已经知道的常见最佳做法——在 v-for 循环中使用 :key。通过设置一个惟一的键属性，它可以确保组件以您期望的方式工作。</p><p>果我们不使用key，Vue将尝试使DOM尽可能高效，这可能意味着 v-for 元素可能会出现乱序或其他不可预测的行为。如果我们对每个元素都有唯一的键引用，那么我们就可以更好地准确地预测DOM将如何操作。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> </span></span><br><span class="xml">    v-for=&#x27;product in products&#x27;</span><br><span class="xml">    :key=&#x27;product._id&#x27;  </span><br><span class="xml">  &gt;</span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">product.name</span> &#125;&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="2-在一个范围内循环"><a href="#2-在一个范围内循环" class="headerlink" title="2.在一个范围内循环"></a>2.在一个范围内循环</h3><p>尽管大多数情况下，v-for 用于遍历数组或对象，但在某些情况下，我们肯定只希望循环执行一定次数。</p><p>例如，假设我们正在为在线商店创建一个分页系统，而我们只希望每页显示10个产品。使用一个变量来跟踪当前的页码，我们可以像这样处理分页。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&#x27;index in 10&#x27;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&#x27;index&#x27;</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">products</span>[page * 10 + index] &#125;&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="3-不要在循环中使用v-if"><a href="#3-不要在循环中使用v-if" class="headerlink" title="3.不要在循环中使用v-if"></a>3.不要在循环中使用v-if</h3><p>一个超级常见的错误是使用 v-if 来过滤 v-for 循环的数据。尽管这看起来很直观，但它会导致一个巨大的性能问题——VueJS优先考虑 v-for 而不是 v-if 指令。</p><p>这意味着您的组件将循环遍历每个元素，然后检查 v-if 条件以确定是否应渲染。因此，实际上，无论条件是什么，您都将遍历数组的每个项目。</p><p>不要这样：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">// BAD CODE!</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> </span></span><br><span class="xml">    v-for=&#x27;product in products&#x27; </span><br><span class="xml">    :key=&#x27;product._id&#x27; </span><br><span class="xml">    v-if=&#x27;product.price &lt; 50&#x27;</span><br><span class="xml">  &gt;</span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">product.name</span> &#125;&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="4-使用计算属性或方法代替"><a href="#4-使用计算属性或方法代替" class="headerlink" title="4.使用计算属性或方法代替"></a>4.使用计算属性或方法代替</h3><p>为避免上述问题，我们应该在遍历模板中的数据之前对其进行过滤。有两种非常相似的方法：</p><p>使用计算属性<br>使用过滤方法<br>让我们快速地介绍一下这两种方法。</p><p>首先，我们只需要设置一个计算属性，为了获得与之前的v-if相同的功能，代码应如下所示。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&#x27;products in productsUnderFifty&#x27;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&#x27;product._id&#x27;</span> &gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">product.name</span> &#125;&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><br><span class="xml">// ...</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  export default &#123;</span><br><span class="xml">    data () &#123;</span><br><span class="xml">      return &#123;</span><br><span class="xml">        products: []</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    computed: &#123;</span><br><span class="xml">      productsUnderFifty: function () &#123;</span><br><span class="xml">        return this.products.filter(product =&gt; product.price &lt; 50)</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>下面的代码几乎相同，但是使用方法改变了我们访问模板中的值的方式，如果我们希望能够将变量传递给筛选器，那么方法是最好的选择。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&#x27;products in productsUnderPrice(50)&#x27;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&#x27;product._id&#x27;</span> &gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">product.name</span> &#125;&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><br><span class="xml">// ...</span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  export default &#123;</span><br><span class="xml">    data () &#123;</span><br><span class="xml">      return &#123;</span><br><span class="xml">        products: []</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    methods: &#123;</span><br><span class="xml">      productsUnderPrice (price) &#123;</span><br><span class="xml">        return this.products.filter(product =&gt; product.price &lt; price)</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="5-在循环中访问项目的索引"><a href="#5-在循环中访问项目的索引" class="headerlink" title="5.在循环中访问项目的索引"></a>5.在循环中访问项目的索引</h3><p>除了遍历数组和访问每个元素之外，我们还可以跟踪每个项的索引。</p><p>为此，我们必须在项目后添加一个索引值，它非常简单，可用于分页，显示列表索引，显示排名等。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&#x27;(products, index) in products&#x27;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&#x27;product._id&#x27;</span> &gt;</span></span><br><span class="xml">    Product #</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">index</span> &#125;&#125;</span><span class="xml">: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">product.name</span> &#125;&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="6-遍历一个对象"><a href="#6-遍历一个对象" class="headerlink" title="6.遍历一个对象"></a>6.遍历一个对象</h3><p>到目前为止，我们只真正看过使用 v-for 遍历数组，但是我们可以轻松地遍历对象的键值对。     </p><p>与访问元素的索引类似，我们必须向循环中添加另一个值。如果我们用一个参数遍历一个对象，我们将遍历所有的项。     </p><p>如果我们添加另一个参数，我们将获得items 和 key，如果添加第三个，我们还可以访问 v-for 循环的索引。     </p><p>假设我们要遍历产品中的每个媒体资源。  </p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&#x27;(products, index) in products&#x27;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&#x27;product._id&#x27;</span> &gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&#x27;(item, key, index) in product&#x27;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&#x27;key&#x27;</span>&gt;</span></span><br><span class="xml">      </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item</span> &#125;&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>引用文章<br><a href="https://juejin.cn/post/6844904121825230856#heading-0">在Vue.js中编写更好的v-for循环的6种技巧</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue去哪儿项目&amp;城市选择页面&amp;动态数据渲染</title>
    <link href="/2021/05/04/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%BA%94)/"/>
    <url>/2021/05/04/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%BA%94)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="城市选择页面路由配置"><a href="#城市选择页面路由配置" class="headerlink" title="城市选择页面路由配置"></a>城市选择页面路由配置</h3><p><img src="/image1/22.png" alt="城市页面路由配置"></p><ol><li>页面跳转</li></ol><p>src\pages\home\components\Header.vue中 <code>router-link to=&quot;/city&quot;</code>实现点击右上角页面跳转</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/city&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header-right&quot;</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">this.city</span> &#125;&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont  arrow-cron&quot;</span>&gt;</span><span class="hljs-symbol">&amp;#xe64a;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这里router-link会使字体颜色发生变化，这是因为router-link在div外层加了个a标签，我们可以给header-right加一个颜色color:#fff</p><ol start="2"><li>src\pages\city\components\Header.vue代码实现</li></ol><p><img src="/image1/23.png" alt="城市页面Header实现代码"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><br>    城市选择<br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont header-back&quot;</span>&gt;</span><span class="hljs-symbol">&amp;#xe624;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;CityHeader&quot;</span></span><br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;stylus&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="css"><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;~styles/varibles.styl&#x27;</span>;</span><br>.header<br><span class="css">   <span class="hljs-attribute">position</span>: relative</span><br><span class="css">   <span class="hljs-attribute">overflow</span> :hidden</span><br><span class="css">   <span class="hljs-attribute">height</span>: $headerHeight</span><br><span class="css">   <span class="hljs-attribute">line-height</span> :$headerHeight</span><br><span class="css">   <span class="hljs-attribute">text-align</span>:center</span><br><span class="css">   <span class="hljs-attribute">color</span>:<span class="hljs-number">#fff</span></span><br><span class="css">   <span class="hljs-attribute">background</span> :$bgColor</span><br><span class="css">   <span class="hljs-attribute">font-size</span>:.<span class="hljs-number">32rem</span></span><br>   .header-back<br><span class="css">       <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span></span><br><span class="css">       <span class="hljs-attribute">left</span>:<span class="hljs-number">0</span></span><br><span class="css">       <span class="hljs-attribute">position</span>:absolute</span><br><span class="css">       <span class="hljs-attribute">width</span> <span class="hljs-number">0.64rem</span></span><br><span class="css">       <span class="hljs-attribute">text-align</span>:center</span><br><span class="css">       <span class="hljs-attribute">font-size</span> :.<span class="hljs-number">4rem</span></span><br><span class="css">       <span class="hljs-attribute">color</span>:<span class="hljs-number">#fff</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ol start="3"><li>src\pages\city\City.vue引入使用上面的组件</li></ol><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">city-header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">city-header</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">import CityHeader from &quot;./components/Header&quot;;</span><br><span class="xml">export default </span><span class="xquery">&#123;</span><br><span class="xquery"> <span class="hljs-built_in"> name</span>: <span class="hljs-string">&quot;City&quot;</span>,</span><br><span class="xquery">  components: &#123;</span><br><span class="xquery">    CityHeader,</span><br><span class="xquery">  &#125;</span><span class="xml">,</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="搜索框布局"><a href="#搜索框布局" class="headerlink" title="搜索框布局"></a>搜索框布局</h3><p><img src="/image1/24.png" alt="城市页面搜索框样式"></p><p>src\pages\city\components\Search.vue代码实现</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">template</span>&gt;<br>&lt;div <span class="hljs-keyword">class</span>=&quot;search&quot;&gt;<br>    &lt;<span class="hljs-keyword">input</span><br>    v-model=&quot;keyword&quot;<br>    <span class="hljs-keyword">class</span>=&quot;search-input&quot;<br>    <span class="hljs-keyword">type</span>=&quot;text&quot;<br>    placeholder=&quot;输入城市名或拼音&quot;<br>    /&gt;<br>&lt;/<span class="hljs-keyword">template</span>&gt;<br>&lt;script&gt;<br>export <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-type">name</span>: &quot;CitySearch&quot;,<br>&#125;&lt;/script&gt;<br>&lt;style lang=&quot;stylus&quot; scoped&gt;<br>@<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;~styles/varibles.styl&#x27;</span>;<br>    .<span class="hljs-keyword">search</span><br>       height:<span class="hljs-number">0.72</span>rem<br>       padding:<span class="hljs-number">0</span>  <span class="hljs-number">.1</span>rem<br>       background:$bgColor<br>       .<span class="hljs-keyword">search</span>-<span class="hljs-keyword">input</span><br>           <span class="hljs-type">box</span>-sizing:border-<span class="hljs-type">box</span><br>           width :<span class="hljs-number">100</span>%<br>           height: <span class="hljs-number">0.62</span>rem<br>           padding:<span class="hljs-number">0</span> <span class="hljs-number">.1</span>rem<br>           <span class="hljs-type">line</span>-height :<span class="hljs-number">.62</span>rem<br>           <span class="hljs-type">text</span>-align :center<br>           border-radius: <span class="hljs-number">0.06</span>rem<br>           color:#<span class="hljs-number">666</span><br>      .<span class="hljs-keyword">search</span>-content<br>          z-<span class="hljs-keyword">index</span>:<span class="hljs-number">1</span><br>          overflow :hidden<br>          position:absolute<br>          top: <span class="hljs-number">1.58</span>rem<br>          right:<span class="hljs-number">0</span><br>          left:<span class="hljs-number">0</span><br>          bottom:<span class="hljs-number">0</span><br>          background:#eee<br>          .<span class="hljs-keyword">search</span>-item<br>            <span class="hljs-type">line</span>-height :<span class="hljs-number">.62</span>rem<br>            padding-left :<span class="hljs-number">.2</span>rem<br>            color:#<span class="hljs-number">666</span><br>            background:#fff<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h3 id="列表布局"><a href="#列表布局" class="headerlink" title="列表布局"></a>列表布局</h3><p><img src="/image1/25.png" alt="城市列表"></p><p>部分代码样式：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;template&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span>&gt;<br>      &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;area&quot;</span>&gt;<br>        &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;title  border-topbottom&quot;</span>&gt;当前城市&lt;/<span class="hljs-keyword">div</span>&gt;<br>        &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;buttom-list&quot;</span>&gt;<br>          &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;buttom-wrapper&quot;</span>&gt;<br>            &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;北京&lt;/<span class="hljs-keyword">div</span>&gt;<br>          &lt;/<span class="hljs-keyword">div</span>&gt;<br>        &lt;/<span class="hljs-keyword">div</span>&gt;<br>      &lt;/<span class="hljs-keyword">div</span>&gt;<br>      &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;area&quot;</span>&gt;<br>        &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;title  border-topbottom&quot;</span>&gt;热门城市&lt;/<span class="hljs-keyword">div</span>&gt;<br>        &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;buttom-list&quot;</span>&gt;<br>          &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;buttom-wrapper&quot;</span> v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;item of hot&quot;</span> :key=<span class="hljs-string">&quot;item.id&quot;</span>&gt;<br>            &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;&#123;&#123; <span class="hljs-built_in">item</span>.<span class="hljs-built_in">name</span> &#125;&#125;&lt;/<span class="hljs-keyword">div</span>&gt;<br>          &lt;/<span class="hljs-keyword">div</span>&gt;<br>        &lt;/<span class="hljs-keyword">div</span>&gt;<br>      &lt;/<span class="hljs-keyword">div</span>&gt;<br>      &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;area&quot;</span> v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(item, key) of cities&quot;</span> :key=<span class="hljs-string">&quot;key&quot;</span> :<span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;key&quot;</span>&gt;<br>        &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;title   border-topbottom&quot;</span>&gt;&#123;&#123; key &#125;&#125;&lt;/<span class="hljs-keyword">div</span>&gt;<br>        &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item-list&quot;</span>&gt;<br>          &lt;<span class="hljs-keyword">div</span><br>            <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item  border-bottom&quot;</span><br>            v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;innerItem of item&quot;</span><br>            :key=<span class="hljs-string">&quot;innerItem.id&quot;</span><br>          &gt;<br>            &#123;&#123; innerItem.<span class="hljs-built_in">name</span> &#125;&#125;<br>          &lt;/<span class="hljs-keyword">div</span>&gt;<br>        &lt;/<span class="hljs-keyword">div</span>&gt;<br>      &lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/template&gt;<br><br>&lt;style lang=<span class="hljs-string">&quot;stylus&quot;</span> scoped&gt;<br>@import &#x27;~styles/varibles.styl&#x27;;<br>.header<br>  display:flex<br>  line-height: $headerHeight<br>  background: $bgColor<br>  color: <span class="hljs-comment">#fff</span><br>  .header-left<br>    width <span class="hljs-number">.64</span>rem<br>    float:left<br>    .<span class="hljs-keyword">back</span>-icon<br>      <span class="hljs-built_in">text</span>-align:center<br>      font-size:<span class="hljs-number">.4</span>rem<br>  .header-input<br>     flex:<span class="hljs-number">1</span><br>     line-height:<span class="hljs-number">.64</span>rem<br>     height: <span class="hljs-number">.64</span>rem<br>     margin-top: <span class="hljs-number">.12</span>rem<br>     margin-left: <span class="hljs-number">.2</span>rem<br>     padding-left:<span class="hljs-number">.2</span>rem<br>     background: <span class="hljs-comment">#fff</span><br>     border-radius: <span class="hljs-number">.1</span>rem<br>     color:<span class="hljs-comment">#ccc</span><br>  .header-right<br>     width: <span class="hljs-number">1.24</span>rem<br>     float:right<br>     <span class="hljs-built_in">text</span>-align:center<br>     color:<span class="hljs-comment">#fff</span><br>     .arrow-icon<br>       margin-left :<span class="hljs-number">-.04</span>rem<br>       font-size :<span class="hljs-number">.24</span>rem<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><p><img src="/image1/25.png" alt="城市列表"></p><h3 id="Better-scroll的使用及字母表布局"><a href="#Better-scroll的使用及字母表布局" class="headerlink" title="Better-scroll的使用及字母表布局"></a>Better-scroll的使用及字母表布局</h3><p>问题：列表布局中.list加了一个绝对定位和overflow:hidden这会导致页面是无法拖动的</p><p>解决：我们可以使用一个第三方的包Better-scroll</p><p><a href="https://github.com/ustbhuangyi/better-scroll">Github地址</a></p><ol><li>安装</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">npm install better-<span class="hljs-keyword">scroll</span> --<span class="hljs-keyword">save</span><br></code></pre></td></tr></table></figure><ol start="2"><li>使用(符合这个dom结构)</li></ol><p>BetterScroll的最常见应用场景是列表滚动。让我们看看它的HTML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    ...<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- you can put some other DOMs here, it won&#x27;t affect the scrolling</span><br><span class="hljs-comment">&lt;/div&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>具体使用</li></ol><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> Bscroll <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;better-scroll&quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;div <span class="hljs-keyword">class</span>=&quot;list&quot; <span class="hljs-keyword">ref</span>=&quot;wrapper&quot;&gt;  //<span class="hljs-keyword">ref</span>帮助我们获取该dom元素<br><br> //生命周期函数，载入后<br>  mounted() &#123;<br>  this.scroll = <span class="hljs-built_in">new</span> Bscroll(this.$refs.<span class="hljs-keyword">wrapper</span>);<br>&#125;,<br></code></pre></td></tr></table></figure><ol start="4"><li>效果：上拉与下拉能够实现，并且有弹性动画效果，非常流畅</li></ol><h4 id="字母表布局"><a href="#字母表布局" class="headerlink" title="字母表布局"></a>字母表布局</h4><p><img src="/image1/26.png" alt="右侧字母表布局"></p><ol><li>创建组件src\pages\city\components\Alphabet.vue</li></ol><p>部分代码样式</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>  &gt;</span></span><br><span class="xml">      </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item</span> &#125;&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">export default &#123;</span><br><span class="xml">  name: &quot;CityAlphabet&quot;,</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;stylus&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="xml">@import &#x27;~styles/varibles.styl&#x27;;</span><br><span class="xml">    .list</span><br><span class="xml">        display:flex</span><br><span class="xml">        flex-direction :column</span><br><span class="xml">        justify-content :center</span><br><span class="xml">        position:absolute</span><br><span class="xml">        top 1.58rem</span><br><span class="xml">        right 0</span><br><span class="xml">        bottom:0</span><br><span class="xml">        width 0.4rem</span><br><span class="xml">        .item</span><br><span class="xml">            text-align:center</span><br><span class="xml">            line-height :.4rem</span><br><span class="xml">            color:$bgColor</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="城市列表页面动态数据渲染"><a href="#城市列表页面动态数据渲染" class="headerlink" title="城市列表页面动态数据渲染"></a>城市列表页面动态数据渲染</h3><p>利用ajax获取数据</p><ol><li>准备好的本地模拟数据</li></ol><p><img src="/image1/27.png" alt="数据"></p><ol start="2"><li>ajax请求一般我们会放在最外层组件中获取，这样一次就能够获取到所有组件需要的内容</li></ol><p>src\pages\city\City.vue这里我们在City.vue中发送</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">city-header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">city-header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">city-search</span> <span class="hljs-attr">:cities</span>=<span class="hljs-string">&quot;cities&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">city-search</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">city-list</span> <span class="hljs-attr">:cities</span>=<span class="hljs-string">&quot;cities&quot;</span> <span class="hljs-attr">:hot</span>=<span class="hljs-string">&quot;hotCities&quot;</span> <span class="hljs-attr">:letter</span>=<span class="hljs-string">&quot;letter&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">city-list</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">city-alphabet</span> <span class="hljs-attr">:cities</span>=<span class="hljs-string">&quot;cities&quot;</span> @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;handLetterChange&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">city-alphabet</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> CityHeader <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Header&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> CitySearch <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Search&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> CityList <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/List&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> CityAlphabet <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Alphabet&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;City&quot;</span>,</span><br>  components: &#123;<br>    CityHeader,<br>    CitySearch,<br>    CityList,<br>    CityAlphabet<br>  &#125;,<br>  methods: &#123;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">getCityInfo</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      axios.get(<span class="hljs-string">&quot;/api/city.json&quot;</span>).then(<span class="hljs-built_in">this</span>.handleGetCityIngoSucc);</span><br>    &#125;,<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">handleGetCityIngoSucc</span>(<span class="hljs-params">res</span>)</span> &#123;</span><br>      res = res.data;<br>      if (res.ret &amp;&amp; res.data) &#123;<br><span class="javascript">        <span class="hljs-keyword">const</span> data = res.data;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.cities = data.cities;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.hotCities = data.hotCities;</span><br>      &#125;<br>    &#125;,<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">handLetterChange</span>(<span class="hljs-params">letter</span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-comment">// console.log(letter);</span></span><br><span class="javascript">      <span class="hljs-built_in">this</span>.letter = letter;</span><br>    &#125;<br>  &#125;,<br><span class="javascript">  <span class="hljs-comment">// 存放数据</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br>      cities: &#123;&#125;,<br>      hotCities: [],<br><span class="javascript">      letter: <span class="hljs-string">&quot;&quot;</span></span><br>    &#125;;<br>  &#125;,<br><span class="javascript">  <span class="hljs-comment">// 生命周期函数</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">this</span>.getCityInfo();</span><br>  &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>父组件向子组件传数据</li></ol><p>例：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">&lt;city-list <span class="hljs-symbol">:cities=<span class="hljs-string">&quot;cities&quot;</span></span> <span class="hljs-symbol">:hot=<span class="hljs-string">&quot;hotCities&quot;</span></span> <span class="hljs-symbol">:letter=<span class="hljs-string">&quot;letter&quot;</span>&gt;&lt;/city-list&gt;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>子组件通过props接收</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts">export <span class="hljs-class">default </span>&#123;<br><span class="hljs-symbol">  name:</span> <span class="hljs-string">&quot;CityList&quot;</span>,<br><span class="hljs-symbol">  props:</span> &#123;<br><span class="hljs-symbol">    hot:</span> Array,<br><span class="hljs-symbol">    cities:</span> Object,<br><span class="hljs-symbol">    letter:</span> String<br>  &#125;,<br></code></pre></td></tr></table></figure><ol start="5"><li>v-for渲染数据</li></ol><p>循环数组</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;buttom-wrapper&quot;</span> v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;item of hot&quot;</span> :key=<span class="hljs-string">&quot;item.id&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;&#123;&#123; <span class="hljs-built_in">item</span>.<span class="hljs-built_in">name</span> &#125;&#125;&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>循环对象(这里我们使用了二次循环)</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;area&quot;</span> v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(item, key) of cities&quot;</span> :key=<span class="hljs-string">&quot;key&quot;</span> :<span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;key&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;title   border-topbottom&quot;</span>&gt;&#123;&#123; key &#125;&#125;&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item-list&quot;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span><br>      <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item  border-bottom&quot;</span><br>      v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;innerItem of item&quot;</span><br>      :key=<span class="hljs-string">&quot;innerItem.id&quot;</span><br>    &gt;<br>      &#123;&#123; innerItem.<span class="hljs-built_in">name</span> &#125;&#125;<br>    &lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br>      &lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue去哪儿项目&amp;Ajax获取首页数据</title>
    <link href="/2021/05/03/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E5%9B%9B)/"/>
    <url>/2021/05/03/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E5%9B%9B)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="Ajax获取首页数据–axios"><a href="#Ajax获取首页数据–axios" class="headerlink" title="Ajax获取首页数据–axios"></a>Ajax获取首页数据–axios</h3><ol><li>项目安装axios </li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm  install  axios <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>分析：首页由5个组件组成，每一个组件都有自己的数据，那么每个组件都发送一个ajax请求。如果这样做首页就会发送5个ajax请求，网站的性能会很低。</p><p>解决：Home.vue组件中发送ajax是最好的选择，这个组件获取ajax请求的数据传给每个子组件中，只用请求一次。</p><ol start="2"><li>引入axios</li></ol><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>使用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//&#x27;/static/mock/index.json&#x27;</span><br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">getHomeInfo</span>(<span class="hljs-params"></span>)</span> &#123;<br>      axios.get(<span class="hljs-string">&quot;/api/index.json&quot;</span>).then(<span class="hljs-built_in">this</span>.getHomeInfoSucc);<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">//mounted (载入后) 在el 被新创建的 vm.$el替换，并挂载到实例上去之后调用</span><br>  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.getHomeInfo();<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里我们的使用的是本地模拟的数据json文件,开发环境中使用转发机制</p><p>vue中提供了一个代理功能</p><p><img src="/image1/20.png" alt="代理"></p><p>index.json</p><p><img src="/image1/21.png" alt="本地json文件"></p><h3 id="首页父子组件数据传递"><a href="#首页父子组件数据传递" class="headerlink" title="首页父子组件数据传递"></a>首页父子组件数据传递</h3><p>Home.vue</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">home-header</span> <span class="hljs-attr">:city</span>=<span class="hljs-string">&quot;city&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">home-header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">home-swiper</span> <span class="hljs-attr">:list</span>=<span class="hljs-string">&quot;swiperList&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">home-swiper</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">home-icons</span> <span class="hljs-attr">:list</span>=<span class="hljs-string">&quot;iconList&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">home-icons</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">home-recommend</span> <span class="hljs-attr">:list</span>=<span class="hljs-string">&quot;recommendList&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">home-recommend</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">home-weekend</span> <span class="hljs-attr">:list</span>=<span class="hljs-string">&quot;weekendList&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">home-weekend</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> HomeHeader <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Header&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> HomeSwiper <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Swiper&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> HomeIcons <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Icons&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> HomeRecommend <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Recommend&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> HomeWeekend <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Weekend&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;Home&quot;</span>,</span><br>  components: &#123;<br>    HomeHeader,<br>    HomeSwiper,<br>    HomeIcons,<br>    HomeRecommend,<br>    HomeWeekend<br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      city: <span class="hljs-string">&quot;&quot;</span>,</span><br>      swiperList: [],<br>      iconList: [],<br>      recommendList: [],<br>      weekendList: []<br>    &#125;;<br>  &#125;,<br>  methods: &#123;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">getHomeInfo</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      axios.get(<span class="hljs-string">&quot;/api/index.json&quot;</span>).then(<span class="hljs-built_in">this</span>.getHomeInfoSucc);</span><br>    &#125;,<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">getHomeInfoSucc</span>(<span class="hljs-params">res</span>)</span> &#123;</span><br>      res = res.data;<br>      if (res.ret &amp;&amp; res.data) &#123;<br><span class="javascript">        <span class="hljs-keyword">const</span> data = res.data;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.city = res.data.city;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.swiperList = data.swiperList;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.iconList = data.iconList;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.recommendList = data.recommendList;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.weekendList = data.weekendList;</span><br>      &#125;<br>    &#125;<br>  &#125;,<br><span class="javascript">  <span class="hljs-comment">//mounted (载入后) 在el 被新创建的 vm.$el替换，并挂载到实例上去之后调用</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">this</span>.getHomeInfo();</span><br>  &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>父组件给子组件传值<br>使用props，父组件可以使用props向子组件传递数据。</p><ol><li>Swiper.vue中小问题</li></ol><p>默认显示的是最后一页的图片</p><p>分析：当页面还没接收数据的时候，也就是还没接收ajax获取的Array数组时，这时候接收的是外面获取的空数组。<br>解决</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;swiper :<span class="hljs-attribute">options</span>=<span class="hljs-string">&quot;swiperOptions&quot;</span> <span class="hljs-attribute">v-if</span>=<span class="hljs-string">&quot;showSwiper&quot;</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;HomeSwiper&quot;</span>,</span><br>  props: &#123;<br><span class="javascript">    list: <span class="hljs-built_in">Array</span></span><br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br>      swiperOptions: &#123;<br><span class="javascript">        pagination: <span class="hljs-string">&quot;.swiper-pagination&quot;</span>,</span><br><span class="javascript">        loop: <span class="hljs-literal">true</span> <span class="hljs-comment">//能够循环滑动，false只能滑倒最后，或最前</span></span><br>      &#125;<br>    &#125;;<br>  &#125;,<br>  computed: &#123;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">showSwiper</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.list.length;</span><br>    &#125;<br>  &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue去哪儿项目首页开发&amp;首页轮播图&amp;推荐组件开发</title>
    <link href="/2021/05/02/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%B8%89)/"/>
    <url>/2021/05/02/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="首页轮播图"><a href="#首页轮播图" class="headerlink" title="首页轮播图"></a>首页轮播图</h3><ol><li>第三方轮播插件使用</li></ol><p>Github地址<br><a href="https://github.com/surmon-china/vue-awesome-swiper">vue-awesome-swiper</a></p><p>安装：项目文件夹路径中,这里我们安装的是@2.6.7版本，其他版本可能兼容性等问题</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> install swiper vue-awesome-swiper@<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">7</span> --save<br></code></pre></td></tr></table></figure><ol start="2"><li>引用(这里我们引用到全局中，因为各个页面可能都会使用)</li></ol><p>main.js</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> Vue from &#x27;vue&#x27;<br><span class="hljs-keyword">import</span> VueAwesomeSwiper from &#x27;vue-awesome-swiper&#x27;<br><br>//这里我们使用这个版本<br>// <span class="hljs-keyword">import</span> style (&gt;= <span class="hljs-type">Swiper</span> 6.<span class="hljs-title">x</span>)<br><span class="hljs-keyword">import</span> &#x27;swiper/swiper-bundle.css&#x27;<br><br>// <span class="hljs-keyword">import</span> style (&lt;= <span class="hljs-type">Swiper</span> 5.<span class="hljs-title">x</span>)<br><span class="hljs-keyword">import</span> &#x27;swiper/css/swiper.css&#x27;<br><br><span class="hljs-type">Vue</span>.use(<span class="hljs-type">VueAwesomeSwiper</span>, /* &#123; <span class="hljs-keyword">default</span> options with global component &#125; */)<br></code></pre></td></tr></table></figure><ol start="3"><li>使用</li></ol><p>Swiper.vue</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">template</span>&gt;<br>  &lt;div <span class="hljs-keyword">class</span>=&quot;wrapper&quot;&gt;<br>    &lt;swiper :<span class="hljs-keyword">options</span>=&quot;swiperOptions&quot; v-<span class="hljs-keyword">if</span>=&quot;showSwiper&quot;&gt;<br>      &lt;swiper-slide v-<span class="hljs-keyword">for</span>=&quot;item of list&quot; :key=&quot;item.id&quot;&gt;<br>        &lt;img <span class="hljs-keyword">class</span>=&quot;swiper-img&quot; :src=&quot;item.imgUrl&quot; alt=&quot;&quot; /&gt;<br>      &lt;/swiper-slide&gt;<br><br>      &lt;div <span class="hljs-keyword">class</span>=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt;<br>    &lt;/swiper&gt;<br>  &lt;/div&gt;<br>&lt;/<span class="hljs-keyword">template</span>&gt;<br>&lt;script&gt;<br>export <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-type">name</span>: &quot;HomeSwiper&quot;,<br>  props: &#123;<br>    list: <span class="hljs-keyword">Array</span><br>  &#125;,<br>  data() &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      swiperOptions: &#123;<br>        pagination: &quot;.swiper-pagination&quot;,<br>        <span class="hljs-keyword">loop</span>: <span class="hljs-keyword">true</span><br>      &#125;<br>    &#125;;<br>  &#125;,<br>  computed: &#123;<br>    showSwiper() &#123;<br>      <span class="hljs-keyword">return</span> this.list.length;<br>    &#125;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;stylus&quot; scoped&gt;<br>// 样式穿透，不受scoped控制了<br>.<span class="hljs-keyword">wrapper</span> &gt;&gt;&gt; .swiper-pagination-bullet-active<br>    background:#fff<br>.<span class="hljs-keyword">wrapper</span><br>    overflow hidden<br>    width:<span class="hljs-number">100</span>%<br>    height:<span class="hljs-number">0</span><br>    padding-bottom :<span class="hljs-number">31.25</span>%<br>    background  :#eee<br>    .swiper-img<br>        width:<span class="hljs-number">100</span>%<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><h4 id="占位"><a href="#占位" class="headerlink" title="占位"></a>占位</h4><p>图片是可替代资源，在页面显然时，会先将页面中静态的内容渲染上去，等数据返回后，在进行重新渲染，这样页面就会出现抖动，影响用户体验，同时性能也比较低。</p><p>可以用下面的css代码对这些可替换资源先进行占位，页面大体框架在第一次渲染后就能呈现给用户，数据获取到后，替换相应的内容就可，就不会出现抖动了。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.<span class="hljs-attribute">icon</span>-img<br>    <span class="hljs-attribute">overflow</span>: hidden<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span><br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span><br>    <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">100%</span><br></code></pre></td></tr></table></figure><p><img src="/image1/15.png" alt="样式，可以滑动"></p><h3 id="图标区域页面布局"><a href="#图标区域页面布局" class="headerlink" title="图标区域页面布局"></a>图标区域页面布局</h3><p>新建一个组件<br>src\pages\home\components\Icons.vue</p><p>在Home.vue中引入并使用</p><p>icons.vue代码</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icons&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">swiper</span> <span class="hljs-attr">:options</span>=<span class="hljs-string">&quot;swiperOptions&quot;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">swiper-slide</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(page, index) of pages&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item of page&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon-img&quot;</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon-img-content&quot;</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">&quot;item.imgUrl&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon-desc&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.desc</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">swiper-slide</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">swiper</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">export default &#123;</span><br><span class="xml">  name: &quot;HomeIcons&quot;,</span><br><span class="xml">  props: &#123;</span><br><span class="xml">    list: Array</span><br><span class="xml">  &#125;,</span><br><span class="xml">  data() &#123;</span><br><span class="xml">    return &#123;</span><br><span class="xml">      swiperOptions: &#123;</span><br><span class="xml">        autoplay: false</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;;</span><br><span class="xml">  &#125;,</span><br><span class="xml">  computed: &#123;</span><br><span class="xml">    pages() &#123;</span><br><span class="xml">      const pages = [];</span><br><span class="xml">      this.list.forEach((item, index) =&gt; &#123;</span><br><span class="xml">        const page = Math.floor(index / 8);</span><br><span class="xml">        if (!pages[page]) &#123;</span><br><span class="xml">          pages[page] = [];</span><br><span class="xml">        &#125;</span><br><span class="xml">        pages[page].push(item);</span><br><span class="xml">      &#125;);</span><br><span class="xml">      return pages;</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;stylus&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="xml">@import &#x27;~styles/varibles.styl&#x27;;</span><br><span class="xml">@import &#x27;~styles/mixins.styl&#x27;;</span><br><span class="xml">.icons  &gt;&gt;&gt; .swiper-container</span><br><span class="xml">  width:100%</span><br><span class="xml">  height:0</span><br><span class="xml">  padding-bottom:50%</span><br><span class="xml">.icons</span><br><span class="xml">  margin-top:.1rem</span><br><span class="xml">  .icon</span><br><span class="xml">    position :relative</span><br><span class="xml">    overflow :hidden</span><br><span class="xml">    float:left</span><br><span class="xml">    width:25%</span><br><span class="xml">    height:0</span><br><span class="xml">    padding-bottom :25%</span><br><span class="xml">    .icon-img</span><br><span class="xml">        position:absolute</span><br><span class="xml">        top:0</span><br><span class="xml">        left:0</span><br><span class="xml">        right:0</span><br><span class="xml">        bottom:.44rem</span><br><span class="xml">        box-sizing:border-box</span><br><span class="xml">        padding:.1rem</span><br><span class="xml">        .icon-img-content</span><br><span class="xml">            display:block</span><br><span class="xml">            margin 0 auto</span><br><span class="xml">            height:100%</span><br><span class="xml">    .icon-desc</span><br><span class="xml">       position :absolute</span><br><span class="xml">       left:0</span><br><span class="xml">       right:0</span><br><span class="xml">       bottom:0</span><br><span class="xml">       height:.44rem</span><br><span class="xml">       line-height :.44rem</span><br><span class="xml">       color:#darkTextColor</span><br><span class="xml">       text-align :center</span><br><span class="xml">       ellipsis()</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><p><img src="/image1/17.png" alt="效果"></p><p>文字太长后面文字用….表示的Css样式</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">overflow :hidden <br>white-space :nowrap <br>text-overflow :ellipsis<br></code></pre></td></tr></table></figure><p>由于这个样式很多地方都会用到，所以我们可以借助stylus的mixins.styl将它封装.</p><p><img src="/image1/16.png" alt="封装"></p><p>使用：</p><p>导入</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;~styles/mixins.styl&#x27;</span>;<br></code></pre></td></tr></table></figure><p>css中使用</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl">.icon-<span class="hljs-variable">desc</span><br>   <span class="hljs-function"><span class="hljs-title">ellipsis</span>()</span><br></code></pre></td></tr></table></figure><h3 id="推荐组件开发"><a href="#推荐组件开发" class="headerlink" title="推荐组件开发"></a>推荐组件开发</h3><p><img src="/image1/18.png" alt="效果"></p><p>新建一个组件<br>src\pages\home\components\Recommend.vue</p><p>在Home.vue中引入并使用</p><p>Recommend.vue代码</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span></span><br><span class="xml">      热销推荐</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item  border-bottom&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item of list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-img&quot;</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;item.imgUrl&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span></span><br><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-info&quot;</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-title&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.title</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-desc&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.desc</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-button&quot;</span>&gt;</span>查看详情<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">export default &#123;</span><br><span class="xml">  name: &quot;HomeRecommend&quot;,</span><br><span class="xml">  props: &#123;</span><br><span class="xml">    list: Array</span><br><span class="xml">  &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;stylus&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="xml">@import &#x27;~styles/mixins.styl&#x27;;</span><br><span class="xml">.title</span><br><span class="xml">    margin-top :.2rem</span><br><span class="xml">    line-height :.8rem</span><br><span class="xml">    background:#eee</span><br><span class="xml">    text-indent:.2rem</span><br><span class="xml">.item</span><br><span class="xml">    overflow: hidden</span><br><span class="xml">    display:flex</span><br><span class="xml">    height :1.9rem</span><br><span class="xml">    .item-img</span><br><span class="xml">       width 1.7rem</span><br><span class="xml">       height 1.7rem</span><br><span class="xml">       padding:.1rem</span><br><span class="xml">    .item-info</span><br><span class="xml">        flex:1</span><br><span class="xml">        padding:.1rem</span><br><span class="xml">        min-width:0</span><br><span class="xml">        .item-title</span><br><span class="xml">            line-height :.54rem</span><br><span class="xml">            font-size :.32rem</span><br><span class="xml">            ellipsis()</span><br><span class="xml">        .item-desc</span><br><span class="xml">            line-height :.4rem</span><br><span class="xml">            color:#ccc</span><br><span class="xml">            ellipsis()</span><br><span class="xml">        .item-button</span><br><span class="xml">            line-height :.44rem</span><br><span class="xml">            margin-top:.16rem</span><br><span class="xml">            background #ff9300</span><br><span class="xml">            padding:0 .2rem</span><br><span class="xml">            border radius 0.06rem</span><br><span class="xml">            color:#fff</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><h3 id="周末游组件开发"><a href="#周末游组件开发" class="headerlink" title="周末游组件开发"></a>周末游组件开发</h3><p><img src="/image1/19.png" alt="效果"></p><p>新建一个组件<br>src\pages\home\components\Weekend.vue</p><p>在Home.vue中引入并使用</p><p>Weekend.vue代码</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span></span><br><span class="xml">      周末去哪儿</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item  border-bottom&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item of list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-img-warpper&quot;</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-img&quot;</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;item.imgUrl&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-info&quot;</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-title&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.title</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-desc&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.desc</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">export default &#123;</span><br><span class="xml">  name: &quot;HomeWeekend&quot;,</span><br><span class="xml">  props: &#123;</span><br><span class="xml">    list: Array</span><br><span class="xml">  &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;stylus&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="xml">@import &#x27;~styles/mixins.styl&#x27;;</span><br><span class="xml">.title</span><br><span class="xml">    line-height :.8rem</span><br><span class="xml">    background:#eee</span><br><span class="xml">    text-indent:.2rem</span><br><span class="xml">.item-img-warpper</span><br><span class="xml">    overflow:hidden</span><br><span class="xml">    height:0</span><br><span class="xml">    padding-bottom :37.9%</span><br><span class="xml">.item-img</span><br><span class="xml">    width 100%</span><br><span class="xml">.item-info</span><br><span class="xml">    padding:.1rem</span><br><span class="xml">    .item-title</span><br><span class="xml">        line-height :.54rem</span><br><span class="xml">        font-size :.32rem</span><br><span class="xml">        ellipsis()</span><br><span class="xml">    .item-desc</span><br><span class="xml">        line-height :.4rem</span><br><span class="xml">        color:#ccc</span><br><span class="xml">        ellipsis()</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue去哪儿项目首页开发&amp;首页header区域</title>
    <link href="/2021/05/02/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%BA%8C)/"/>
    <url>/2021/05/02/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="首页header区域"><a href="#首页header区域" class="headerlink" title="首页header区域"></a>首页header区域</h3><ol><li>安装开发依赖包(项目目录下)<br>stylus：CSS的预处理框架，即将stylus转换为css使用<br>stylus-loader：让webpack理解stylus<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm  install  stylus <span class="hljs-comment">--save</span><br>npm  install  stylus-loader  <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure></li></ol><p>参考使用文章：<br><a href="https://juejin.cn/post/6844903696409722894">『前端干货篇』：你不知道的Stylus</a><br><a href="www.zhangxinxu.com/jq/stylus/">张鑫旭大大的Stylus文章</a></p><p>使用过程中报错：npm run dev后报错<br>Vue中使用Stylus报错：Module build failed: TypeError: this.getOptions is not a function</p><p>报错原因<br>stylus-loader版本过高，更改为<a href="mailto:&#x73;&#x74;&#121;&#x6c;&#117;&#x73;&#x2d;&#108;&#111;&#97;&#100;&#x65;&#114;&#64;&#51;&#46;&#48;&#x2e;&#49;">&#x73;&#x74;&#121;&#x6c;&#117;&#x73;&#x2d;&#108;&#111;&#97;&#100;&#x65;&#114;&#64;&#51;&#46;&#48;&#x2e;&#49;</a>即可</p><p>再次安装stylus</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm uninstall stylus stylus-loader <span class="hljs-regexp">//</span>删除之前的loader<br>npm install stylus stylus-loader@<span class="hljs-number">3.0</span>.<span class="hljs-number">1</span> --save-dev <span class="hljs-regexp">//</span>再次安装<br></code></pre></td></tr></table></figure><ol start="2"><li>src\pages\home\components路径下新建一个Header.vue</li></ol><p>页面组件化，对于Home这个页面可以被拆分成多个小组件，Header.vue可以放在compons中被使用</p><ol start="3"><li>引入组件使用</li></ol><p><img src="/image1/8.png" alt="使用组件"></p><ol start="4"><li>Header.vue页面样式</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs maxima">&lt;template&gt;<br>  &lt;div class=<span class="hljs-string">&quot;header&quot;</span>&gt;<br>    &lt;div class=<span class="hljs-string">&quot;header-left&quot;</span>&gt;返回&lt;/div&gt;<br>    &lt;div class=<span class="hljs-string">&quot;header-input&quot;</span>&gt;输入城市/景点/游玩/主题&lt;/div&gt;<br>    &lt;div class=<span class="hljs-string">&quot;header-right&quot;</span>&gt;城市&lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  name: <span class="hljs-string">&quot;HomeHeader&quot;</span><br>&#125;;<br>&lt;/script&gt;<br><br>&lt;<span class="hljs-built_in">style</span> lang=<span class="hljs-string">&quot;stylus&quot;</span> scoped&gt;<br>.header<br>  <span class="hljs-built_in">display</span>:flex<br>  line-<span class="hljs-built_in">height</span>: .86<span class="hljs-built_in">rem</span><br>  <span class="hljs-built_in">background</span> #<span class="hljs-number">00bcd4</span><br>  <span class="hljs-built_in">color</span>: #fff<br>  .header-left<br>    <span class="hljs-built_in">width</span> .64<span class="hljs-built_in">rem</span><br>    <span class="hljs-built_in">float</span>:left<br>  .header-input<br>     flex:<span class="hljs-number">1</span><br>     line-<span class="hljs-built_in">height</span>:.64<span class="hljs-built_in">rem</span><br>     <span class="hljs-built_in">height</span>: .64<span class="hljs-built_in">rem</span><br>     margin-top .12<span class="hljs-built_in">rem</span><br>     margin-left: .2<span class="hljs-built_in">rem</span><br>     <span class="hljs-built_in">background</span>: #fff<br>     <span class="hljs-built_in">border</span>-<span class="hljs-built_in">radius</span>: .1<span class="hljs-built_in">rem</span><br>     <span class="hljs-built_in">color</span>:#ccc<br>  .header-right<br>     <span class="hljs-built_in">width</span>: <span class="hljs-number">1.</span>24<span class="hljs-built_in">rem</span><br>     <span class="hljs-built_in">float</span>:right<br>     text-align:<span class="hljs-built_in">center</span><br>&lt;/<span class="hljs-built_in">style</span>&gt;<br><br></code></pre></td></tr></table></figure><p>补充：<code>&lt;style lang=&quot;stylus&quot; scoped&gt;</code><br>我们写的这个组件不要对其他组件产生影响，使用scoped可以限制.header的样式只对当前组件有效，不对其他组件有影响<br>当<code> &lt;style&gt;</code> 标签有 scoped 属性时，它的 CSS 只作用于当前组件中的元素。</p><p>完成效果：</p><p><img src="/image1/9.png" alt="使用组件"></p><h3 id="iconfont的使用和代码优化"><a href="#iconfont的使用和代码优化" class="headerlink" title="iconfont的使用和代码优化"></a>iconfont的使用和代码优化</h3><p><img src="/image1/10.png" alt="iconfont下载使用"></p><ol><li>将以下文件放入项目静态资源中,这里我们修改一下引用路径</li></ol><p><img src="/image1/11.png" alt="资源引入"></p><ol><li>引入iconfont</li></ol><p>由于我们几乎所有页面都要使用iconfont，所以我们可以在main.js中引用</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;styles/iconfont.css&#x27;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>使用，这里的代码是Unicode编码</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont back-icon&quot;</span>&gt;</span><span class="hljs-symbol">&amp;#xe624;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont&quot;</span>&gt;</span><span class="hljs-symbol">&amp;#xe632;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont  arrow-cron&quot;</span>&gt;</span><span class="hljs-symbol">&amp;#xe64a;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>css样式(省略)</p><ol start="4"><li>代码优化</li></ol><p>整个Header背景色都是一个绿色的内容，我们这个网页很多地方都会用到这个背景色，我们可以将这个颜色单独放在一个变量中，然后单独的去引用。未来网站颜色风格需要切换，只需要去改变这一个变量，全局都会改变，这个可维护性会有很大的提升</p><p>解决：</p><p>全局变量文件</p><p><img src="/image1/12.png" alt="全局变量文件"></p><p>引入使用：</p><p><img src="/image1/13.png" alt="引入与使用"></p><ol start="5"><li>引入优化</li></ol><p>起别名：</p><p><img src="/image1/14.png" alt="起别名"></p><p>使用：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;~styles/varibles.styl&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这里我们修改了webpack中的配置项时，一定要重启项目，否者会报错</p>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue去哪儿项目环境搭建</title>
    <link href="/2021/05/01/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%B8%80)/"/>
    <url>/2021/05/01/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="项目环境准备"><a href="#项目环境准备" class="headerlink" title="项目环境准备"></a>项目环境准备</h3><ol><li>安装node</li><li>Gitee创建一个自己的仓库</li></ol><p><img src="/image1/1.png" alt="仓库"></p><ol start="3"><li><p>git ssh本地免密</p></li><li><p>git  clone 项目到本地电脑</p></li><li><p>全局安装vue-cli</p></li></ol><p><img src="/image1/2.png" alt="全局安装"></p><ol start="6"><li>项目初始化</li></ol><p><img src="/image1/3.png" alt="初始化项目"></p><ol start="7"><li>项目启动</li></ol><p>npm  run  dev</p><p><img src="/image1/4.png" alt="启动成功"></p><p>目录结构</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs verilog">readme              <span class="hljs-comment">//项目的说明文件</span><br><span class="hljs-keyword">package</span><span class="hljs-variable">.json</span>         <span class="hljs-comment">//第三方依赖包配置</span><br><span class="hljs-keyword">package</span><span class="hljs-variable">.lock</span><span class="hljs-variable">.json</span>    <span class="hljs-comment">//帮助我们去确定安装的第三方依赖包的具体的版本，保持团队编程的统一</span><br>license             <span class="hljs-comment">//开源协议的说明</span><br>index<span class="hljs-variable">.html</span>          <span class="hljs-comment">//项目默认的首页模版文件</span><br><span class="hljs-variable">.postcssrc</span><span class="hljs-variable">.js</span>        <span class="hljs-comment">//对 postcss 的配置项</span><br><span class="hljs-variable">.gitignore</span>          <span class="hljs-comment">//不需要上传到 git 上的文件管理 </span><br><span class="hljs-variable">.eslintrc</span><span class="hljs-variable">.js</span>        <span class="hljs-comment">//对写的代码检测是否标准做一个检测</span><br><span class="hljs-variable">.eslintignore</span>       <span class="hljs-comment">//配置不需要 eslintrc 检测工具检测的文件</span><br><span class="hljs-variable">.editorconfig</span>       <span class="hljs-comment">//配置编辑器总风格统一的自动化格式的语法</span><br><span class="hljs-variable">.babelrc</span>            <span class="hljs-comment">//项目写的代码是 Vue 的大文件组件的代码的写法，所以需要通过 babel 这种语法解析器做一些语法上的转换，最终转换成浏览器能够编译执行的代码，babel 需要做额外配置时，就放在文件里面</span><br><span class="hljs-keyword">static</span>                  <span class="hljs-comment">//static 目录放的是静态资源，要用到的静态图片啊或者后续需要模拟的 json 数据</span><br>node_modules                 <span class="hljs-comment">//项目中需要用到的第三方 node 包</span><br>src                         <span class="hljs-comment">//放的是项目的源代码</span><br>src/main<span class="hljs-variable">.js</span>                  <span class="hljs-comment">//整个项目的入口文件</span><br>src/app<span class="hljs-variable">.vue</span>                 <span class="hljs-comment">//整个项目最原始的根组件</span><br>src/router/index<span class="hljs-variable">.js</span>          <span class="hljs-comment">//项目的路由放置位置</span><br>src/components               <span class="hljs-comment">//项目中要用到的小组件</span><br>src/assets                  <span class="hljs-comment">//项目中需要用到的图片</span><br><span class="hljs-keyword">config</span>                      <span class="hljs-comment">//放置项目配置文件</span><br><span class="hljs-keyword">config</span>/index<span class="hljs-variable">.js</span>              <span class="hljs-comment">//放基础配置</span><br><span class="hljs-keyword">config</span>/dev<span class="hljs-variable">.ent</span><span class="hljs-variable">.js</span>            <span class="hljs-comment">//开发环境配置信息</span><br><span class="hljs-keyword">config</span>/prod<span class="hljs-variable">.ent</span><span class="hljs-variable">.js</span>           <span class="hljs-comment">//线上环境配置信息</span><br>build                      <span class="hljs-comment">//放置项目打包的 webpack 配置信息，vue-cli 会自动构建</span><br>build/webpack<span class="hljs-variable">.base</span><span class="hljs-variable">.conf</span><span class="hljs-variable">.js</span>   <span class="hljs-comment">//基础的 webpack 配置信息</span><br>build/webpack<span class="hljs-variable">.dev</span><span class="hljs-variable">.conf</span><span class="hljs-variable">.js</span>    <span class="hljs-comment">//开发环境的 webpack 配置信息</span><br>build/webpack<span class="hljs-variable">.prod</span><span class="hljs-variable">.conf</span><span class="hljs-variable">.js</span>   <span class="hljs-comment">//线上环境的 webpack 配置信息</span><br></code></pre></td></tr></table></figure><h3 id="项目代码初始化"><a href="#项目代码初始化" class="headerlink" title="项目代码初始化"></a>项目代码初始化</h3><p>由于做的是webapp，所以需要针对移动端，做相应的准备。</p><ol><li> meta标签相关设置</li></ol><p>项目中的  index.html</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>效果：页面比例始终是1：1，用户通过手指操作缩放是无效的</p><ol start="2"><li>引入reset.css<br>目的：重置页面样式</li></ol><p>因为在不同移动端、不同浏览器上页面的初始样式是不一样的，引入reset.css为了保证在每个浏览器上展示出的初始效果是一样的</p><ol start="3"><li>引入border.css</li></ol><p>目的：解决移动端1像素边框问题  原因，不同手机上显示的像素不同(可能有二倍屏，多倍屏)</p><p>main.js中代码导入</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span>  fastClick  <span class="hljs-keyword">from</span>  <span class="hljs-string">&#x27;fastclick&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./assets/styles/reset.css&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./assets/styles/border.css&#x27;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>项目中安装fastclick</li></ol><p>npm install fastclick –save</p><p>目的：解决移动端300ms延迟问题</p><p>移动端浏览器click事件为什么会有300ms的延迟呢？因为在手机上有个双击方案 —— 在手机上快速点击两下，实现页面放大；再次双击，恢复到原始比例。</p><p>那它是如何实现的呢？浏览器在捕捉到第一次点击事件后，会等待一段时间，如果在这段时间内，用户没有再次进行点击操作的话，就执行单击事件；如果用户进行了第二次点击操作的话，就会执行双击事件。这段等待的时间大约300ms。</p><ol start="5"><li>Iconfont阿里巴巴矢量图标注册账号使用</li></ol><h3 id="单页应用与多页应用"><a href="#单页应用与多页应用" class="headerlink" title="单页应用与多页应用"></a>单页应用与多页应用</h3><p><img src="/image1/5.png" alt="对比"></p><p>本项目页面采用的是单页页面</p><h3 id="项目下方报error解决"><a href="#项目下方报error解决" class="headerlink" title="项目下方报error解决"></a>项目下方报error解决</h3><p>问题：由于esLint校验导致报错或警告</p><p><img src="/image1/6.png" alt="error"></p><p>解决</p><p><img src="/image1/7.png" alt="注释"></p>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue&amp;插槽</title>
    <link href="/2021/05/01/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%BA%94)/"/>
    <url>/2021/05/01/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%BA%94)/</url>
    
    <content type="html"><![CDATA[<p>槽，也就是slot，是组件的一块HTML模板，这块模板显示不显示、以及怎样显示由父组件来决定。 实际上，一个slot最核心的两个问题在这里就点出来了，是显示不显示和怎样显示。</p><p>由于插槽是一块模板，所以，对于任何一个组件，从模板种类的角度来分，其实都可以分为非插槽模板和插槽模板两大类。 非插槽模板指的是html模板，比如‘div、span、ul、table’这些，非插槽模板的显示与隐藏以及怎样显示由组件自身控制；插槽模板是slot，它是一个空壳子，因为它的显示与隐藏以及最后用什么样的html模板显示由父组件控制。但是插槽显示的位置却由子组件自身决定，slot写在组件template的什么位置，父组件传过来的模板将来就显示在什么位置。</p><hr><h3 id="单个插槽-默认插槽-匿名插槽"><a href="#单个插槽-默认插槽-匿名插槽" class="headerlink" title="单个插槽 | 默认插槽 | 匿名插槽"></a>单个插槽 | 默认插槽 | 匿名插槽</h3><p>首先是单个插槽，单个插槽是vue的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置name属性。</p><p>单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（name属性）不同就可以了。</p><p>下面通过一个例子来展示。</p><p>父组件：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;template&gt;<br>    &lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">father</span>&quot;&gt;<br>        &lt;<span class="hljs-symbol">h3</span>&gt;这里是父组件&lt;/<span class="hljs-symbol">h3</span>&gt;<br>        &lt;<span class="hljs-symbol">child</span>&gt;<br>            &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">tmpl</span>&quot;&gt;<br>              &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>              &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>              &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>              &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>              &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">5</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>              &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">6</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>            &lt;/<span class="hljs-symbol">div</span>&gt;<br>        &lt;/<span class="hljs-symbol">child</span>&gt;<br>    &lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;/<span class="hljs-symbol">template</span>&gt;<br></code></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>这里是子组件<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这个例子里，因为父组件在里面写了html模板，那么子组件的匿名插槽这块模板就是下面这样。也就是说，子组件的匿名插槽被使用了，是被下面这块模板使用了。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">tmpl</span>&quot;&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">5</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">6</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>匿名插槽没有name属性，所以是匿名插槽，那么，插槽加了name属性，就变成了具名插槽。具名插槽可以在一个组件中出现N次，出现在不同的位置。下面的例子，就是一个有两个具名插槽和单个插槽的组件，这三个插槽被父组件用同一套css样式显示了出来，不同的是内容上略有区别。</p><p>父组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>这里是父组件<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tmpl&quot;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;up&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单4<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单5<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单6<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tmpl&quot;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;down&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-4<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-5<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-6<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tmpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-&gt;1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-&gt;2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-&gt;3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-&gt;4<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-&gt;5<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-&gt;6<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;template&gt;<br>  &lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">child</span>&quot;&gt;<br>    // 具名插槽<br>    &lt;<span class="hljs-symbol">slot</span> <span class="hljs-symbol">name</span>=&quot;<span class="hljs-symbol">up</span>&quot;&gt;&lt;/<span class="hljs-symbol">slot</span>&gt;<br>    &lt;<span class="hljs-symbol">h3</span>&gt;这里是子组件&lt;/<span class="hljs-symbol">h3</span>&gt;<br>    // 具名插槽<br>    &lt;<span class="hljs-symbol">slot</span> <span class="hljs-symbol">name</span>=&quot;<span class="hljs-symbol">down</span>&quot;&gt;&lt;/<span class="hljs-symbol">slot</span>&gt;<br>    // 匿名插槽<br>    &lt;<span class="hljs-symbol">slot</span>&gt;&lt;/<span class="hljs-symbol">slot</span>&gt;<br>  &lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;/<span class="hljs-symbol">template</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="具名插槽的缩写"><a href="#具名插槽的缩写" class="headerlink" title="具名插槽的缩写"></a>具名插槽的缩写</h4><p>跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header：</p><h3 id="作用域插槽-带数据的插槽"><a href="#作用域插槽-带数据的插槽" class="headerlink" title="作用域插槽 | 带数据的插槽"></a>作用域插槽 | 带数据的插槽</h3><p>最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的template里面写</p><p>匿名插槽</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;slot&gt;</span><span class="hljs-section">&lt;/slot&gt;</span><br></code></pre></td></tr></table></figure><p>具名插槽</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;up&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是作用域插槽要求，在slot上面绑定数据。也就是你得写成大概下面这个样子。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs elixir">&lt;slot name=<span class="hljs-string">&quot;up&quot;</span> <span class="hljs-symbol">:data=<span class="hljs-string">&quot;data&quot;</span>&gt;&lt;/slot&gt;</span><br> export default &#123;<br>    <span class="hljs-symbol">data:</span> function()&#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-symbol">data:</span> [<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-string">&#x27;lisi&#x27;</span>,<span class="hljs-string">&#x27;wanwu&#x27;</span>,<span class="hljs-string">&#x27;zhaoliu&#x27;</span>,<span class="hljs-string">&#x27;tianqi&#x27;</span>,<span class="hljs-string">&#x27;xiaoba&#x27;</span>]<br>      &#125;<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>我们前面说了，插槽最后显示不显示是看父组件有没有在child下面写模板，像下面那样。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;child&gt;</span><br>   <span class="hljs-attribute">html</span>模板<br><span class="hljs-section">&lt;/child&gt;</span><br></code></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://juejin.cn/post/6844903555837493256#heading-0">深入理解vue中的slot与slot-scope</a></p><p><a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue&amp;组件之间的传值通信&amp;props$&amp;$emits&amp;ref/refs</title>
    <link href="/2021/05/01/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/"/>
    <url>/2021/05/01/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="vue变量赋值的时候，在什么时候用双引号，什么时候用单引号，什么时候不用引号"><a href="#vue变量赋值的时候，在什么时候用双引号，什么时候用单引号，什么时候不用引号" class="headerlink" title="vue变量赋值的时候，在什么时候用双引号，什么时候用单引号，什么时候不用引号"></a>vue变量赋值的时候，在什么时候用双引号，什么时候用单引号，什么时候不用引号</h3><p>变量值赋值的时候要根据是什么类型来给对应的符号</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">String 字符串 类型的加双引号       <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;陈钰&quot;</span>;<br><br>char   字符     类型的加单引号       <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;男&#x27;</span>;<br><br>boolean 布尔值  类型的不加引号     <span class="hljs-attribute">isShow</span>=<span class="hljs-literal">true</span>;<br><br>number 数字      类型的不加引号     <span class="hljs-attribute">num</span>=18;<br><br>只要不是char字符类型，String字符串类型，其他的类型都不需要加引号<br></code></pre></td></tr></table></figure><p>在vue中也是如此，只不过在data里面的赋值符号要改一下,把等号改为冒号，把最后面的分号改为逗号</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> 字符串 类型的加双引号       name:<span class="hljs-string">&quot;陈钰&quot;</span>,<br><br><span class="hljs-keyword">char</span>   字符     类型的加单引号       sex:<span class="hljs-string">&#x27;男&#x27;</span>,<br><br><span class="hljs-keyword">boolean</span> 布尔值  类型的不加引号     isShow:<span class="hljs-literal">true</span>,<br><br>number 数字      类型的不加引号     num:<span class="hljs-number">18</span>,<br></code></pre></td></tr></table></figure><p>在计算机语言中，大多数单引号表示的是一个字符，双引号表示的是表示一个字符串</p><p>前端HTML和Javascript建议统一使用双引号</p><p>在<code>&#123;&#123;&#125;&#125;</code>内的双引号内的是字符串<br>在标签的属性中的双引号内的变量</p><h3 id="请详细说下你对vue生命周期的理解"><a href="#请详细说下你对vue生命周期的理解" class="headerlink" title="请详细说下你对vue生命周期的理解"></a>请详细说下你对vue生命周期的理解</h3><p>vue生命周期总共分为8个阶段: 创建前/后，载入前/后，更新前/后， 销毁前/后。</p><ul><li>beforeCreate （创建前）vue实例的挂载元素$el和数据对象 data都是undefined, 还未初始化</li><li>created (创建后) 完成了 data数据初始化, el还未初始化</li><li>beforeMount (载入前) vue实例的$el和data都初始化了, 相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。</li><li>mounted (载入后) 在el 被新创建的 vm.$el替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互</li><li>beforeUpdate (更新前) 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。</li><li>updated （更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li><li>beforeDestroy (销毁前） 在实例销毁之前调用。实例仍然完全可用。</li><li>destroyed (销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</li></ul><h3 id="组件之间的传值通信"><a href="#组件之间的传值通信" class="headerlink" title="组件之间的传值通信"></a>组件之间的传值通信</h3><p>组件之间通讯分为三种: 父传子、子传父、兄弟组件之间的通讯<br>父组件通过props的方式向子组件传递数据，而通过$emit 子组件可以向父组件通信。          </p><ol><li>父组件给子组件传值<br>使用props，父组件可以使用props向子组件传递数据。</li></ol><p>父组件vue模板father.vue:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child.vue&#x27;</span>;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>    components: &#123;<br>        child<br>    &#125;,<br>    data () &#123;<br><span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">            message: <span class="hljs-string">&#x27;father message&#x27;</span>;</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子组件vue模板child.vue:</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">msg</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">export default &#123;</span><br><span class="xml">    props: &#123;</span><br><span class="xml">        msg: &#123;</span><br><span class="xml">            type: String,</span><br><span class="xml">            required: true</span><br><span class="xml">        &#125;</span><br><span class="xml">    &#125;</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="2"><li>子组件向父组件通信<br>父组件向子组件传递事件方法，子组件通过$emit触发事件，回调给父组件。</li></ol><p>父组件vue模板father.vue:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child</span> @<span class="hljs-attr">msgFunc</span>=<span class="hljs-string">&quot;func&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child.vue&#x27;</span>;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>    components: &#123;<br>        child<br>    &#125;,<br>    methods: &#123;<br>        func (msg) &#123;<br><span class="javascript">            <span class="hljs-built_in">console</span>.log(msg);</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子组件vue模板child.vue:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>点我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>    props: &#123;<br>        msg: &#123;<br><span class="javascript">            type: <span class="hljs-built_in">String</span>,</span><br><span class="javascript">            required: <span class="hljs-literal">true</span></span><br>        &#125;<br>    &#125;,<br>    methods () &#123;<br>        handleClick () &#123;<br><span class="javascript">            <span class="hljs-comment">//........</span></span><br><span class="javascript">            <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;msgFunc&#x27;</span>);</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>非父子, 兄弟组件之间通信<br>vue2中废弃了dispatch和broadcast广播和分发事件的方法。父子组件中可以用props和$emit()。如何实现非父子组件间的通信，可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，然后通过分别调用Bus事件触发和监听来实现通信和参数传递。 Bus.js可以是这样:<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vue()<br></code></pre></td></tr></table></figure>在需要通信的组件都引入Bus.js:<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toBus&quot;</span>&gt;</span>子组件传给兄弟组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">import Bus from &#x27;../common/js/bus.js&#x27;</span><br><span class="xml">export default</span><span class="xquery">&#123;</span><br><span class="xquery">methods: &#123;</span><br><span class="xquery">    toBus () &#123;</span><br><span class="xquery">        Bus.<span class="hljs-variable">$emit</span>(<span class="hljs-string">&#x27;on&#x27;</span>, <span class="hljs-string">&#x27;来自兄弟组件&#x27;</span>)</span><br><span class="xquery">    &#125;</span><br><span class="xml">  &#125;</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>另一个组件也import Bus.js 在钩子函数中监听on事件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Bus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../common/js/bus.js&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        message: <span class="hljs-string">&#x27;&#x27;</span><br>      &#125;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>       Bus.$on(<span class="hljs-string">&#x27;on&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> &#123;<br>         <span class="hljs-built_in">this</span>.message = msg<br>       &#125;)<br>     &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="ref-refs"><a href="#ref-refs" class="headerlink" title="ref / refs"></a>ref / refs</h3><p>访问子组件实例或子元素<br>尽管存在 prop 和事件，有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。为了达到这个目的，你可以通过 ref 这个 attribute 为子组件赋予一个 ID 引用。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">&lt;<span class="hljs-keyword">base</span>-input <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;usernameInput&quot;</span>&gt;&lt;/<span class="hljs-keyword">base</span>-input&gt;<br></code></pre></td></tr></table></figure><p>现在在你已经定义了这个 ref 的组件里，你可以使用：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">this</span>.$<span class="hljs-built_in">ref</span>s.usernameInput<br></code></pre></td></tr></table></figure><p>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据， 我们看一个ref 来访问组件的例子:</p><p>// 子组件 A.vue</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      name: <span class="hljs-string">&#x27;Vue.js&#x27;</span><br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    sayHello () &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>// 父组件 app.vue</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">component-a</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;comA&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component-a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>    mounted () &#123;<br><span class="javascript">      <span class="hljs-keyword">const</span> comA = <span class="hljs-built_in">this</span>.$refs.comA;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(comA.name);  <span class="hljs-comment">// Vue.js</span></span><br><span class="javascript">      comA.sayHello();  <span class="hljs-comment">// hello</span></span><br>    &#125;<br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>$refs 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 $refs。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2021/04/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%A7%A3(%E4%B8%80)/"/>
    <url>/2021/04/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%A7%A3(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h2 id="操作系统相当于一个特殊的软件：这种软件对上服务着我们用户的程序，对下管理硬件。"><a href="#操作系统相当于一个特殊的软件：这种软件对上服务着我们用户的程序，对下管理硬件。" class="headerlink" title="操作系统相当于一个特殊的软件：这种软件对上服务着我们用户的程序，对下管理硬件。"></a>操作系统相当于一个特殊的软件：这种软件对上服务着我们用户的程序，对下管理硬件。</h2><h3 id="操作系统主要做什么"><a href="#操作系统主要做什么" class="headerlink" title="操作系统主要做什么"></a>操作系统主要做什么</h3><p><img src="/image/24.1.png" alt="管理硬件，管理应用"></p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>假设你的键盘按下了ctrl+deletel键要求马上给一个反馈杀死某个程序，机器内核跑的好好的，突然过来一个东西，这时候会断掉一下。这叫做操作系统中断。</p><h3 id="进程，线程（-）"><a href="#进程，线程（-）" class="headerlink" title="进程，线程（*）"></a>进程，线程（*）</h3><p>程序：硬盘上某一个可执行文件就是程序  (例如：qq.exe)</p><p>你双击一下就是一个进程，你再双击一下就又是一个进程，进程就是这个程序跑起来了，放到内存里开始执行了，CPU开始执行他的指令了就叫一个进程。在这个进程中有好多个工作是并行进行的，比如（qq在显示页面，网络传输，存盘），那么是怎么执行的呢，就是通过线程来。</p><h4 id="纤程"><a href="#纤程" class="headerlink" title="纤程"></a>纤程</h4><p>在一个线程中还可以做并行任务，一个线程里面不同的执行路径同时可以执行的那种，叫纤程。java中叫fiber.</p><h2 id="区别：进程是分配资源的单位，线程进行执行，调度单位。"><a href="#区别：进程是分配资源的单位，线程进行执行，调度单位。" class="headerlink" title="区别：进程是分配资源的单位，线程进行执行，调度单位。"></a>区别：进程是分配资源的单位，线程进行执行，调度单位。</h2><p>（解释：如果我启动一个进程的时候，我是会分配一个内存空间的，这个是虚拟内存最后映射到物理内存上也是会给它分配物理空间的，起线程的时候不会给线程分配任何物理空间，这个线程共享了进程的物理空间）</p><h3 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3><p>一共有四种，了解这两种宏外核，微内核（还有系统外核，VMM）</p><p>功能：<br>调度CPU，内存管理，管理文件，管理文件系统，处理中断，管理应用，进行进程调度</p><p><img src="/image/24.2.png" alt="功能"></p><ol><li>宏内核–操作系统的东西全部都集中在一起<br>操作系统的核心包括周边的东西叫宏内核</li></ol><p><img src="/image/24.3.png" alt="宏内核"></p><ol start="2"><li>微内核—-全球的大厂商的都在做，微软，苹果，谷歌，华为。华为首先推出商用的鸿蒙系统。<h4 id="微内核的核心就干一个事就是进程调度。"><a href="#微内核的核心就干一个事就是进程调度。" class="headerlink" title="微内核的核心就干一个事就是进程调度。"></a>微内核的核心就干一个事就是进程调度。</h4>所有的东西都是以内核为核心，cpu调度文件系统则访问内核，内核去访问文件系统。核心非常小，周围一堆的插件。缺点是运行速度稍低，优点是你可以做到非常灵活的部署，可以做到很灵活的拆装。</li></ol><p><img src="/image/24.4.png" alt="微内核"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript同步与异步</title>
    <link href="/2021/04/27/JS%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/"/>
    <url>/2021/04/27/JS%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p>JavaScript起源<br>技术的出现,和应用场景密切相关的。JavaScript诞生于1995年。当时，它的主要目的是处理以前由服务器端语言（如Perl）负责的一些输入验证操作。在JavaScript问世之前，必须把表单数据发送到服务器端才能确定用户是否没有填写某个必填域，是否输入了无效的值。Netscape Navigator希望通过JavaScript来解决这个问题。起初名字为livescript，但是后来Netscape(网景)与Sun公司成立了一个开发联盟。Netscape为了搭上媒体热炒Java的顺风车，临时把LiveScript改名为JavaScript，所以从本质上来说JavaScript和Java没什么关系（趁热度）。 如今，JavaScript的用途早已不再局限于简单的数据验证，而是具备了与浏览器窗口及其内容等几乎所有方面交互的能力。今天的JavaScript已经成为一门功能全面的编程语言</p><p>总结:js最初的用途是为来实现用户与浏览器的交互</p><hr><h3 id="JS为何是单线程的？"><a href="#JS为何是单线程的？" class="headerlink" title="JS为何是单线程的？"></a>JS为何是单线程的？</h3><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成这门语言的核心特征，将来也不会改变。</p><p>注：所谓单线程，是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个</p><h3 id="计算机的同步与异步（重点）–与生活中相反"><a href="#计算机的同步与异步（重点）–与生活中相反" class="headerlink" title="计算机的同步与异步（重点）–与生活中相反"></a>计算机的同步与异步（重点）–与生活中相反</h3><p>计算机领域中的同步（Synchronous）和异步（Asynchronous）和我们生活中的同步和异步的概念是恰好相反的。生活中的同步，突出的是‘同’，相同的步伐，是咱俩一起行动，比如一起去逛街吃饭饭睡觉觉。异步则是你忙你的，我忙我的，步调不致且互不干扰。难到计算机里的同步和异步不是这样？确实不是。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>计算机中的同步就是排队等待，假如你是第一百零一个备胎，那你只能等前面的一百个爆了之后才能‘处理’你。异步就是，尽管你是第一百零一个，她还是能照顾到你的感受。</p><h4 id="同步："><a href="#同步：" class="headerlink" title="同步："></a>同步：</h4><p>同步的定义：是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么，这个进程将会一直等待下去，直到收到返回信息才继续执行下去。</p><p>特点：<br>同步是阻塞模式；<br>同步是按顺序执行，执行完一个再执行下一个，需要等待，协调运行；                    </p><h4 id="异步："><a href="#异步：" class="headerlink" title="异步："></a>异步：</h4><p>是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。<br>特点：<br>异步是非阻塞模式，无需等待；<br>异步是彼此独立，在等待某事件的过程中，继续做自己的事，不需要等待这一事件完成后再工作。线程是异步实现的一个方式。</p><h4 id="同步与异步的优缺点："><a href="#同步与异步的优缺点：" class="headerlink" title="同步与异步的优缺点："></a>同步与异步的优缺点：</h4><p>同步可以避免出现死锁，读脏数据的发生。一般共享某一资源的时候，如果每个人都有修改权限，同时修改一个文件，有可能使一个读取另一个人已经删除了内容，就会出错，同步就不会出错。但，同步需要等待资源访问结束，浪费时间，效率低。</p><p>异步可以提高效率，但，安全性较低。</p><h3 id="js单线程为什么会有’异步’问题"><a href="#js单线程为什么会有’异步’问题" class="headerlink" title="js单线程为什么会有’异步’问题"></a>js单线程为什么会有’异步’问题</h3><p>js是同步的？<br>是的，单线程，那肯定只能同步(排队)执行咯</p><p>js为什么需要异步?<br>如果JS中不存在异步,只能自上而下执行,万一上一行解析时间很长,那么下面的代码就会被阻塞。 对于用户而言,阻塞就意味着”卡死”,这样就导致了很差的用户体验</p><p>js单线程又是如何实现异步的呢?<br>通过事件循环(event loop) 实现’异步’</p><p>经典问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>)<br>&#125;,<span class="hljs-number">0</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>)  <br><span class="hljs-comment">//       1，3，2</span><br></code></pre></td></tr></table></figure><p>也就是说,setTimeout里的函数并没有立即执行,而是延迟了一段时间,满足一定条件后,才去执行的,这类代码,我们叫异步代码。</p><p>所以,这里我们首先知道了JS里的一种分类方式,就是将任务分为: 同步任务和异步任务</p><p><img src="/image/23.png" alt="如图"></p><p>虽然JS是单线程的但是浏览器的内核是多线程的，在浏览器的内核中不同的异步操作由不同的浏览器内核模块调度执行，异步操作会将相关回调添加到任务队列中。而不同的异步操作添加到任务队列的时机也不同，如 onclick, setTimeout, ajax 处理的方式都不同，这些异步操作是由浏览器内核的 webcore 来执行的，webcore 包含上图中的3种 webAPI，分别是 DOM Binding、network、timer模块。</p><p>按照这种分类方式:JS的执行机制是</p><p>首先判断js代码是同步还是异步,同步就进入主进程,异步就进入event table<br>异步任务在event table中注册函数,当满足触发条件后,被推入event queue<br>同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主进程中 以上三步循环执行,这就是event loop<br>总结：同步可以保证顺序一致，但是容易导致阻塞；异步可以解决阻塞问题，但是会改变顺序性，根据不同的需要去写你的代码。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844903810263941134">前端面试：js同步与异步问题</a></p><p><a href="https://www.cnblogs.com/sunshine-blog/p/8392576.html">《计算机操作系统》总结（三）—同步与异步</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript闭包</title>
    <link href="/2021/04/26/JS%E9%97%AD%E5%8C%85%E7%90%86%E8%A7%A3/"/>
    <url>/2021/04/26/JS%E9%97%AD%E5%8C%85%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>闭包并不是需要学习新的语法才能使用的工具。闭包的产生是基于词法作用域写代码时自然产生的结果。换句话说，你不需要要为了闭包而写闭包，闭包在我们写的代码中随处可见。当你真正了解闭包之后，会发现，哦~，原来我以前所敲的代码中已经出现了很多闭包！</p><hr><h3 id="一个小-demo"><a href="#一个小-demo" class="headerlink" title="一个小 demo"></a>一个小 demo</h3><p>仔细看看下面的例子我们会感到奇怪，明明都是调用result(),为什么结果会不一样呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> count=<span class="hljs-number">500</span> <span class="hljs-comment">//全局作用域</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//函数全局作用域</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    count++;<span class="hljs-comment">//函数内部作用域</span><br>    <span class="hljs-built_in">console</span>.log(count);<br>    <span class="hljs-keyword">return</span> count;<br>  &#125;<br>  <span class="hljs-keyword">return</span> foo2;<span class="hljs-comment">//返回函数</span><br>&#125;<br><span class="hljs-keyword">let</span> result = foo1();<br>result();<span class="hljs-comment">//结果为1</span><br>result();<span class="hljs-comment">//结果为2</span><br></code></pre></td></tr></table></figure><p>首先foo1()返回的是一个foo2()函数,当我们调用result()的时候就会返回foo2()执行的函数,foo2()里面有什么呢? 首先我们看到如下有一个count变量,但是没有定义.我们根据JavaScript的作用域链的定义可知,当函数内部的变量没有定义的时候,就会采用冒泡的方式,向上一级寻找.上一级没有接着上一级找,直到最顶层window. 如果都没有,就会报undefined的错误.这里我们在foo1()中找到了count,于是count+1,第一次输出的是1,没有什么问题.</p><p>但是第二次我们再执行result()的时候就出现了问题,为什么会是2呢?按照流程,首先再foo2()函数内部寻找count,没有然后到外层寻找,找到了count=0,这时候count+1应该为1才对.这里就涉及到闭包的问题了.</p><p><img src="/image/22.png" alt="debugger"></p><p>首先我们在原来的代码中加一个debugger,然后到谷歌浏览器右键检查,点击sources就可以看到右边有一个Closure,浏览器的可视化已经证实了这的确是一个闭包.并且count=1已经存储在了Closure之中.也就说明count=1没有被销毁,等下次在调用result()的时候count=2.</p><h3 id="认识作用域"><a href="#认识作用域" class="headerlink" title="认识作用域"></a>认识作用域</h3><p>作用域包括：</p><ol><li>全局作用域</li><li>函数作用域</li><li>块级作用域(es6 新出,解决 var 问题, 新增 let, const)</li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">var</span> <span class="hljs-keyword">count</span> = 100; <span class="hljs-comment">//全局作用域</span><br> function foo1() &#123;<br>   <span class="hljs-keyword">var</span> <span class="hljs-keyword">count</span> = 0; <span class="hljs-comment">//函数全局作用域</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">count</span>; <span class="hljs-comment">//返回函数</span><br> &#125;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">count</span> == 1) &#123;<br>   <span class="hljs-comment">//块级作用域</span><br>   console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">count</span>);<br> &#125;<br></code></pre></td></tr></table></figure><p>上面代码简单可以看出作用域分类,需要注意是,一个函数(function)也是块级作用域,简单来说,一般有 {}都可以算做是一个块级作用域.</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>作用域里面嵌套作用域,就形成了作用域链. 外部作用域无法访问内部的作用域,看如下例子</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">function foo()&#123;<br><span class="hljs-selector-tag">var</span> n=<span class="hljs-number">1</span><br>function foo2()&#123;<br>  <span class="hljs-selector-tag">var</span> m=<span class="hljs-number">1</span><br>  console<span class="hljs-selector-class">.log</span>(n) <span class="hljs-comment">//1</span><br>&#125;<br><span class="hljs-function"><span class="hljs-title">foo2</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br>console<span class="hljs-selector-class">.log</span>(n) <span class="hljs-comment">//err: n is not defined</span><br></code></pre></td></tr></table></figure><p>上述代码中在全局中无法访问内部的n,但是在嵌套的内部foo2()可以访问外部的函数,这就是作用域产生的特殊效果.</p><p>明白了作用域链,我们再来看个例子(很有迷惑性,仔细看看哦):</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">var name = <span class="hljs-string">&#x27;Mike&#x27;</span>; <span class="hljs-regexp">//</span>第一次定义name<br> <span class="hljs-keyword">function</span> showName() &#123;<br>   console.log(name);  <span class="hljs-regexp">//</span>输出 Mike 还是 Jay ？     <br> &#125;<br><br> <span class="hljs-keyword">function</span> changeName() &#123;<br>   var name = <span class="hljs-string">&#x27;Jay&#x27;</span>; <span class="hljs-regexp">//</span>重新定义name<br>   showName(); <span class="hljs-regexp">//</span>调用showName()<br> &#125;<br> changeName();<span class="hljs-regexp">//</span>Mike<br><br></code></pre></td></tr></table></figure><p>以上两个输出的均为Mike,在这里我们引出了一个新的概念,词法作用域 作用域有两种模型:</p><ul><li>词法作用域（静态）：js查找是按照代码书写时候的位置来决定的，而不是按照调用时候位置</li><li>动态作用域：目前还有使用的有Perl，Bash (可以自行了解)</li></ul><ol><li>调用changeName()时,找到这个函数</li><li>定义var name = “Jay”</li><li>调用showName()</li><li>在changeName()里面查找是否有showName()这个方法,发现没有,向外层查找,找到了</li><li>调用console.log(name),在函数内部查找有没有name,没有,向外查找,找到了,name=”Mike”</li><li>输出Mike</li></ol><h2 id="闭包：闭包就是能够读取其他函数内部变量的函数"><a href="#闭包：闭包就是能够读取其他函数内部变量的函数" class="headerlink" title="闭包：闭包就是能够读取其他函数内部变量的函数"></a>闭包：闭包就是能够读取其他函数内部变量的函数</h2><h3 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h3><p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p><p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p><h3 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h3><p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。<br>怎么来理解这句话呢？请看下面的代码。<br>Js代码</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>nAdd = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;<br>n += <span class="hljs-number">1</span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123;<br>alert(n);<br>&#125;<br><span class="hljs-keyword">return</span> f2;<br>&#125;<br><span class="hljs-keyword">var</span> result = f1();<br>result(); <span class="hljs-comment">// 999</span><br>nAdd();<br>result(); <span class="hljs-comment">// 1000</span><br></code></pre></td></tr></table></figure><p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p><p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p><p>这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个</p><p>匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844904161268482062#heading-4">javascript 近乎神话般的概念：闭包</a></p><p><a href="https://my.oschina.net/u/3693769/blog/1544436">JavaScript 闭包</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVC&amp;MVVM双向数据绑定&amp;单向数据流</title>
    <link href="/2021/04/26/MVC&amp;MVVM%E7%90%86%E8%A7%A3/"/>
    <url>/2021/04/26/MVC&amp;MVVM%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>MVVM和MVC总结</p><hr><h3 id="什么是MVVM？"><a href="#什么是MVVM？" class="headerlink" title="什么是MVVM？"></a>什么是MVVM？</h3><p>MVVM 由 Model、View、ViewModel 三部分构成</p><ol><li>View 层</li></ol><p>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。</p><ol start="2"><li><p>Model 层<br>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</p></li><li><p>ViewModel 是一个同步View 和 Model的对象；</p></li></ol><p><img src="/image/20.1.png" alt="MVVM"></p><p>MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用</p><p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p><h3 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h3><p>MVC是Model-View-Controller的缩写，即模型—视图—控制器</p><ul><li>Model：后端传递的 数据 。</li><li>View：所看到的 页面 。</li><li>Controller：页面 业务逻辑 。</li></ul><ol><li>MVC是 单向通信。即View和Model，必须通过Controller来承上启下。</li><li>使用MVC的 目的 就是 将M和V的代码分离 。</li></ol><h3 id="MVC和MVVM的区别"><a href="#MVC和MVVM的区别" class="headerlink" title="MVC和MVVM的区别"></a>MVC和MVVM的区别</h3><p>mvc 和 mvvm 都是一种设计思想。主要就是 把mvc 中 Controller 演变成 mvvm 中的viewModel。MVC和MVVM的区别并不是VM完全取代了C，只是在MVC的基础上增加了一层VM，只不过是弱化了C的概念，ViewModel存在目的在于抽离Controller中展示的业务逻辑，而不是替代Controller，其它视图操作业务等还是应该放在Controller中实现。</p><h4 id="mvvm-主要解决了-mvc-中大量的-DOM-操作使页面渲染性能降低，加载速度变慢，影响用户体验的缺点。当-Model-频繁发生变化，开发者都需要主动更新到-View-。MVVM实现的是业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。"><a href="#mvvm-主要解决了-mvc-中大量的-DOM-操作使页面渲染性能降低，加载速度变慢，影响用户体验的缺点。当-Model-频繁发生变化，开发者都需要主动更新到-View-。MVVM实现的是业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。" class="headerlink" title="mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验的缺点。当 Model 频繁发生变化，开发者都需要主动更新到 View 。MVVM实现的是业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。"></a>mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验的缺点。当 Model 频繁发生变化，开发者都需要主动更新到 View 。MVVM实现的是业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。</h4><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://juejin.cn/post/6844903918753808398#heading-20">什么是 MVVM？</a></p><p><a href="https://zhuanlan.zhihu.com/p/192341615">知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>豆瓣&amp;搜索页面布局&amp;详情评分bug解决</title>
    <link href="/2021/04/25/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E5%85%AD)/"/>
    <url>/2021/04/25/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E5%85%AD)/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV17p4y1b7eP">项目视频演示地址</a></p><hr><h3 id="搜索页面样式布局完成"><a href="#搜索页面样式布局完成" class="headerlink" title="搜索页面样式布局完成"></a>搜索页面样式布局完成</h3><p>要完成样式</p><p><img src="/image/19.11.png" alt="页面样式"></p><ol><li>search.wxml</li></ol><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cos">&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;item-list-group&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;item-group&quot;</span>&gt;<br>&lt;image  src=<span class="hljs-string">&quot;https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2635676317.webp&quot;</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;thumbnail&quot;</span>&gt;&lt;/image&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;info-group&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;六人-泰坦尼克上的中国幸存者&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;rate-year&quot;</span>&gt;<span class="hljs-number">8.5</span>分/<span class="hljs-number">2020</span>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>search.wxss</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-list-group</span>&#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10</span>rpx  <span class="hljs-number">20</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.item-list-group</span>  <span class="hljs-selector-class">.item-group</span>&#123;<br>  <span class="hljs-attribute">padding</span>:<span class="hljs-number">10</span>rpx <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">/* 底部分割线 */</span><br>  <span class="hljs-attribute">border-bottom</span>:<span class="hljs-number">1px</span>  solid <span class="hljs-number">#e4e4e4</span>;<br>  <span class="hljs-comment">/* 左右分布布局 */</span><br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><span class="hljs-selector-class">.item-group</span> <span class="hljs-selector-class">.thumbnail</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">80</span>rpx;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.item-group</span> <span class="hljs-selector-class">.info-group</span>&#123;<br>  <span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">display</span>:flex;<br>  <span class="hljs-attribute">flex-direction</span>: column;<br>  <span class="hljs-attribute">justify-content</span>: space-between;<br>&#125;<br><br><span class="hljs-selector-class">.info-group</span> <span class="hljs-selector-class">.title</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.info-group</span> <span class="hljs-selector-class">.rate-year</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#7b7b7b</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>样式渲染完成，采用flex布局</p><h3 id="搜索功能实现"><a href="#搜索功能实现" class="headerlink" title="搜索功能实现"></a>搜索功能实现</h3><ol><li>搜索请求实现</li></ol><p>分析：1.在输入框中输入输入文字，那么就应该要获取到输入框中的文字了，但是输入框是单独放在<br>一个searchbar组件中，我们要获取的话没有那么方便   </p><p> 2.解决：在组件中监听输入框中input事件，将监听到的input输入框中输入的东西及时反馈，然后组件监听得到后再区触发另外一个事件，这样就可以传到外面了。</p><ol start="2"><li>代码实现</li></ol><p>bindinput事件是只要你在输入框中新增删除文字它都会去执行事件</p><p><img src="/image/19.13.png" alt="绑定事件"></p><p>searchbar.js</p><p>方法实现，组件主要复制将信息传递出去，执行在search中，这样职责划分更明确</p><p><img src="/image/19.14.png" alt="绑定事件"></p><p>search.wxml绑定查找事件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">searchbar</span>  <span class="hljs-attr">bindsearchinput</span>=<span class="hljs-string">&quot;onSearchInputEvent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">searchbar</span>&gt;</span><br></code></pre></td></tr></table></figure><p>serch.js监听事件</p><p><img src="/image/19.15.png" alt="绑定事件"></p><p>此时控制台type类型变为searchinput类型,能够得到用户输入的值</p><ol start="3"><li>发送网路请求url</li></ol><p>url.js</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">searchUrl: <span class="hljs-keyword">function</span> <span class="hljs-title"></span>(q) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">&quot;https://m.douban.com/rexxar/api/v2/search?type=movie&amp;q=&quot;</span> + q<br>&#125;<br></code></pre></td></tr></table></figure><p>network.js</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">// 搜索item</span><br>getSearch:function(<span class="hljs-keyword">params</span>)&#123;<br>  <span class="hljs-built_in">var</span> q =<span class="hljs-keyword">params</span>.q;<br>  <span class="hljs-built_in">var</span>  url = globalurls.searchUrl(q);<br>  wx.request(&#123;<br>    url: url,<br>    success:function(res)&#123;<br>      <span class="hljs-comment">// console.log(res);</span><br>      <span class="hljs-built_in">var</span>  subjects = res.<span class="hljs-built_in">data</span>.subjects;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">params</span>.success)&#123;<br>        <span class="hljs-keyword">params</span>.success(subjects);<br>      &#125;<br>    &#125;<br>  &#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>search.js</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">onSearchInputEvent:<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span></span>&#123;<br><span class="hljs-keyword">var</span>  that= <span class="hljs-keyword">this</span>;<br><span class="hljs-comment">// console.log(event)</span><br><span class="hljs-keyword">var</span>  value = event.detail.value;<br>network.getSearch(&#123;<br>  q:value,<br>  success:<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(subjects)</span></span>&#123;<br>        that.setData(&#123;<br>          subjects:subjects<br>        &#125;)<br>  &#125;<br>&#125;)<br>&#125;,<br></code></pre></td></tr></table></figure><p>因豆瓣Api限制访问，经常请求不到数据</p><p><img src="/image/19.12.png" alt="能够搜索"></p><ol start="4"><li>此时能够拿到数据，我们将数据渲染到页面</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">searchbar</span>  <span class="hljs-attr">bindsearchinput</span>=<span class="hljs-string">&quot;onSearchInputEvent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">searchbar</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-list-group&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">subjects</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span></span></span><br><span class="xml"> class=&quot;item-group&quot;  wx:key =&quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.id</span>&#125;&#125;</span><span class="xml">&quot;</span><br><span class="xml"> <span class="hljs-comment">&lt;!-- 绑定了一个点击事件，这样点击item可以跳转到详情页面中 --&gt;</span></span><br><span class="xml"> bindtap=&quot;onItemTapEvent&quot;  data-id=&quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.id</span>&#125;&#125;</span><span class="xml">&quot; &gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">image</span>  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.pic.normal</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;thumbnail&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;info-group&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rate-year&quot;</span>&gt;</span> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.rating.value</span>&#125;&#125;</span><span class="xml">分</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.year</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>绑定了一个点击事件，这样点击item可以跳转到详情页面中,同时获取id</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">bindtap</span>=<span class="hljs-string">&quot;onItemTapEvent&quot;</span>  <span class="hljs-class"><span class="hljs-keyword">data</span>-id=&quot;&#123;&#123;<span class="hljs-title">item</span>.<span class="hljs-title">id</span>&#125;&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>search.js</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gml">onItemTapEvent:<span class="hljs-keyword">function</span>(event)&#123;<br>   <span class="hljs-comment">// console.log(event)</span><br>   <span class="hljs-keyword">var</span> <span class="hljs-symbol">id</span> = event.currentTarget.dataset.<span class="hljs-symbol">id</span>;<br>   <span class="hljs-comment">// 跳转到某一个页面</span><br>   wx.navigateTo(&#123;<br>     url: <span class="hljs-string">&#x27;/pages/detail/detail?type=movie&amp;id=&#x27;</span>+<span class="hljs-symbol">id</span>,<br>   &#125;)<br> &#125;<br></code></pre></td></tr></table></figure><p>至此，点击电影也可以跳转到详情页面了</p><h3 id="历史搜索记录布局"><a href="#历史搜索记录布局" class="headerlink" title="历史搜索记录布局"></a>历史搜索记录布局</h3><p><img src="/image/19.16.png" alt="要完成的样式"></p><p>search.wxml</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cos">&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;history-list-group&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;history-title&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;历史记录&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;clear&quot;</span>&gt;清除&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;navigator  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;history-group&quot;</span>&gt;泰坦尼克号&lt;/navigator&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br></code></pre></td></tr></table></figure><p>search.wxss</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.history-list-group</span>&#123;<br>  <span class="hljs-attribute">padding</span>:<span class="hljs-number">10</span>rpx <span class="hljs-number">20</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.history-list-group</span> <span class="hljs-selector-class">.history-title</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: space-between;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20</span>rpx  <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#f9f9f9</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">28</span>rpx;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#9e9e9e</span>;<br>&#125;<br><span class="hljs-selector-class">.history-list-group</span>  <span class="hljs-selector-class">.history-group</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20</span>rpx <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">border-bottom</span>:<span class="hljs-number">1px</span>  solid  <span class="hljs-number">#e4e4e4</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>优化：history-group可以将它变为一个navigator组件，因为历史搜索是不需要任何操作的，可以直接从本地读取</p><h4 id="历史记录功能实现"><a href="#历史记录功能实现" class="headerlink" title="历史记录功能实现"></a>历史记录功能实现</h4><p>由于豆瓣api次数限制控制，搜索有时候请求不到，故这里并未实现</p><p><a href="https://study.163.com/course/courseLearn.htm?courseId=1208961810#/learn/video?lessonId=1278472316&courseId=1208961810">学习思路</a></p><h3 id="详情评分bug解决"><a href="#详情评分bug解决" class="headerlink" title="详情评分bug解决"></a>详情评分bug解决</h3><p>所有电影，综艺，电视剧评分均为9.7，因为我们这里写成固定的了</p><p><img src="/image/19.17.png" alt="rate"></p><p>代码修改</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">stars</span> <span class="hljs-attr">rate</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.rating.value</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">stars</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/image/19.18.png" alt="问题"></p><p>评论的评分是能够接收的，同理上面的星星评分也是能设置进来的。</p><p>分析：stars.js中代码问题</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">  lifetimes:&#123;<br>attached:<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">this</span>.updateRate();<br>&#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>问题原因：attached生命周期函数执行时，rate还没有设置进来，因为rate是通过网络请求加载出来的，需要时间加载进来，所以这时候rate为0默认值。</p><p>解决</p><p>stars.js</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs axapta">  properties: &#123;<br>  rate:&#123;<br>        type:Number,<br>        value:<span class="hljs-number">0</span>,<br>        observer: function(newVal, oldVal,changePath) &#123;<br>          <span class="hljs-comment">// 属性值变化时执行,newVal就是新设置的数据，old是旧数据</span><br>          <span class="hljs-keyword">this</span>.updateRate();<br>        &#125;<br>      &#125; <br>      &#125;,<br>methods: &#123;<br>updateRate:function()&#123;<br>  <span class="hljs-built_in">var</span>  that = <span class="hljs-keyword">this</span>;<br>  <span class="hljs-built_in">var</span>  rate= that.properties.rate;<br>  <span class="hljs-built_in">var</span>  inRate = parseInt(rate);<br>  <span class="hljs-built_in">var</span>  light = parseInt(rate/<span class="hljs-number">2</span>);<br>  <span class="hljs-built_in">var</span>  half = inRate%<span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">var</span>  gray  = <span class="hljs-number">5</span>-light-half;<br>  <span class="hljs-built_in">var</span> lights = [];<br>  <span class="hljs-built_in">var</span>  halfs = [];<br>  <span class="hljs-built_in">var</span>  grays = [];<br>  <span class="hljs-comment">// for循环遍历存放到数组中</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">var</span>  <span class="hljs-keyword">index</span>=<span class="hljs-number">1</span>;<span class="hljs-keyword">index</span>&lt;=light;<span class="hljs-keyword">index</span>++)&#123;<br>    lights.push(<span class="hljs-keyword">index</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">var</span>  <span class="hljs-keyword">index</span>=<span class="hljs-number">1</span>;<span class="hljs-keyword">index</span>&lt;=half;<span class="hljs-keyword">index</span>++)&#123;<br>    halfs.push(<span class="hljs-keyword">index</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">var</span>  <span class="hljs-keyword">index</span>=<span class="hljs-number">1</span>;<span class="hljs-keyword">index</span>&lt;=gray;<span class="hljs-keyword">index</span>++)&#123;<br>    grays.push(<span class="hljs-keyword">index</span>);<br>  &#125;<br>  <span class="hljs-comment">// 评分设置</span><br>  <span class="hljs-built_in">var</span>   ratetext = rate &amp;&amp; rate&gt;<span class="hljs-number">0</span>?rate.toFixed(<span class="hljs-number">1</span>):<span class="hljs-string">&quot;未评分&quot;</span><br>  <span class="hljs-comment">//数组获取到后 修改 data 中的值</span><br>  that.setData(&#123;<br>    lights:lights,<br>    halfs:halfs,<br>    grays:grays,<br>    ratetext:ratetext,<br>  &#125;);<br>&#125;<br>&#125;,<br><br>lifetimes:&#123;<br>attached:function()&#123;<br>  <span class="hljs-keyword">this</span>.updateRate();<br>  &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>至此，问题解决了</p><blockquote><p>问题的核心元素是：代码之前执行是放在一个attached中，这个函数是被加载到页面中才会去执行，加载到页面中我们的数据没有从网络中请求到，这时候数据就是默认的0，我们可以用observer函数，一旦监听到改变了评分的值，就可以重新设置一下这个值。</p></blockquote><p><img src="/image/19.20.png" alt="星星加载成功"></p><h4 id="项目Github地址"><a href="#项目Github地址" class="headerlink" title="项目Github地址"></a><a href="https://github.com/Pengzhenglong/doubanxiaochengxu">项目Github地址</a></h4>]]></content>
    
    
    <categories>
      
      <category>WX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WX</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>豆瓣&amp;评论列表页实现</title>
    <link href="/2021/04/24/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E4%BA%94)/"/>
    <url>/2021/04/24/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E4%BA%94)/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="评论列表页实现"><a href="#评论列表页实现" class="headerlink" title="评论列表页实现"></a>评论列表页实现</h2><p><img src="/image/19.png" alt="实现点击该页面跳转后"></p><h3 id="完成布局和样式"><a href="#完成布局和样式" class="headerlink" title="完成布局和样式"></a>完成布局和样式</h3><ol><li>先创建comment页面app.json中</li></ol><p>可以将该页面放在第一位,这样方便后面调试页面在第一页</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;pages/comment/comment&quot;</span>,<br></code></pre></td></tr></table></figure><p>ctrl+s保存后生成页面</p><ol start="2"><li>comment.wxml代码</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-group&quot;</span></span></span><br><span class="xml">bindtap=&quot;onItemTapEvent&quot;&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">image</span>    <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;thumbnail&quot;</span>  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">thumbnail</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-title&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">text</span>   <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-rate&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">rate</span>&#125;&#125;</span><span class="xml">分<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><ol start="3"><li>comment.wxss样式</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;<br>  <span class="hljs-attribute">padding</span>:<span class="hljs-number">20</span>rpx  <span class="hljs-number">30</span>rpx;<br>&#125;<br><br><span class="hljs-selector-class">.item-group</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: flex-start;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.item-group</span> <span class="hljs-selector-class">.thumbnail</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50</span>rpx;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">10</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10</span>rpx;<br>&#125;<br><br><span class="hljs-selector-class">.item-group</span>  <span class="hljs-selector-class">.item-title</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>  <span class="hljs-attribute">color</span> : <span class="hljs-number">#41be57</span>;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">10</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10</span>rpx;<br>&#125;<br><br><span class="hljs-selector-class">.item-group</span>  <span class="hljs-selector-class">.item-rate</span>&#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">28</span>rpx;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#ccc</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成后效果</p><p><img src="/image/19.1.png" alt="样式"></p><ol start="4"><li>将comment页面降级，实现跳转功能</li></ol><p>app.json</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">&quot;pages/<span class="hljs-keyword">index</span>/<span class="hljs-keyword">index</span><span class="hljs-string">&quot;,</span><br><span class="hljs-string">&quot;</span>pages/comment/comment<span class="hljs-string">&quot;,</span><br></code></pre></td></tr></table></figure><ol start="5"><li>detail.wxml中实现跳转url</li></ol><p>url 中接收了从上一页传递到下一页的一些参数?后面的</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">navigator</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;more-comment&quot;</span> </span></span><br><span class="xml">url=&quot;/pages/comment/comment?id=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">id</span>&#125;&#125;</span><span class="xml">&amp;type=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">type</span>&#125;&#125;</span><span class="xml">&amp;thumbnail=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.cover.image.small.url</span>&#125;&#125;</span><span class="xml">&amp;title=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.title</span>&#125;&#125;</span><span class="xml">&amp;rate=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.rating.value</span>&#125;&#125;</span><span class="xml">&quot; &gt;查看更多短评<span class="hljs-tag">&lt;/<span class="hljs-name">navigator</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><p>此时我们在comment.js中打印一下数据</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">onLoad: <span class="hljs-keyword">function</span> (<span class="hljs-keyword">options</span>) &#123;<br>  console.log(<span class="hljs-keyword">options</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：没有打印id和type</p><p><img src="/image/19.2.png" alt="问题"></p><p>解决：detail.js中虽然获取到了type和id，但是没有保存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">that.setData(&#123;<br><span class="hljs-built_in">id</span>:<span class="hljs-built_in">id</span>,<br><span class="hljs-built_in">type</span>:<span class="hljs-built_in">type</span><br>&#125;)<br></code></pre></td></tr></table></figure><ol start="6"><li>comment.js中保存数据</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">onLoad: <span class="hljs-keyword">function</span> (options) &#123;<br>   <span class="hljs-keyword">var</span>  <span class="hljs-literal">that</span>=<span class="hljs-built_in">this</span>;<br>   <span class="hljs-literal">that</span>.setData(options);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>渲染数据</li></ol><p>修改以下数据，从url中获取的参数，渲染到页面，会根据点击实现数据的改变</p><p><img src="/image/19.3.png" alt="修改"></p><h3 id="点击完成页面跳转"><a href="#点击完成页面跳转" class="headerlink" title="点击完成页面跳转"></a>点击完成页面跳转</h3><ol><li>能够点击头像完成上一页的跳转</li></ol><p><img src="/image/19.4.png" alt="能够点击跳转"></p><p>分析：能够通过rul或js实现</p><ol start="2"><li>这里我们通过js实现,绑定一个点击事件</li></ol><p><img src="/image/19.5.png" alt="绑定一个点击事件"></p><ol start="3"><li>comment.js函数实现</li></ol><p>这里我们调用的是微信的Api,返回到上一页</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">onItemTapEvent:<span class="hljs-built_in">function</span>(event)&#123;<br>  wx.<span class="hljs-built_in">navigateBack</span>(&#123;&#125;)<br>&#125;,<br><br></code></pre></td></tr></table></figure><p>问题，这里返回到的是上一页的最下面，不是很好</p><p>解决： 在detail界面中加上一个滚动事件，一旦页面show出来了，就展示在最上面</p><p>detail.js</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 生命周期函数--监听页面显示</span><br><span class="hljs-comment"> */</span><br>onShow: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;<br>    wx.pageScrollTo(&#123;<br>      scrollTop:<span class="hljs-number">0</span>,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>问题解决。</p><h3 id="加载评论数据"><a href="#加载评论数据" class="headerlink" title="加载评论数据"></a>加载评论数据</h3><ol><li><p>分析，影评和上面的标题的左右间距都一样，所以可以将它放在.container中</p></li><li><p>wxml代码</p></li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-comment">&lt;!-- 影评 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;comment-title&quot;</span>&gt;</span>全部影评(</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">total</span>&#125;&#125;</span><span class="xml">)<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">onecomment</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">comments</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">onecomment</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>wxss代码</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.comment-title</span>&#123;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">60</span>rpx;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">40</span>rpx;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="评论列表页面抽取注册成组件"><a href="#评论列表页面抽取注册成组件" class="headerlink" title="评论列表页面抽取注册成组件"></a>评论列表页面抽取注册成组件</h3><p><img src="/image/19.6.png" alt="分析"></p><p>评论的样式和布局之前已经在详情页中已经做了，我们在这里没有必要再写一遍，我们可以将之前评论的样式和布局单独抽取出来，做成一个组件，然后直接使用组件，非常方便。</p><ol><li><p>创建一个onecomment组件</p></li><li><p>将detail中的comment代码剪切到onecomment中</p></li></ol><p><img src="/image/19.7.png" alt="代码"></p><ol start="3"><li>将css代码剪切到onecomment中</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 左边固定，右边内容适配 */</span><br> <span class="hljs-selector-class">.comment-group</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: flex-start;<br>  <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">40</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.comment-group</span> <span class="hljs-selector-class">.left-comment</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">70</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.left-comment</span>  <span class="hljs-selector-class">.avatar</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">70</span>rpx;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">70</span>rpx;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>&#125;<br><span class="hljs-selector-class">.comment-group</span>  <span class="hljs-selector-class">.right-comment</span>&#123;<br>  <span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-selector-class">.right-comment</span>   <span class="hljs-selector-class">.username-rate</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: flex-start;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br><span class="hljs-selector-class">.username-rate</span> <span class="hljs-selector-class">.username</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">36</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.release-time</span>&#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#b3b3b3</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">10</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.content</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#353535</span>;<br>  <span class="hljs-attribute">margin-top</span>:<span class="hljs-number">10</span>rpx;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>再onecomment中设置一个属性，这样我们可以使用使数据显示</li></ol><p>onecomment.js</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">properties:</span> &#123;<br><span class="hljs-symbol">      item:</span>&#123;<br><span class="hljs-symbol">        type:</span>Object,<br><span class="hljs-symbol">        value:</span>&#123;&#125;<br>      &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>onecomment.wxml代码</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;comment-group&quot;</span> &gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left-comment&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">image</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;avatar&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.user.avatar</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"> <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right-comment&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;username-rate&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.user.name</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">stars</span>  <span class="hljs-attr">rate</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.rating.value</span>*<span class="hljs-number">2</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">starsize</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">istext</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">false</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">stars</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;release-time&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.create_time</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.comment</span>&#125;&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="5"><li>detail中使用先注册组件</li></ol><p>detail.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;stars&quot;</span>:<span class="hljs-string">&quot;/components/stars/stars&quot;</span>,<br>    <span class="hljs-attr">&quot;onecomment&quot;</span>:<span class="hljs-string">&quot;/components/onecomment/onecomment&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>detail.wxml中使用</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">onecomment</span>  <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">comments</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">onecomment</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>其他样式和之前一样，但是出现了问题：星星样式没了</p><p>解决：再onecomment中注册stars组件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;component&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;stars&quot;</span>:<span class="hljs-string">&quot;/components/stars/stars&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成。</p><h3 id="请求评论数据"><a href="#请求评论数据" class="headerlink" title="请求评论数据"></a>请求评论数据</h3><ol><li>comment.js</li></ol><p>请求数据，先导入network.js</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">import</span>  &#123;network&#125;  <span class="hljs-keyword">from</span>  <span class="hljs-string">&quot;../../utils/network.js&quot;</span>;<br><br>  onLoad: <span class="hljs-keyword">function</span> (options) &#123;<br>     <span class="hljs-keyword">var</span>  <span class="hljs-literal">that</span>=<span class="hljs-built_in">this</span>;<br>     <span class="hljs-literal">that</span>.setData(options);<br>    network.getItemComments(&#123;<br>      type:options.type,<br>      id:options.id,<br>      start:<span class="hljs-number">1</span>,<br>      count:<span class="hljs-number">20</span>,<br>      success:<span class="hljs-keyword">function</span>(data)&#123;<br>        <span class="hljs-keyword">var</span>  total = data.total;<br>        <span class="hljs-keyword">var</span>  comments = data.interests;<br>        <span class="hljs-literal">that</span>.setData(&#123;<br>          total:total,<br>          comments:comments<br>        &#125;)<br>      &#125;<br>    &#125;)<br>  &#125;,<br></code></pre></td></tr></table></figure><ol start="2"><li>comment中注册组件</li></ol><p>comment.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;onecomment&quot;</span>:<span class="hljs-string">&quot;/components/onecomment/onecomment&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>使用组件</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;onecomment&quot;</span>:<span class="hljs-string">&quot;/components/onecomment/onecomment&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成</p><h3 id="翻页按钮布局"><a href="#翻页按钮布局" class="headerlink" title="翻页按钮布局"></a>翻页按钮布局</h3><p>要完成样式</p><p><img src="/image/19.8.png" alt="样式"></p><ol><li>comment.wxml代码</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-btn-group&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-btn&quot;</span><span class="hljs-attr">bindtap</span>=<span class="hljs-string">&quot;onPrePageTap&quot;</span></span><br><span class="hljs-tag">&gt;</span>上一页<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-btn&quot;</span><span class="hljs-attr">bindtap</span>=<span class="hljs-string">&quot;onNextPageTap&quot;</span></span><br><span class="hljs-tag">&gt;</span>下一页<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>comment.wxss代码</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.page-btn-group</span>&#123;<br>  <span class="hljs-attribute">margin-top</span>:<span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">display</span>:flex;<br>  <span class="hljs-comment">/* 水平方向从左到右 */</span><br>  <span class="hljs-attribute">justify-content</span>: flex-start;<br>  <span class="hljs-comment">/* 垂直反向居中 */</span><br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.page-btn</span>&#123;<br>  <span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">60</span>rpx;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#898989</span>;<br>  <span class="hljs-attribute">border-color</span>:<span class="hljs-number">#898989</span>;<br>  <span class="hljs-attribute">line-height</span>:<span class="hljs-number">60</span>rpx;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="翻页功能实现"><a href="#翻页功能实现" class="headerlink" title="翻页功能实现"></a>翻页功能实现</h3><p>优化用户体验，从用户角度出发，给用户更好的体验</p><ol><li>点击绑定事件</li></ol><p><img src="/image/19.10.png" alt="绑定"></p><ol start="2"><li>comment.js实现</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span>  &#123;network&#125;  from  <span class="hljs-string">&quot;../../utils/network.js&quot;</span>;<br>Page(&#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 页面的初始数据</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">data</span>: &#123;<br>      total:<span class="hljs-number">0</span>,<br>      start:<span class="hljs-number">1</span>,<br>      count:<span class="hljs-number">20</span><br>  &#125;,<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 生命周期函数--监听页面加载</span><br><span class="hljs-comment">   */</span><br>onLoad: function (options) &#123;<br>     <span class="hljs-keyword">var</span>  that=<span class="hljs-keyword">this</span>;<br>    that.setData(options);<br>    <span class="hljs-comment">// 传入的为第一页</span><br>    that.getComments(<span class="hljs-number">1</span>);<br>  &#125;,<br><span class="hljs-comment">// 传入一个start参数</span><br>getComments:function(start)&#123;<br><span class="hljs-keyword">var</span>  that= <span class="hljs-keyword">this</span>;<br><span class="hljs-keyword">var</span> type  = that.<span class="hljs-keyword">data</span>.type;<br><span class="hljs-keyword">var</span>  id = that.<span class="hljs-keyword">data</span>.id;<br><span class="hljs-comment">// loading判断用户点击是上一页还是下一页</span><br><span class="hljs-keyword">if</span>(start&gt;that.<span class="hljs-keyword">data</span>.start)&#123;<br>  that.setData(&#123;<br>    nextLoading:<span class="hljs-literal">true</span><br>  &#125;);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  that.setData(&#123;<br>    preLoading:<span class="hljs-literal">true</span><br>  &#125;);<br>&#125;<br>  network.getItemComments(&#123;<br>    type:type,<br>    id:id,<br>    start:start,<br>    count:<span class="hljs-number">20</span>,<br>    success:function(<span class="hljs-keyword">data</span>)&#123;<br>      <span class="hljs-keyword">var</span>  total = <span class="hljs-keyword">data</span>.total;<br>      <span class="hljs-keyword">var</span>  comments = <span class="hljs-keyword">data</span>.interests;<br>      that.setData(&#123;<br>        total:total,<br>        comments:comments,<br>        start:start,<br>        <span class="hljs-comment">// 数据请求完毕loading关闭</span><br>        preLoading:<span class="hljs-literal">false</span>,<br>        nextLoading:<span class="hljs-literal">false</span><br>      &#125;);<br>      <span class="hljs-comment">// 优化，点击下一页或上一页返回为最上面</span><br>        wx.pageScrollTo(&#123;<br>          scrollTop: <span class="hljs-number">0</span>,<br>        &#125;)<br>    &#125;<br>  &#125;)<br>&#125;,<br><span class="hljs-comment">// 返回上一页</span><br>  onItemTapEvent:function(event)&#123;<br>    wx.navigateBack(&#123;&#125;)<br>  &#125;,<br><span class="hljs-comment">// 上一页</span><br>  onPrePageTap:function(event)&#123;<br>    <span class="hljs-keyword">var</span>  that= <span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">var</span>  oldStar= that.<span class="hljs-keyword">data</span>.start;<br>    <span class="hljs-keyword">var</span> count = that.<span class="hljs-keyword">data</span>.count;<br>    <span class="hljs-keyword">if</span>(oldStar-count&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">var</span>  start =  oldStar-count; <br>        that.getComments(start);<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 下一页</span><br>  onNextPageTap:function(event)&#123;<br>      <span class="hljs-keyword">var</span>  that=<span class="hljs-keyword">this</span>;<br>      <span class="hljs-keyword">var</span> oldStart = that.<span class="hljs-keyword">data</span>.start;<br>      <span class="hljs-keyword">var</span>  start = oldStart+that.<span class="hljs-keyword">data</span>.count;<br>      that.getComments(start);<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>基本完成</p><p><img src="/image/19.9.png" alt="完成"></p>]]></content>
    
    
    <categories>
      
      <category>WX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WX</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>豆瓣&amp;详情页面固定样式完成&amp;详情页短评数据获取与渲染</title>
    <link href="/2021/04/23/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/"/>
    <url>/2021/04/23/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="详情页面固定样式完成"><a href="#详情页面固定样式完成" class="headerlink" title="详情页面固定样式完成"></a>详情页面固定样式完成</h3><h4 id="详情页面header完成"><a href="#详情页面header完成" class="headerlink" title="详情页面header完成"></a>详情页面header完成</h4><p>要完成的样式<br><img src="/image/18.png" alt="要完成的样式"></p><ol><li>创建detail页面</li></ol><p>app.json中,<strong>将detail放在最前面方便后面调试</strong></p><p><img src="/image/18.1.png" alt="保存生成detail页面"></p><ol start="2"><li>分析布局</li></ol><p><img src="/image/18.2.png" alt="分析"></p><ol start="3"><li>detail.wxml代码编写</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-header&quot;&gt;<br>  &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-title&quot;&gt; 肖申克的救赎(<span class="hljs-number">1994</span>) &lt;/<span class="hljs-keyword">view</span>&gt;<br>  &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-detail&quot;&gt;<br>    &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;left-detail&quot;&gt;<br>      &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-rate&quot;&gt;<br>        &lt;stars rate=&quot;9.7&quot;&gt;&lt;/stars&gt;<br>        &lt;<span class="hljs-type">text</span> <span class="hljs-keyword">class</span>=&quot;comment-persons&quot;&gt;<span class="hljs-number">203894</span>评价&lt;/<span class="hljs-type">text</span>&gt;<br>      &lt;/<span class="hljs-keyword">view</span>&gt;<br>      &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-sub-detail&quot;&gt;<br>        &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-type&quot;&gt; <span class="hljs-number">142</span>分钟 剧情 / 犯罪 &lt;/<span class="hljs-keyword">view</span>&gt;<br>        &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-show&quot;&gt; <span class="hljs-number">1994</span><span class="hljs-number">-10</span><span class="hljs-number">-14</span>(美国) &lt;/<span class="hljs-keyword">view</span>&gt;<br>        &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-actors&quot;&gt;<br>          导演: 弗兰克·德拉邦特/ 主演: 蒂姆·罗宾斯<br>        &lt;/<span class="hljs-keyword">view</span>&gt;<br>      &lt;/<span class="hljs-keyword">view</span>&gt;<br>    &lt;/<span class="hljs-keyword">view</span>&gt;<br>    &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;right-detail&quot;&gt;<br>      &lt;image<br>        src=&quot;https://img2.doubanio.com/view/photo/s_ratio_poster/public/p480747492.webp&quot;<br>      &gt;&lt;/image&gt;<br>    &lt;/<span class="hljs-keyword">view</span>&gt;<br>  &lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br></code></pre></td></tr></table></figure><p>detail.wxss代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-header</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">60</span>rpx <span class="hljs-number">30</span>rpx;<br>&#125;<br><br><span class="hljs-selector-class">.item-header</span> <span class="hljs-selector-class">.item-title</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50</span>rpx;<br>&#125;<br><br><span class="hljs-selector-class">.item-header</span> <span class="hljs-selector-class">.item-detail</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: space-between;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br><br><span class="hljs-selector-class">.item-detail</span> <span class="hljs-selector-class">.left-detail</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br><br><span class="hljs-selector-class">.left-detail</span> <span class="hljs-selector-class">.item-rate</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: flex-start;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.item-rate</span> <span class="hljs-selector-class">.comment-persons</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">28</span>rpx;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ccc</span>;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br><br><span class="hljs-selector-class">.item-detail</span> <span class="hljs-selector-class">.right-detail</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200</span>rpx;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300</span>rpx;<br>&#125;<br><br><span class="hljs-selector-class">.right-detail</span> image &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.item-sub-detail</span> &#123;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>&#125;<br><br><span class="hljs-selector-class">.item-sub-detail</span> view &#123;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">10</span>rpx;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>效果图</p><p><img src="/image/18.3.png" alt="效果图片"></p><h4 id="标签布局和样式完成"><a href="#标签布局和样式完成" class="headerlink" title="标签布局和样式完成"></a>标签布局和样式完成</h4><p><img src="/image/18.4.png" alt="样式"></p><p>detail.wxml代码</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-tags&quot;&gt;<br>  &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-tags-title&quot;&gt;豆瓣成员常用标签&lt;/<span class="hljs-keyword">view</span>&gt;<br>  &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-tags-list&quot;&gt;<br>    &lt;<span class="hljs-type">text</span>&gt;黑色幽默&lt;/<span class="hljs-type">text</span>&gt;&lt;<span class="hljs-type">text</span>&gt;小人物&lt;/<span class="hljs-type">text</span>&gt;&lt;<span class="hljs-type">text</span>&gt;戏剧&lt;/<span class="hljs-type">text</span><br>    &gt;&lt;<span class="hljs-type">text</span>&gt;方言&lt;/<span class="hljs-type">text</span>&gt;&lt;<span class="hljs-type">text</span>&gt;中国大陆&lt;/<span class="hljs-type">text</span>&gt;&lt;<span class="hljs-type">text</span>&gt;人性&lt;/<span class="hljs-type">text</span><br>    &gt;&lt;<span class="hljs-type">text</span>&gt;剧情&lt;/<span class="hljs-type">text</span>&gt;<br>  &lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br></code></pre></td></tr></table></figure><p>detail.wxss代码</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.item-tags-title</span>&#123;<br>  <span class="hljs-comment">/* 设置元素的下外边距 */</span><br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">10</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.item-tags</span>&#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">30</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.item-tags</span> <span class="hljs-selector-class">.item-tags-title</span>&#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#b3b3b3</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>  <span class="hljs-attribute">margin-bottom</span>:<span class="hljs-number">20</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.item-tags</span> <span class="hljs-selector-class">.item-tags-list</span>&#123;<br>  <span class="hljs-attribute">display</span>:flex;<br>  <span class="hljs-attribute">justify-content</span>: flex-start;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>&#125;<br><span class="hljs-selector-class">.item-tags-list</span> text&#123;<br>  <span class="hljs-attribute">padding</span>:<span class="hljs-number">10</span>rpx <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#f5f5f5</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>  <span class="hljs-attribute">columns</span>: <span class="hljs-number">#353535</span>;<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="详情页布局完成"><a href="#详情页布局完成" class="headerlink" title="详情页布局完成"></a>详情页布局完成</h4><p>分析：</p><p><img src="/image/18.5.png" alt="要完成的样式"></p><p>detail.wxml</p><p>这里的头像图片和文字我们先从豆瓣网获取，方便页面布局显示</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cos">&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;comment-list-group&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;comment-title&quot;</span>&gt;短评(<span class="hljs-number">202220297</span>)&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;comment-group&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;left-comment&quot;</span>&gt;<br>&lt;image  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;avatar&quot;</span> src=<span class="hljs-string">&quot;https://img3.doubanio.com/icon/u218767230-1.jpg&quot;</span>&gt;&lt;/image&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;right-comment&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;username-rate&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;羚锐&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;stars  rate=<span class="hljs-string">&quot;5&quot;</span> starsize=<span class="hljs-string">&quot;30&quot;</span> istext=<span class="hljs-string">&quot;&#123;&#123;false&#125;&#125;&quot;</span> &gt;&lt;/stars&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;release-time&quot;</span>&gt;<span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">03</span>   <span class="hljs-number">12</span>:<span class="hljs-number">22</span>:<span class="hljs-number">22</span>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;这部纪录片上映也等了很久，就像这段历史被揭开的时间也是等待了太久，<br>这几个人的人生或许仍然不能被探索清楚，但至少已经开始被发掘，其实这不仅是关于八个中国乘客，也是那一代华人移民故事，方的故事尤为震撼，<br>一个从冰海里挣扎出来的幸存者，又如此努力在美国讨生活还要帮助亲友，他的故事比电影更加传奇。<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br><br> &lt;navigator <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;more-comment&quot;</span>&gt;查看更多短评&lt;/navigator&gt;<br></code></pre></td></tr></table></figure><p>detail.wxss</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.comment-list-group</span>&#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">60</span>rpx <span class="hljs-number">30</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.comment-list-group</span>  <span class="hljs-selector-class">.comment-title</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#b3b3b3</span>;<br>&#125;<br><span class="hljs-comment">/* 左边固定，右边内容适配 */</span><br><span class="hljs-selector-class">.comment-list-group</span>  <span class="hljs-selector-class">.comment-group</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: flex-start;<br>  <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">40</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.comment-group</span> <span class="hljs-selector-class">.left-comment</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">70</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.left-comment</span>  <span class="hljs-selector-class">.avatar</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">70</span>rpx;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">70</span>rpx;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>&#125;<br><span class="hljs-selector-class">.comment-group</span>  <span class="hljs-selector-class">.right-comment</span>&#123;<br>  <span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-selector-class">.right-comment</span>   <span class="hljs-selector-class">.username-rate</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: flex-start;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br><span class="hljs-selector-class">.username-rate</span> <span class="hljs-selector-class">.username</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">36</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.release-time</span>&#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#b3b3b3</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">10</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.content</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#353535</span>;<br>  <span class="hljs-attribute">margin-top</span>:<span class="hljs-number">10</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.more-comment</span>&#123;<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">36</span>rpx;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#41be57</span>;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">60</span>rpx;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：星星这里出现了评分数字</p><p><img src="/image/18.6.png" alt="要完成的样式"></p><p>解决：</p><p>在stars.js文件中定义一个属性，是否需要文本</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">istext:</span>&#123;<br><span class="hljs-symbol">  type:</span>Boolean,<br><span class="hljs-symbol">  value:</span>true<br>&#125;<br></code></pre></td></tr></table></figure><p>stars.wxml中<br><img src="/image/18.7.png" alt="代码添加判断"></p><p>detail.wxml代码</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">stars</span>  <span class="hljs-attr">rate</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">starsize</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">istext</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">false</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">stars</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/image/18.8.png" alt="页面完成"></p><h2 id="以下是将详情页的数据转换为真实从网上获取的数据"><a href="#以下是将详情页的数据转换为真实从网上获取的数据" class="headerlink" title="以下是将详情页的数据转换为真实从网上获取的数据"></a>以下是将详情页的数据转换为真实从网上获取的数据</h2><h3 id="详情页入口参数设置"><a href="#详情页入口参数设置" class="headerlink" title="详情页入口参数设置"></a>详情页入口参数设置</h3><ol><li>分析：进入详情页面有多种途径，1从首页中电影，电视剧，综艺都可以进入，2从列表页面也可以点击进入</li></ol><p>所以我们要对点击进入详情页面进行入口设置，因为(电影，电视剧，综艺)三个的url类型是不同的，所以获取详情页前要传递类型和item的id过去，告诉它我们传递的类型和id</p><ol start="2"><li>接下来我们来到首页index.wxml中，发现页面是在indexmodul中，而页面是写在itemview中</li></ol><p>之前我们只是在itemview中写了一些样式，并没有跳转的链接</p><p>itemview.js中定义类型</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">itemurl:</span>&#123;<br><span class="hljs-symbol">  type:</span>String,<br><span class="hljs-symbol">  value:</span><span class="hljs-string">&quot;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>itemview.wxml url跳转链接</p><p><img src="/image/18.9.png" alt="url"></p><ol start="3"><li>indexmodule设置跳转页面</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">itemview</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">items</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>  <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>  <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> </span></span><br><br><span class="xml">itemurl=&quot;/pages/detail/detail?type=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">type</span>&#125;&#125;</span><span class="xml">&amp;id=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.id</span>&#125;&#125;</span><span class="xml">&quot;</span><br><span class="xml">&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">itemview</span>&gt;</span>  </span><br></code></pre></td></tr></table></figure><ul><li>可以实现，但是我们还需要传递两个参数 type和id(通过查询字符串的方式?)</li></ul><p>indexmodule.js  属性设置</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">type</span>:&#123;<br>  <span class="hljs-keyword">type</span>:<span class="hljs-keyword">String</span>,<br>  value:<span class="hljs-string">&quot;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以后在使用这个组件的时候要传递一个字符串type进来，index页面中。</p><p><img src="/image/18.10.png" alt="type"></p><ul><li>id 的传递—item中有一个属性id</li></ul><p>id=</p><p>首页中点击可以获取到数据</p><p><img src="/image/18.11.png" alt="console"></p><ol start="4"><li>列表页面实现获取list</li></ol><p>它直接使用的就是itemview,所以我们就只需要传递url</p><p>list.js</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pony"><span class="hljs-keyword">var</span>  that= <span class="hljs-literal">this</span>;<br><span class="hljs-keyword">var</span>  <span class="hljs-keyword">type</span> = options.<span class="hljs-keyword">type</span>;<br>that.setData(&#123;<br>  <span class="hljs-keyword">type</span>:<span class="hljs-keyword">type</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><img src="/image/18.12.png" alt="console"></p><p>点击type和id都能获取</p><h3 id="详情页item详情数据获取"><a href="#详情页item详情数据获取" class="headerlink" title="详情页item详情数据获取"></a>详情页item详情数据获取</h3><p>详情页面参数已经可以获取了</p><ol><li><p>detail.js </p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span>  <span class="hljs-keyword">type</span> =options.<span class="hljs-keyword">type</span>;<br><span class="hljs-keyword">var</span>  id=options.id;<br></code></pre></td></tr></table></figure></li><li><p>导入详情页面的三个url到url.js中</p></li></ol><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">movieDetail:</span> <span class="hljs-string">&quot;https://m.douban.com/rexxar/api/v2/movie/&quot;</span>,<br><span class="hljs-symbol">tvDetail:</span> <span class="hljs-string">&quot;https://m.douban.com/rexxar/api/v2/tv/&quot;</span>,<br><span class="hljs-symbol">showDetail:</span> <span class="hljs-string">&quot;https://m.douban.com/rexxar/api/v2/tv/&quot;</span>,<br></code></pre></td></tr></table></figure><ol start="3"><li>network.js 文件中定义一个新的函数来获取网络请求</li></ol><p><img src="/image/18.13.png" alt="获取网络请求"></p><p>最后成功获取通过success函数回调返回item</p><ol start="4"><li>detail.js中导入network</li></ol><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span>  &#123;network&#125;  <span class="hljs-keyword">from</span>  <span class="hljs-string">&quot;../../utils/network&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/image/18.14.png" alt="获取打印数据"></p><p>此时点击首页一个数据发现控制台200的状态并打印了数据，发现通过url可以获取到数据</p><h3 id="详情页面item数据渲染"><a href="#详情页面item数据渲染" class="headerlink" title="详情页面item数据渲染"></a>详情页面item数据渲染</h3><h4 id="将获取到的item的数据设置到界面上"><a href="#将获取到的item的数据设置到界面上" class="headerlink" title="将获取到的item的数据设置到界面上"></a>将获取到的item的数据设置到界面上</h4><ol><li>detail.js中保存data数据</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">var</span> <span class="hljs-literal">that</span>  =<span class="hljs-built_in">this</span>;<br><br>  <span class="hljs-literal">that</span>.setData(&#123;<br>              item:item<br>            &#125;)<br> <span class="hljs-regexp">// console.log(item)  //</span>打印查看数据列表<br></code></pre></td></tr></table></figure><p><img src="/image/18.15.png" alt="控制台数据答应"></p><ol start="2"><li>detail.wxml中修改</li></ol><p><img src="/image/18.17.png" alt="修改位置"></p><ol start="3"><li>detail.js中代码</li></ol><p><img src="/image/18.16.png" alt="部分细节处理"></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs axapta">onLoad: function (options) &#123;<br>        <span class="hljs-built_in">var</span> that  =<span class="hljs-keyword">this</span>;<br>        <span class="hljs-built_in">var</span>  type =options.type;<br>        <span class="hljs-built_in">var</span>  id=options.id;<br><br>        network.getItemDetail(&#123;<br>          type:type,<br>          id:id,<br>          success:function(item)&#123;<br>            <span class="hljs-built_in">var</span>  genres= item.genres;<br>           <span class="hljs-comment">//字符串拼接  电影类型</span><br>           genres = genres.<span class="hljs-keyword">join</span>(<span class="hljs-string">&quot;/&quot;</span>);<br>           item.genres = genres;<br><br>           <span class="hljs-built_in">var</span>   actors = item.actors;<br>           <span class="hljs-built_in">var</span>  actorNames = [];<br>             <span class="hljs-comment">//slice函数截取数组的一部分，slice(0,3)左闭右开取(0,1,2)，演员数组太多，取三个返回</span><br>           <span class="hljs-keyword">if</span>(actors.length&gt;<span class="hljs-number">3</span>)&#123;<br>             actors = actors.slice(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);<br>           &#125;<br>        <span class="hljs-comment">//    for循环压入数组中</span><br>           <span class="hljs-keyword">for</span>(<span class="hljs-built_in">var</span>  <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;<span class="hljs-keyword">index</span>&lt;actors.length;<span class="hljs-keyword">index</span>++)&#123;<br>             <span class="hljs-built_in">var</span>  actor  = actors[<span class="hljs-keyword">index</span>];<br>             actorNames.push(actor.name);<br>           &#125;<br>           actorNames = actorNames.<span class="hljs-keyword">join</span>(<span class="hljs-string">&quot;/&quot;</span>);<br>           <span class="hljs-built_in">var</span>  director  = item.directors[<span class="hljs-number">0</span>].name;<br>           <span class="hljs-built_in">var</span>  authors = director+<span class="hljs-string">&quot;(导演)/&quot;</span>+actorNames;<br>           item.authors = authors;<br><br>            that.setData(&#123;<br>              item:item<br>            &#125;)<br>           <span class="hljs-comment">// console.log(item)</span><br>          &#125;<br>        &#125;);<br> &#125;<br></code></pre></td></tr></table></figure><p><img src="/image/18.18.png" alt="页面数据可以从网络上请求改变"></p><h4 id="标签完成"><a href="#标签完成" class="headerlink" title="标签完成"></a>标签完成</h4><p>标签数据获取与数据渲染</p><p><img src="/image/18.19.png" alt="如图"></p><ol><li>url.js设置</li></ol><p><img src="/image/18.20.png" alt="url设置"></p><ol start="2"><li>network.js函数设置</li></ol><p><img src="/image/18.21.png" alt="network.js"></p><ol start="3"><li>detail.js中触发该函数</li></ol><p>tags用来接收调用network.js中函数返回传的参数</p><p><img src="/image/18.22.png" alt="detail.js"></p><ol start="4"><li>修改detail.wxml代码</li></ol><p>wx:for循环中，默认的下标名称的index,默认的值的名称的item</p><p><img src="/image/18.23.png" alt="wx:for"></p><h4 id="详情页短评数据获取与渲染"><a href="#详情页短评数据获取与渲染" class="headerlink" title="详情页短评数据获取与渲染"></a>详情页短评数据获取与渲染</h4><ol><li>url链接获取</li></ol><p>url.js代码</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xquery">// 默认传一个<span class="hljs-keyword">start</span>=<span class="hljs-number">0</span><span class="hljs-built_in">,count</span> =<span class="hljs-number">3</span><br>movieComments: <span class="hljs-keyword">function</span><span class="hljs-built_in">(id</span>,<span class="hljs-keyword">start</span>=<span class="hljs-number">0</span><span class="hljs-built_in">,count</span>=<span class="hljs-number">3</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;https://m.douban.com/rexxar/api/v2/movie/&#x27;</span> +<span class="hljs-built_in"> id</span> + <span class="hljs-string">&#x27;/interests?count=&#x27;</span> +<span class="hljs-built_in"> count</span> + <span class="hljs-string">&#x27;&amp;start=&#x27;</span> + <span class="hljs-keyword">start</span>;<br>&#125;,<br>tvComments: <span class="hljs-keyword">function</span><span class="hljs-built_in">(id</span>,<span class="hljs-keyword">start</span>=<span class="hljs-number">0</span><span class="hljs-built_in">,count</span>=<span class="hljs-number">3</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;https://m.douban.com/rexxar/api/v2/tv/&#x27;</span> +<span class="hljs-built_in"> id</span> + <span class="hljs-string">&#x27;/interests?count=&#x27;</span> +<span class="hljs-built_in"> count</span> + <span class="hljs-string">&#x27;&amp;start=&#x27;</span> + <span class="hljs-keyword">start</span>;<br>&#125;,<br>showComments: <span class="hljs-keyword">function</span><span class="hljs-built_in">(id</span>,<span class="hljs-keyword">start</span>=<span class="hljs-number">0</span><span class="hljs-built_in">,count</span>=<span class="hljs-number">3</span>)&#123;<br>  <span class="hljs-keyword">return</span> this.tvComments<span class="hljs-built_in">(id</span>,<span class="hljs-keyword">start</span><span class="hljs-built_in">,count</span>);<br>&#125;,<br><br></code></pre></td></tr></table></figure><ol start="2"><li>network.js写一个获取网络请求的接口</li></ol><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">// 获取短评</span><br>  getItemComments:function(<span class="hljs-keyword">params</span>)&#123;<br>    <span class="hljs-built_in">var</span>  <span class="hljs-keyword">type</span> =<span class="hljs-keyword">params</span>.<span class="hljs-keyword">type</span>;<br>    <span class="hljs-built_in">var</span>  id= <span class="hljs-keyword">params</span>.id;<br>    <span class="hljs-built_in">var</span>  start = <span class="hljs-keyword">params</span>.start?<span class="hljs-keyword">params</span>.start:<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">var</span> count  = <span class="hljs-keyword">params</span>.count?<span class="hljs-keyword">params</span>.count:<span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">var</span>  url=<span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;movie&#x27;</span>)&#123;<br>      url = globalurls.movieComments(id,start,count);<br>    &#125;<span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">type</span> ===<span class="hljs-string">&#x27;tv&#x27;</span>)&#123;<br>      url = globalurls.tvComments(id,start,count);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      url  =globalurls.showComments(id,start,count);<br>    &#125;<br>    wx.request(&#123;<br>      url:url,<br>      success:function(res)&#123;<br>        <span class="hljs-built_in">var</span>  <span class="hljs-built_in">data</span>  =res.<span class="hljs-built_in">data</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">params</span>.success)&#123;<br>          <span class="hljs-keyword">params</span>.success(<span class="hljs-built_in">data</span>);<br>        &#125;<br>      &#125;<br>    &#125;)<br>  &#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>detail页面调用 detail.js文件种</li></ol><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">//  获取评论</span><br>network.getItemComments(&#123;<br>  <span class="hljs-keyword">type</span>:<span class="hljs-keyword">type</span>,<br>  id:id,<br>  success:function(<span class="hljs-built_in">data</span>)&#123;<br>    <span class="hljs-built_in">var</span>  totalComment = <span class="hljs-built_in">data</span>.total;<br>    <span class="hljs-built_in">var</span>  comments= <span class="hljs-built_in">data</span>.interests;<br>    that.setData(&#123;<br>      totalComment:totalComment,<br>      comments:comments<br>    &#125;)<br>    <span class="hljs-comment">// console.log(data)</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="4"><li><p>控制台能够打印200状态，并获取到data</p></li><li><p>数据渲染到detail.wxml种</p></li></ol><p>变量修改</p><p><img src="/image/18.24.png" alt="wxml代码修改"></p><ol start="6"><li>页面效果</li></ol><p><img src="/image/18.25.png" alt="真实数据"></p>]]></content>
    
    
    <categories>
      
      <category>WX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WX</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>豆瓣&amp;itemview重构&amp;列表数据渲染成真实数据</title>
    <link href="/2021/04/22/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E4%B8%89)/"/>
    <url>/2021/04/22/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="电影列表页面布局"><a href="#电影列表页面布局" class="headerlink" title="电影列表页面布局"></a>电影列表页面布局</h3><h4 id="itemview重构"><a href="#itemview重构" class="headerlink" title="itemview重构"></a>itemview重构</h4><p>分析：首页和更多页面的布局基本一样，所以我们可以将首页布局代码拿过来直接用         </p><p>(我们在代码的时候发现有些东西是重复的，我们可以将代码单独抽取出来，然后再哪个地方需要使用的时候再引用，这样相当于对代码进行了重构，方便后期对代码进行管理)</p><p><img src="/image/17.1.png" alt="首页代码"></p><ol><li>首页代码在indexmodul组件中，所以我们去该组价中再进行代码优化</li></ol><ol start="2"><li><p>在components中新建一个itemview组件</p></li><li><p>将indexmodule.wxml中的代码剪切到itemview.wxml中</p></li></ol><p>navigator也可以拿过去，因为后期我们点击一个电影也会跳转到详情页面中</p><p><img src="/image/17.2.png" alt="itemview.wxml"></p><ol start="4"><li>将样式代码页抽取到itemview.wxss中</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs css"> <span class="hljs-selector-class">.item-navigator</span>&#123;<br>  <span class="hljs-attribute">width</span>:<span class="hljs-number">200</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>&#125;<br><br><span class="hljs-selector-class">.item-navigator</span>  <span class="hljs-selector-class">.item-group</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.item-group</span> <span class="hljs-selector-class">.thumbnail-group</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">284</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.thumbnail-group</span> <span class="hljs-selector-class">.thumbnail</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><span class="hljs-selector-class">.item-group</span> <span class="hljs-selector-class">.item-title</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">28</span>rpx;<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-comment">/* 文本过长处理 */</span><br>  <span class="hljs-attribute">text-overflow</span>:ellipsis;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="5"><li>展示items，应该要传一个items属性过来</li></ol><p><img src="/image/17.3.png" alt="问题"></p><p>解决： 在itemsview.js文件中</p><p><img src="/image/17.4.png" alt="属性"></p><ol start="6"><li>注册组件</li></ol><p><img src="/image/17.5.png" alt="注册组件"></p><ol start="7"><li>使用组件</li></ol><p><img src="/image/17.6.png" alt="使用组件"></p><ol start="8"><li>问题</li></ol><p>右边距没有了</p><p><img src="/image/17.7.png" alt="问题"></p><p>解决：我们把itemview单独放在一个当中使用了，所以item-navigator只有一个则last-of-type就是它本身<br>将该代码删除就可以了</p><p><img src="/image/17.8.png" alt="解决"></p><ol start="9"><li>此时星星组件不见了，将星星组件放到itemview.json文件中使用</li></ol><p><img src="/image/17.9.png" alt="解决"></p><p>以上操作方便了我们后期布局</p><h4 id="创建列表页"><a href="#创建列表页" class="headerlink" title="创建列表页"></a>创建列表页</h4><ol><li>创建列表页面</li></ol><p>在app.json中添加该行代码保存就会自动创建页面</p><p><img src="/image/17.10.png" alt="创建页面"></p><ol start="2"><li><p>分析：电影，电视剧，综艺三个列表页面都是相同的样式，唯独不一样的是数据，所以我们完全没有必要为这三个弄三个单独的页面。我们完全可以使用同一个页面，后期我们传不同的参数过去，告诉它我现在要获取电影，电视剧，综艺.这样可以达到重用。</p></li><li><p>列表页入口</p></li></ol><p>应该有一个入口可以来到列表页–更多</p><p>在首页添加url</p><p><img src="/image/17.11.png" alt="moreurl"></p><ol start="4"><li>列表页搜索栏<br>列表页也应该有搜索栏,将之前的searchbar组件拿过来使用</li></ol><p>注册list.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;searchbar&quot;</span>:<span class="hljs-string">&quot;/components/searchbar/searchbar&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 list.wxml</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">searchbar</span>  <span class="hljs-attr">isnavigator</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">true</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">searchbar</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这时候列表页出现了搜索栏</p><ol start="5"><li>电影排列–flex布局</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">itemview</span>  <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">items</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>  <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>  <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">itemview</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>由于.container在app.wxss中存在，这里我们将app.wxss代码删除掉</p><ol start="6"><li>电影数据获取</li></ol><p>在list.js的onLoad函数中调用电影列表数据</p><ul><li>导入network.js</li></ul><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> &#123;network&#125;  <span class="hljs-keyword">from</span>  <span class="hljs-string">&quot;../../utils/network.js&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><p>请求数据</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">onLoad: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(options)</span> </span>&#123;<br>    <span class="hljs-keyword">var</span>  that= <span class="hljs-keyword">this</span>;<br>          <span class="hljs-comment">// 请求的电影数据</span><br>      network.getMovieList(&#123;<br>        success:<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(items)</span></span>&#123;<br>          that.setData(&#123;<br>            items: items<br>          &#125;);    <br>        &#125;&#125;<br></code></pre></td></tr></table></figure></li><li><p>css样式</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: space-between;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">30</span>rpx;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="列表数据渲染成真实数据"><a href="#列表数据渲染成真实数据" class="headerlink" title="列表数据渲染成真实数据"></a>列表数据渲染成真实数据</h3><ol><li>分析：电影，电视剧，综艺用的都是list页面中的，这时候我们要怎么去区分它呢？</li></ol><p>我们可以在首页index中传一个参数过去，当点击更多的时候，我们list页面得到这个参数就可以根据参数发送不同的请求</p><p>传递参数</p><p><img src="/image/17.12.png" alt="type"></p><p>list.js中接收参数</p><p><img src="/image/17.13.png" alt="接收"></p><ol start="2"><li>怎么能够获取所有正在热映的电影，电视剧，综艺？</li></ol><p>分析：我们在首页中就已经写过网络请求的代码，不过我们写的count=7,我们现在要获取所有的数据，之前的代码也可以重用。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lasso"> wx.request(&#123;<br>   <span class="hljs-comment">//  豆瓣电影接口</span><br>    url: globalurls.movieList,<br>    <span class="hljs-built_in">data</span>:&#123;<br>      count:count<br>     &#125;,<br>    success:function(res)&#123;<br>     <span class="hljs-comment">// console.log(res)</span><br>      <span class="hljs-built_in">var</span>   movies = res.<span class="hljs-built_in">data</span>.subjects;<br>       <span class="hljs-keyword">if</span>(<span class="hljs-keyword">params</span> &amp;&amp; <span class="hljs-keyword">params</span>.success)&#123;<br>         <span class="hljs-keyword">params</span>.success(movies)<br>       &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>解决：将network.js文件进行重构<br>我们network.js 文件在list文件中也用的到，所以放在全局文件中比较合适，可以放在utils中。网络请求代码不是很多，所以我们这里放在一个文件中是可以的。</p><ol start="3"><li>在utils中新建一个network.js文件</li></ol><p>将原来的network.js文件代码拷贝过来，原来文件可以删除了</p><p>此时将所有相关引用路径更改</p><p>network.js代码</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs sqf">import  &#123;globalurls&#125;  <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;urls.js&quot;</span><br><br>const  network=&#123;<br>  <br>getMovieList:function(<span class="hljs-built_in">params</span>)&#123;<br><span class="hljs-built_in">params</span>.<span class="hljs-built_in">type</span>= <span class="hljs-string">&quot;movie&quot;</span>;<br>this.getItemList(<span class="hljs-built_in">params</span>);<br>&#125;,<br>getTVList:function(<span class="hljs-built_in">params</span>)&#123;<br>    <span class="hljs-built_in">params</span>.<span class="hljs-built_in">type</span>= <span class="hljs-string">&quot;tv&quot;</span>;<br>    this.getItemList(<span class="hljs-built_in">params</span>);<br>     &#125; ,<br>getShowList: function(<span class="hljs-built_in">params</span>)&#123;<br>    <span class="hljs-built_in">params</span>.<span class="hljs-built_in">type</span>= <span class="hljs-string">&quot;show&quot;</span>;<br>    this.getItemList(<span class="hljs-built_in">params</span>);<br>&#125;,<br><br><br><span class="hljs-comment">// 获取item列表 params获取传递参数type</span><br>getItemList:function(<span class="hljs-built_in">params</span>)&#123;<br>  <span class="hljs-comment">// 获取不同url</span><br>  var  url=<span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">params</span>.<span class="hljs-built_in">type</span> === <span class="hljs-string">&quot;movie&quot;</span>)&#123;<br>    url= globalurls.movieList;<br>  &#125;<span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">params</span>.<span class="hljs-built_in">type</span>===<span class="hljs-string">&quot;tv&quot;</span>)&#123;<br>    url = globalurls.tvList;<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    url= globalurls.showList;<br>  &#125;<br>  var <span class="hljs-built_in">count</span> = <span class="hljs-built_in">params</span>.<span class="hljs-built_in">count</span> ? <span class="hljs-built_in">params</span>.<span class="hljs-built_in">count</span> : <span class="hljs-number">7</span>;<br>  wx.request(&#123;<br>    <span class="hljs-comment">//  豆瓣电影接口</span><br>     url: url,<br>     data:&#123;<br>       <span class="hljs-built_in">count</span>:<span class="hljs-built_in">count</span><br>     &#125;,<br>     success:function(res)&#123;<br>    <span class="hljs-comment">// item代表所有的项</span><br>       var   <span class="hljs-built_in">items</span> =res.data.subject_collection_items;<br>       var  itemsCount = <span class="hljs-built_in">items</span>.length;<br>       var  left = itemsCount%<span class="hljs-number">3</span>;<br>       <span class="hljs-keyword">if</span>(left===<span class="hljs-number">2</span>)&#123;<br>         <span class="hljs-built_in">items</span>.push(null);<br>       &#125;<br>       <span class="hljs-keyword">if</span>(<span class="hljs-built_in">params</span> &amp;&amp; <span class="hljs-built_in">params</span>.success)&#123;<br>        <span class="hljs-comment">//  将items传出</span><br>        <span class="hljs-built_in">params</span>.success( <span class="hljs-built_in">items</span>)<br>      &#125;<br>     &#125;,<br> &#125;);<br>&#125;<br>&#125;<br><br>export  &#123;network&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>在list.js中请求网络</li></ol><p>修改引入路径<br>import {network}  from  “../../utils/network.js”;</p><p>list.js代码</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs sqf">onLoad: function (options) &#123;<br>   var  that= this;<br>   var  <span class="hljs-built_in">type</span> = options.<span class="hljs-built_in">type</span>;<br>   var  title =<span class="hljs-string">&quot;&quot;</span>;<br>   <span class="hljs-comment">// 数据加载前</span><br>   wx.showLoading(&#123;<br>     title: <span class="hljs-string">&#x27;正在加载中...&#x27;</span>,<br>   &#125;)<br>   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">type</span> === <span class="hljs-string">&quot;movie&quot;</span>)&#123;<br>     <span class="hljs-comment">// 请求的电影数据</span><br>     network.getMovieList(&#123;<br>       success:function(<span class="hljs-built_in">items</span>)&#123;<br>         that.setData(&#123;<br>           <span class="hljs-built_in">items</span>: <span class="hljs-built_in">items</span><br>         &#125;);<br>         <span class="hljs-comment">// 数据加载完成</span><br>           wx.hideLoading();<br>       &#125;,<br>       <span class="hljs-comment">// 确保获取到所有数据</span><br>             <span class="hljs-built_in">count</span>:<span class="hljs-number">1000</span><br>     &#125;)<br>    title= <span class="hljs-string">&quot;电影&quot;</span><br>   &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">type</span>=== <span class="hljs-string">&quot;tv&quot;</span>)&#123;<br>     <span class="hljs-comment">// 请求电视剧的数据</span><br>     network.getTVList(&#123;<br>       success:function(<span class="hljs-built_in">items</span>)&#123;<br>         that.setData(&#123;<br>           <span class="hljs-built_in">items</span>: <span class="hljs-built_in">items</span><br>         &#125;);<br>         wx.hideLoading();<br>       &#125;,<br>       <span class="hljs-built_in">count</span>:<span class="hljs-number">1000</span><br>     &#125;);<br>     title = <span class="hljs-string">&quot;电视剧&quot;</span><br>   &#125;<span class="hljs-keyword">else</span>  &#123;<br>     <span class="hljs-comment">//请求综艺的数据</span><br>     network.getShowList(&#123;<br>       success:function(<span class="hljs-built_in">items</span>)&#123;<br>         that.setData(&#123;<br>           <span class="hljs-built_in">items</span>: <span class="hljs-built_in">items</span><br>         &#125;);<br>         wx.hideLoading();<br>       &#125;,<br>       <span class="hljs-built_in">count</span>:<span class="hljs-number">1000</span><br>     &#125;);<br>     title=<span class="hljs-string">&quot;综艺&quot;</span>;<br>   &#125;<br>   wx.setNavigationBarTitle(&#123;<br>     title:title,<br>   &#125;)<br> &#125;<br></code></pre></td></tr></table></figure><p>问题：发现页面不显示但是也没有报错，说明数据获取了但是没有渲染</p><p>问题：将原来的movies修改为items</p><p><img src="/image/17.14.png" alt="问题"></p><ol start="5"><li>优化</li></ol><p>当点击更多之后(电影，电视剧，综艺)三个上方均显示为豆瓣评分，这时候我们需要考虑到用户体验，将上面的数据进行修改。</p><p><img src="/image/17.15.png" alt="优化"></p><p>解决：在list.js文件中</p><p>微信的函数设置</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss">wx.setNavigationBarTitle(&#123;<br>  <span class="hljs-built_in">title</span>:<span class="hljs-built_in">title</span>,<br>&#125;)<br></code></pre></td></tr></table></figure><p>函数上面定义一个title</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">var  title</span> =<span class="hljs-string">&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="/image/17.16.png" alt="根据请求数据改变title"></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ol><li>如果底部剩余两个item就会出现一下情况，因为是flex布局</li></ol><p><img src="/image/17.17.png" alt="左右各一个,中间空"></p><ol start="2"><li>分析：</li></ol><ul><li>在主轴上的那布局排列总共有5中</li><li>1从左到右排列，最下面的可以但是上面的可能排列就不那么好看了，因为它的中间的间距你不好掌握</li><li>2中间间距相等的方式也不这么好，页面排列也不那么好看</li></ul><p>什么时候会产生这个问题，就是底部余2个，余1余活3个都不会产生</p><p>解决：这时候我们要迎合flex布局方式，在数据渲染的时候判断数据对3取余是不是等于2</p><p>当然我们还要对index页面进行分析，因为index页面也调用了network.js,因为首页是得到了7个数据，对3取余为1，所以对network.js处理是不会对页面有影响的。</p><p>代码解决network.js</p><p>如果余2就添加一个空的数据</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">var</span>  itemsCount = items.length;<br><span class="hljs-built_in">var</span>  <span class="hljs-built_in">left</span> = itemsCount%<span class="hljs-number">3</span>;<br><span class="hljs-built_in">if</span>(<span class="hljs-built_in">left</span>===<span class="hljs-number">2</span>)&#123;<br>  items.push(null);<br>&#125;<br></code></pre></td></tr></table></figure><p>新问题：出现一个未评分</p><p><img src="/image/17.18.png" alt="新问题"></p><p>解决：在itemview中判断是否传入值</p><p><img src="/image/17.19.png" alt="item解决"></p><ol start="3"><li>页面加载优化</li></ol><p>数据加载需要时间，如果长时间没有加载出来，用户体验会不好，会损失用户。</p><p>处理：调用小程序Api实现，</p><p><img src="/image/17.20.png" alt="三个同时作用"></p>]]></content>
    
    
    <categories>
      
      <category>WX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WX</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>豆瓣&amp;首页布局和数据获取&amp;首页模块重构&amp;网络请求模块重构</title>
    <link href="/2021/04/21/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
    <url>/2021/04/21/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="首页布局和数据获取"><a href="#首页布局和数据获取" class="headerlink" title="首页布局和数据获取"></a>首页布局和数据获取</h3><ol><li>将电影中假的数据变成真的数据(wx.request请求Api)</li></ol><p>首页js文件中获取，在onLoad中请求数据，这个页面一旦加载完毕就去请求</p><p>index.js</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs awk">/*<br>*生命周期函数-监听页面加载<br>*/<br>onLoad:<span class="hljs-keyword">function</span>(options)&#123;<br>  <span class="hljs-regexp">//</span> that方便后期使用当前Page对象<br>   var  that = this;<br>  <span class="hljs-regexp">//</span>  top20电影<br>   wx.request(&#123;<br>    <span class="hljs-regexp">//</span>  豆瓣电影接口<br>     url: <span class="hljs-string">&#x27;https://api.rixingyike.com/doubanapiv2/movie/top250?start=0&amp;count=10&#x27;</span>,<br>     success:<span class="hljs-keyword">function</span>(res)&#123;<br>      <span class="hljs-regexp">//</span> console.log(res)<br>       var   movies = res.data.subjects;<br>      <span class="hljs-regexp">//</span>  console.log(movies);<br>      &lt;!-- 保存movies数据 --&gt;<br>       that.setData(&#123;<br>         movies: movies<br>       &#125;);<br>    <br>     &#125;,<br> &#125;)<br>    <span class="hljs-regexp">//</span>  正在热映的电影<br>    wx.request(&#123;<br>      <span class="hljs-regexp">//</span>  豆瓣电影接口<br>       url: <span class="hljs-string">&#x27;https://api.rixingyike.com/doubanapiv2/movie/in_theaters?start=0&amp;count=10&#x27;</span>,<br>       success:<span class="hljs-keyword">function</span>(res)&#123;<br>        <span class="hljs-regexp">//</span> console.log(res)<br>         var   tvs = res.data.subjects;<br>         that.setData(&#123;<br>           tvs:tvs<br>         &#125;);<br>       &#125;,<br>   &#125;),<br>  <span class="hljs-regexp">//</span>  即将上映的电影<br>  wx.request(&#123;<br>    <span class="hljs-regexp">//</span>  豆瓣电影接口<br>     url: <span class="hljs-string">&#x27;https://api.rixingyike.com/doubanapiv2/movie/coming_soon?start=0&amp;count7&#x27;</span>,<br>     success:<span class="hljs-keyword">function</span>(res)&#123;<br>      <span class="hljs-regexp">//</span> console.log(res)<br>       var   shows = res.data.subjects;<br>       that.setData(&#123;<br>       shows:shows<br>       &#125;);<br>     &#125;,<br> &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/16.9.png" alt="数据放置,其他类型同理"></p><ol start="2"><li><p>由于豆瓣Api不对外开放，以上Api是我从网上得到进行处理的，部分数据加载不出来。</p></li><li><p>测试版本微信要勾选不校验合法域名才能网上获取数据</p></li></ol><p><img src="/image/16.10.png" alt="勾选不校验合法域名"></p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><blockquote><p>wx:key作用：<br>如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如<code> &lt;input/&gt;</code> 中的输入内容， <code>&lt;switch/&gt; </code>的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。<br>wx:key 的值以两种形式提供：                      </p></blockquote><ol><li>字符串或者数字，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。在写的时候，直接写这个 property 的名字就可以了，不需要写 item.property 的形式，并且不需要加中括号。                        </li><li>保留关键字 this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，*框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。</li></ol><blockquote><p>setData<br>如果以后想要修改 data 中的值，应该使用 setData 方法。 setData 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）。注意事项：</p></blockquote><ol><li>直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致。      </li><li>放到 data 中的值，只能使用可以 JSON 序列化的：字符串，数字，布尔值，对象，数组。否则将不会渲染。          </li><li>其中 key 可以以数据路径的形式给出，支持改变数组中的某一项或对象的某个属性，如<br>array[2].message ， a.b.c.d ，并且不需要在 this.data 中预先定义。    </li></ol><h3 id="首页模块重构"><a href="#首页模块重构" class="headerlink" title="首页模块重构"></a>首页模块重构</h3><p><img src="/image/16.11.png" alt="首页图片"></p><h4 id="分析：首页三个模块中90-以上的代码都是重复的，我们可以把它给重构"><a href="#分析：首页三个模块中90-以上的代码都是重复的，我们可以把它给重构" class="headerlink" title="分析：首页三个模块中90%以上的代码都是重复的，我们可以把它给重构"></a>分析：首页三个模块中90%以上的代码都是重复的，我们可以把它给重构</h4><p>把不同的东西提取出来，通过变量的方式表示，将以上一个模块做成一个组件。然后做成三个属性{电影，更多，循环的movies}</p><p><img src="/image/16.12.png" alt="分析"></p><ol><li>在components中新建一个indexmodules组件</li></ol><p>将index.wxml中的代码剪切到indexmodules.wxml中</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;module-group&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">view</span>   <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;module-top&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;module-title&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">navigator</span>  <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">moreurl</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;module-more&quot;</span>&gt;</span>更多<span class="hljs-tag">&lt;/<span class="hljs-name">navigator</span>&gt;</span> </span><br><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">scroll-view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;module-scroll-view&quot;</span>  <span class="hljs-attr">scroll-x</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">true</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">navigator</span>   <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">items</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>  <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item-title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-navigator&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-group&quot;</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;thumbnail-group&quot;</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;thumbnail&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.images.small</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-title&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">stars</span>  <span class="hljs-attr">rate</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.rating.average</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">stars</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">navigator</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">scroll-view</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">  </span><br></code></pre></td></tr></table></figure><p>将index.wxss中的代码剪切到indexmodules.wxss中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 最大模块 */</span><br><span class="hljs-selector-class">.module-group</span>&#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br><span class="hljs-comment">/* 顶部电影 更多flex布局 */</span><br><span class="hljs-selector-class">.module-group</span> <span class="hljs-selector-class">.module-top</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">36</span>rpx;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-comment">/* 主轴元素贴两边 */</span><br>  <span class="hljs-attribute">justify-content</span>: space-between;<br>&#125;<br><span class="hljs-comment">/* title字体颜色设置 */</span><br><span class="hljs-selector-class">.module-top</span> <span class="hljs-selector-class">.moudle-title</span>&#123;<br>  <span class="hljs-attribute">color</span>:<span class="hljs-number">#494949</span>;<br>&#125;<br><span class="hljs-comment">/* more颜色设置 */</span><br><span class="hljs-selector-class">.module-top</span> <span class="hljs-selector-class">.module-more</span>&#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#41be57</span>;<br>&#125;<br><br><span class="hljs-selector-class">.module-scroll-view</span>&#123;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">400</span>rpx;<br>  <span class="hljs-comment">/* 设置横向滚动 */</span><br>  <span class="hljs-attribute">white-space</span>: nowrap;<br>&#125;<br><span class="hljs-selector-class">.module-scroll-view</span> <span class="hljs-selector-class">.item-navigator</span>&#123;<br>  <span class="hljs-attribute">width</span>:<span class="hljs-number">200</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>&#125;<br><span class="hljs-comment">/* 最后一个的右边距 对齐 */</span><br><span class="hljs-selector-class">.module-scroll-view</span> <span class="hljs-selector-class">.item-navigator</span><span class="hljs-selector-pseudo">:last-of-type</span>&#123;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.item-navigator</span>  <span class="hljs-selector-class">.item-group</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.item-group</span> <span class="hljs-selector-class">.thumbnail-group</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">284</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.thumbnail-group</span> <span class="hljs-selector-class">.thumbnail</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><span class="hljs-selector-class">.item-group</span> <span class="hljs-selector-class">.item-title</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">28</span>rpx;<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-comment">/* 文本过长处理 */</span><br>  <span class="hljs-attribute">text-overflow</span>:ellipsis;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>将要渲染的数据定义成三个属性</li></ol><p>indexmodules.js文件中</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 组件的属性列表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-symbol">properties:</span> &#123;<br><span class="hljs-symbol">    title:</span>&#123;<br><span class="hljs-symbol">      type:</span>String,<br><span class="hljs-symbol">      value:</span><span class="hljs-string">&quot;&quot;</span><br>    &#125;,<br><span class="hljs-symbol">    moreurl:</span>&#123;<br><span class="hljs-symbol">      type:</span>String,<br><span class="hljs-symbol">      value:</span><span class="hljs-string">&quot;&quot;</span><br>    &#125;,<br><span class="hljs-symbol">    items:</span>&#123;<br><span class="hljs-symbol">      type:</span>Array,<br><span class="hljs-symbol">      value:</span>[]<br>    &#125;<br><br>&#125;,<br></code></pre></td></tr></table></figure><ol start="3"><li>组件引用</li></ol><p>index.json文件中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;searchbar&quot;</span>:<span class="hljs-string">&quot;/components/searchbar/searchbar&quot;</span>,<br>    <span class="hljs-attr">&quot;stars&quot;</span>:<span class="hljs-string">&quot;/components/stars/stars&quot;</span>,<br>    <span class="hljs-attr">&quot;indexmodule&quot;</span>:<span class="hljs-string">&quot;/components/indexmodule/indexmodule&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>组件使用</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-comment">&lt;!-- top20电影 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">indexmodule</span>  <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;电影&quot;</span>  <span class="hljs-attr">items</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">movies</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">indexmodule</span>&gt;</span></span><br><span class="xml"> <span class="hljs-comment">&lt;!-- 正在热映的电影 --&gt;</span></span><br><span class="xml"> <span class="hljs-tag">&lt;<span class="hljs-name">indexmodule</span>  <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;正在热映电影&quot;</span>  <span class="hljs-attr">items</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">tvs</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">indexmodule</span>&gt;</span></span><br><span class="xml"> <span class="hljs-comment">&lt;!-- 即将上映的电影 --&gt;</span></span><br><span class="xml"> <span class="hljs-tag">&lt;<span class="hljs-name">indexmodule</span>  <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;即将上映电影&quot;</span>  <span class="hljs-attr">items</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">shows</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">indexmodule</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><p><img src="/image/16.13.png" alt="组件使用"></p><ol start="5"><li>问题：此时评分不见了stars是放在indexmodule中使用，所以要在indexmodule.js中引用一下stars组件</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;component&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;stars&quot;</span>:<span class="hljs-string">&quot;/components/stars/stars&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时页面效果和之前一样了<br><img src="/image/16.11.png" alt="页面效果"></p><h3 id="网络请求模块重构"><a href="#网络请求模块重构" class="headerlink" title="网络请求模块重构"></a>网络请求模块重构</h3><h4 id="对index-js中的网络请求代码进行重构"><a href="#对index-js中的网络请求代码进行重构" class="headerlink" title="对index.js中的网络请求代码进行重构"></a>对index.js中的网络请求代码进行重构</h4><ol><li>index.js中只有这些网路请求的代码</li><li>代码重复较多</li><li>MVC思想 Model(数据data)  View(html,css)  Controller(控制器,起到指挥的作用，具体怎么去实现交给专门的模块,可以比喻成交警指挥交通并不会去开车)</li></ol><p><img src="/image/16.14.png" alt="代码示例"></p><h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><ol><li>将网络请求放入一个network.js文件中去完成</li></ol><p>将index.wxml中的request请求剪切到network.js中</p><p><img src="/image/16.15.png" alt="network.js"></p><ol start="2"><li>index.js 导入模块  import  {network}  from  “../../utils/network.js”</li></ol><p>代码处理，存储数据，其他模块进行相同处理<br><img src="/image/16.16.png" alt="network.js"></p><ol start="3"><li><p>这时候index.js就起到了一个控制器的作用，不会起到网络请求的的作用，真正的网络请求在network.js文件中。我们只负责调用。</p></li><li><p>考虑到后期我们点击更多列表页使用的ur和首页的url是一样的，所以我们可以把url链接单独抽取出来。</p></li></ol><p>在utils文件中单独创建一个文件用来存储这些链接urls.js</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts">const  globalurls=&#123;<br><span class="hljs-symbol">  movieList:</span> <span class="hljs-string">&quot;https://m.douban.com/rexxar/api/v2/subject_collection/movie_showing/items&quot;</span>,<br><span class="hljs-symbol">  tvList:</span> <span class="hljs-string">&quot;https://m.douban.com/rexxar/api/v2/subject_collection/tv_hot/items&quot;</span>,<br><span class="hljs-symbol">  showList:</span> <span class="hljs-string">&quot;https://m.douban.com/rexxar/api/v2/subject_collection/tv_variety_show/items&quot;</span>,<br>&#125;<br><span class="hljs-class">export </span>&#123;globalurls&#125;   <span class="hljs-comment">//导出</span><br></code></pre></td></tr></table></figure><p>network.js文件中修改代码</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">url:</span> globalurls.movieList,<br><span class="hljs-symbol">data:</span>&#123;<br><span class="hljs-symbol">  count:</span><span class="hljs-number">7</span><br> &#125;,<br></code></pre></td></tr></table></figure><h4 id="重构后首页效果与之前一样"><a href="#重构后首页效果与之前一样" class="headerlink" title="重构后首页效果与之前一样"></a>重构后首页效果与之前一样</h4><p>由于我的Api换了，所以数据发生了一些变化，之前代码一些数据获取代码可能之后不同</p><p><img src="/image/16.17.png" alt="首页"></p>]]></content>
    
    
    <categories>
      
      <category>WX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WX</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>豆瓣小程序&amp;入门&amp;搜索栏的实现&amp;评分星星布局</title>
    <link href="/2021/04/20/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <url>/2021/04/20/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<p>微信小程序由于适用性强、逻辑简要、开发迅速的特性，叠加具有海量活跃用户的腾讯公司背景，逐渐成为了轻量级单一功能应用场景的较佳承载方式，诸如电影购票、外卖点餐、移动商城、生活服务等场景服务提供商迅速切入了。<br>前段时间学习了一个微信小程序，将所学的html,css,js一起运用学习，下面是记录我的开发过程。</p><hr><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>下载微信开发者工具新建一个微信小程序即可,会出现以下目录结构：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- project.config.json：项目的配置文件。比如设置项目的名字，设置appid等。<br>- app.js：小程序逻辑处理。比如小程序加载完成执行的代码。<br>- app.json：小程序公共配置。比如小程序的页面，是否有tabbar等。<br>- app.wxss：小程序公共样式。在这个里面写的样式可以被所有页面使用。<br>- pages：存储小程序页面的。<br>- <span class="hljs-keyword">index</span>：页面的名称<br>- <span class="hljs-keyword">index</span>.js：<span class="hljs-keyword">index</span>页面的逻辑处理文件。<br>- <span class="hljs-keyword">index</span>.json：<span class="hljs-keyword">index</span>页面的配置文件。<br>- <span class="hljs-keyword">index</span>.wxml：<span class="hljs-keyword">index</span>页面的页面结构。<br>- <span class="hljs-keyword">index</span>.wxss：<span class="hljs-keyword">index</span>页面的样式。<br>- 其他页面<br></code></pre></td></tr></table></figure><p><img src="/image/16.1.PNG" alt="目录结构"></p><p>修改app.json文件全局配置</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;window&quot;</span>:&#123;<br>  <span class="hljs-string">&quot;backgroundTextStyle&quot;</span>:<span class="hljs-string">&quot;light&quot;</span>,<br>  <span class="hljs-string">&quot;navigationBarBackgroundColor&quot;</span>: <span class="hljs-string">&quot;#41be57&quot;</span>,<br>  <span class="hljs-string">&quot;navigationBarTitleText&quot;</span>: <span class="hljs-string">&quot;豆瓣评分&quot;</span>,<br>  <span class="hljs-string">&quot;navigationBarTextStyle&quot;</span>:<span class="hljs-string">&quot;white&quot;</span><br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="微信小程序组件封装"><a href="#微信小程序组件封装" class="headerlink" title="微信小程序组件封装"></a>微信小程序组件封装</h3><p>相信大家在开发小程序时会遇到某个功能多次使用的情况，比如弹出框。这个时候大家首先想到的是组件化开发，就是把弹出框封装成一个组件，然后哪里使用哪里就调用。</p><h3 id="搜索栏的实现1–主页search"><a href="#搜索栏的实现1–主页search" class="headerlink" title="搜索栏的实现1–主页search"></a>搜索栏的实现1–主页search</h3><p>因为搜索栏会在多处使用，所以把它做成组件是最好的，这样可以多处使用，实现代码的优化。</p><p><img src="/image/16.2.png" alt="新建组件"></p><ol><li>分析：搜索框由两部分组成，即外盒子和搜索框组成</li><li>在主页的时候是导航栏，在搜索页面的时候是搜索框。</li></ol><p><img src="/image/16.3.png" alt="搜索框"></p><ol start="2"><li>searchbar.wxml/.wxss代码实现</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;searchbar&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 导航栏 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">navigator</span>    <span class="hljs-attr">url</span>=<span class="hljs-string">&#x27;/pages/search/search&#x27;</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;search-navigator&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">navigator</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;search-input&#x27;</span>  <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;搜索&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 这里一保存ctrl+s就会自动生成/pages/search/search文件了 --&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.searchbar</span>&#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#41be57</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.search-navigator</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">60</span>rpx;<br>  <span class="hljs-attribute">background</span>:<span class="hljs-number">#fff</span>;<br>  <span class="hljs-attribute">border-radius</span>:  <span class="hljs-number">10</span>rpx;<br><br>  &lt;!-- 本地图片资源无法通过wxss获取，可以通过网络图片，或者base64，或者&lt;/image&gt;标签  这里我们使用网络转换的base图片 --&gt;<br><br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAPA0lEQVR4Xu2dj5UUNxLGpQgMERhHwBKBrUnAEIFxBOYiOByBIQKvIzBOYAQR3F4EhyM4iED3Pq/mPDvsTFep1b3qqq/f4wFvJc3qK/2mVKU/HQMfKkAFzioQqQ0VoALnFSAgHB1U4IICBITDgwoQEI4BKtCmAD1Im26s5UQBAuLE0OxmmwIEpE031nKiAAFxYmh2s00BAtKmG2s5UYCAODE0u9mmAAFp0421nChAQJwYmt1sU4CAtOnGWk4UICBO.....省略&quot;</span>);<br><br>  <span class="hljs-attribute">background-position</span>: center center;<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">8%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>组件被使用(在首页中使用)在index.json文件中注册</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;searchbar&quot;</span>:<span class="hljs-string">&quot;/components/searchbar/searchbar&quot;</span>,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>组件的使用</li></ol><p>index.html中代码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;searchbar&gt;</span><span class="hljs-section">&lt;/searchbar&gt;</span><br></code></pre></td></tr></table></figure><h3 id="搜索栏的实现2—search页面"><a href="#搜索栏的实现2—search页面" class="headerlink" title="搜索栏的实现2—search页面"></a>搜索栏的实现2—search页面</h3><ol><li>使用组件</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;searchbar&quot;</span>:<span class="hljs-string">&quot;/components/searchbar/searchbar&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/16.4.png" alt="组件的注册"></p><ol start="2"><li>组件使用</li></ol><p>search.wxml中代码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;searchbar&gt;</span><span class="hljs-section">&lt;/searchbar&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>搜索页面searchbar.wxml</li></ol><p>将导航组将navigator添加到组件的属性列表</p><p><img src="/image/16.5.png" alt="添加属性"></p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;searchbar&quot;</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-comment">&lt;!--根据导航组件进行不同的渲染 --&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">navigator</span>  <span class="hljs-attr">wx:if</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">isnavigator</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>  <span class="hljs-attr">url</span>=<span class="hljs-string">&#x27;/pages/search/search&#x27;</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;search-navigator&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">navigator</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">wx:else</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;search-input-group&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;search-input&#x27;</span>  <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;搜索&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><p>首页index.wxml  </p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">searchbar</span>  <span class="hljs-attr">isnavigator</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">true</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">searchbar</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>搜索框样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.search-input-group</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">60</span>rpx;<br>  <span class="hljs-attribute">background</span>:<span class="hljs-number">#fff</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10</span>rpx;<br>  <span class="hljs-attribute">border-radius</span>:<span class="hljs-number">10</span>rpx;<br>  <span class="hljs-attribute">padding</span>:<span class="hljs-number">10</span>rpx <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>&#125;<br><span class="hljs-selector-class">.search-input</span>&#123;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="电影模块布局"><a href="#电影模块布局" class="headerlink" title="电影模块布局"></a>电影模块布局</h3><ol><li>分析：为一个模块而不是一个盒子，因为下面的是一样的模块，所以后面可以复用。</li></ol><p>wxml</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;module-group&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;module-top&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;module-title&quot;</span>&gt;</span>正在热映电影<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">navigator</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;module-more&quot;</span>&gt;</span>更多<span class="hljs-tag">&lt;/<span class="hljs-name">navigator</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">scroll-view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;module-scroll-view&quot;</span> <span class="hljs-attr">scroll-x</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">true</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="xml">    &lt;navigator</span><br><span class="xml">      wx:for=&quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">tvs</span>&#125;&#125;</span><span class="xml">&quot;</span><br><span class="xml">      wx:key=&quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item-title</span>&#125;&#125;</span><span class="xml">&quot;</span><br><span class="xml">      class=&quot;item-navigator&quot;</span><br><span class="xml">    &gt;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-group&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;thumbnail-group&quot;</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;thumbnail&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.images.small</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-title&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">stars</span> <span class="hljs-attr">rate</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.rating.average</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">stars</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">navigator</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">scroll-view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>wxss</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 最大模块 */</span><br><span class="hljs-selector-class">.module-group</span>&#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br><span class="hljs-comment">/* 顶部电影 更多flex布局 */</span><br><span class="hljs-selector-class">.module-group</span> <span class="hljs-selector-class">.module-top</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">36</span>rpx;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-comment">/* 主轴元素贴两边 */</span><br>  <span class="hljs-attribute">justify-content</span>: space-between;<br>&#125;<br><span class="hljs-comment">/* title字体颜色设置 */</span><br><span class="hljs-selector-class">.module-top</span> <span class="hljs-selector-class">.moudle-title</span>&#123;<br>  <span class="hljs-attribute">color</span>:<span class="hljs-number">#494949</span>;<br>&#125;<br><span class="hljs-comment">/* more颜色设置 */</span><br><span class="hljs-selector-class">.module-top</span> <span class="hljs-selector-class">.module-more</span>&#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#41be57</span>;<br>&#125;<br><br><span class="hljs-selector-class">.module-scroll-view</span>&#123;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">400</span>rpx;<br>  <span class="hljs-comment">/* 设置横向滚动 */</span><br>  <span class="hljs-attribute">white-space</span>: nowrap;<br>&#125;<br><span class="hljs-selector-class">.module-scroll-view</span> <span class="hljs-selector-class">.item-navigator</span>&#123;<br>  <span class="hljs-attribute">width</span>:<span class="hljs-number">200</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>&#125;<br><span class="hljs-comment">/* 最后一个的右边距 对齐 */</span><br><span class="hljs-selector-class">.module-scroll-view</span> <span class="hljs-selector-class">.item-navigator</span><span class="hljs-selector-pseudo">:last-of-type</span>&#123;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.item-navigator</span>  <span class="hljs-selector-class">.item-group</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.item-group</span> <span class="hljs-selector-class">.item-title</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">28</span>rpx;<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-comment">/* 文本过长处理 */</span><br>  <span class="hljs-attribute">text-overflow</span>:ellipsis;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/image/16.7.png" alt="css作用效果例图"></p><p>补充：</p><p>scroll-view：<br>有时候我们的一些视图在手机指定的宽度和高度不够存放。那么可以放在 scroll-view 中。<br>设置横向滚动：</p><ol><li>给 scroll-view 添加 scroll-x=”true” 属性。</li><li>给 scroll-view 添加 white-space:nowrap; 样式。</li><li>给 scroll-view 中的子元素设置为 display:inline-block; 。</li></ol><h3 id="评分星星布局1–初始化固定样式"><a href="#评分星星布局1–初始化固定样式" class="headerlink" title="评分星星布局1–初始化固定样式"></a>评分星星布局1–初始化固定样式</h3><p>wxml</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rate-group&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/imags/rate_light.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/imags/rate_half.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/imags/rate_gray.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span>8.0<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>图片来源本地</p><p><img src="/image/16.6.png" alt="星星图片"></p><p>wxss</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.rate-group</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-content</span>: center;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-attribute">color</span>:<span class="hljs-number">#ccc</span>;<br>  <span class="hljs-attribute">margin-top</span>:<span class="hljs-number">20</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.rate-group</span>  image&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="评分星星布局2–组件化"><a href="#评分星星布局2–组件化" class="headerlink" title="评分星星布局2–组件化"></a>评分星星布局2–组件化</h3><h4 id="分析：评分的星星-高亮，半高亮，不亮星星-是通过评分数字变化的，而评分数字是变化的-不同电影-，所以我们可以将数字传进来计算星星的个数，这时候我们可以使用组件的方式。在组件当中我们定义一个属性评分，然后接收评分的数字在生命周期方法中计算星星-高亮，半高亮，不亮星星-，另一个好处是可以多处复用。"><a href="#分析：评分的星星-高亮，半高亮，不亮星星-是通过评分数字变化的，而评分数字是变化的-不同电影-，所以我们可以将数字传进来计算星星的个数，这时候我们可以使用组件的方式。在组件当中我们定义一个属性评分，然后接收评分的数字在生命周期方法中计算星星-高亮，半高亮，不亮星星-，另一个好处是可以多处复用。" class="headerlink" title="分析：评分的星星(高亮，半高亮，不亮星星)是通过评分数字变化的，而评分数字是变化的(不同电影)，所以我们可以将数字传进来计算星星的个数，这时候我们可以使用组件的方式。在组件当中我们定义一个属性评分，然后接收评分的数字在生命周期方法中计算星星(高亮，半高亮，不亮星星)，另一个好处是可以多处复用。"></a>分析：评分的星星(高亮，半高亮，不亮星星)是通过评分数字变化的，而评分数字是变化的(不同电影)，所以我们可以将数字传进来计算星星的个数，这时候我们可以使用组件的方式。在组件当中我们定义一个属性评分，然后接收评分的数字在生命周期方法中计算星星(高亮，半高亮，不亮星星)，另一个好处是可以多处复用。</h4><ol><li>创建stars组件</li></ol><p><img src="/image/16.8.png" alt="创建"></p><ol start="2"><li>将上面的wxml代码放入stars.wxml中，wxss同理</li></ol><ol start="3"><li>在index.json中导入使用<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;searchbar&quot;</span>:<span class="hljs-string">&quot;/components/searchbar/searchbar&quot;</span>,<br>    <span class="hljs-attr">&quot;stars&quot;</span>:<span class="hljs-string">&quot;/components/stars/stars&quot;</span>,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>index.wxml中使用<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;stars&gt;</span><span class="hljs-section">&lt;/stars&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="将数据变成活的"><a href="#将数据变成活的" class="headerlink" title="将数据变成活的"></a>将数据变成活的</h4><ol><li>定义属性<br>在stars的stars.js文件中定义星星的一些属性<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dts"> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 组件的属性列表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-symbol">properties:</span> &#123;<br><span class="hljs-symbol">rate:</span>&#123;<br><span class="hljs-symbol">      type:</span>Number,<br><span class="hljs-symbol">      value:</span><span class="hljs-number">0</span><br>    &#125;, <br><span class="hljs-symbol">starsize:</span>&#123;<br><span class="hljs-symbol">  type:</span>Number,<br><span class="hljs-symbol">  value:</span><span class="hljs-number">20</span> <span class="hljs-comment">//rpx</span><br>&#125;,<br><span class="hljs-symbol">fontsize:</span>&#123;<br><span class="hljs-symbol">  type:</span> Number,<br><span class="hljs-symbol">  value:</span><span class="hljs-number">20</span> <span class="hljs-comment">//rpx</span><br>&#125;,<br><span class="hljs-symbol">fontcolor:</span>&#123;<br><span class="hljs-symbol">  type:</span>String,<br><span class="hljs-symbol">  value:</span><span class="hljs-string">&quot;#ccc&quot;</span><br>&#125;<br>&#125;,<br></code></pre></td></tr></table></figure></li><li>在组件的生命周期实现(attached生命周期就是你的组件一旦被加载就会被执行)</li></ol><p>stars.js文件中的代码</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs excel">lifetim<span class="hljs-symbol">es:</span>&#123;<br>  attach<span class="hljs-symbol">ed:fu</span>nction()&#123;<br>    <span class="hljs-built_in">var</span>  that = this;<br>    <span class="hljs-built_in">var</span>  <span class="hljs-built_in">rate</span>= that.properties.rate;<br>    <span class="hljs-built_in">var</span>  inRate = parseInt(<span class="hljs-built_in">rate</span>);<br>    <span class="hljs-built_in">var</span>  light = parseInt(<span class="hljs-built_in">rate</span>/<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">var</span>  half = inRate%<span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">var</span>  gray  = <span class="hljs-number">5</span>-light-half;<br>    <span class="hljs-built_in">var</span> lights = [];<br>    <span class="hljs-built_in">var</span>  halfs = [];<br>    <span class="hljs-built_in">var</span>  grays = [];<br>    // for循环遍历存放到数组中<br>    for(<span class="hljs-built_in">var</span>  <span class="hljs-built_in">index</span>=<span class="hljs-number">1</span>;<span class="hljs-built_in">index</span>&lt;=light;<span class="hljs-built_in">index</span>++)&#123;<br>      lights.push(<span class="hljs-built_in">index</span>);<br>    &#125;<br>    for(<span class="hljs-built_in">var</span>  <span class="hljs-built_in">index</span>=<span class="hljs-number">1</span>;<span class="hljs-built_in">index</span>&lt;=half;<span class="hljs-built_in">index</span>++)&#123;<br>      halfs.push(<span class="hljs-built_in">index</span>);<br>    &#125;<br>    for(<span class="hljs-built_in">var</span>  <span class="hljs-built_in">index</span>=<span class="hljs-number">1</span>;<span class="hljs-built_in">index</span>&lt;=gray;<span class="hljs-built_in">index</span>++)&#123;<br>      grays.push(<span class="hljs-built_in">index</span>);<br>    &#125;<br>    // 评分设置<br>   <span class="hljs-built_in">var</span>   ratetext = <span class="hljs-built_in">rate</span> &amp;&amp; <span class="hljs-built_in">rate</span>&gt;<span class="hljs-number">0</span>?rate.toFixed(<span class="hljs-number">1</span>)<span class="hljs-symbol">:</span><span class="hljs-string">&quot;未评分&quot;</span><br>    //数组获取到后 修改 data 中的值<br>    that.setData(&#123;<br>      ligh<span class="hljs-symbol">ts:li</span>ghts,<br>      hal<span class="hljs-symbol">fs:ha</span>lfs,<br>      gra<span class="hljs-symbol">ys:gr</span>ays,<br>      ratete<span class="hljs-symbol">xt:ra</span>tetext,<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>修改wxml文件中样式</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rate-group&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">image</span>   <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">starsize</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">rpx; height:</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">starsize</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">rpx&quot;</span>   <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">lights</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>    <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;this&quot;</span>   <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/imags/rate_light.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">image</span>   <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">starsize</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">rpx; height:</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">starsize</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">rpx&quot;</span>   <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">halfs</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>     <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;this&quot;</span>   <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/imags/rate_half.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">image</span>   <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">starsize</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">rpx; height:</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">starsize</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">rpx&quot;</span>    <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">grays</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>    <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;this&quot;</span>    <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/imags/rate_gray.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">text</span>   <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-size:</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">fontsize</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">rpx;color:</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">fontcolor</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string"> &quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">ratetext</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>补充： 生命周期：<br>组件本身的生命周期：<br>组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。<br>其中，最重要的生命周期是 created/attached/detached ，包含一个组件实例生命流程的最主要时间点。（注意：在2.2.3基础库之前，生命周期函数写在 Component 中就可以，在 2.2.3 后应该写在 lifetimes 中。）            </p><ol><li>组件实例刚刚被创建好时， created 生命周期被触发。此时，组件数据 this.data 就是在 Component 构造器中定义的数据 data 。此时还不能调用setData 。通常情况下，这个生命周期只应该用于给组件 this 添加一些自定义属性字段。                </li><li>在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。此时， this.data 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。                    </li><li>在组件离开页面节点树后，detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则detached 会被触发。       </li></ol>]]></content>
    
    
    <categories>
      
      <category>WX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WX</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue&amp;计算属性&amp;计算属性缓存vs方法methods&amp;Vue侦听器</title>
    <link href="/2021/04/18/Vue&amp;computed%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
    <url>/2021/04/18/Vue&amp;computed%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>前言：插值表达式的语法相当简洁，使用起来也很方便。但是也不免暴露出它的一些缺点，最典型的就是无法进行复杂逻辑运算。所以，Vue才会自带计算属性的功能。</p><hr><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span></span><br><span class="xml">  </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">message.split</span>(<span class="hljs-name">&#x27;&#x27;</span>).reverse().join(<span class="hljs-name">&#x27;&#x27;</span>) &#125;&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中多包含此处的翻转字符串时，就会更加难以处理。</span><br><br><span class="xml">所以，对于任何复杂逻辑，你都应当使用计算属性。</span><br></code></pre></td></tr></table></figure><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>计算属性的本质就是辅助插值表达式来进行复杂逻辑运算的。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">msg</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">count</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  var vm = new Vue(&#123;</span><br><span class="xml">    el: &quot;#app&quot;,</span><br><span class="xml">    data: &#123;</span><br><span class="xml">      msg: &quot;hello  Vue&quot;,</span><br><span class="xml">    &#125;,</span><br><span class="xml">    computed: &#123;</span><br><span class="xml">      count: function () &#123;</span><br><span class="xml">        //切割，翻转，拼接</span><br><span class="xml">        return this.msg.split(&quot; &quot;).reverse().join(&quot;====&quot;); //Vue========hello</span><br><span class="xml">      &#125;,</span><br><span class="xml">    &#125;,</span><br><span class="xml">  &#125;);</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>上面这个案例就是一个computed的实例演示，我们通过代码不难看出：第一个p标记中的插值表达式显示的是原文，而第二个p标记中，显示的则是经过一系列API处理之后的文本内容。</p><p>其中，所有的API操作都放在了computed中的count方法中来实现，而最终插值表达式，只是将computed中处理完毕的属性绑定给自己即可。这也从另一个侧面证实了computed只负责进行复杂逻辑运算的特点。</p><h3 id="计算属性setter和getter"><a href="#计算属性setter和getter" class="headerlink" title="计算属性setter和getter"></a>计算属性setter和getter</h3><ol><li>计算属性一般是没有set方法，只读属性</li><li>使用getter方法较多<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">message</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">    const app = new Vue(&#123;</span><br><span class="xml">      el: &quot;#app&quot;,</span><br><span class="xml">      data: &#123;</span><br><span class="xml">        firstName: &quot;kobe&quot;,</span><br><span class="xml">        lastName: &quot;Bryant&quot;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">      // 计算属性一般是没有set方法，只读属性</span><br><span class="xml">      computed: &#123;</span><br><span class="xml">        // set中方法可以传参数</span><br><span class="xml">        //   fullName: &#123;</span><br><span class="xml">        //     set: function () &#123;</span><br><span class="xml">        //       console.log(&quot;----&quot;);</span><br><span class="xml">        //     &#125;,</span><br><span class="xml">        //   &#125;,</span><br><br><span class="xml">        fullName: &#123;</span><br><span class="xml">          get: function () &#123;</span><br><span class="xml">            return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="xml">          &#125;,</span><br><span class="xml">        &#125;,</span><br><span class="xml">        //与上面方法一样，一般只使用getter方法</span><br><span class="xml">        //   fullName: &#123;</span><br><span class="xml">        //     function() &#123;</span><br><span class="xml">        //       return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="xml">        //     &#125;,</span><br><span class="xml">        //   &#125;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">      methods: &#123;</span><br><span class="xml">         full : function () &#123;</span><br><span class="xml">          return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="xml">        &#125;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">    &#125;);</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ol><h3 id="计算属性缓存-vs-方法methods"><a href="#计算属性缓存-vs-方法methods" class="headerlink" title="计算属性缓存 vs 方法methods"></a>计算属性缓存 vs 方法methods</h3><p>你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：</p><p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，<strong>不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 full 计算属性会立即返回之前的计算结果，而不必再次执行函数。</strong></p><p>这也同样意味着下面的计算属性将不再更新，因为computed中的return <code>this.firstName + &quot; &quot; + this.lastName;</code> 不是响应式依赖：      </p><p>相比之下，每当触发重新渲染时，调用方法将<strong>总会</strong>再次执行函数。</p><p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。</p><h3 id="Vue侦听器"><a href="#Vue侦听器" class="headerlink" title="Vue侦听器"></a>Vue侦听器</h3><p>侦听属性，响应数据（data&amp;computed）的变化，当数据变化时，会立刻执行对应函数。</p><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-comment">&lt;!-- 这里表示被vue控制的区域 --&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">fullName</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">age</span> &#125;&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  const vm = new Vue(&#123;</span><br><span class="xml">    el: &quot;#app&quot;, // 控制id为app的元素</span><br><span class="xml">    data: &#123;</span><br><span class="xml">      firstName: &quot;li&quot;,</span><br><span class="xml">      lastName: &quot;xinxin&quot;,</span><br><span class="xml">      fullName: &quot;li xinxin&quot;,</span><br><span class="xml">      age: 20,</span><br><span class="xml">    &#125;,</span><br><span class="xml">    watch: &#123;</span><br><span class="xml">      firstName() &#123;</span><br><span class="xml">        console.log(&quot;侦听器执行了&quot;);</span><br><span class="xml">        return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="xml">      &#125;,</span><br><span class="xml">      lastName() &#123;</span><br><span class="xml">        console.log(&quot;侦听器执行了&quot;);</span><br><span class="xml">        return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="xml">      &#125;,</span><br><span class="xml">    &#125;,</span><br><span class="xml">  &#125;);</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/image/15.png" alt="如图"></p><h4 id="侦听器-vs-计算属性"><a href="#侦听器-vs-计算属性" class="headerlink" title="侦听器 vs 计算属性"></a>侦听器 vs 计算属性</h4><ol><li>两者都可以观察和响应Vue实例上的数据的变动。</li><li>watch擅长处理的场景是：一个数据影响多个数据。计算属性擅长处理的场景是：多个数据影响一个数据。</li><li>在侦听器中可以执行异步，但是在计算属性中不可以。</li></ol><h3 id="当我们可以使用一个功能，使用计算属性、方法、侦听器都可以时，推荐使用计算属性。计算属性的模板较轻，有利于提高浏览器的性能。"><a href="#当我们可以使用一个功能，使用计算属性、方法、侦听器都可以时，推荐使用计算属性。计算属性的模板较轻，有利于提高浏览器的性能。" class="headerlink" title="当我们可以使用一个功能，使用计算属性、方法、侦听器都可以时，推荐使用计算属性。计算属性的模板较轻，有利于提高浏览器的性能。"></a>当我们可以使用一个功能，使用计算属性、方法、侦听器都可以时，推荐使用计算属性。计算属性的模板较轻，有利于提高浏览器的性能。</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://cn.vuejs.org/v2/guide/computed.html">Vue官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-promise</title>
    <link href="/2021/04/17/ES6(promise)/"/>
    <url>/2021/04/17/ES6(promise)/</url>
    
    <content type="html"><![CDATA[<p>在JavaScript的世界中，所有代码都是单线程执行的。由于这个“缺陷”，导致 <strong>JavaScript的所有网络操作，浏览器事件</strong>，都必须是异步执行。异步执行可以用回调函数实现。一旦有一连串的ajax请求a,b,c,d….后面的请求依赖前面的请求结果，就需要层层嵌套。这种缩进和层层嵌套的方式，非常容易造成上下文代码混乱，我们不得不非常小心翼翼处理内层函数与外层函数的数据，一旦内层函数使用了上层函数的变量，这种混乱程度就会加剧…总之，这种层叠上下文的层层嵌套方式，着实增加了神经的紧张程度</p><hr><p>先理解一下什么是回调函数</p><h4 id="什么是函数？"><a href="#什么是函数？" class="headerlink" title="什么是函数？"></a>什么是函数？</h4><p>函数是在其中有一组代码的逻辑构件，用来执行特定任务。实际上为了易于调试和维护，函数允许以更有组织的方式去编写代码。函数还允许代码重用。</p><p>你只需定义一次函数，然后在需要时去调用它，而不必一次又一次地编写相同的代码。</p><h2 id="回调函数（callback）"><a href="#回调函数（callback）" class="headerlink" title="回调函数（callback）"></a>回调函数（callback）</h2><p>首先回调函数就是一个函数,形式上和其他函数没有半点区别.<br>举个例子:</p><p>一般函数:function a(int a, String b):接收的参数是一般类型.</p><p>特殊函数:function b(function c):接收的参数是一个函数,c这个函数就叫回调函数.</p><p>你也可以这么理解:本质区别是,一般一个函数调用另一个函数,被调用的函数是出现在方法体当中,而回调函数比较特殊,它是出现在参数列表当中.也就是说,当调用的时候,需要从其他地方拿到这个(回调)函数,以参数的形式传入.<br><img src="/image/12.png" alt="示例"></p><h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><h3 id="同步和异步区别？"><a href="#同步和异步区别？" class="headerlink" title="同步和异步区别？"></a>同步和异步区别？</h3><p>举个栗子，煮开水，同步就是把水放上去烧，得一直等水开，中途不能做其他事情。而异步，则是把水放上去烧，让水在烧，你可以玩手机看电视，等水开了把火关掉。同样的，代码中也是一样，同步是现在发生的，异步是未来某个时刻发生的。</p><h3 id="JS-运行机制"><a href="#JS-运行机制" class="headerlink" title="JS 运行机制"></a>JS 运行机制</h3><p>先介绍下JavaScript运行机制，因为JS 是单线程运行的，所以这意味着两段代码不能同时运行，而是必须一个接一个地运行，所以，在同步代码执行过程中，异步代码是不执行的。只有等同步代码执行结束后，异步代码才会被添加到事件队列中。</p><h3 id="JS-中异步有几种？"><a href="#JS-中异步有几种？" class="headerlink" title="JS 中异步有几种？"></a>JS 中异步有几种？</h3><p>JS 中异步操作还挺多的，常见的分以下几种：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">setTimeout</span> (<span class="hljs-built_in">setInterval</span>)<br>AJAX<br><span class="hljs-built_in">Promise</span><br><span class="hljs-keyword">async</span>/<span class="hljs-keyword">await</span><br></code></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>状态的特点<br>Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。    </p><p>Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。<br>语法：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim">new <span class="hljs-type">Promise</span>( function(resolve, reject) <span class="hljs-meta">&#123;...&#125;</span>);<br></code></pre></td></tr></table></figure><p>Promise 对象是由关键字 new 及其构造函数来创建的。这个“处理器函数”接受两个函数 resolve 和 reject 作为其参数。当异步任务顺利完成且返回结果值时，会调用 resolve 函数；而当异步任务失败且返回失败原因（通常是一个错误对象）时，会调用reject 函数。       </p><p>new Promise 返回一个 promise 对象，在遇到 resolve 或 reject之前，状态一直是pending，如果调用 resolve 方法，状态变为 fulfilled，如果调用了 reject 方法，状态变为 rejected。   </p><p>例子：<br>案例:用户登录，并展示该用户的各科成绩。在页面发送两次请求:<br>1.查询当前用户信息<br>2.按照当前用户的id查出他的课程<br>3.按照当前课程id查出分数<br>分析:此时后台应该提供三个接口，一个提供用户查询接口，一个提供科目的接口，一个提供各科成绩的接口，为了渲染方便，最好响应json数据。在这里就不编写后台接口了，而是提供三个json文件，直接提供json数据，模拟后台接口。<br><img src="/image/12.1.png" alt="数据如图"></p><ol><li>ajax发送请求获取数据方法<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 导入JQuery --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  $.ajax(&#123;</span><br><span class="javascript">    url: <span class="hljs-string">&quot;mock/user.json&quot;</span>,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">success</span>(<span class="hljs-params">data</span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;查询用户：&quot;</span>, data);</span><br><span class="javascript">      $.ajax(&#123;</span><br><span class="javascript">        url: <span class="hljs-string">`mock/user_corse_<span class="hljs-subst">$&#123;data.id&#125;</span>.json`</span>,</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">success</span>(<span class="hljs-params">data</span>)</span> &#123;</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;查询到课程：&quot;</span>, data);</span><br><span class="javascript">          $.ajax(&#123;</span><br><span class="javascript">            url: <span class="hljs-string">`mock/corse_score_<span class="hljs-subst">$&#123;data.id&#125;</span>.json`</span>,</span><br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">success</span>(<span class="hljs-params">data</span>)</span> &#123;</span><br><span class="javascript">              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;查询到分数：&quot;</span>, data);</span><br>            &#125;,<br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">error</span>(<span class="hljs-params">error</span>)</span> &#123;</span><br><span class="javascript">              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;出现异常了：&quot;</span> + error);</span><br>            &#125;,<br>          &#125;);<br>        &#125;,<br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">error</span>(<span class="hljs-params">error</span>)</span> &#123;</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;出现异常了：&quot;</span> + error);</span><br>        &#125;,<br>      &#125;);<br>    &#125;,<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">error</span>(<span class="hljs-params">error</span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;出现异常了：&quot;</span> + error);</span><br>    &#125;,<br>  &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>Promise方法</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.</span>primise可以封装异步操作<br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">//1.异步操作</span><br>  $.ajax(&#123;<br>    url: <span class="hljs-string">&quot;user.json&quot;</span>,<br>    success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;查询用户成功：&quot;</span>, data);<br>      resolve(data); <span class="hljs-comment">//成功了</span><br>    &#125;,<br>    error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>      reject(err); <span class="hljs-comment">//失败了</span><br>    &#125;,<br>  &#125;);<br>&#125;);<br><span class="hljs-comment">//then 方法接收两个函数作为参数，第一个参数是 Promise 执行成功时的回调，</span><br><span class="hljs-comment">//第二个参数是 Promise 执行失败时的回调，两个函数只会有一个被调用。</span><br><span class="hljs-comment">// obj对象是上一步传下来的对象</span><br>p.then(<span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">//p.then调用完以后还会返回一个promise对象</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    $.ajax(&#123;<br>      url: <span class="hljs-string">`usr_corse_<span class="hljs-subst">$&#123;obj.id&#125;</span>.json`</span>,<br>      success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;查询用户课程成功：&quot;</span>, data);<br>        resolve(data);<br>      &#125;,<br>      error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>        reject(err);<br>      &#125;,<br>    &#125;);<br>  &#125;);<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// data是上一步的data</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;上一步的结果&quot;</span>, data);<br>  $.ajax(&#123;<br>    url: <span class="hljs-string">`corse_score_<span class="hljs-subst">$&#123;data.id&#125;</span>.json`</span>,<br>    success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;查询课程得分成功：&quot;</span>, data);<br>    &#125;,<br>    error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;&#125;,<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="3"><li>简化Promise,抽取方法</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">url, data</span>) </span>&#123;<br>  <span class="hljs-comment">// new  Promise封装一个异步操作</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    $.ajax(&#123;<br>      url: url,<br>      data: data,<br>      success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>        resolve(data);<br>      &#125;,<br>      error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>        reject(err);<br>      &#125;,<br>    &#125;);<br>  &#125;);<br>&#125;<br><span class="hljs-comment">// 发送一个get请求，由于get封装的是Promise方法所以可以调用.then方法</span><br>get(<span class="hljs-string">&quot;user.json&quot;</span>)<br>  .then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;用户查询成功:&quot;</span>, data);<br>    <span class="hljs-keyword">return</span> get(<span class="hljs-string">`usr_corse_<span class="hljs-subst">$&#123;data.id&#125;</span>.json`</span>);<br>  &#125;)<br>  .then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;课程查询成功:&quot;</span>, data);<br>    <span class="hljs-keyword">return</span> get(<span class="hljs-string">`corse_score_<span class="hljs-subst">$&#123;data.id&#125;</span>.json`</span>);<br>  &#125;)<br>  .then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;课程成绩查询成功:&quot;</span>, data);<br>  &#125;)<br>  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;数据异常&quot;</span>, err);<br>  &#125;);<br></code></pre></td></tr></table></figure><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Promise</span>.<span class="hljs-literal">all</span>([promise<span class="hljs-number">1</span>, promise<span class="hljs-number">2</span>]).then(success<span class="hljs-number">1</span>, fail<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>promise1和promise2都成功才会调用success1</p><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Promise</span>.race([promise<span class="hljs-number">1</span>, promise<span class="hljs-number">2</span>]).then(success<span class="hljs-number">1</span>, fail<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>promise1和promise2只要有一个成功就会调用success1</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.Promise的作用<br>主要用于异步计算<br>可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果<br>可以在对象之间传递和操作promise，帮助我们处理队列  </p><p>2.理解<br>promise是一个对象，对象和函数的区别就是对象可以保存状态，函数不可以（闭包除外）<br>并未剥夺函数return的能力，因此无需层层传递callback，进行回调获取数据<br>代码风格，容易理解，便于维护<br>多个异步等待合并便于解决</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://juejin.cn/post/6844903541543288840">理解 JavaScript 异步操作</a><br><a href="https://www.runoob.com/w3cnote/es6-promise.html">菜鸟教程</a></p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript 关于赋值、浅拷贝、深拷贝</title>
    <link href="/2021/04/17/javascript%20%E5%85%B3%E4%BA%8E%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <url>/2021/04/17/javascript%20%E5%85%B3%E4%BA%8E%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>以下是对关于赋值、浅拷贝、深拷贝的学习</p><hr><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>说这个话题之前，先扯一下JS的基本数据类型。</p><p>大家都知道JS中的数据类型分为：<br>基本类型：string, number, boolean, null, undefined,symbol(ES6新增)<br>引用类型：Object，特殊的有Array, Function, Date, Math, RegExp, Error等((Object类)有常规名值对的无序对象{a:1}，数组[1,2,3]，以及函数等)     </p><p>那什么是引用类型呢？这又得扯上JS的内存机制了。</p><p>JS的内存跟其他的内存差不多，分为堆（heap）和栈（stack）。 </p><ol><li>栈和堆<br>栈：由系统自动分配，自动回收，效率高，但容量小。<br>堆：由程序员手动分配内存，并且手动销毁（高级语言如JS中有垃圾自动回收机制），效率不如栈，但容量大。<br>请注意区分数据结构中所说的堆栈和内存中的堆栈是两回事。</li><li>基本类型和引用类型分配位置(栈，堆)<br>JS的基本类型分配在栈中，而因为引用类型大小的不固定，系统将存储该引用类型的地址存在栈中，并赋值给变量本身，而具体的内容存在堆中。所以当访问一个对象的时候，先访问栈中它的地址，然后按照这个地址去堆中找到它的实际内容。<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4></li></ol><ol><li>a.基本类型–名值存储在栈内存中，例如let a=1;<br><img src="/image/14.1.PNG" alt="如图"><br>当你b=a复制时，栈内存会新开辟一个内存，例如这样：<br><img src="/image/14.2.PNG" alt="如图">   </li></ol><p>所以当复制的时候，对于基本类型的变量，系统会为新的变量在栈中开辟一个新的空间，赋予相同的值，然后这两个变量就各自独立，毫无牵连。所以当你此时修改a=2，对b并不会造成影响，因为此时的b已自食其力，翅膀硬了，不受a的影响了.         </p><ol><li>b.引用数据类型–名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值<br><img src="/image/14.3.PNG" alt="如图"><br>而对于引用类型的变量，新的变量复制的是那个对象在堆中的地址，这两个变量指向的是同一个对象。        </li></ol><p>例子：简单的引用拷贝(浅拷贝)</p><pre><code>var obj = &#123;name: &#39;Yecao&#39;&#125;;var obj2 = obj;console.log(obj2.name); // &#39;Yecao&#39;obj2.name = &#39;Claire&#39;;console.log(obj.name); //&#39;Claire&#39;</code></pre><p>以上是个很简单的例子，obj2复制了obj之后，两个其实指向的是同一个对象。           </p><p>而当我们a[0]=1时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。             </p><p><img src="/image/14.4.PNG" alt="如图">        </p><p>实现简单的深拷贝<br>这么我们封装一个深拷贝的函数(PS：只是一个基本实现的展示，并非最佳实践)</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> deep<span class="hljs-constructor">Clone(<span class="hljs-params">obj</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> objClone = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">obj</span>)</span>?<span class="hljs-literal">[]</span>:&#123;&#125;;<br>    <span class="hljs-keyword">if</span>(obj<span class="hljs-operator"> &amp;&amp; </span>typeof obj===<span class="hljs-string">&quot;object&quot;</span>)&#123;<br>        <span class="hljs-keyword">for</span>(key <span class="hljs-keyword">in</span> obj)&#123;<br>            <span class="hljs-keyword">if</span>(obj.has<span class="hljs-constructor">OwnProperty(<span class="hljs-params">key</span>)</span>)&#123;<br>                <span class="hljs-comment">//判断ojb子元素是否为对象，如果是，递归复制</span><br>                <span class="hljs-keyword">if</span>(obj<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span>&amp;&amp;typeof obj<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> ===<span class="hljs-string">&quot;object&quot;</span>)&#123;<br>                    objClone<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> = deep<span class="hljs-constructor">Clone(<span class="hljs-params">obj</span>[<span class="hljs-params">key</span>])</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//如果不是，简单复制</span><br>                    objClone<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> = obj<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    return objClone;<br>&#125;    <br><span class="hljs-keyword">let</span> a=<span class="hljs-literal">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]</span>,<br>    b=deep<span class="hljs-constructor">Clone(<span class="hljs-params">a</span>)</span>;<br>a<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>=<span class="hljs-number">2</span>;<br>console.log(a,b);<br></code></pre></td></tr></table></figure><p>可以看到<br><img src="/image/14.5.PNG" alt="如图">        </p><p>跟之前想象的一样，现在b脱离了a的控制，不再受a影响了。</p><p>这里再次强调，深拷贝，是拷贝对象各个层级的属性<br><img src="/image/14.6.PNG" alt="如图">   </p><p>第一层的属性确实深拷贝，拥有了独立的内存，但更深的属性却仍然公用了地址，所以才会造成上面的问题。</p><p>同理，concat方法与slice也存在这样的情况，他们都不是真正的深拷贝，这里需要注意。  </p><h4 id="slice-和-concat"><a href="#slice-和-concat" class="headerlink" title="slice 和 concat"></a>slice 和 concat</h4><p>Array 的 slice 和 concat 方法 和 jQuery 中的 extend 复制方法，他们都会复制第一层的值，对于 第一层 的值都是 深拷贝，而到 第二层 的时候 Array 的 slice 和 concat 方法就是 复制引用 ，jQuery 中的 extend 复制方法 则 取决于 你的 第一个参数， 也就是是否进行递归复制。所谓第一层 就是 key 所对应的 value 值是基本数据类型，也就像上面栗子中的name、age，而对于 value 值是引用类型 则为第二层，也就像上面栗子中的 company。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>JS的基本类型不存在浅拷贝还是深拷贝的问题,深拷贝与浅拷贝的概念只存在于引用类型。</li><li>对于仅仅是复制了引用（地址），换句话说，复制了之后，原来的变量和新的变量指向同一个东西，彼此之间的操作会互相影响，为 浅拷贝。<br>而如果是在堆中重新分配内存，拥有不同的地址，但是值是一样的，复制后的对象与原来的对象是完全隔离，互不影响，为 深拷贝。</li><li>深浅拷贝 的主要区别就是：复制的是引用(地址)还是复制的是实例。</li></ol><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.cnblogs.com/echolun/p/7889848.html">博客圆</a></p><p><a href="https://zhuanlan.zhihu.com/p/26282765">知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-模块化</title>
    <link href="/2021/04/17/ES6%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2021/04/17/ES6%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>模块化就是把代码进行拆分，方便重复利用，类似java中的导包，需要使用一个包，必须先导包，而js中没有包的概念，换来的是<strong>模块</strong></p><p>ES6 的模块化分为导出（export） @与导入（import）两个模块。</p><hr><h3 id="一个页面需要引入多个js文件引发的问题"><a href="#一个页面需要引入多个js文件引发的问题" class="headerlink" title="一个页面需要引入多个js文件引发的问题"></a>一个页面需要引入多个js文件引发的问题</h3><ol><li>请求过多</li><li>依赖模糊</li><li>难以维护 这些问题可以通过现代模块化编码和项目构建来解决</li></ol><h2 id="模块化优点"><a href="#模块化优点" class="headerlink" title="模块化优点"></a>模块化优点</h2><ol><li>避免命名冲突（减少命名空间污染）</li><li>更好的分类，按需加载</li><li>更高的复用性</li><li>高可维护性</li></ol><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><p>ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 use strict;。</p></li><li><p>模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。</p></li><li><p>每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。</p></li><li><p>每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。</p></li></ol><h3 id="export-与-import"><a href="#export-与-import" class="headerlink" title="export 与 import"></a>export 与 import</h3><p>模块导入导出各种类型的变量，如字符串，数值，函数，类。</p><ol><li>导出的函数声明与类声明必须要有名称（export default 导出了一个对象，没给这个对象起名字，导入的时候可以随意起名字）。</li><li>不仅能导出声明还能导出引用（例如函数）。</li><li>export 命令可以出现在模块的任何位置，但必需处于模块顶层。(如果处于块级作用域内，就会报错)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;bar&#x27;</span> <span class="hljs-comment">// SyntaxError</span><br>&#125;<br>foo()<br></code></pre></td></tr></table></figure><ol start="4"><li>import 命令会提升到整个模块的头部，首先执行。</li></ol><p>代码示例<br>hello.js</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>  export   const  util=&#123;<br><span class="hljs-regexp">//</span>     sum(a,b)&#123;<br><span class="hljs-regexp">//</span>         return  a+b;<br><span class="hljs-regexp">//</span>     &#125;<br><span class="hljs-regexp">//</span> &#125;<br><br><span class="hljs-regexp">//</span> 这两个等效<br><span class="hljs-regexp">//</span> 导出了一个对象，没给这个对象起名字，导入的时候可以随意起名字<br>export  default&#123;<br>        sum(a,b)&#123;<br>            return  a+b;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>user.js</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">var  <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;jack&quot;</span><br>var  <span class="hljs-attribute">age</span>=21<br><br>function  <span class="hljs-builtin-name">add</span>(a,b)&#123;<br>    return  a+b;<br>&#125;<br><br><span class="hljs-builtin-name">export</span>  &#123;name,age,add&#125;<br></code></pre></td></tr></table></figure><p>main.js</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> abc  <span class="hljs-keyword">from</span>  &quot;./hello.js&quot;<br><span class="hljs-keyword">import</span>  &#123;<span class="hljs-type">name</span>,<span class="hljs-keyword">add</span>&#125;  <span class="hljs-keyword">from</span>  &quot;./user.js&quot;<br><br>abc.sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>console.log(<span class="hljs-type">name</span>);<br><span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>标签导入</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;script <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;./main.js&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>Babel是一个Javascript编译器，有些浏览器 (如 IE) 尚未支持 ES6 模块化部分语法，因此我们需要使用 babel 对其进行转化，变为浏览器可以识别的语法（ES5）。提升其兼容性。</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.runoob.com/w3cnote/es6-module.html">菜鸟教程</a></p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue&amp; axios的基本使用</title>
    <link href="/2021/04/17/Vue&amp;axios(%E4%B8%80)/"/>
    <url>/2021/04/17/Vue&amp;axios(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h3 id="Vue-js-Ajax-axios"><a href="#Vue-js-Ajax-axios" class="headerlink" title="Vue.js Ajax(axios)"></a>Vue.js Ajax(axios)</h3><p>Vue.js 2.0 版本推荐使用 axios 来完成 ajax 请求。</p><p>Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p><p>Github开源地址： <a href="https://github.com/axios/axios">https://github.com/axios/axios</a></p><h4 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h4><ol><li>使用 cdn:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>使用 npm:<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> axios<br></code></pre></td></tr></table></figure></li><li>其他</li></ol><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol><li>axios必须先导入才可以使用</li><li>使用get或post方法即可发送对应的请求</li><li>then方法中的回调函数会在请求成功或失败时触发</li><li>通过回调函数的形参可以获取响应内容，或错误信息</li></ol><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;get请求&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;get&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;post请求&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;post&quot;</span> /&gt;</span><br>  <span class="hljs-comment">&lt;!-- 官网提供的axios在线地址 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    /*<br>        接口1：随机笑话<br><span class="javascript">        请求地址：https:<span class="hljs-comment">//autumnfish.cn/api/joke/list</span></span><br>        请求方法：get<br>        请求参数：num(笑话条数，数字)<br>        响应内容：随机笑话<br>        */<br><span class="javascript">    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.get&quot;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br>      axios<br><span class="javascript">        .get(<span class="hljs-string">&quot;https://autumnfish.cn/api/joke/list?num=6&quot;</span>)</span><br><span class="javascript">        .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(response);</span><br>        &#125;),<br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(err);</span><br>        &#125;;<br>    &#125;;<br>    /*<br>        接口2：用户注册<br><span class="javascript">        请求地址：https:<span class="hljs-comment">//autumnfish.cn/api/user/reg</span></span><br>        请求方法：post<br>        请求参数：username(用户名，字符串)<br>        响应内容：注册成功失败<br>        */<br><span class="javascript">    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.post&quot;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br>      axios<br><span class="javascript">        .post(<span class="hljs-string">&quot;https://autumnfish.cn/api/user/reg&quot;</span>, &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;jack&quot;</span> &#125;)</span><br><span class="javascript">        .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(response);</span><br>        &#125;),<br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(err);</span><br>        &#125;;<br>    &#125;;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>querySelector() 方法返回文档中匹配指定 CSS 选择器的一个元素。</p><p>注意： querySelector() 方法仅仅返回匹配指定选择器的第一个元素。如果你需要返回所有的元素，请使用 querySelectorAll() 方法替代。</p><h3 id="axios-vue"><a href="#axios-vue" class="headerlink" title="axios+vue"></a>axios+vue</h3><p>例子：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;获取笑话&quot;</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;getJoke&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">joke</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  <span class="hljs-comment">&lt;!-- 官网提供的axios在线地址 --&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">    /*</span><br><span class="xml">        接口1：随机笑话</span><br><span class="xml">        请求地址：https://autumnfish.cn/api/joke/list</span><br><span class="xml">        请求方法：get</span><br><span class="xml">        请求参数：num(笑话条数，数字)</span><br><span class="xml">        响应内容：随机笑话</span><br><span class="xml">        */</span><br><span class="xml">    var app = new Vue(&#123;</span><br><span class="xml">      el: &quot;#app&quot;,</span><br><span class="xml">      data: &#123;</span><br><span class="xml">        joke: &quot;很好笑的笑话&quot;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">      methods: &#123;</span><br><span class="xml">        getJoke: function () &#123;</span><br><span class="xml">          console.log(this.joke);</span><br><span class="xml">          var that = this;</span><br><span class="xml">          axios</span><br><span class="xml">            .get(&quot;https://autumnfish.cn/api/joke&quot;)</span><br><span class="xml">            .then(function (response) &#123;</span><br><span class="xml">              // console.log(response);</span><br><span class="xml">              console.log(response.data);</span><br><span class="xml">              // console.log(this.joke);</span><br><span class="xml">              that.joke = response.data;</span><br><span class="xml">            &#125;),</span><br><span class="xml">            function (err) &#123;&#125;;</span><br><span class="xml">        &#125;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">    &#125;);</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue&amp;v-on&amp;v-show&amp;v-if&amp;v-bind&amp;v-for&amp;v-model</title>
    <link href="/2021/04/16/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
    <url>/2021/04/16/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。</p><p>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。</p><hr><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><ol><li>该指令的作用是：为元素绑定事件</li><li>事件名不需要写on</li><li>指令可以简写为@</li><li>绑定的方法定义在methods属性中</li><li>方法内部通过this关键字可以访问定义在data中的数据</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;v-on指令&quot;</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;doIt&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;v-on简写&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;doIt&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;双击事件&quot;</span> @<span class="hljs-attr">dblclick</span>=<span class="hljs-string">&quot;doIt&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeFood&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">food</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">    var app = new Vue(&#123;</span><br><span class="xml">      el: &quot;#app&quot;,</span><br><span class="xml">      data: &#123;</span><br><span class="xml">        food: &quot;西兰花炒蛋&quot;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">      methods: &#123;</span><br><span class="xml">        doIt: function () &#123;</span><br><span class="xml">          alert(&quot;学Vue&quot;);</span><br><span class="xml">        &#125;,</span><br><span class="xml">        changeFood: function () &#123;</span><br><span class="xml">          // console.log(this.food);</span><br><span class="xml">          this.food += &quot;好好吃！&quot;;</span><br><span class="xml">        &#125;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">    &#125;);</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/image/11.6.PNG" alt="效果图"></p><h4 id="v-on例子"><a href="#v-on例子" class="headerlink" title="v-on例子"></a>v-on例子</h4><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">  <span class="hljs-comment">&lt;!-- html结构 --&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-num&quot;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">num</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sub&quot;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  <span class="hljs-comment">&lt;!-- 编码 --&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">    // 创建Vue实例</span><br><span class="xml">    var app = new Vue(&#123;</span><br><span class="xml">      el: &quot;#app&quot;,</span><br><span class="xml">      data: &#123;</span><br><span class="xml">        num: 1,</span><br><span class="xml">      &#125;,</span><br><span class="xml">      methods: &#123;</span><br><span class="xml">        add: function () &#123;</span><br><span class="xml">          // console.log(&quot;add&quot;);</span><br><span class="xml">          if (this.num &lt; 10) &#123;</span><br><span class="xml">            this.num++;</span><br><span class="xml">          &#125; else &#123;</span><br><span class="xml">            alert(&quot;别点了，最大了！&quot;);</span><br><span class="xml">          &#125;</span><br><span class="xml">        &#125;,</span><br><span class="xml">        sub: function () &#123;</span><br><span class="xml">          // console.log(&quot;sub&quot;);</span><br><span class="xml">          if (this.num &gt; 0) &#123;</span><br><span class="xml">            this.num--;</span><br><span class="xml">          &#125; else &#123;</span><br><span class="xml">            alert(&quot;别点了，最小了&quot;);</span><br><span class="xml">          &#125;</span><br><span class="xml">        &#125;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">    &#125;);</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><ol><li>该指令的作用是根据真假切换元素的显示状态</li><li>原理是修改元素的display，实现显示隐藏</li><li>指令后面的内容，最终都会解析为<strong>布尔值</strong></li><li>值为<strong>true</strong>元素显示，值为<strong>false</strong>元素隐藏</li><li>数据改变之后，对应元素的显示状态会<strong>同步更新</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;切换显示状态&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeIsShow&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;累加年龄&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addAge&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isshow&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;.//node_modules/vue/img/1.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;age&gt;=18&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;.//node_modules/vue/img/1.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&quot;#app&quot;</span>,</span><br>      data: &#123;<br><span class="javascript">        isshow: <span class="hljs-literal">false</span>,</span><br>        age: 17,<br>      &#125;,<br>      methods: &#123;<br><span class="javascript">        changeIsShow: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.isshow = !<span class="hljs-built_in">this</span>.isshow;</span><br>        &#125;,<br><span class="javascript">        addAge: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.age++;</span><br>        &#125;,<br>      &#125;,<br>    &#125;);<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><ol><li>该指令的作用是根据表达式的真假来切换元素的显示状态</li><li>本质是通过操作<strong>dom</strong>元素来切换显示状态</li><li>表达式的值为<strong>true</strong>,元素存在于<strong>dom</strong>中；为<strong>false</strong>，从<strong>dom</strong>树中移除</li><li>频繁的切换使用<strong>v-show</strong>,反之使用<strong>v-if</strong>,前者的切换消耗小</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;切换显示&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toggleIsShow&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isshow&quot;</span>&gt;</span>学习Vue<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isshow&quot;</span>&gt;</span>学习Vue---v-show修饰<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;temperature&gt;=35&quot;</span>&gt;</span>热死了<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&quot;#app&quot;</span>,</span><br>      data: &#123;<br><span class="javascript">        isshow: <span class="hljs-literal">false</span>,</span><br>        temperature: 20,<br>      &#125;,<br>      methods: &#123;<br><span class="javascript">        toggleIsShow: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.isshow = !<span class="hljs-built_in">this</span>.isshow;</span><br>        &#125;,<br>      &#125;,<br>    &#125;);<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><ol><li>该指令的作用是：为元素绑定属性</li><li>完整写法是 v-bind:属性名</li><li>简写的话可以直接省略v-bind，只保留 :属性名</li><li>需要动态的增删 class 建议使用对象的方式</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>  .active &#123;<br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">&quot;imgSrc&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;imgSrc&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;imgTitle +&#x27;!!!&#x27;&quot;</span>//</span><br><span class="hljs-tag">    <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;isActive?&#x27;active&#x27;:&#x27;&#x27;&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toggleActive&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    //&#123;&#125;为使用对象的方式<br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;imgSrc&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;imgTitle +&#x27;!!!&#x27;&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;active:isActive&#125;&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toggleActive&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&quot;#app&quot;</span>,</span><br>      data: &#123;<br><span class="javascript">        imgSrc: <span class="hljs-string">&quot;https://www.itheima.com/images/logo.png&quot;</span>,</span><br><span class="javascript">        imgTitle: <span class="hljs-string">&quot;好好学习&quot;</span>,</span><br><span class="javascript">        isActive: <span class="hljs-literal">false</span>,</span><br>      &#125;,<br>      methods: &#123;<br><span class="javascript">        toggleActive: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.isActive = !<span class="hljs-built_in">this</span>.isActive;</span><br>        &#125;,<br>      &#125;,<br>    &#125;);<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><ol><li>该指令的作用是：根据数据生成列表结构</li><li>数组经常和v-for结合使用</li><li>语法是(item,index) in 数据(item可以自己取任意字母代表)</li><li>item 和index 可以结合其他指令一起使用</li><li>数组长度的更新会同步到页面上，是响应式的</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;添加数据&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;移除数据&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;remove&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(it,index)  in arr&quot;</span>&gt;</span></span><br><span class="xml">        </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">index</span>+<span class="hljs-number">1</span>&#125;&#125;</span><span class="xml">我想去旅游的地方有：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">it</span>&#125;&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in vegetables&quot;</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">&quot;item.name&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.name</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">    var app = new Vue(&#123;</span><br><span class="xml">      el: &quot;#app&quot;,</span><br><span class="xml">      data: &#123;</span><br><span class="xml">        arr: [&quot;北京&quot;, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;],</span><br><span class="xml">        vegetables: [&#123; name: &quot;西兰花炒蛋&quot; &#125;, &#123; name: &quot;蛋炒西兰花&quot; &#125;],</span><br><span class="xml">      &#125;,</span><br><span class="xml">      methods: &#123;</span><br><span class="xml">        add: function () &#123;</span><br><span class="xml">          this.vegetables.push(&#123; name: &quot;花菜炒蛋&quot; &#125;);</span><br><span class="xml">        &#125;,</span><br><span class="xml">        remove: function () &#123;</span><br><span class="xml">          this.vegetables.shift();</span><br><span class="xml">        &#125;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">    &#125;);</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="v-on-补充"><a href="#v-on-补充" class="headerlink" title="v-on 补充"></a>v-on 补充</h3><ol><li>事件绑定的方法写成 <strong> 函数调用</strong>  的形式，可以传入自定义参数</li><li>定义方法时需要定义 <strong>形参 </strong>来接收传入的实参</li><li>事件的后面跟上<strong> .修饰符</strong>可以对事件进行限制</li><li><strong> .enter </strong>可以限制触发按键回车</li><li>事件修饰符有多种</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;点击&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;doIt(666,&#x27;老铁&#x27;)&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- @keyup.enter --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">&quot;sayHi&quot;</span> /&gt;</span><br>    <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&quot;#app&quot;</span>,</span><br>      methods: &#123;<br><span class="javascript">        doIt: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">p1, p2</span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;做IT&quot;</span>);</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(p1);</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(p2);</span><br>        &#125;,<br><span class="javascript">        sayHi: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">          alert(<span class="hljs-string">&quot;吃了没&quot;</span>);</span><br>        &#125;,<br>      &#125;,<br>    &#125;);<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><ol><li>该指令的作用是便捷的设置和获取表单元素的值</li><li>绑定的数据会和表单元素的<strong>值</strong>相关联</li><li>绑定的数据<strong>&lt;—&gt;</strong>表单元素的值</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;修改message&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;setM&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">&quot;getM&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">message</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">    var app = new Vue(&#123;</span><br><span class="xml">      el: &quot;#app&quot;,</span><br><span class="xml">      data: &#123;</span><br><span class="xml">        message: &quot;学习Vue&quot;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">      methods: &#123;</span><br><span class="xml">        getM: function () &#123;</span><br><span class="xml">          alert(this.message);</span><br><span class="xml">        &#125;,</span><br><span class="xml">        setM: function () &#123;</span><br><span class="xml">          this.message = &quot;好好学习&quot;;</span><br><span class="xml">        &#125;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">    &#125;);</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue&amp;MVVM思想&amp;安装&amp;Vue.js目录结构&amp;v-text</title>
    <link href="/2021/04/16/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <url>/2021/04/16/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<p>以下是对Vue入门的学习(安装Vue,v-text,v-html  )</p><hr><h3 id="MVVM思想-重要"><a href="#MVVM思想-重要" class="headerlink" title="MVVM思想(重要)"></a>MVVM思想(重要)</h3><ol><li>M：即Model模型，包括数据和一些基本操作</li><li>V：即View，视图，页面渲染结果</li><li>VM： 即View-Model，模型于视图间的双向操作(无需开发人员干涉)</li></ol><p>在MVVM之前，开发人员从后端获取需要的数据模型，然后要通过DOM操作Model渲染到View中。而后当用户操作视图，我们还需要通过DOM获取View中的数据，然后同步到Model中。</p><p>而MVVM中的VM要做的事情就是把DOM操作完全封装起来，开发人员不再关心Model和View之间的如何相互影响的</p><h3 id="安装Vue"><a href="#安装Vue" class="headerlink" title="安装Vue"></a>安装Vue</h3><ol><li>方法一 直接<code>&lt;script&gt;</code>引入</li></ol><p>CDN<br>对于制作原型或学习，你可以这样使用最新版本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>方法二  NPM</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm  init -y  <span class="hljs-regexp">//</span>初始化项目，项目路径多了一个package.json文件，代表是一个npm来管理的项目<br>npm install vue  <span class="hljs-regexp">//</span>安装Vue   <br></code></pre></td></tr></table></figure><p>由于 npm 安装速度慢，本教程使用了淘宝的镜像及其命令 cnpm，安装使用介绍参照：使用<a href="https://www.runoob.com/nodejs/nodejs-npm.html#taobaonpm">淘宝 NPM 镜像</a>。</p><p>npm 版本需要大于 3.0，如果低于此版本需要升级它：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 查看版本</span><br>$ npm -v<br><span class="hljs-number">2</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><br><span class="hljs-comment">#升级 npm</span><br>cnpm <span class="hljs-keyword">install </span>npm -g<br><br><br><span class="hljs-comment"># 升级或安装 cnpm</span><br>npm <span class="hljs-keyword">install </span>cnpm -g<br><br>在用 Vue.<span class="hljs-keyword">js </span>构建大型应用时推荐使用 cnpm 安装：<br><span class="hljs-comment"># 最新稳定版</span><br>$ cnpm <span class="hljs-keyword">install </span>vue<br></code></pre></td></tr></table></figure><ol start="3"><li>命令行工具<br>Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。</li></ol><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 全局安装 vue-cli</span><br>$ cnpm install <span class="hljs-comment">--global vue-cli  //这里是vue cli2.x版本命令</span><br>$ npm install -g @vue/cli@<span class="hljs-number">3.11</span><span class="hljs-number">.0</span>  <span class="hljs-comment"> //这里是vue cli3.x版本命令(使用这个)</span><br><span class="hljs-comment"># 创建一个基于 webpack 模板的新项目</span><br>$ vue init webpack my-project <span class="hljs-comment"> //注：这里是vue cli2.x版本命令</span><br>$ vue  <span class="hljs-built_in">create</span>  my-project <span class="hljs-comment"> //这里是vue cli3.x版本命令</span><br><span class="hljs-comment"># 这里需要进行一些配置，默认回车即可</span><br>This will install Vue <span class="hljs-number">2.</span>x <span class="hljs-built_in">version</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> template.<br><br>For Vue <span class="hljs-number">1.</span>x use: vue init webpack<span class="hljs-comment">#1.0 my-project</span><br><br>? Project name my-project<br>? Project description A Vue.js project<br>? Author runoob &lt;test@runoob.com&gt;<br>? Vue build standalone<br>? Use ESLint <span class="hljs-built_in">to</span> lint your code? Yes<br>? Pick <span class="hljs-keyword">an</span> ESLint preset Standard<br>? Setup unit tests <span class="hljs-keyword">with</span> Karma + Mocha? Yes<br>? Setup e2e tests <span class="hljs-keyword">with</span> Nightwatch? Yes<br><br>   vue-cli · Generated <span class="hljs-string">&quot;my-project&quot;</span>.<br><br>   To <span class="hljs-built_in">get</span> started:<br>   <br>     cd my-project<br>     npm install<br>     npm run dev<br>   <br>   Documentation can be found <span class="hljs-keyword">at</span> <span class="hljs-keyword">https</span>://vuejs-templates.github.io/webpack<br></code></pre></td></tr></table></figure><p>进入项目，安装并运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> my-project</span><br><span class="hljs-meta">$</span><span class="bash"> cnpm install</span><br><span class="hljs-meta">$</span><span class="bash"> cnpm run dev</span><br> DONE  Compiled successfully in 4388ms<br><br><span class="hljs-meta">&gt;</span><span class="bash"> Listening at http://localhost:8080</span><br></code></pre></td></tr></table></figure><p>成功执行以上命令后访问 <a href="http://localhost:8080/">http://localhost:8080/</a>，</p><p><img src="/image/11.1.PNG" alt="运行效果"></p><p>注意：Vue.js 不支持 IE8 及其以下 IE 版本。</p><h3 id="Vue-js-目录结构"><a href="#Vue-js-目录结构" class="headerlink" title="Vue.js 目录结构"></a>Vue.js 目录结构</h3><p>我们使用了 npm安装项目，我们在 IDE(visual code) 中打开该目录，结构如下所示:<br><img src="/image/11.2.png" alt="Vue项目目录结构"></p><h3 id="VUE简介"><a href="#VUE简介" class="headerlink" title="VUE简介"></a>VUE简介</h3><ol><li>JavaScript框架</li><li>简化Dom操作</li><li>响应式数据驱动</li></ol><h3 id="Vue基础-el-挂载点，data-数据对象"><a href="#Vue基础-el-挂载点，data-数据对象" class="headerlink" title="Vue基础(el:挂载点，data:数据对象)"></a>Vue基础(el:挂载点，data:数据对象)</h3><h4 id="el-挂载点—用来设置Vue实例挂载-管理-的元素"><a href="#el-挂载点—用来设置Vue实例挂载-管理-的元素" class="headerlink" title="el:挂载点—用来设置Vue实例挂载(管理)的元素"></a>el:挂载点—用来设置Vue实例挂载(管理)的元素</h4><ol><li>Vue实例的作用范围是什么呢？<br>Vue会管理el选项<strong>命中的元素</strong>及其内部的<strong>后代元素</strong></li><li>是否可以使用其他的选择器？<br>可以使用其他的选择器，但是建议使用<strong>id选择器</strong>(一般建议使用id选择器(唯一)，因为类选择器和标签选择器都可以命中多个元素)</li><li>是否可以设置其他dom元素呢？<br>可以使用其他的双标签，不能使用<strong>HTML</strong>和<strong>Body</strong><br><img src="/image/11.3.png" alt="不能使用body"></li></ol><h4 id="data-数据对象"><a href="#data-数据对象" class="headerlink" title="data:数据对象"></a>data:数据对象</h4><ol><li>Vue中用到的数据定义在data中</li><li>data中可以写复杂类型的数据</li><li>渲染复杂数据类型时，遵守js的语法即可</li></ol><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><ol><li>该指令的作用的：设置标签的内容(textContent)</li><li>默认写法会<strong>替换全部内容</strong>，使用<strong>差值表达式<code>&#123;&#123;&#125;&#125;</code></strong>可以替换指定内容</li><li>内部支持写表达式</li></ol><p><img src="/image/11.4.PNG" alt="效果"></p><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><ol><li>该指令的作用是：设置元素的innerHTML</li><li>内容中有html结构会被解析为标签</li><li>v-text指令无论内容是什么，只会被解析为文本</li><li>解析文本使用v-text,需要解析html结构使用v-html</li></ol><p><img src="/image/11.5.PNG" alt="如图"></p><h4 id="为什么要用指令和插值表达式"><a href="#为什么要用指令和插值表达式" class="headerlink" title="为什么要用指令和插值表达式"></a>为什么要用指令和插值表达式</h4><p>前面我们已经说到过，在Vue中不直接对DOM进行操作，而是通过数据的改变来改变页面的显示状态。但是如果在HTML中直接像这样设置页面内容，那么改变数据时将无法用到Vue提供的便捷方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello&quot;</span> &gt;</span>hello world<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>为了能通过变量来决定显示的内容，用原生JS我们可以这样写</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">var <span class="hljs-attribute">str</span>=<span class="hljs-string">&quot;hello world&quot;</span>;<br>document.getEleMentById(<span class="hljs-string">&#x27;hello&#x27;</span>).<span class="hljs-attribute">innerText</span>=str;<br></code></pre></td></tr></table></figure><p>但此时在控制台中改变str的值，页面并不会改变，因为在页面不刷新的情况下，变量改变页面不会重新渲染。</p><p>因此，我们需要使用Vue提供的方法，来做到在不刷新页面的情况下重新渲染页面。</p><p>Vue实例的数据，要定义在实例中的data内，当某个数据改变时，就会重新渲染页面中用到了该数据的地方。而要达到这个目的，要解决的问题就是：如何使用在Vue实例中定义的数据，这也就用到了标题中的两种方法，指令和插值表达式。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-map&amp;reduce</title>
    <link href="/2021/04/14/Map&amp;&amp;Set&amp;&amp;Weakmap&amp;&amp;Weakset/"/>
    <url>/2021/04/14/Map&amp;&amp;Set&amp;&amp;Weakmap&amp;&amp;Weakset/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="1-传统对象结构"><a href="#1-传统对象结构" class="headerlink" title="1. 传统对象结构"></a>1. 传统对象结构</h4><p>Map本质上是一个键值对的集合。和传统对象结构相比，传统的对象只能用字符串作为键名，这就在使用上造成了很大的限制了。这也是新增 Map 的原因之一。</p><h4 id="2-Map-结构"><a href="#2-Map-结构" class="headerlink" title="2. Map 结构"></a>2. Map 结构</h4><p>Map类似于对象，但是键名不限于字符串，可以说Object结构提供键-值对应，Map结构提供值-值对应因此其实采用map结构会优于传统对象</p><h4 id="3-Map-的特点"><a href="#3-Map-的特点" class="headerlink" title="3. Map 的特点"></a>3. Map 的特点</h4><ol><li><p>Map 默认情况下不包含任何键，所有键都是自己添加进去的。不同于 Object 原型链上有一些默认的键。</p></li><li><p>Map 的键可以是<strong>任意类型数据</strong>，就连函数都可以。</p></li><li><p>Map 的键值对个数可以<strong>轻易</strong>通过size属性获取，Object 需要手动计算。</p></li><li><p>Map 在频繁增删键值对的场景下<strong>性能</strong>要比 Object 好。</p></li></ol><h4 id="4-什么时候用-Map"><a href="#4-什么时候用-Map" class="headerlink" title="4. 什么时候用 Map"></a>4. 什么时候用 Map</h4><ol><li>要添加的键值名和 Object 上的默认键值名冲突，又不想改名时，用 Map</li><li>需要 String 和 Symbol 以外的数据类型做键值时，用 Map</li><li>键值对很多，有需要计算数量时，用 Map</li><li>需要频繁增删键值对时，用 Map</li></ol><h3 id="Map-实例属性和方法"><a href="#Map-实例属性和方法" class="headerlink" title="Map 实例属性和方法"></a>Map 实例属性和方法</h3><h4 id="1-set"><a href="#1-set" class="headerlink" title="1. set"></a>1. set</h4><p>set方法设置键名key对应的键值为value，然后会返回整个Map结构，如果设置的key已经存在，则会更新value值，否则会新生成该键</p><h4 id="2-get"><a href="#2-get" class="headerlink" title="2. get"></a>2. get</h4><p>通过get方法读取key对应的键值，如果传入的键值不存在，则会返回undefined</p><h4 id="3-has"><a href="#3-has" class="headerlink" title="3. has"></a>3. has</h4><p>判断传入的键是否存在当前Map对象中，该方法返回一个布尔值</p><h4 id="4-delete"><a href="#4-delete" class="headerlink" title="4. delete"></a>4. delete</h4><p>删除传入的键，返回true，如果删除失败，则返回false</p><h4 id="5-clear"><a href="#5-clear" class="headerlink" title="5. clear"></a>5. clear</h4><p>清除所有成员，没有返回值</p><h3 id="三、遍历方法"><a href="#三、遍历方法" class="headerlink" title="三、遍历方法"></a>三、遍历方法</h3><p>可以采用for…of循环和forEach两种方法。由于Map实例会维护键值对的插入顺序，因此可以根据插入顺序进行遍历<br>采用for…of</p><p>for…of可以遍历有iterator接口的数据结构</p><p>keys()：返回键名的遍历器<br>values()：返回键值的遍历器<br>entries()：返回键值对的遍历器<br>forEach()：使用回调函数遍历每个成员</p><h4 id="map-entries"><a href="#map-entries" class="headerlink" title="map.entries()"></a>map.entries()</h4><p>在Map实例中有一个迭代器，能以插入顺序生成[key,value]形式的数据。<br>我们可以通过entries方法来获得这个迭代器，从而利用for…of进行遍历操作</p><h4 id="map-values"><a href="#map-values" class="headerlink" title="map.values()"></a>map.values()</h4><p>可以采用遍历map.values()的方式来遍历map容器的属性值</p><h4 id="map-keys"><a href="#map-keys" class="headerlink" title="map.keys()"></a>map.keys()</h4><p>可以采用map.keys()来遍历键名</p><h4 id="采用-forEach-回调遍历"><a href="#采用-forEach-回调遍历" class="headerlink" title="采用 forEach() 回调遍历"></a>采用 forEach() 回调遍历</h4><h3 id="四、Map-类型转化"><a href="#四、Map-类型转化" class="headerlink" title="四、Map 类型转化"></a>四、Map 类型转化</h3><p>几种与map相互类型转化的方法</p><h4 id="Map-转为数组"><a href="#Map-转为数组" class="headerlink" title="Map 转为数组"></a>Map 转为数组</h4><p>通过扩展运算符实现</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">let</span> <span class="hljs-built_in">map</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Map</span>()<br><span class="hljs-keyword">let</span> arr = <span class="hljs-meta">[</span><span class="hljs-params">...</span><span class="hljs-built_in">map</span><span class="hljs-meta">]</span><br></code></pre></td></tr></table></figure><h4 id="数组转为-Map"><a href="#数组转为-Map" class="headerlink" title="数组转为 Map"></a>数组转为 Map</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">let</span> <span class="hljs-built_in">map</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Map</span>(arr)<br></code></pre></td></tr></table></figure><h4 id="Map-转为对象"><a href="#Map-转为对象" class="headerlink" title="Map 转为对象"></a>Map 转为对象</h4><p>通过遍历利用set将键值对加入对象中</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span> = &#123;&#125;<br>for (<span class="hljs-keyword">let</span> [k, v] of <span class="hljs-built_in">map</span>) &#123;<br>  obj[k] = v<br>&#125;<br></code></pre></td></tr></table></figure><p>对象转为 Map</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">( let k of Object.keys(obj)</span></span>)&#123;<br>  map<span class="hljs-selector-class">.set</span>(k,obj<span class="hljs-selector-attr">[k]</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="五、什么是-WeakMap-？"><a href="#五、什么是-WeakMap-？" class="headerlink" title="五、什么是 WeakMap ？"></a>五、什么是 WeakMap ？</h3><p>总所周知，WeakMap是 ES6 中新增的一种集合类型，叫做“弱映射”。它和Map是兄弟关系，与Map的区别就在于这个弱字，API 还是Map的那套（只有set get has delete)<br>那它真正是什么意思呢？</p><blockquote><p>这其实描述的是 JS 中垃圾回收程序对待“弱映射”中键的方式</p></blockquote><h4 id="六、WeakMap-的特性"><a href="#六、WeakMap-的特性" class="headerlink" title="六、WeakMap 的特性"></a>六、WeakMap 的特性</h4><p>我们先从 WeakMap 的特性讲起</p><ol><li>WeakMap 只能将对象作为键名<br>只接受对象作为键名（null 除外），不接受其他类型的值作为键名<br>null 除外</li><li>WeakMap 的键名引用的对象是弱引用<br>这里懵了挺久的，但是这是WeakMap结构的关键所在</li></ol><p>要想读懂这句话，不容易，我们需要先知道强引用和弱引用</p><h6 id="在上面我们谈到强引用数据被删除时，需要手动解除引用，而弱引用则可以等待垃圾回收机制自动清除"><a href="#在上面我们谈到强引用数据被删除时，需要手动解除引用，而弱引用则可以等待垃圾回收机制自动清除" class="headerlink" title="在上面我们谈到强引用数据被删除时，需要手动解除引用，而弱引用则可以等待垃圾回收机制自动清除"></a>在上面我们谈到强引用数据被删除时，需要手动解除引用，而弱引用则可以等待垃圾回收机制自动清除</h6><p>总的来说， WeakMap 保持了对键名所引用的对象的弱引用，即垃圾回收机制不将该引用考虑在内。只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p><h4 id="七、Map-和-WeakMap-的区别"><a href="#七、Map-和-WeakMap-的区别" class="headerlink" title="七、Map 和 WeakMap 的区别"></a>七、Map 和 WeakMap 的区别</h4><p>看到这里相信心中已经有答案了</p><p>1.Map 的键可以是任意类型，WeakMap 只接受对象作为键（null除外），不接受其他类型的值作为键<br>2. Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键； WeakMap 的键是弱引用，键所指向的对象可以被垃圾回收，此时键是无效的<br>3. Map 可以被遍历， WeakMap 不能被遍历</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6993101968545677319">浅析 Map 和 WeakMap 区别以及使用场景</a></p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS3--flex布局</title>
    <link href="/2021/04/14/CSS3flex%E5%B8%83%E5%B1%80/"/>
    <url>/2021/04/14/CSS3flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>以下是对flex布局的学习(重点)</p><hr><h3 id="flex布局体验"><a href="#flex布局体验" class="headerlink" title="flex布局体验"></a>flex布局体验</h3><p><img src="/image/10.png" alt="flex布局"></p><h3 id="布局原理"><a href="#布局原理" class="headerlink" title="布局原理"></a>布局原理</h3><p>flex  是flexible  Box的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为flex布局。</p><ul><li>当我们为父盒子设为flex布局以后，子元素的float,clear和vertical-align属性将无效</li><li>伸缩布局=弹性布局=伸缩盒布局=弹性盒布局=flex布局            <h4 id="flex布局布局原理：就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式"><a href="#flex布局布局原理：就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式" class="headerlink" title="flex布局布局原理：就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式"></a>flex布局布局原理：就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式</h4></li></ul><h3 id="常见父项属性"><a href="#常见父项属性" class="headerlink" title="常见父项属性"></a>常见父项属性</h3><p>以下由6个属性是对父元素设置的</p><ul><li>flex-direction:  设置主轴的方向</li><li>justify-content:  设置主轴上的子元素排列方式</li><li>flex-warp: 设置子元素是否换行</li><li>align-content:设置侧轴上的子元素排列方式(多行)</li><li>align-items:设置侧轴上的子元素排列方式(单行)</li><li>flex-flow: 符合属性，相当于同时设置了flex-direction和flex-warp</li></ul><h4 id="flex-direction-设置主轴的方向"><a href="#flex-direction-设置主轴的方向" class="headerlink" title="flex-direction:  设置主轴的方向"></a>flex-direction:  设置主轴的方向</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="css">    <span class="hljs-comment">/* 给父级添加flex属性 */</span></span><br><span class="css">    <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    <span class="hljs-comment">/* 默认的主轴是x轴，行 row  那么y轴就是侧轴 */</span></span><br><span class="css">    <span class="hljs-comment">/* 我们的元素是跟着主轴来排列的 */</span></span><br><span class="css">    <span class="hljs-comment">/* flex-direction: row; 默认从左到右*/</span></span><br><span class="css">    <span class="hljs-comment">/* flex-direction: row-reverse; 简单了解  翻转从右到左 */</span></span><br><span class="css">    <span class="hljs-comment">/* flex-direction: column; 从上到下 */</span></span><br><span class="css">    <span class="hljs-comment">/* flex-direction: column-reverse;  从下到上 */</span></span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: red;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="justify-content-设置主轴上的子元素排列方式"><a href="#justify-content-设置主轴上的子元素排列方式" class="headerlink" title="justify-content 设置主轴上的子元素排列方式"></a>justify-content 设置<strong>主轴</strong>上的子元素排列方式</h4><h4 id="注意：使用这个属性之前一定要确定好主轴是哪个"><a href="#注意：使用这个属性之前一定要确定好主轴是哪个" class="headerlink" title="注意：使用这个属性之前一定要确定好主轴是哪个"></a>注意：使用这个属性之前一定要确定好主轴是哪个</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs awk">div &#123;<br>  display: flex;<br>  width: <span class="hljs-number">800</span>px;<br>  height: <span class="hljs-number">300</span>px;<br>  background-color: pink;<br>  <span class="hljs-regexp">/* 默认的主轴是x轴row */</span><br>  flex-direction: row;<br>  <span class="hljs-regexp">/*默认值，从头部开始，如果主轴是x轴，则从左到右  */</span><br>  <span class="hljs-regexp">/* justify-content: flex-start; */</span><br><br>  <span class="hljs-regexp">/* 从尾部开始 */</span><br>  <span class="hljs-regexp">/* justify-content: flex-end; */</span><br><br>  <span class="hljs-regexp">/* 让我们子元素居中对齐 */</span><br>  <span class="hljs-regexp">/* justify-content: center; */</span><br><br>  <span class="hljs-regexp">/* 平分剩余空间 */</span><br>  <span class="hljs-regexp">/* justify-content: space-around; */</span><br><br>  <span class="hljs-regexp">/* 先两边贴边，在分配剩余的空间 */</span><br>  <span class="hljs-regexp">/* justify-content: space-between; */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="flex-wrap-wrap-设置子元素是否换行"><a href="#flex-wrap-wrap-设置子元素是否换行" class="headerlink" title="flex-wrap: wrap  设置子元素是否换行"></a>flex-wrap: wrap  设置子元素是否换行</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-comment">/* flex布局中，默认的子元素是不换行的，如果装不开，会缩小子元素的宽度，放到父元素里面 */</span><br><br>  <span class="hljs-comment">/* flex-wrap: nowrap; nowrap默认值,不换行*/</span><br><br>  <span class="hljs-comment">/* flex-wrap: wrap; 换行 */</span><br>&#125;<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: purple;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="align-items-设置侧轴上的子元素排列方式-单行"><a href="#align-items-设置侧轴上的子元素排列方式-单行" class="headerlink" title="align-items 设置侧轴上的子元素排列方式(单行)"></a>align-items 设置侧轴上的子元素排列方式(单行)</h3><p>该属性是控制子项在侧轴(默认是y轴)上的排列方式，在子项为单项的时候使用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">display: flex;<br><br><span class="hljs-regexp">/* 我们是需要一个侧轴居中 */</span><br>align-items: center;<br><br><span class="hljs-regexp">/* 从上到下 */</span><br><span class="hljs-regexp">/* align-items: flex-start; */</span><br><br><span class="hljs-regexp">/* 从下到上 */</span><br><span class="hljs-regexp">/* align-items: flex-end; */</span><br><br><span class="hljs-regexp">/*拉伸，但是子盒子不要给高度  */</span><br><span class="hljs-regexp">/* align-items: stretch; */</span><br></code></pre></td></tr></table></figure><h3 id="align-content-设置侧轴上的子元素的排列方式-多行"><a href="#align-content-设置侧轴上的子元素的排列方式-多行" class="headerlink" title="align-content 设置侧轴上的子元素的排列方式(多行)"></a>align-content 设置侧轴上的子元素的排列方式(多行)</h3><p><img src="/image/10.1.png" alt="换行"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">800px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br><br>  <span class="hljs-comment">/* 因为有了换行，此时我们侧轴上控制子元素的对齐方式我们用align-content */</span><br><br>  <span class="hljs-comment">/* align-content: flex-start; */</span><br>  <span class="hljs-attribute">align-content</span>: center;<br>  <span class="hljs-comment">/* align-content: space-between; */</span><br>  <span class="hljs-comment">/* align-content: space-around; */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="align-content-和align-items区别"><a href="#align-content-和align-items区别" class="headerlink" title="align-content 和align-items区别"></a>align-content 和align-items区别</h3><p><img src="/image/10.2.png" alt="区别"></p><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p>flex-flow 属性是flex-direction和flex-wrap 属性的复合属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* flex-direction: column;</span><br><span class="hljs-comment">flex-wrap: wrap; */</span><br><span class="hljs-comment">/* 把设置主轴方向和 是否换行(换列)简写*/</span><br><span class="hljs-attribute">flex-flow</span>: column wrap;<br></code></pre></td></tr></table></figure><h3 id="flex布局子项常见属性"><a href="#flex布局子项常见属性" class="headerlink" title="flex布局子项常见属性"></a>flex布局子项常见属性</h3><ol><li>flex子项目占的分数</li></ol><p>flex属性定义子项目<strong>分配剩余空间</strong>，用flex来表示占多少<strong>份数</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-selector-tag">section</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">60%</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">section</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>) &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: red;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">section</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;</span><br><span class="css">    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><br><span class="css">    <span class="hljs-comment">/* flex:&lt;number&gt; 表示多少份 */</span></span><br><span class="css">    <span class="hljs-attribute">background-color</span>: green;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">section</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: blue;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>align-self 控制子项自己在侧轴上的排列方式(了解)<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    <span class="hljs-comment">/* 让三个子盒子沿着侧轴底侧对齐 */</span></span><br><span class="css">    <span class="hljs-comment">/* align-items: flex-end; */</span></span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: purple;</span><br><span class="css">    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">5px</span>;</span><br>  &#125;<br><span class="css">  <span class="hljs-comment">/* 我们想只让3号盒子下来底侧 */</span></span><br><span class="css">  <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) &#123;</span><br><span class="css">    <span class="hljs-attribute">align-self</span>: flex-end;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>order 属性定义项目的排列顺序(了解)</li></ol><p>数值越小，排列越靠前，默认为0<br>注意：和z-index不一样</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-attribute">order</span>: -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>前端基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-Object新增的API&amp;声明对象的简写&amp;对象函数的简写</title>
    <link href="/2021/04/13/ES6(%E5%9B%9B)/"/>
    <url>/2021/04/13/ES6(%E5%9B%9B)/</url>
    
    <content type="html"><![CDATA[<p>以下是对新增的API,声明对象的简写,对象函数的简写,对象拓展运算符的学习</p><hr><h3 id="新增的API"><a href="#新增的API" class="headerlink" title="新增的API"></a>新增的API</h3><p>ES6给Object扩展了许多新的方法，如：</p><h4 id="keys-obj-，获取对象的所有key形成的数组"><a href="#keys-obj-，获取对象的所有key形成的数组" class="headerlink" title="-keys(obj)，获取对象的所有key形成的数组"></a>-keys(obj)，获取对象的所有key形成的数组</h4><h4 id="values-obj-获取对象的所有value形成的数组"><a href="#values-obj-获取对象的所有value形成的数组" class="headerlink" title="-values(obj),获取对象的所有value形成的数组"></a>-values(obj),获取对象的所有value形成的数组</h4><h4 id="entries-obj-，获取对象的所有key和value形成的二维数组"><a href="#entries-obj-，获取对象的所有key和value形成的二维数组" class="headerlink" title="-entries(obj)，获取对象的所有key和value形成的二维数组"></a>-entries(obj)，获取对象的所有key和value形成的二维数组</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const person = &#123;<br>   <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>   age: <span class="hljs-number">21</span>,<br>   <span class="hljs-keyword">language</span>: [<span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;js&#x27;</span>, <span class="hljs-string">&#x27;css&#x27;</span>],<br> &#125;;<br> console.log(<span class="hljs-keyword">Object</span>.keys(person)); <br> console.log(<span class="hljs-keyword">Object</span>.<span class="hljs-keyword">values</span>(person)); <br> console.log(<span class="hljs-keyword">Object</span>.entries(person)); <br><br></code></pre></td></tr></table></figure><p><img src="/imageO/Object.jpg" alt="Object"><br>对象的新方法</p><h4 id="Object-assign-dest-···src-将多个src对象的值拷贝到dest中-第一层为深拷贝，第二层为浅拷贝"><a href="#Object-assign-dest-···src-将多个src对象的值拷贝到dest中-第一层为深拷贝，第二层为浅拷贝" class="headerlink" title="Object.assign(dest,  ···src) ,将多个src对象的值拷贝到dest中(第一层为深拷贝，第二层为浅拷贝)"></a>Object.assign(dest,  ···src) ,将多个src对象的值拷贝到dest中(第一层为深拷贝，第二层为浅拷贝)</h4><p>用于将源对象的所有可枚举属性复制到目标对象中。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">const</span> <span class="hljs-keyword">target</span> = &#123; a: 1 &#125;;<br><span class="hljs-keyword">const</span> source1 = &#123; b: 2 &#125;;<br><span class="hljs-keyword">const</span> source2 = &#123; c: 3 &#125;;<br><span class="hljs-comment">// Object.assign方法的第一个参数是目标对象，后面的参数都是源对象</span><br>Object.assign(<span class="hljs-keyword">target</span>, source1, source2);<br>console.log(<span class="hljs-keyword">target</span>); <span class="hljs-comment">//&#123;a: 1, b: 2, c: 3&#125;</span><br></code></pre></td></tr></table></figure><p>Object.assign()方法的第一个参数是目标对象，后面的参数都是源对象。<br>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。<br>如果只有一个参数，Object.assign()会直接返回该参数。<br>如果该参数不是对象，则会先转成对象，然后返回。<br>由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。<br>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。</p><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。<br>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.is</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;foo&#x27;</span>)<br><span class="hljs-comment">// true</span><br><span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.is</span>(&#123;&#125;, &#123;&#125;)<br><span class="hljs-comment">// false</span><br><br></code></pre></td></tr></table></figure><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p>ES5 的Object.getOwnPropertyDescriptor()方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk">const obj = &#123;<br>  foo: <span class="hljs-number">123</span>,<br>  get bar() &#123; return <span class="hljs-string">&#x27;abc&#x27;</span> &#125;<br>&#125;;<br><br>Object.getOwnPropertyDescriptors(obj)<br><span class="hljs-regexp">//</span> &#123; foo:<br><span class="hljs-regexp">//</span>    &#123; value: <span class="hljs-number">123</span>,<br><span class="hljs-regexp">//</span>      writable: true,<br><span class="hljs-regexp">//</span>      enumerable: true,<br><span class="hljs-regexp">//</span>      configurable: true &#125;,<br><span class="hljs-regexp">//</span>   bar:<br><span class="hljs-regexp">//</span>    &#123; get: [Function: get bar],<br><span class="hljs-regexp">//</span>      set: undefined,<br><span class="hljs-regexp">//</span>      enumerable: true,<br><span class="hljs-regexp">//</span>      configurable: true &#125; &#125;<br></code></pre></td></tr></table></figure><p>上面代码中，Object.getOwnPropertyDescriptors()方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p><h3 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__属性"></a>__proto__属性</h3><p>JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。<br>__proto__属性<br>__proto__属性（前后各两个下划线），用来读取或设置当前对象的原型对象（prototype）。目前，所有浏览器（包括 IE11）都部署了这个属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// es5 的写法</span><br><span class="hljs-keyword">const</span> obj = &#123;<br>  method: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; ... &#125;<br>&#125;;<br>obj.__proto__ = someOtherObj;<br><br><span class="hljs-comment">// es6 的写法</span><br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(someOtherObj);<br>obj.method = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; ... &#125;;<br></code></pre></td></tr></table></figure><p>该属性没有写入 ES6 的正文，而是写入了附录，原因是__proto__前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/7000675538310266910#heading-6">es6对象新增的方法</a></p><h3 id="声明对象的简写"><a href="#声明对象的简写" class="headerlink" title="声明对象的简写"></a>声明对象的简写</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">const</span> age = <span class="hljs-number">23</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;张三&#x27;</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">const</span> person1 = &#123; age: age, name: name &#125;<span class="hljs-comment">;</span><br><br><span class="hljs-keyword">const</span> person2 = &#123; age, name &#125;<span class="hljs-comment">;</span><br>console.<span class="hljs-built_in">log</span>(person2)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="对象函数的简写"><a href="#对象函数的简写" class="headerlink" title="对象函数的简写"></a>对象函数的简写</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person3 = &#123;<br>  name: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>  <span class="hljs-comment">//以前</span><br>  eat: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">food</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;在吃&#x27;</span> + food);<br>  &#125;,<br>  <span class="hljs-comment">//箭头函数this不能使用，对象，属性</span><br>  eat2: <span class="hljs-function">(<span class="hljs-params">food</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(person3.name + <span class="hljs-string">&#x27;在吃&#x27;</span> + food),<br>  <span class="hljs-comment">//方法三  使用较多</span><br>  <span class="hljs-function"><span class="hljs-title">eat3</span>(<span class="hljs-params">food</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;在吃&#x27;</span> + food);<br>  &#125;,<br>&#125;;<br>person3.eat(<span class="hljs-string">&#x27;香蕉&#x27;</span>);<br>person3.eat2(<span class="hljs-string">&#x27;苹果&#x27;</span>);<br>person3.eat3(<span class="hljs-string">&#x27;橘子&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="对象拓展运算符"><a href="#对象拓展运算符" class="headerlink" title="对象拓展运算符"></a>对象拓展运算符</h3><ol><li>拷贝对象（第一层为深拷贝，第二层为浅拷贝）</li></ol><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">let</span> p1 = &#123; name: <span class="hljs-string">&#x27;Amy&#x27;</span>, age: <span class="hljs-number">15</span> &#125;;<br><span class="hljs-keyword">let</span> someone = &#123; <span class="hljs-params">...</span>p1 &#125;;<br>console.<span class="hljs-keyword">log</span>(someone); <span class="hljs-comment">//age: 15 name: &quot;Amy&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>合并对象</li></ol><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">let</span> age1 = &#123; age: <span class="hljs-number">15</span> &#125;;<br><span class="hljs-keyword">let</span> name1 = &#123; name: <span class="hljs-string">&#x27;Amy&#x27;</span> &#125;;<br><span class="hljs-comment">//假设之前已经有一个值，但是打印时最后的值还是会覆盖原来的值</span><br><span class="hljs-keyword">let</span> p2 = &#123; name: <span class="hljs-string">&#x27;zhangsan&#x27;</span> &#125;;<br>p2 = &#123; <span class="hljs-params">...</span>age1, <span class="hljs-params">...</span>name1 &#125;;<br>console.<span class="hljs-keyword">log</span>(p2); <span class="hljs-comment">//age: 15 name: &quot;Amy&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-函数优化&amp;箭头函数(使用较多)</title>
    <link href="/2021/04/13/ES6(%E4%B8%89)/"/>
    <url>/2021/04/13/ES6(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<p>以下是对函数,不定参数,箭头函数的学习</p><hr><h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法；</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-comment">//判断是否为空，为空就给默认值；</span><br>  b = b || <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-comment">//传一个参数</span><br><span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">10</span>));<br><span class="hljs-comment">//现在可以这么写，直接给参数写上默认值，没传给会自动使用默认值</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add2</span>(<span class="hljs-params">a, b = <span class="hljs-number">1</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-built_in">console</span>.log(add2(<span class="hljs-number">20</span>));<br></code></pre></td></tr></table></figure><p>注意点：使用函数默认参数时，不允许有同名参数。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs fortran">// 不报错<br><span class="hljs-function"><span class="hljs-keyword">function</span></span> fn(<span class="hljs-keyword">name</span>,<span class="hljs-keyword">name</span>)&#123;<br> console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">name</span>);<br>&#125;<br> <br>// 报错<br>//SyntaxError: Duplicate <span class="hljs-keyword">parameter</span> <span class="hljs-keyword">name</span> not allowed <span class="hljs-keyword">in</span> this context<br><span class="hljs-function"><span class="hljs-keyword">function</span></span> fn(<span class="hljs-keyword">name</span>,<span class="hljs-keyword">name</span>,age=<span class="hljs-number">17</span>)&#123;<br> console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">name</span>+<span class="hljs-string">&quot;,&quot;</span>+age);<br>&#125;<br></code></pre></td></tr></table></figure><p>只有在未传递参数，或者参数为 undefined 时，才会使用默认参数，null 值被认为是有效的值传递。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> fn(<span class="hljs-type">name</span>,age=<span class="hljs-number">17</span>)&#123;<br>    console.log(<span class="hljs-type">name</span>+&quot;,&quot;+age);<br>&#125;<br>fn(&quot;Amy&quot;,<span class="hljs-keyword">null</span>); // Amy,<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><h3 id="不定参数"><a href="#不定参数" class="headerlink" title="不定参数"></a>不定参数</h3><p>不定参数用来表示不确定参数个数，形如，…变量名，由…加上一个具名参数标识符组成。具名参数只能放在参数组的最后，并且有且只有一个不定参数。</p><p>基本用法</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-rest_arg">...values</span>)</span></span>&#123;<br>    console.log(values.length);<br>&#125;<br>f(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);      <span class="hljs-comment">//2</span><br>f(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);  <span class="hljs-comment">//4</span><br></code></pre></td></tr></table></figure><h3 id="箭头函数-使用较多"><a href="#箭头函数-使用较多" class="headerlink" title="箭头函数(使用较多)"></a>箭头函数(使用较多)</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">      <span class="hljs-comment">//以前声明一个方法</span><br>      <span class="hljs-comment">// var  print=function(obj)&#123;</span><br>      <span class="hljs-comment">//     console.log(obj);</span><br>      <span class="hljs-comment">// &#125;</span><br>      <span class="hljs-keyword">var</span> print = <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> console.log(obj);<br>      print(<span class="hljs-string">&#x27;hello&#x27;</span>);<span class="hljs-comment">//hello</span><br>或<br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>)</span>&#123;<br> <span class="hljs-keyword">return</span> a;<br>&#125;<br>f(<span class="hljs-number">1</span>);  <span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><p>当箭头函数没有参数或者有多个参数，要用 () 括起来。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> f = <span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> a+b;<br>f(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>);  <span class="hljs-comment">//8</span><br></code></pre></td></tr></table></figure><p>当箭头函数函数体有多行语句，用 {} 包裹起来，表示代码块，当只有一行语句，并且需要返回结果时，可以省略 {} , 结果会自动返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> &#123;<br> <span class="hljs-keyword">let</span> result = a+b;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br>f(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>);  <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><p>当箭头函数要返回对象的时候，为了区分于代码块，要用 () 将对象包裹起来</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xquery">// 报错<br>var f = <span class="hljs-built_in">(id</span><span class="hljs-built_in">,name</span>) =&gt; <span class="hljs-built_in">&#123;id</span>:<span class="hljs-built_in"> id</span>,<span class="hljs-built_in"> name</span>:<span class="hljs-built_in"> name</span>&#125;;<br>f(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>);  // SyntaxError: Unexpected token :<br> <br>// 不报错<br>var f = <span class="hljs-built_in">(id</span><span class="hljs-built_in">,name</span>) =&gt; (<span class="hljs-built_in">&#123;id</span>:<span class="hljs-built_in"> id</span>,<span class="hljs-built_in"> name</span>:<span class="hljs-built_in"> name</span>&#125;);<br>f(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>);  // <span class="hljs-built_in">&#123;id</span>: <span class="hljs-number">6</span>,<span class="hljs-built_in"> name</span>: <span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><p>注意点：没有 this、super、arguments 和 new.target 绑定。<br>箭头函数体中的 this 对象，是定义函数时的对象，而不是使用函数时的对象。<br>不可以作为构造函数，也就是不能使用 new 命令，否则会报错</p><ul><li>箭头函数+解构</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  name: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>  age: <span class="hljs-number">21</span>,<br>  language: [<span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;js&#x27;</span>, <span class="hljs-string">&#x27;css&#x27;</span>],<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params">person</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>, person.name);<br>&#125;<br><span class="hljs-comment">//箭头函数+解构</span><br><span class="hljs-keyword">var</span> hello2 = <span class="hljs-function">(<span class="hljs-params">&#123; name &#125;</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>, name);<br>hello2(person);<br></code></pre></td></tr></table></figure><h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><p>本篇我们重点比较一下箭头函数与普通函数。<br>主要区别包括：</p><h4 id="没有-this"><a href="#没有-this" class="headerlink" title="没有 this"></a>没有 this</h4><p>箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。<br>这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this。</p><h4 id="1-箭头函数this为父作用域的this，不是调用时的this"><a href="#1-箭头函数this为父作用域的this，不是调用时的this" class="headerlink" title="1.箭头函数this为父作用域的this，不是调用时的this"></a>1.箭头函数this为父作用域的this，不是调用时的this</h4><p><img src="/imageO/JTHS.jpg" alt="this"><br>箭头函数的this永远指向其父作用域，任何方法都改变不了，包括call，apply，bind。</p><p>普通函数的this指向调用它的那个对象。</p><blockquote><p>上例中，init为箭头函数，其内部的this为全局window，onclick的this也就是init函数的this，也是window，得到的this.name就为undefined。</p></blockquote><h4 id="没有-arguments"><a href="#没有-arguments" class="headerlink" title="没有 arguments"></a>没有 arguments</h4><p>箭头函数没有自己的 arguments 对象，这不一定是件坏事，因为箭头函数可以访问外围函数的 arguments 对象：<br>那如果我们就是要访问箭头函数的参数呢？<br>你可以通过命名参数或者 rest 参数的形式访问参数:<br>let nums = (…nums) =&gt; nums;</p><h4 id="不能通过-new-关键字调用"><a href="#不能通过-new-关键字调用" class="headerlink" title="不能通过 new 关键字调用"></a>不能通过 new 关键字调用</h4><p>JavaScript 函数有两个内部方法：[[Call]] 和 [[Construct]]。</p><p>当通过 new 调用函数时，执行 [[Construct]] 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。</p><p>当直接调用的时候，执行 [[Call]] 方法，直接执行函数体。</p><p>箭头函数并没有 [[Construct]] 方法，不能被用作构造函数，如果通过 new 的方式调用，会报错。</p><p>var Foo = () =&gt; {};<br>var foo = new Foo(); // TypeError: Foo is not a constructor</p><h4 id="没有-new-target"><a href="#没有-new-target" class="headerlink" title="没有 new.target"></a>没有 new.target</h4><p>因为不能使用 new 调用，所以也没有 new.target 值。</p><p>关于 new.target，可以参考 es6.ruanyifeng.com/#docs/class…</p><h4 id="没有原型"><a href="#没有原型" class="headerlink" title="没有原型"></a>没有原型</h4><p>由于不能使用 new 调用箭头函数，所以也没有构建原型的需求，于是箭头函数也不存在 prototype 这个属性。</p><p>var Foo = () =&gt; {};<br>console.log(Foo.prototype); // undefined</p><h4 id="没有-super"><a href="#没有-super" class="headerlink" title="没有 super"></a>没有 super</h4><p>连原型都没有，自然也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的，不过跟 this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。</p><h4 id="箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或-new-target。这些函数表达式最适合用于非方法函数-non-method-functions-，并且它们不能用作构造函数"><a href="#箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或-new-target。这些函数表达式最适合用于非方法函数-non-method-functions-，并且它们不能用作构造函数" class="headerlink" title="箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数(non-method functions)，并且它们不能用作构造函数"></a>箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数(non-method functions)，并且它们不能用作构造函数</h4><p><a href="https://juejin.cn/post/6844903616231260174#heading-4">参考文章</a></p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-解构&amp;字符串</title>
    <link href="/2021/04/12/ES6(%E4%BA%8C)/"/>
    <url>/2021/04/12/ES6(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<p>以下是对解构&amp;字符串的学习</p><hr><p>解构赋值是对赋值运算符的扩展。<br>他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。</p><p>解构的源，解构赋值表达式的右边部分。<br>解构的目标，解构赋值表达式的左边部分。</p><h3 id="数组模型的解构（Array）"><a href="#数组模型的解构（Array）" class="headerlink" title="数组模型的解构（Array）"></a>数组模型的解构（Array）</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">let arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-regexp">//</span>以前我们想获取其中的值，只能通过角标。ES6可以这样。<br><span class="hljs-regexp">//</span>   let a = arr[<span class="hljs-number">0</span>];<br><span class="hljs-regexp">//</span>   let b = arr[<span class="hljs-number">1</span>];<br><span class="hljs-regexp">//</span>   let c = arr[<span class="hljs-number">2</span>];<br>let [a, b, c] = arr; <span class="hljs-regexp">//</span>x,y,z将与arr中的每个位置对应来取值<br>console.log(a, b, c);<br></code></pre></td></tr></table></figure><h3 id="对象模型的解构（Object）"><a href="#对象模型的解构（Object）" class="headerlink" title="对象模型的解构（Object）"></a>对象模型的解构（Object）</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sqf">const person = &#123;<br>  <span class="hljs-built_in">name</span>: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>  age: <span class="hljs-number">21</span>,<br>  <span class="hljs-built_in">language</span>: [<span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;js&#x27;</span>, <span class="hljs-string">&#x27;css&#x27;</span>],<br>&#125;;<br><span class="hljs-comment">// const  name=person.name;</span><br><span class="hljs-comment">// const  age=person.age;</span><br><span class="hljs-comment">// const  language=person.language;</span><br><span class="hljs-comment">//对象结构</span><br>const &#123; <span class="hljs-built_in">name</span>, age, <span class="hljs-built_in">language</span> &#125; = person; <span class="hljs-comment">//方法一</span><br>const &#123; <span class="hljs-built_in">name</span>: abc, age, <span class="hljs-built_in">language</span> &#125; = person; <span class="hljs-comment">//方法二</span><br>console.<span class="hljs-built_in">log</span>(abc, age, <span class="hljs-built_in">language</span>);<br></code></pre></td></tr></table></figure><h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ol><li>扩展的方法，子串的识别<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs processing">let <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;hello.vue&#x27;</span>;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span>.startsWith(<span class="hljs-string">&#x27;hello&#x27;</span>)); <span class="hljs-comment">//true</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span>.endsWith(<span class="hljs-string">&#x27;.vue&#x27;</span>)); <span class="hljs-comment">//true</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span>.includes(<span class="hljs-string">&#x27;e&#x27;</span>)); <span class="hljs-comment">//true</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span>.includes(<span class="hljs-string">&#x27;hello&#x27;</span>)); <span class="hljs-comment">//true</span><br><br></code></pre></td></tr></table></figure></li><li>字符串模板<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts">let ss = `<span class="hljs-params">&lt;div&gt;</span><br>                  <span class="hljs-params">&lt;span&gt;</span>hello world<span class="hljs-params">&lt;span&gt;</span><br>                  <span class="hljs-params">&lt;/div&gt;</span>`;<br>      console.log(ss);<span class="hljs-comment">//空格也能打印</span><br></code></pre></td></tr></table></figure></li></ol><p>控制台效果：</p><p><img src="/image/9.1.png" alt="运行效果"></p><ol><li>符串插入变量和表达式。变量名写在${}中，${}中可以放入javascript表达式。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这是一个函数&#x27;</span>;<br>&#125;<br><br>let info = `我是$&#123;abc&#125;，今年$&#123;age + <span class="hljs-number">10</span>&#125;了，我想说： $&#123;<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#125;`;<br>console.log(info);<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-let&amp;const</title>
    <link href="/2021/04/12/ES6(%E4%B8%80)/"/>
    <url>/2021/04/12/ES6(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<p>以下是对 ES6-let&amp;const的学习</p><hr><p>ECMAScript是浏览器脚本语言的规范，而我们熟知的JS语言，如<strong>JavaScript则是规范的具体实现。</strong></p><h3 id="let与var对比-做项目中习惯用let声明变量"><a href="#let与var对比-做项目中习惯用let声明变量" class="headerlink" title="let与var对比(做项目中习惯用let声明变量)"></a>let与var对比(做项目中习惯用let声明变量)</h3><ul><li>var声明的变量往往会越狱 (let 是在代码块内有效，var 是在全局范围内有效:)</li><li>let声明的变量有严格局部作用域</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>   <span class="hljs-keyword">var</span>  a=<span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">let</span>  b=<span class="hljs-number">2</span>;<br> &#125;<br> <span class="hljs-built_in">console</span>.log(a);  <span class="hljs-comment">//1</span><br> <span class="hljs-built_in">console</span>.log(b);  <span class="hljs-comment">//ReferenceError:b  is  not  defined</span><br></code></pre></td></tr></table></figure><ul><li>var可以声明多次</li><li>let只能声明一次<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span>  m=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span>  m=<span class="hljs-number">2</span>;<br><span class="hljs-keyword">let</span>  n=<span class="hljs-number">3</span>;<br><span class="hljs-keyword">let</span>  n=<span class="hljs-number">4</span>;<br><span class="hljs-built_in">console</span>.log(m);  <span class="hljs-comment">//2</span><br><span class="hljs-built_in">console</span>.log(n);  <span class="hljs-comment">//Identifier &#x27;n&#x27; has already been declared</span><br></code></pre></td></tr></table></figure></li><li> var 会变量提升</li><li> let 不存在变量提升<br>变量 b 用 var 声明存在变量提升，所以当脚本开始运行的时候，b 已经存在了，但是还没有赋值，所以会输出 undefined。<br>变量 a 用 let 声明不存在变量提升，在声明变量 a 之前，a 不存在，所以会报错。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">//  undefined</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">console</span>.log(y); <span class="hljs-comment">//Cannot access &#x27;y&#x27; before initialization</span><br><span class="hljs-keyword">let</span> y = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><h3 id="const声明变量-只读变量"><a href="#const声明变量-只读变量" class="headerlink" title="const声明变量 (只读变量)"></a>const声明变量 (只读变量)</h3></li><li>声明之后不允许改变</li><li>一旦声明必须初始化，否者会报错</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const a = <span class="hljs-number">1</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">a</span> = <span class="hljs-number">3</span><span class="hljs-comment">; //Uncaught TypeError: Assignment to constant variable.</span><br></code></pre></td></tr></table></figure><p>const 如何做到变量在声明初始化之后不允许改变的？其实 const 其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JQuery</title>
    <link href="/2021/04/08/Javascript%E5%85%A5%E9%97%A8(%E4%B8%83)/"/>
    <url>/2021/04/08/Javascript%E5%85%A5%E9%97%A8(%E4%B8%83)/</url>
    
    <content type="html"><![CDATA[<p>以下是对JQuery的学习</p><hr><p>Javascript<br>JQuery库(小型且功能丰富的JavaScript库)，里面存在大量的Javascript函数(通过易于使用的API（可在多种浏览器中使用），它使HTML文档的遍历和操作，事件处理，动画和Ajax等事情变得更加简单。)<br>能够避免重复造轮子。</p><h3 id="获取JQuery"><a href="#获取JQuery" class="headerlink" title="获取JQuery"></a>获取JQuery</h3><p>(CDN jQuery)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  //两种导入方式，一种本地，一种在线方式导入<br>    <span class="hljs-comment">&lt;!-- CDN引入 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;lib/jquery-3.6.0.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test-jquery&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">      <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;id&#x27;</span>);</span><br><span class="javascript">      <span class="hljs-comment">//选择器就是css的选择器</span></span><br><span class="javascript">      $(<span class="hljs-string">&#x27;test-jquery&#x27;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        alert(<span class="hljs-string">&#x27;hello,jQuery&#x27;</span>);</span><br>      &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>选择器</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>原生js,选择器少，麻烦不好记<br><span class="hljs-regexp">//</span>标签<br>document.getElementsByTagName();<br><span class="hljs-regexp">//i</span>d<br>document.getElementById();<br><span class="hljs-regexp">//</span>类<br>document.getElementById();<br><span class="hljs-regexp">//</span>jQuery  css种的选择器都能用<br>$(<span class="hljs-string">&#x27;p&#x27;</span>).click(); <span class="hljs-regexp">//</span>标签选择器<br>$(<span class="hljs-string">&#x27;#id1&#x27;</span>).click(); <span class="hljs-regexp">//i</span>d选择器<br>$(<span class="hljs-string">&#x27;.class1&#x27;</span>).click(); <span class="hljs-regexp">//</span>class选择器<br></code></pre></td></tr></table></figure><p>文档工具站：(<a href="https://jquery.cuishifeng.cn/">https://jquery.cuishifeng.cn/</a>)<br><img src="/image/7.1.PNG" alt="文档工具"></p><blockquote><p>事件</p></blockquote><p>鼠标事件，键盘事件，其他事件<br><img src="/image/7.3.png" alt="鼠标点击"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;lib/jquery-3.6.0.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>//导入JQuery<br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>  #divMove &#123;<br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;</span><br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 事件：获取鼠标当前的一个坐标 --&gt;</span><br>  mouse:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mouseMove&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;divMove&quot;</span>&gt;</span>在这里移动鼠标试试<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">//当网页元素加载完毕之后，响应事件</span></span><br><span class="javascript">    <span class="hljs-comment">// $(document).ready(function () &#123;&#125;);</span></span><br><span class="javascript">    <span class="hljs-comment">//简写</span></span><br><span class="javascript">    $(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">      $(<span class="hljs-string">&#x27;#divMove&#x27;</span>).mousemove(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-comment">//e代表获取的参数</span></span><br><span class="javascript">        $(<span class="hljs-string">&#x27;#mouseMove&#x27;</span>).text(<span class="hljs-string">&#x27;x:&#x27;</span> + e.pageX + <span class="hljs-string">&#x27;y&#x27;</span> + e.pageY);</span><br>      &#125;);<br>    &#125;);<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>操作DOM</p></blockquote><p>节点文本操作</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(&#x27;#<span class="hljs-params">test</span>-<span class="hljs-params">ul</span>  <span class="hljs-params">li</span>[<span class="hljs-params">name</span>=<span class="hljs-params">python</span>]&#x27;)</span>.text<span class="hljs-literal">()</span>; <span class="hljs-comment">//获得值</span><br><span class="hljs-constructor">$(&#x27;#<span class="hljs-params">test</span>-<span class="hljs-params">ul</span>  <span class="hljs-params">li</span>[<span class="hljs-params">name</span>=<span class="hljs-params">python</span>]&#x27;)</span>.text(&#x27;设置值&#x27;); <span class="hljs-comment">//设置值</span><br><span class="hljs-constructor">$(&#x27;#<span class="hljs-params">test</span>-<span class="hljs-params">ul</span>&#x27;)</span>.html<span class="hljs-literal">()</span>; <span class="hljs-comment">//获得值</span><br><span class="hljs-constructor">$(&#x27;#<span class="hljs-params">test</span>-<span class="hljs-params">ul</span>&#x27;)</span>.html(&#x27;&lt;strong&gt;<span class="hljs-number">123</span>&lt;/strong&gt;&#x27;); <span class="hljs-comment">//设置值</span><br></code></pre></td></tr></table></figure><p>css的操作</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(&#x27;#<span class="hljs-params">test</span>-<span class="hljs-params">ul</span>  <span class="hljs-params">li</span>[<span class="hljs-params">name</span>=<span class="hljs-params">python</span>]&#x27;)</span>.css(&#x27;color&#x27;, &#x27;red&#x27;);<br></code></pre></td></tr></table></figure><p>元素的显示和隐藏，本质<code>display:none</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(&#x27;#<span class="hljs-params">test</span>-<span class="hljs-params">ul</span>  <span class="hljs-params">li</span>[<span class="hljs-params">name</span>=<span class="hljs-params">python</span>]&#x27;)</span>.show<span class="hljs-literal">()</span><br><span class="hljs-constructor">$(&#x27;#<span class="hljs-params">test</span>-<span class="hljs-params">ul</span>  <span class="hljs-params">li</span>[<span class="hljs-params">name</span>=<span class="hljs-params">python</span>]&#x27;)</span>.hide<span class="hljs-literal">()</span><br></code></pre></td></tr></table></figure><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1JJ41177di?p=1">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
      <tag>JQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript操作表单(验证)(六)</title>
    <link href="/2021/04/08/Javascript%E5%85%A5%E9%97%A8(%E5%85%AD)/"/>
    <url>/2021/04/08/Javascript%E5%85%A5%E9%97%A8(%E5%85%AD)/</url>
    
    <content type="html"><![CDATA[<p>以下是对Javascript操作表单(验证)的学习</p><hr><h2 id="操作表单-验证"><a href="#操作表单-验证" class="headerlink" title="操作表单(验证)"></a>操作表单(验证)</h2><blockquote><p>表单是什么 form 本身也是DOM树</p></blockquote><ul><li>文本框 text</li><li>下拉框 select</li><li>单选框 radio</li><li>多选框 checkbox</li><li>隐藏域 hidden</li><li>密码框 password</li><li>….</li></ul><blockquote><p>获得要提交的信息</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>用户名：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 单，多选框的值，就是定义好的value --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>性别：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;man&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;boy&quot;</span> /&gt;</span>男<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;woman&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;girl&quot;</span> /&gt;</span>女<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> input_text = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;username&#x27;</span>);</span><br><span class="javascript">  <span class="hljs-keyword">var</span> boy_radio = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;boy&#x27;</span>);</span><br><span class="javascript">  <span class="hljs-keyword">var</span> girl_radio = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;girl&#x27;</span>);</span><br><span class="javascript">  <span class="hljs-comment">//得到输入框的值</span></span><br>  input_text.value;<br><span class="javascript">  <span class="hljs-comment">//修改输入框的值</span></span><br><span class="javascript">  <span class="hljs-comment">//对于单，多选框等等固定的值，boy_radio，value只能取到当前的值</span></span><br><span class="javascript">  boy_radio.checked; <span class="hljs-comment">//查看返回的结果，是否为true,如果为true,则被选中~</span></span><br><span class="javascript">  girl_radio.checked = <span class="hljs-literal">true</span>; <span class="hljs-comment">//赋值</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>提交表单。md5加密密码，表单优化</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>   <span class="hljs-comment">&lt;!-- 表单绑定提交事件</span><br><span class="hljs-comment">   onsubmit= 绑定一个提交检测的函数：true,fale</span><br><span class="hljs-comment">   将这个结果返回给表单，使用onsubmit接受！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   --&gt;</span><br>   &lt;form<br>     action=&quot;https://wwww.baidu.com/&quot;<br>     method=&quot;post&quot;<br>     onsubmit=&quot;return  aaa()&quot;<br>   &gt;<br>     <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>用户名：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> /&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>密码 ：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input-password&quot;</span> /&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;md5-password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> /&gt;</span>//隐藏密码<br>     <span class="hljs-comment">&lt;!--绑定事件onclick 被点击   onclick=&quot;aaa()&quot; --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">     <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aaa</span>(<span class="hljs-params"></span>) </span>&#123;</span><br>       alert(1);<br><span class="javascript">       <span class="hljs-keyword">var</span> uname = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;username&#x27;</span>);</span><br><span class="javascript">       <span class="hljs-keyword">var</span> pwd = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;input-password&#x27;</span>);</span><br><span class="javascript">       <span class="hljs-keyword">var</span> md5pwd = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;md5-password&#x27;</span>);</span><br>       md5pwd.value = md5(pwd.value);<br><span class="javascript">       <span class="hljs-comment">//可以校验判断表单内容，true就是通过提交，false,阻止提交</span></span><br><span class="javascript">       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="javascript">       <span class="hljs-comment">// console.log(uname.value);</span></span><br><span class="javascript">       <span class="hljs-comment">// //MD5  算法</span></span><br><span class="javascript">       <span class="hljs-comment">// pwd.value = md5(pwd);//密码隐藏</span></span><br><span class="javascript">       <span class="hljs-comment">// console.log(pwd.value);</span></span><br>     &#125;<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1JJ41177di?p=1">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript操作BOM对象与DOM(五)</title>
    <link href="/2021/04/06/Javascript%E5%85%A5%E9%97%A8(%E4%BA%94)/"/>
    <url>/2021/04/06/Javascript%E5%85%A5%E9%97%A8(%E4%BA%94)/</url>
    
    <content type="html"><![CDATA[<p>以下是对Javascript操作BOM对象与DOM的学习</p><hr><h2 id="操作BOM对象-重点"><a href="#操作BOM对象-重点" class="headerlink" title="操作BOM对象(重点)"></a>操作BOM对象(重点)</h2><blockquote><p>浏览器介绍<br>JavaScript 和浏览器关系？<br>JavaScript诞生就是伪类能够让他在浏览器中运行！<br><strong>BOM：浏览器对象模型</strong>      </p></blockquote><p>内核</p><ul><li>IE 6-11</li><li>Chrome</li><li>Safari</li><li>FireFox</li><li>Opera</li></ul><blockquote><p>window(重要)</p></blockquote><p>window代表浏览器窗口</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">window</span>.alert(<span class="hljs-number">1</span>)<br><span class="hljs-literal">undefined</span><br><span class="hljs-built_in">window</span>.innerHeight<br><span class="hljs-number">271</span><br><span class="hljs-built_in">window</span>.innerWidth<br><span class="hljs-number">1088</span><br><span class="hljs-built_in">window</span>.outerHeight<br><span class="hljs-number">805</span><br><span class="hljs-built_in">window</span>.outerWidth<br><span class="hljs-number">1104</span><br></code></pre></td></tr></table></figure><blockquote><p>Navigator(不建议使用)</p></blockquote><p>navigator,封装了浏览器的信息</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">navigator.appVersion<br><span class="hljs-string">&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36&quot;</span><br>navigator.userAgent<br><span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36&quot;</span><br>navigator.platform<br><span class="hljs-string">&quot;Win32&quot;</span><br></code></pre></td></tr></table></figure><p>大多数时候，我们不会使用navigator对象，因为会被人为修改！<br>不建议使用这些属性来判断和编写代码</p><blockquote><p>screen<br>代表屏幕尺寸</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">screen.width<br><span class="hljs-number">1536</span><br>screen.height<br><span class="hljs-number">864</span><br></code></pre></td></tr></table></figure><blockquote><p>location  (重要)</p></blockquote><p>location代表当前页面的URL信息</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">host:<span class="hljs-string">&quot;www.baidu.com&quot;</span><br>href: <span class="hljs-string">&quot; https://www.baidu.com/&quot;</span><br>protocol: <span class="hljs-string">&quot;https:&quot;</span><br>reload: ƒ reload()  <span class="hljs-regexp">//</span>刷新网页<br>location.assign(<span class="hljs-string">&#x27;https://pengzhenglong.github.io/&#x27;</span>)<span class="hljs-regexp">//</span>设置新的地址<br></code></pre></td></tr></table></figure><blockquote><p>document(内容)</p></blockquote><p>document代表当前的页面，HTML DOM文档树</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">document</span>.title<br><span class="hljs-string">&quot;百度一下，你就知道&quot;</span><br><span class="hljs-built_in">document</span>.title=<span class="hljs-string">&#x27;DragonPeng&#x27;</span><br><span class="hljs-string">&quot;DragonPeng&quot;</span><br></code></pre></td></tr></table></figure><p>获取具体的文档树节点</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>javase<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>javaEE<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> dl = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;app&#x27;</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>获取cookie</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">document</span>.cookie<br></code></pre></td></tr></table></figure><p>劫持cookie原理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;aa.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 恶意人员；获取你的cookie上传到他的服务器 --&gt;</span><br></code></pre></td></tr></table></figure><p>服务端可以设置cookie:httpOnly</p><blockquote><p>history(不建议使用)</p></blockquote><p>history代表浏览器的历史记录</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">history.back() <span class="hljs-regexp">//</span>后退<br>history.forward()<span class="hljs-regexp">//</span>前进<br></code></pre></td></tr></table></figure><h2 id="操作DOM对象-重点"><a href="#操作DOM对象-重点" class="headerlink" title="操作DOM对象(重点)"></a>操作DOM对象(重点)</h2><blockquote><p>核心</p></blockquote><p>浏览器网页就是一个Dom树形结构！    </p><ul><li>更新：更新Dom节点</li><li>遍历Dom节点：得到Dom节点</li><li>删除：删除一个Dom节点</li><li>添加：添加一个新的节点<br>要操作一个Dom节点，就必须要先获得这个Dom节点</li></ul><blockquote><p>获取dom节点</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 对应css选择器</span><br><span class="hljs-keyword">var</span> h1 = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;h1&#x27;</span>);<br><span class="hljs-keyword">var</span> h1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;p1&#x27;</span>);<br><span class="hljs-keyword">var</span> p2 = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&#x27;p2&#x27;</span>);<br><span class="hljs-keyword">var</span> father = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;father&#x27;</span>);<br><span class="hljs-keyword">var</span> childrens = father.children[index]; <span class="hljs-comment">//获取父节点下的所有子节点</span><br><span class="hljs-comment">//   father.firstChild;</span><br><span class="hljs-comment">//   father.lastChild;</span><br></code></pre></td></tr></table></figure><p>这是原生代码，之后我们尽量都使用JQuery();</p><blockquote><p>更新节点</p></blockquote><p>操作文本</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">id1.innerText=<span class="hljs-string">&#x27;456&#x27;</span>  <span class="hljs-regexp">//</span>修改文本的值<br>id1.innerHTML=<span class="hljs-string">&#x27;&lt;strong&gt;123&lt;/strong&gt;&#x27;</span><span class="hljs-regexp">//</span>可以解析HTML文本标签<br></code></pre></td></tr></table></figure><p>操作css</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">id1.style.color</span>=<span class="hljs-string">&#x27;red&#x27;</span><span class="hljs-comment">;  //属性使用  字符串</span><br><span class="hljs-attr">id1.style.fontSize</span>=<span class="hljs-string">&#x27;20px&#x27;</span><span class="hljs-comment">; //_转驼峰命名问题</span><br><span class="hljs-attr">id1.style.padding</span>  =<span class="hljs-string">&#x27;2em&#x27;</span>  <br><br></code></pre></td></tr></table></figure><blockquote><p>删除节点</p></blockquote><p>删除节点的步骤：先获取父节点，再通过父节点删除自己</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>标题1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p2&quot;</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> self = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;p1&#x27;</span>);</span><br><span class="javascript"><span class="hljs-keyword">var</span>  father = p1.parentElement;</span><br>father.removeChild(self);<br><br><span class="javascript"><span class="hljs-comment">//删除是一个动态的过程</span></span><br>father.removeChild(father.children[0])<br>father.removeChild(father.children[1])<br>father.removeChild(father.children[2])<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong>删除多个节点的时候，children是再时刻变化的，删除节点的时候一定要注意！</p><blockquote><p>插入节点</p></blockquote><p>我们获得了某个Dom节点，假设这个dom节点是空的，我们通过innerHTML就可以增加一个元素了，但是这个DOM节点已经存在元素了，我们就不能这么干了！会产生覆盖</p><p>追加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;js&quot;</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;se&quot;</span>&gt;</span>JavaSE<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ee&quot;</span>&gt;</span>JavaEE<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;me&quot;</span>&gt;</span>JavaMe<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> js = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;js&#x27;</span>);</span><br><span class="javascript">  <span class="hljs-keyword">var</span> list = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;list&#x27;</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果:<br><img src="/image/6.2.png" alt="追加到后面了"></p><blockquote><p>创建一个新的标签，实现插入</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> js = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;js&#x27;</span>); <span class="hljs-comment">//已经存在的节点</span></span><br><span class="javascript">  <span class="hljs-keyword">var</span> list = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;list&#x27;</span>);</span><br><span class="javascript">  <span class="hljs-comment">//通过JS创建一个新的节点</span></span><br><span class="javascript">  <span class="hljs-keyword">var</span> newP = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;p&#x27;</span>); <span class="hljs-comment">//创建一个P标签</span></span><br><span class="javascript">  newP.id = <span class="hljs-string">&#x27;newP&#x27;</span>;</span><br><br><span class="javascript">  newP.innerText = <span class="hljs-string">&#x27;hello.DragonPeng&#x27;</span>;</span><br><span class="javascript">  <span class="hljs-comment">//创建一个标签节点</span></span><br><span class="javascript">  <span class="hljs-keyword">var</span> myScript = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);</span><br><span class="javascript">  myScript.setAttribute(<span class="hljs-string">&#x27;type&#x27;</span>, <span class="hljs-string">&#x27;text/javascript&#x27;</span>);</span><br><br><span class="javascript">  <span class="hljs-comment">//可以创建一个Style标签</span></span><br><span class="javascript">  <span class="hljs-keyword">var</span> myStyle = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;style&#x27;</span>); <span class="hljs-comment">//创建了一个空style标签</span></span><br><span class="javascript">  myStyle.setAttribute(<span class="hljs-string">&#x27;type&#x27;</span>, <span class="hljs-string">&#x27;text/css&#x27;</span>);</span><br><span class="javascript">  myStyle.innerHTML = <span class="hljs-string">&#x27;body&#123;background-color: blue;&#125;&#x27;</span>; <span class="hljs-comment">//设置标签内容</span></span><br><span class="javascript">  <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;head&#x27;</span>)[<span class="hljs-number">0</span>].appendChild(myStyle);</span><br><span class="javascript">  <span class="hljs-comment">//   list.appendChild(js);</span></span><br><span class="javascript">  <span class="hljs-comment">//   list.append(newP);</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>insert</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> ee = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;ee&#x27;</span>);<br><span class="hljs-keyword">var</span> js = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;js&#x27;</span>);<br><span class="hljs-keyword">var</span> list = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;list&#x27;</span>);<br><span class="hljs-comment">// 要包含的节点，insertBefore(newNode, targetNode);</span><br>list.insertBefore(js, ee);<br></code></pre></td></tr></table></figure><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1JJ41177di?p=1">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript面向对象&amp;json(四)</title>
    <link href="/2021/04/05/Javascript%E5%85%A5%E9%97%A8(%E5%9B%9B)/"/>
    <url>/2021/04/05/Javascript%E5%85%A5%E9%97%A8(%E5%9B%9B)/</url>
    
    <content type="html"><![CDATA[<p>以下是对JavaScript函数与面向对象的学习</p><hr><h2 id="内部对象"><a href="#内部对象" class="headerlink" title="内部对象"></a>内部对象</h2><p>标准对象</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">typeof</span> <span class="hljs-number">123</span>o<br><span class="hljs-string">&quot;number&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;123&#x27;</span><br><span class="hljs-string">&quot;string&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span><br><span class="hljs-string">&quot;boolean&quot;</span><br><span class="hljs-keyword">typeof</span>  <span class="hljs-literal">NaN</span><br><span class="hljs-string">&quot;number&quot;</span><br><span class="hljs-keyword">typeof</span> []<br><span class="hljs-string">&quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> &#123;&#125;<br><span class="hljs-string">&quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Math</span>.abs<br><span class="hljs-string">&quot;function&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span><br><span class="hljs-string">&quot;undefined&quot;</span><br></code></pre></td></tr></table></figure><ol><li>Date<br>基本使用<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var now = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>; <span class="hljs-comment">//Mon Apr 12 2021 18:27:49 GMT+0800 (中国标准时间)</span><br>now.get<span class="hljs-constructor">FullYear()</span>; <span class="hljs-comment">//年</span><br>now.get<span class="hljs-constructor">Month()</span>; <span class="hljs-comment">//月  0~11月</span><br>now.get<span class="hljs-constructor">Date()</span>; <span class="hljs-comment">//日</span><br>now.get<span class="hljs-constructor">Day()</span>; <span class="hljs-comment">//星期几</span><br>now.get<span class="hljs-constructor">Hours()</span>; <span class="hljs-comment">//时</span><br>now.get<span class="hljs-constructor">Minutes()</span>; <span class="hljs-comment">//分</span><br>now.get<span class="hljs-constructor">Seconds()</span>; <span class="hljs-comment">//秒</span><br>now.get<span class="hljs-constructor">Time()</span>; <span class="hljs-comment">//时间戳  全世界统一 1970  1.1 0：00：00</span><br>console.log(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Date(1618223269100)</span>); <span class="hljs-comment">//时间戳转为时间</span><br></code></pre></td></tr></table></figure>转换<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">now = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Date(1618223269100)</span><br>Mon Apr <span class="hljs-number">12</span> <span class="hljs-number">2021</span> <span class="hljs-number">18</span>:<span class="hljs-number">27</span>:<span class="hljs-number">49</span> GMT+<span class="hljs-number">0800</span> (中国标准时间)<br>now.toLocaleDateString <span class="hljs-comment">//注意，调用的是一个方式，不是一个属性;</span><br>ƒ <span class="hljs-keyword">to</span><span class="hljs-constructor">LocaleDateString()</span> &#123; <span class="hljs-literal">[<span class="hljs-identifier">native</span> <span class="hljs-identifier">code</span>]</span> &#125;<br>now.toLocaleString<br>ƒ <span class="hljs-keyword">to</span><span class="hljs-constructor">LocaleString()</span> &#123; <span class="hljs-literal">[<span class="hljs-identifier">native</span> <span class="hljs-identifier">code</span>]</span> &#125;<br>now.<span class="hljs-keyword">to</span><span class="hljs-constructor">LocaleString()</span><br><span class="hljs-string">&quot;2021/4/12 下午6:27:49&quot;</span><br>now.<span class="hljs-keyword">to</span><span class="hljs-constructor">GMTString()</span><br><span class="hljs-string">&quot;Mon, 12 Apr 2021 10:27:49 GMT&quot;</span><br></code></pre></td></tr></table></figure></li><li>json是什么<br>早期，所有数据传输习惯使用XML文件</li></ol><ul><li> JSON是一种轻量级的数据交互格式。</li><li> 简洁和清晰的<strong>层次结构</strong>使得JSON成为理想的数据交互语言。</li><li> 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。<br>在JavaScript一切皆为对象，任何js支持的类型都可以用JSON来表示; number, string…     </li></ul><p>格式：</p><ul><li>对象都用{}</li><li>数组都用[]</li><li>所有的键值对都是用key:value</li></ul><ol start="3"><li>JSON字符串和JS对象的转化<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">var</span> student = &#123;<br>  <span class="hljs-built_in">na</span><span class="hljs-symbol">me:</span> &#x27;zhansan&#x27;,<br>  a<span class="hljs-symbol">ge:</span> <span class="hljs-number">3</span>,<br>  s<span class="hljs-symbol">ex:</span> &#x27;男&#x27;,<br>&#125;; //&#123;<span class="hljs-built_in">na</span><span class="hljs-symbol">me:</span> <span class="hljs-string">&quot;zhansan&quot;</span>, a<span class="hljs-symbol">ge:</span> <span class="hljs-number">3</span>, s<span class="hljs-symbol">ex:</span> <span class="hljs-string">&quot;男&quot;</span>&#125;<br>//对象转化为JSON字符串 &#123;<span class="hljs-string">&quot;name&quot;</span><span class="hljs-symbol">:</span><span class="hljs-string">&quot;zhansan&quot;</span>,<span class="hljs-string">&quot;age&quot;</span><span class="hljs-symbol">:3</span>,<span class="hljs-string">&quot;sex&quot;</span><span class="hljs-symbol">:</span><span class="hljs-string">&quot;男&quot;</span>&#125;<br><span class="hljs-built_in">var</span> jasonStudent = JSON.stringify(student);<br><br>//json字符串转化为对象，参数为json字符串<br><span class="hljs-built_in">var</span> obj = JSON.parse(&#x27;&#123;<span class="hljs-string">&quot;name&quot;</span><span class="hljs-symbol">:</span><span class="hljs-string">&quot;zhansan&quot;</span>,<span class="hljs-string">&quot;age&quot;</span><span class="hljs-symbol">:3</span>,<span class="hljs-string">&quot;sex&quot;</span><span class="hljs-symbol">:</span><span class="hljs-string">&quot;男&quot;</span>&#125;&#x27;);<br></code></pre></td></tr></table></figure>JSON和js对象的区别<br>JSON是一种格式化的字符串，而对象是键值对形式的<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">var</span> obj = &#123; a: <span class="hljs-symbol">&#x27;hell</span>o&#x27;, b: <span class="hljs-symbol">&#x27;hello</span>b&#x27; &#125;;<br><span class="hljs-keyword">var</span> json = &#x27;&#123;<span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>:<span class="hljs-string">&quot;hellob&quot;</span>&#125;&#x27;;<br></code></pre></td></tr></table></figure><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3></li><li>什么是面向对象<br>JavaScript，java,c#….面向对象;JavaScript有些区别！</li></ol><ul><li>类：模板</li><li>对象；具体的实例<br>在JavaScript中这个需要大家换一下思维方式！<br>原型：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> student = &#123;<br>  name: <span class="hljs-string">&#x27;zhansan&#x27;</span>,<br>  age: <span class="hljs-number">3</span>,<br>  sex: <span class="hljs-string">&#x27;男&#x27;</span>,<br>  run: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;run...&#x27;</span>);<br>  &#125;,<br>&#125;;<br><span class="hljs-keyword">var</span> xiaoming = &#123;<br>  name: <span class="hljs-string">&#x27;xiaoming&#x27;</span>,<br>&#125;;<br><span class="hljs-comment">//原型对象</span><br>xiaoming.__proto__ = student;<br><span class="hljs-keyword">var</span> Bird = &#123;<br>  fly: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;fly....&#x27;</span>);<br>  &#125;,<br>&#125;;<br><span class="hljs-comment">//小明的原型是Student</span><br>xiaoming.__proto__ = Bird;<br></code></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span><span class="hljs-params">(name)</span> </span>&#123;<br>  <span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-comment">//给student新增一个方法</span><br>Student.prototype.hello = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;<br>  alert(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>class继承<br>class关键字，是在ES6引入的</li><li>定义一个类，属性，方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//定义一个学生类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> &#123;<br>    alert(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;hello&#x27;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> xiaoming = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;小明&#x27;</span>);<br><span class="hljs-keyword">var</span> xioahong = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;小红&#x27;</span>);<br>xiaoming.hello();<br></code></pre></td></tr></table></figure></li><li>继承<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> &#123;<br>    alert(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XiaoStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, grade</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name); <span class="hljs-comment">//记得用super调用父类的构造方法!</span><br>    <span class="hljs-built_in">this</span>.grade = grade;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">myGrade</span>(<span class="hljs-params"></span>)</span> &#123;<br>    alert(<span class="hljs-string">&#x27;我是一名小学生&#x27;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> xiaoming = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;小明&#x27;</span>);<br><span class="hljs-keyword">var</span> xiaohong = <span class="hljs-keyword">new</span> XiaoStudent(<span class="hljs-string">&#x27;小红&#x27;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>本质：查看对象原型         </li></ol><p><img src="/image/6.png" alt="查看对象原型"></p><ol start="3"><li>原型链         </li></ol><p><img src="/image/6.1.png" alt="原型链"></p><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1JJ41177di?p=1">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript函数&amp;变量的作用域&amp;&amp;方法(三)</title>
    <link href="/2021/04/04/Javascript%E5%85%A5%E9%97%A8(%E4%B8%89)/"/>
    <url>/2021/04/04/Javascript%E5%85%A5%E9%97%A8(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<p>以下是对JavaScript函数的学习</p><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><ol><li>定义方式一</li></ol><p>绝对值函数</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sas">function<span class="hljs-meta"> abs(</span><span class="hljs-meta">x</span>) &#123;<br>  <span class="hljs-meta">if</span> (<span class="hljs-meta">x</span> &gt;= 0) &#123;<br>    <span class="hljs-meta">return</span> <span class="hljs-meta">x</span>;<br>  &#125; <span class="hljs-meta">else</span> &#123;<br>    <span class="hljs-meta">return</span> -<span class="hljs-meta">x</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦执行到return代表函数结束，返回结果！<br>如果没有执行return，函数执行完也会返回结果，结果就是undefined</p><ol start="2"><li><p>定义方式二</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada">var <span class="hljs-keyword">abs</span> = <span class="hljs-keyword">function</span> <span class="hljs-title"></span>(x) &#123;<br>  if (x &gt;= 0) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">x</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> -x;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>function(x){….}这是一个匿名函数，但是可以把结果赋值给abs，通过abs就可以调用函数！<br>方式一和方式二等价！</p></li><li><p>调用函数</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">abs</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>  <span class="hljs-comment">//10</span><br><span class="hljs-function"><span class="hljs-title">abs</span><span class="hljs-params">(-<span class="hljs-number">10</span>)</span></span>  <span class="hljs-comment">//10</span><br></code></pre></td></tr></table></figure><p>参数问题： JavaScript可以传任意个参数，也可以不传递参数~<br>参数尽量是否存在的问题？<br>假设不存在参数，如何规避？</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> abs = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x)</span> </span>&#123;<br>  <span class="hljs-comment">//   手动抛出异常来判断</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;Not  a Number&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> x;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> -x;          <br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>arguments<br>arguments是一个JS免费赠送的关键字：<br>代表，传递进来的所有的参数，是一个数组！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> abs = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x=&gt;&#x27;</span> + x);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[i]);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> x;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> -x;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>问题： arguments包含所有的参数，我们有时候使用多余的参数来进行附加操作。需要排除已有参数~     </p></li><li><p>rest<br>ES6引入的新特性，获取除了已经定义的参数之外的所有参数~<br>以前  </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">arguments</span>.<span class="hljs-built_in">length</span>&gt;<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">for</span>(var  <span class="hljs-built_in">i</span>=<span class="hljs-number">2</span>;<span class="hljs-built_in">i</span>&lt;<span class="hljs-keyword">arguments</span>.<span class="hljs-built_in">length</span>;<span class="hljs-built_in">i</span>++)&#123;<br>            <br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>ES6引入的新特性，获取除了已经定义的参数之外的所有参数~    </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aaa</span><span class="hljs-params">(a, b, <span class="hljs-rest_arg">...rest</span>)</span> </span>&#123;<br>  console.log(<span class="hljs-string">&#x27;a=&gt;&#x27;</span> + a);<br>  console.log(<span class="hljs-string">&#x27;b=&gt;&#x27;</span> + b);<br>  console.log(rest);<br>&#125;<br></code></pre></td></tr></table></figure><p>rest 参数只能写在最后面，必须用…标识。</p></li></ol><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><ol><li><p>在JavaScript中，var定义的变量实际是有作用域的。<br>假设在函数体中声明，则在函数体外不可以使用~(非要想实现的话后面可以研究以下闭包)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qj</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;<br>  x = x + <span class="hljs-number">1</span>;<br>&#125;<br>x = x + <span class="hljs-number">2</span>; <span class="hljs-comment">//Uncaught ReferenceError: x is not defined</span><br></code></pre></td></tr></table></figure></li><li><p>如果两个函数使用了相同的变量名，只要在函数内部，就不冲突</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qj</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;<br>  x = x + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qj2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-string">&#x27;a&#x27;</span>;<br>  X = X + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>假设，内部函数变量和外部函数的变量，重名！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qj</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qj2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-string">&#x27;A&#x27;</span>;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;inner&#x27;</span> + x); <span class="hljs-comment">//innerA</span><br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;outer&#x27;</span> + x); <span class="hljs-comment">//outer1</span><br>  qj2();<br>&#125;<br>  qj();<br></code></pre></td></tr></table></figure><p>假设在JavaScript中函数查找变量从自身函数开始~，由“内”向“外”查找，假设外部存在这个同名的函数变量，则内部函数会屏蔽外部函数的变量。</p></li><li><p>提升变量的作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qj</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-string">&#x27;x&#x27;</span> + y;<br>  <span class="hljs-built_in">console</span>.log(x);<br>  <span class="hljs-keyword">var</span> y = <span class="hljs-string">&#x27;y&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果： xundefined<br>说明：js执行引擎，自动提升了y的声明，但是不会提升变量y的赋值；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qj2</span>(<span class="hljs-params"></span>) </span>&#123;<br> <span class="hljs-keyword">var</span>  y;<br> <span class="hljs-keyword">var</span> x = <span class="hljs-string">&#x27;x&#x27;</span> + y;<br>  <span class="hljs-built_in">console</span>.log(x);<br>  y = <span class="hljs-string">&#x27;y&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个是在JavaScript建立之初就存在的特性。养成规范：所有的变量定义都放在函数的头部，不要乱放，便于代码维护。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qj2</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>  y = x + <span class="hljs-number">1</span>;<br>  z, i, a; <span class="hljs-comment">//undefined</span><br><br>  <span class="hljs-comment">//之后随意用</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>全局函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//全局变量</span><br> <span class="hljs-keyword">var</span>  x=<span class="hljs-number">1</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-built_in">console</span>.log(x);<br>  &#125;<br>  f();<br>  <span class="hljs-built_in">console</span>.log(x);<br></code></pre></td></tr></table></figure></li><li><p><strong>全局对象window</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sas">var <span class="hljs-meta">x</span> = <span class="hljs-string">&#x27;xxx&#x27;</span>;<br><span class="hljs-meta">window</span>.alert(<span class="hljs-meta">x</span>);<br><span class="hljs-meta">window</span>.alert(<span class="hljs-meta">window</span>.<span class="hljs-meta">x</span>); //默认所有的全局变量，都会自动绑定在<span class="hljs-meta">window</span>对象下<br></code></pre></td></tr></table></figure></li></ol><p>alter()这个函数本身也是一个window变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-string">&#x27;xxx&#x27;</span>;<br><span class="hljs-built_in">window</span>.alert(x);<br><span class="hljs-comment">//   window.alert(window.x); //默认所有的全局变量，都会自动绑定在window对象下</span><br><span class="hljs-keyword">var</span> old_alter = <span class="hljs-built_in">window</span>.alert;<br><span class="hljs-comment">//   old_alter(x);</span><br><span class="hljs-built_in">window</span>.alert = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-comment">//发现alter()失效了</span><br><span class="hljs-built_in">window</span>.alert(<span class="hljs-number">123</span>);<br><span class="hljs-comment">//恢复</span><br><span class="hljs-built_in">window</span>.alert = old_alter;<br><span class="hljs-built_in">window</span>.alert(<span class="hljs-number">456</span>);<br></code></pre></td></tr></table></figure><p>JavaScript实际上只有一个全局作用域，任何变量(函数也可以视为变量)，假如没有在函数作用范围内找到，就会向外查找。如果在全局作用域都没有找到，报错ReferenceError.<br>7. 规范<br>由于我们所有的全局变量都会绑定在我们的window上，如果不同的js文件，使用了相同的全局变量，冲突-&gt;如何能够减少冲突？</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada">//唯一全局变量<br>var <span class="hljs-keyword">all</span> = &#123;&#125;;<br>//定义全局变量<br><span class="hljs-keyword">all</span>.name = <span class="hljs-symbol">&#x27;DragonPeng</span>&#x27;;<br><span class="hljs-keyword">all</span>.add = <span class="hljs-keyword">function</span> <span class="hljs-title"></span>(a, b) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">a</span> + b;<br>&#125;;<br></code></pre></td></tr></table></figure><p>把自己的代码全部放入自己定义的唯一空间命名中，降低全局命名冲突的问题~</p><ol start="8"><li><p><strong>局部作用域let</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aaa</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>    <span class="hljs-built_in">console</span>.log(i);<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(i + <span class="hljs-number">1</span>); <span class="hljs-comment">//问题？i出了这个作用域还可以使用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ES6  let关键字，解决局部作用域冲突问题！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aaa</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>    <span class="hljs-built_in">console</span>.log(i);<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(i + <span class="hljs-number">1</span>); <span class="hljs-comment">//Uncaught ReferenceError: i is not defined</span><br>&#125;<br></code></pre></td></tr></table></figure><p>建议大家都用let去定义局部作用域的变量</p></li><li><p>常量const<br>在ES6之前，怎么定义常量，只有用全部大写字母命名的变量就是常量；建议不要修改这样的值</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams">var <span class="hljs-built_in">PI</span> = <span class="hljs-string">&#x27;3.14&#x27;</span>;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">PI</span>);<br><span class="hljs-built_in">PI</span> = <span class="hljs-string">&#x27;214&#x27;</span>;<span class="hljs-comment">//可以改变这个值</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">PI</span>);<br></code></pre></td></tr></table></figure><p>在ES6引入了常量关键字 const</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">const</span> <span class="hljs-literal">PI</span> = <span class="hljs-string">&#x27;3.14&#x27;</span>;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-literal">PI</span>);<br><span class="hljs-literal">PI</span> = <span class="hljs-string">&#x27;123&#x27;</span>;<span class="hljs-comment">//Uncaught TypeError: Assignment to constant variable.</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-literal">PI</span>); <br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>定义方法：<br>方法就是把函数放在对象的里面，对象只有两个东西:属性和方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">      <span class="hljs-keyword">var</span> student = &#123;<br>        name: <span class="hljs-string">&#x27;haha&#x27;</span>,<br>        birth: <span class="hljs-number">2000</span>,<br>        <span class="hljs-comment">//方法</span><br>        age: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-comment">//今年-出生的年</span><br>          <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getFullYear();<br>          <span class="hljs-keyword">return</span> now - <span class="hljs-built_in">this</span>.birth;<br>        &#125;,<br>      &#125;;<br><span class="hljs-comment">//属性</span><br>student.name<br><span class="hljs-comment">//方法，一定要带()</span><br>student.age()<br></code></pre></td></tr></table></figure><p>this代表什么？拆开上面的代码看看~</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">//今年-出生的年</span><br>  <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getFullYear();<br>  <span class="hljs-keyword">return</span> now - <span class="hljs-built_in">this</span>.birth;<br>&#125;<br><span class="hljs-keyword">var</span> student = &#123;<br>  name: <span class="hljs-string">&#x27;haha&#x27;</span>,<br>  birth: <span class="hljs-number">2000</span>,<br>  age: getAge,<br>&#125;;<br><span class="hljs-comment">//student.age() //ok</span><br><span class="hljs-comment">//   getAge()   NaN  window</span><br></code></pre></td></tr></table></figure><p>this是无法指向的，是默认指向调用它的那个对象；      </p></li></ol><blockquote><p>applay</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">//今年-出生的年</span><br>  <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getFullYear();<br>  <span class="hljs-keyword">return</span> now - <span class="hljs-built_in">this</span>.birth;<br>&#125;<br><span class="hljs-keyword">var</span> student = &#123;<br>  name: <span class="hljs-string">&#x27;haha&#x27;</span>,<br>  birth: <span class="hljs-number">2000</span>,<br>  age: getAge,<br>&#125;;<br><span class="hljs-comment">//student.age() //ok</span><br><span class="hljs-comment">//   getAge()   NaN</span><br>getAge.apply(student, []); <span class="hljs-comment">//this,指向了student，参数为空</span><br></code></pre></td></tr></table></figure><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1JJ41177di?p=1">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript&amp;字符串类型&amp;数组类型&amp;对象类型(二)</title>
    <link href="/2021/04/02/Javascript%E5%85%A5%E9%97%A8(%E4%BA%8C)/"/>
    <url>/2021/04/02/Javascript%E5%85%A5%E9%97%A8(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串类型，数组类型，对象类型-详讲"><a href="#字符串类型，数组类型，对象类型-详讲" class="headerlink" title="字符串类型，数组类型，对象类型(详讲)"></a>字符串类型，数组类型，对象类型(详讲)</h2><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol><li>正常字符串我们使用 单引号，或者双引号包裹</li><li>注意转义字符\</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\&#x27;</span>   代表字符串<br><span class="hljs-string">\n</span>   换行<br><span class="hljs-string">\t</span>   tab<br><span class="hljs-string">\u4e2d</span>  <span class="hljs-string">\u###</span>  Unicode字符<br><span class="hljs-string">\x41</span>  Ascll字符<br></code></pre></td></tr></table></figure><ol start="3"><li>多行字符串编写</li></ol><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-comment">//  tab上面esc下面</span><br><span class="hljs-keyword">var</span>  msg= <br>    <span class="hljs-string">&#x27;hello </span><br><span class="hljs-string">    world</span><br><span class="hljs-string">    你好ya</span><br><span class="hljs-string">    你好&#x27;</span><br></code></pre></td></tr></table></figure><ol start="4"><li><strong>模板字符串</strong> (掌握es6的新特性)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//tab上面esc下面</span><br><span class="hljs-keyword">let</span>  name = <span class="hljs-string">&quot;xm&quot;</span>;<br><span class="hljs-keyword">let</span>  age=<span class="hljs-number">3</span>;<br><span class="hljs-keyword">let</span>  msg= <span class="hljs-string">&#x27;你好呀，$&#123;name&#125;&#x27;</span><br><span class="hljs-built_in">console</span>.log(msg)<br>你好呀，$&#123;name&#125;<br><br></code></pre></td></tr></table></figure><ol start="5"><li>字符串长度</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">str.<span class="hljs-built_in">length</span><br></code></pre></td></tr></table></figure><ol start="6"><li><strong>字符串的不可变性</strong>(掌握)</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">console.<span class="hljs-built_in">log</span>(student[<span class="hljs-number">0</span>])<br>s<br>student[<span class="hljs-number">0</span>]<span class="hljs-operator">=</span><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br>console.<span class="hljs-built_in">log</span>(student)<br>student<br></code></pre></td></tr></table></figure><ol start="7"><li>大小写转换</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//注意，这里是方法，不是属性</span><br>student.<span class="hljs-keyword">to</span><span class="hljs-constructor">UpperCase()</span>  <span class="hljs-comment">//大写</span><br><span class="hljs-string">&quot;STUDENT&quot;</span><br>student.<span class="hljs-keyword">to</span><span class="hljs-constructor">LowerCase()</span>  <span class="hljs-comment">//小写</span><br><span class="hljs-string">&quot;student&quot;</span><br></code></pre></td></tr></table></figure><ol start="8"><li>获取指定的下标</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">console.<span class="hljs-built_in">log</span>(student.indexOf(<span class="hljs-string">&#x27;t&#x27;</span>))<br> <span class="hljs-number">1</span><br>console.<span class="hljs-built_in">log</span>(student.indexOf(<span class="hljs-string">&#x27;s&#x27;</span>))<br> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ol start="9"><li><strong>substring</strong>(掌握)</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">[)<br>student.substring(<span class="hljs-number">1</span>)  <span class="hljs-regexp">//</span>从第一个字符串截取到最后一个字符串<br><span class="hljs-string">&quot;tudent&quot;</span><br>student.substring(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>) <span class="hljs-regexp">//</span>[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<br><span class="hljs-string">&quot;tu&quot;</span><br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Array 可以包含任意的数据类型</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var</span>  arr =<span class="hljs-meta"> [1,2,3,4,5,6]  //通过下标取值和赋值</span><br><span class="hljs-meta">arr[0]</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">0</span>] =<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><ol><li>长度</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">arr.<span class="hljs-built_in">length</span><br></code></pre></td></tr></table></figure><p><strong>注意：假如给arr.length，数组大小就会发生变化。如果赋值过小，元素就会丢失。</strong></p><ol start="2"><li>indexOf,通过元素获得下标索引<br>indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。</li></ol><p>如果没有找到匹配的字符串则返回 -1。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">arr</span>.indexOf(<span class="hljs-number">2</span>)<br><span class="hljs-attribute">1</span><br></code></pre></td></tr></table></figure><p>字符串的”1”和数字1是不同的<br>3. slice()  截取Array的一部分，返回一个新数组，类似于String中的substring</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs"><span class="hljs-attribute">arr</span>.slice(<span class="hljs-number">3</span>)<br>[4, 5, 6]<br></code></pre></td></tr></table></figure><ol start="4"><li>push,pop  尾部(掌握)</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">push</span>:  压入到尾部<br><span class="hljs-keyword">pop</span>:  弹出尾部的一个元素<br>arr.<span class="hljs-keyword">push</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;a&quot;</span>)<br>arr.<span class="hljs-keyword">pop</span>()<br></code></pre></td></tr></table></figure><ol start="5"><li>unshift(),shift()头部  (掌握)</li></ol><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">unshift</span>  压入到头部<br><span class="hljs-keyword">shift</span>    弹出头部的一个元素 <br></code></pre></td></tr></table></figure><ol start="6"><li>排序  sort()</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">arr</span><br>(<span class="hljs-number">3</span>) <span class="hljs-selector-attr">[<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>]</span><br><span class="hljs-selector-tag">arr</span><span class="hljs-selector-class">.sort</span>()<br>(<span class="hljs-number">3</span>) <span class="hljs-selector-attr">[<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>]</span><br></code></pre></td></tr></table></figure><ol start="7"><li>元素反转  reverse()</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">(<span class="hljs-number">3</span>) <span class="hljs-selector-attr">[<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>]</span><br>arr<span class="hljs-selector-class">.reverse</span>()<br>(<span class="hljs-number">3</span>) <span class="hljs-selector-attr">[<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>]</span><br></code></pre></td></tr></table></figure><ol start="8"><li>concat()     (掌握)</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">(<span class="hljs-number">3</span>) <span class="hljs-selector-attr">[<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>]</span><br>arr<span class="hljs-selector-class">.concat</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br>(<span class="hljs-number">6</span>) <span class="hljs-selector-attr">[<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, 1, 2, 3]</span><br>arr<br>(<span class="hljs-number">3</span>) <span class="hljs-selector-attr">[<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>注意： concat()并没有修改数组，只是会返回一个新的数组</strong></p><ol start="9"><li>连接符join<br>打印拼接数组，使用特定的字符串连接</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">(<span class="hljs-number">3</span>) <span class="hljs-selector-attr">[<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>]</span><br>arr<span class="hljs-selector-class">.join</span>(<span class="hljs-string">&#x27;-&#x27;</span>)<br><span class="hljs-string">&quot;C-B-A&quot;</span><br></code></pre></td></tr></table></figure><ol start="10"><li>多维数组</li></ol><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">arr= [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>]];<br>arr[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>总结： 数组:存储数据(如何存，如何取，方法都可以自己实现！)</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>是若干个键值对<br><strong>Js中所有的键都是字符串，值是任意对象！</strong></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dts">var 对象名=&#123;<br>    属性名: 属性值;<br>    属性名: 属性值;<br>    属性名: 属性值;<br>&#125;<br><span class="hljs-comment">//定义了一个student对象，它有四个属性！</span><br>var student=&#123;<br>    name :<span class="hljs-string">&quot;zhangsan&quot;</span>,<br><span class="hljs-symbol">    age:</span><span class="hljs-number">10</span>,<br><span class="hljs-symbol">    email:</span>  <span class="hljs-string">&quot;24132413241@qq.com&quot;</span>,<br><span class="hljs-symbol">    score:</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Js中对象，{…}表示一个对象，键值对描述属性xxxx:xxxx,多个属性之间使用逗号隔开，最后一个属性不加逗号！</p><ol><li>对象赋值</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">student.<span class="hljs-built_in">name</span><br><span class="hljs-string">&quot;zhangsan&quot;</span><br>student.<span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;lishi&quot;</span><br><span class="hljs-string">&quot;lishi&quot;</span><br>student.<span class="hljs-built_in">name</span><br><span class="hljs-string">&quot;lishi&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>使用一个不存在的对象属性，不会报错！ undefined</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">student.hahah<br><span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><ol start="3"><li>动态的删减属性，通过delete删除对象的属性</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">delete</span> student.name<br><span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><ol start="4"><li>动态添加,直接给新属性添加值即可</li></ol><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">student.<span class="hljs-attr">haha=</span> <span class="hljs-string">&quot;haha&quot;</span><br><span class="hljs-string">&quot;haha&quot;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>判断属性值是否在这个对象中！ xx in xxx!</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">in</span> student<br><span class="hljs-literal">true</span>   <br><span class="hljs-comment">//继承</span><br><span class="hljs-string">&#x27;toString&#x27;</span>  <span class="hljs-keyword">in</span> student<br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ol start="6"><li>判断一个属性是否是这个对象自身拥有的hasOwnProperty()</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">student.has<span class="hljs-constructor">OwnProperty(&#x27;<span class="hljs-params">toString</span>&#x27;)</span><br><span class="hljs-literal">false</span><br>student.has<span class="hljs-constructor">OwnProperty(&#x27;<span class="hljs-params">age</span>&#x27;)</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ol><li>if判断 else</li><li>while循环 ，避免程序死循环</li><li>for循环</li><li><strong>forEach循环</strong>(5.1引入的)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span>  age=[<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">31</span>,<span class="hljs-number">23</span>,<span class="hljs-number">123</span>]<br><span class="hljs-comment">//函数</span><br>age.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(value)<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="5"><li>for…in(age 不知道是数组大小的情况用)</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs maxima">//<span class="hljs-keyword">for</span>(<span class="hljs-built_in">var</span>  index  <span class="hljs-keyword">in</span> object)&#123;&#125;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-built_in">var</span> <span class="hljs-built_in">num</span> <span class="hljs-keyword">in</span> age) &#123;<br>        <span class="hljs-keyword">if</span> (age.hasOwnProperty(<span class="hljs-built_in">num</span>)) &#123;<br>          console.<span class="hljs-built_in">log</span>(&#x27;存在&#x27;);<br>          console.<span class="hljs-built_in">log</span>(age[<span class="hljs-built_in">num</span>]);<br>        &#125;<br>      &#125;<br></code></pre></td></tr></table></figure><h2 id="Map和Set-ES6的新特性"><a href="#Map和Set-ES6的新特性" class="headerlink" title="Map和Set (ES6的新特性)"></a>Map和Set (ES6的新特性)</h2><p>Map：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>ES6   Map<br><span class="hljs-regexp">//</span>学生的成绩，学生的名字<br><span class="hljs-regexp">//</span> var  names  =[<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-string">&quot;haha&quot;</span>] ;<br><span class="hljs-regexp">//</span> var  scores= [<span class="hljs-number">100</span>,<span class="hljs-number">90</span>,<span class="hljs-number">80</span>];<br>var map = new Map([<br>  [<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-number">100</span>],<br>  [<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">90</span>],<br>  [<span class="hljs-string">&#x27;haha&#x27;</span>, <span class="hljs-number">80</span>],<br>]);<br>var name = map.get(<span class="hljs-string">&#x27;tom&#x27;</span>);<br>map.set(<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-number">1223456</span>); <span class="hljs-regexp">//</span>添加<br>console.log(name); <span class="hljs-regexp">//</span>通过Key获得value<br>map.<span class="hljs-keyword">delete</span>(<span class="hljs-string">&#x27;tom&#x27;</span>);<span class="hljs-regexp">//</span>删除<br></code></pre></td></tr></table></figure><p>Set:无序不重复的集合</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">var <span class="hljs-built_in">set</span> = <span class="hljs-built_in">new</span> Set([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]);<span class="hljs-comment"> //Set可以去重</span><br>     <span class="hljs-built_in">set</span>.<span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>); <span class="hljs-comment"> //添加</span><br>     <span class="hljs-built_in">set</span>.<span class="hljs-built_in">delete</span>(<span class="hljs-number">1</span>);<span class="hljs-comment"> // 删除</span><br>     console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">set</span>.has(<span class="hljs-number">3</span>)); <span class="hljs-comment"> //是否包含某个元素</span><br></code></pre></td></tr></table></figure><h2 id="iterator-es6新特性"><a href="#iterator-es6新特性" class="headerlink" title="iterator(es6新特性)"></a>iterator(es6新特性)</h2><p>遍历数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> arr) &#123;<br>  <span class="hljs-built_in">console</span>.log(x);<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历map</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">var</span> <span class="hljs-keyword">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([<br>  [<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-number">100</span>],<br>  [<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">90</span>],<br>  [<span class="hljs-string">&#x27;haha&#x27;</span>, <span class="hljs-number">70</span>],<br>]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> <span class="hljs-keyword">map</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(x);<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历set</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">var <span class="hljs-meta">set</span> = new <span class="hljs-meta">Set</span>([5, 6, 7]);<br>for (let <span class="hljs-meta">x</span> of <span class="hljs-meta">set</span>) &#123;<br>  console<span class="hljs-meta">.log(</span><span class="hljs-meta">x</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024358748480">参考链接</a></p><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1JJ41177di?p=1">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS浮动&amp;父级边框塌陷问题&amp;定位</title>
    <link href="/2021/04/02/CSS%E5%AD%A6%E4%B9%A0(%E4%B8%89)/"/>
    <url>/2021/04/02/CSS%E5%AD%A6%E4%B9%A0(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<p>以下是对CSS(浮动，父级边框塌陷问题，定位)的学习(重点)</p><hr><h2 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h2><p>边框的粗细，样式，颜色( border: 1px solid red;)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-comment">/* body 总有以一个默认的外边距margin:0 常见操作 */</span></span><br><span class="css"><span class="hljs-selector-tag">h1</span>, <span class="hljs-selector-tag">ul</span>, <span class="hljs-selector-tag">li</span>, <span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="css">    <span class="hljs-attribute">text-decoration</span>: none;</span><br>  &#125;<br><span class="css">  <span class="hljs-comment">/* border: 粗细，样式，颜色 */</span></span><br>  #box &#123;<br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">h2</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#3cbda6</span>;</span><br><span class="css">    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">30px</span>;</span><br><span class="css">    <span class="hljs-attribute">color</span>: white;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">form</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">background</span>: <span class="hljs-number">#3cbda6</span>;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">1</span>) <span class="hljs-selector-tag">input</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid black;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">div</span>:<span class="hljs-built_in">neh-of-type</span>(<span class="hljs-number">2</span>) iniput &#123;</span><br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> dashed <span class="hljs-number">#4d0b8c</span>;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">div</span>:<span class="hljs-built_in">neh-of-type</span>(<span class="hljs-number">3</span>) iniput &#123;</span><br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> dashed <span class="hljs-number">#008c27</span>;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="内外边距及边框居中"><a href="#内外边距及边框居中" class="headerlink" title="内外边距及边框居中"></a>内外边距及边框居中</h2>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;外边距的妙用，居中元素<br><span class="hljs-attribute">margin</span>:<span class="hljs-number">10</span>px <span class="hljs-number">5</span>px <span class="hljs-number">15</span>px <span class="hljs-number">20</span>px;(上右下左)--顺时针<br><span class="hljs-attribute">margin</span>:<span class="hljs-number">10</span>px <span class="hljs-number">5</span>px;上下<span class="hljs-number">10</span>px,左右 <span class="hljs-number">5</span>px <br><span class="hljs-attribute">margin</span>:<span class="hljs-number">10</span>px <span class="hljs-number">5</span>px <span class="hljs-number">15</span>px;上外边距是<span class="hljs-number">10</span>px，左右<span class="hljs-number">5</span>px，下外边距是<span class="hljs-number">15</span>px<br><span class="hljs-attribute">margin</span>:<span class="hljs-number">10</span>px;所有 <span class="hljs-number">4</span> 个外边距都是 <span class="hljs-number">10</span>px<br></code></pre></td></tr></table></figure><p>盒子大小计算方式<br><img src="/image/5.1.PNG" alt="盒子大小"></p><h2 id="圆角边框"><a href="#圆角边框" class="headerlink" title="圆角边框"></a>圆角边框</h2><p>4个角</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  border-radius  左上  右上  右下  左下 ，顺时针方向 --&gt;</span><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">  圆圈  = 半径+边距!</span><br><span class="hljs-comment"> --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid red;</span><br><span class="css">    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">100px</span>;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="盒子阴影-box-shadow"><a href="#盒子阴影-box-shadow" class="headerlink" title="盒子阴影(box-shadow)"></a>盒子阴影(box-shadow)</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">    <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><br><span class="css">      <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50px</span>;</span><br><span class="css">      <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">10px</span> <span class="hljs-number">10px</span> <span class="hljs-number">1px</span> yellow;</span><br>    &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>box-shadow: h-shadow v-shadow blur spread color inset;<br>h-shadow必需。水平阴影的位置。允许负值。<br>v-shadow必需。垂直阴影的位置。允许负值。<br>blur    可选。模糊距离。<br>spread    可选。阴影的尺寸。<br>color    可选。阴影的颜色。请参阅 CSS 颜色值。<br>inset    可选。将外部阴影 (outset) 改为内部阴影。<br></code></pre></td></tr></table></figure><h2 id="模仿网站思路"><a href="#模仿网站思路" class="headerlink" title="模仿网站思路"></a>模仿网站思路</h2><p><a href="https://www.bilibili.com/video/BV1YJ411a7dy?p=16">网页链接</a><br>视频后半部分讲解</p><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><h3 id="标准文档流"><a href="#标准文档流" class="headerlink" title="标准文档流"></a>标准文档流</h3><p>块级元素: 独占一行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>~<span class="hljs-selector-tag">h6</span>   <span class="hljs-selector-tag">p</span>  <span class="hljs-selector-tag">div</span>  列表...<br></code></pre></td></tr></table></figure><p>行内元素: 不占一行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">span</span>  <span class="hljs-selector-tag">a</span>  <span class="hljs-selector-tag">img</span>  <span class="hljs-selector-tag">strong</span>....<br></code></pre></td></tr></table></figure><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>这个也是一种实现行内元素排列的方式，但是我们很多情况都是float</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">    block 块元素</span><br><span class="hljs-comment">    inline  行内元素</span><br><span class="hljs-comment">    inline-block 是块元素，但是可以内联在一行！</span><br><span class="hljs-comment">    none</span><br><span class="hljs-comment"> --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;</span><br><span class="css">    <span class="hljs-attribute">display</span>: none;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">span</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;</span><br><span class="css">    <span class="hljs-attribute">display</span>: inline-block;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><p>左右浮动 float </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>;<br>&#125;<br><span class="hljs-selector-id">#father</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-number">#000</span> solid;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br><span class="hljs-selector-id">#father</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br><span class="hljs-selector-class">.layer01</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-number">#00f</span> dashed;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">float</span>: left;<br>&#125;<br><span class="hljs-selector-class">.layer02</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-number">#00f</span> dashed;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">float</span>: left;<br>&#125;<br><br><span class="hljs-selector-class">.layer03</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-number">#00f</span> dashed;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">float</span>: right;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li>display 方向不可以控制</li><li>float    浮动起来的话会脱离标准文档流，所以要解决父级边框塌陷的问题<h2 id="父级边框塌陷问题"><a href="#父级边框塌陷问题" class="headerlink" title="父级边框塌陷问题"></a>父级边框塌陷问题</h2>clear<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq">/*  <span class="hljs-built_in">clear</span>: <span class="hljs-built_in">right</span>;  右侧不允许有浮动元素<br>    <span class="hljs-built_in">clear</span>: <span class="hljs-built_in">left</span>;  左侧不允许有浮动元素<br>    <span class="hljs-built_in">clear</span>: both;  两侧不允许有浮动元素<br>     <span class="hljs-built_in">clear</span>: none默认值。允许浮动元素出现在两侧。<br>*/<br></code></pre></td></tr></table></figure>解决方案：</li></ul><ol><li>增加父级元素的高度~<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#father</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-number">#000</span> solid;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">800px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>增加一个空的div标签，清除浮动<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;div class=&quot;clear&quot;&gt;</span><span class="hljs-params">&lt;/div&gt;</span><br>.<span class="hljs-class">clear </span>&#123;<br><span class="hljs-symbol">  clear:</span> both;<br><span class="hljs-symbol">  margin:</span> <span class="hljs-number">0</span>;<br><span class="hljs-symbol">  padding:</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>overflow<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">在父级元素中添加一个  <span class="hljs-attribute">overflow</span>:hidden;<br></code></pre></td></tr></table></figure></li><li>父类添加一个伪元素  ::after<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#father</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><h3 id="1-相对定位-position-relative"><a href="#1-相对定位-position-relative" class="headerlink" title="1.相对定位 position: relative;"></a>1.相对定位 position: relative;</h3><p> 相对原来自己的位置，进行指定的偏移，相对定位的话，它仍然在标准文档流中，原来的位置会被保留。<br> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">top</span>: -<span class="hljs-number">20px</span>;上<br><span class="hljs-attribute">left</span>:<span class="hljs-number">20px</span>;左<br><span class="hljs-attribute">bottom</span>:-<span class="hljs-number">10px</span>;下<br><span class="hljs-attribute">right</span>: <span class="hljs-number">20px</span>;右<br></code></pre></td></tr></table></figure></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 相对定位</span><br><span class="hljs-comment">相对自己原来的位置进行偏移 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;</span><br><span class="css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>;</span><br><span class="css">    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;</span><br><span class="css">    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">25px</span>;</span><br>  &#125;<br>  #father &#123;<br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#666</span>;</span><br><span class="css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br>  &#125;<br>  #first &#123;<br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> dashed <span class="hljs-built_in">rgb</span>(<span class="hljs-number">35</span>, <span class="hljs-number">204</span>, <span class="hljs-number">50</span>);</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: cyan;</span><br><span class="css">    <span class="hljs-attribute">position</span>: relative; <span class="hljs-comment">/* 相对定位，上下左右  */</span></span><br><span class="css">    <span class="hljs-attribute">top</span>: -<span class="hljs-number">20px</span>;</span><br><span class="css">    <span class="hljs-attribute">left</span>: <span class="hljs-number">20px</span>;</span><br>  &#125;<br>  #second &#123;<br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> dashed <span class="hljs-built_in">rgb</span>(<span class="hljs-number">16</span>, <span class="hljs-number">58</span>, <span class="hljs-number">194</span>);</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="css">    <span class="hljs-attribute">position</span>: relative;</span><br><span class="css">    <span class="hljs-attribute">bottom</span>: -<span class="hljs-number">10px</span>; <span class="hljs-comment">/* 向下 */</span></span><br>  &#125;<br>  #third &#123;<br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> dashed <span class="hljs-built_in">rgb</span>(<span class="hljs-number">167</span>, <span class="hljs-number">46</span>, <span class="hljs-number">92</span>);</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: chartreuse;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-绝对定位-position-absolute"><a href="#2-绝对定位-position-absolute" class="headerlink" title="2. 绝对定位 position: absolute;"></a>2. 绝对定位 position: absolute;</h3><p>定位: 基于xxx定位，上下左右~</p><ol><li>没有父级元素定位的前提下，相对于浏览器定位</li><li>假如父级元素存在定位，我们通常会相对于父级元素进行偏移</li><li>在父级元素范围内移动</li></ol><p>相对于父级或浏览器的位置，进行指定的偏移，绝对定位的话，它不在标准文档流中，原来的位置不会被保留。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;</span><br><span class="css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>;</span><br><span class="css">    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;</span><br><span class="css">    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">25px</span>;</span><br>  &#125;<br>  #father &#123;<br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#666</span>;</span><br><span class="css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="css">    <span class="hljs-attribute">position</span>: relative;</span><br>  &#125;<br>  #first &#123;<br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> dashed <span class="hljs-built_in">rgb</span>(<span class="hljs-number">35</span>, <span class="hljs-number">204</span>, <span class="hljs-number">50</span>);</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: cyan;</span><br>  &#125;<br>  #second &#123;<br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> dashed <span class="hljs-built_in">rgb</span>(<span class="hljs-number">16</span>, <span class="hljs-number">58</span>, <span class="hljs-number">194</span>);</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="css">    <span class="hljs-attribute">position</span>: absolute;</span><br><span class="css">    <span class="hljs-attribute">right</span>: <span class="hljs-number">30px</span>;</span><br>  &#125;<br>  #third &#123;<br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> dashed <span class="hljs-built_in">rgb</span>(<span class="hljs-number">167</span>, <span class="hljs-number">46</span>, <span class="hljs-number">92</span>);</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: chartreuse;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;first&quot;</span>&gt;</span>第一个盒子<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;second&quot;</span>&gt;</span>第二个盒子<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;third&quot;</span>&gt;</span>第三个盒子<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-固定定位-position-fixed"><a href="#3-固定定位-position-fixed" class="headerlink" title="3.固定定位      position: fixed;"></a>3.固定定位      position: fixed;</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">1000px</span>;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">1</span>) &#123;</span><br><span class="css">    <span class="hljs-comment">/*绝对定位，相对于浏览器*/</span></span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">background</span>: red;</span><br><span class="css">    <span class="hljs-attribute">position</span>: absolute;</span><br><span class="css">    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><br><span class="css">    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">2</span>) &#123;</span><br><span class="css">    <span class="hljs-comment">/*fixed  固定定位*/</span></span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;</span><br><span class="css">    <span class="hljs-attribute">background</span>: yellow;</span><br><span class="css">    <span class="hljs-attribute">position</span>: fixed;</span><br><span class="css">    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><br><span class="css">    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-z-index"><a href="#4-z-index" class="headerlink" title="4. z-index"></a>4. z-index</h3><p>图层~<br>z-index:  默认是0，最高~999(z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。)<br>注释：元素可拥有负的 z-index 属性值。<br>注释：Z-index 仅能在定位元素上奏效（例如 position:absolute;）！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;style/style.css&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;images/1.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tipText&quot;</span>&gt;</span>学习CSS<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tipBg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>时间:2021-1-23<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>地点：月球一号基地<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>opacity: 0.5;背景透明度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#content</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">304px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">25px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> black solid;<br>&#125;<br><span class="hljs-selector-tag">ul</span>,<br><span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">list-style</span>: none;<br>&#125;<br><span class="hljs-comment">/* 父级元素相对定位 */</span><br><span class="hljs-selector-id">#content</span> <span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.tipText</span>,<br><span class="hljs-selector-class">.tipBg</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">304px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">25px</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">164px</span>;<br>&#125;<br><span class="hljs-selector-class">.tipText</span> &#123;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">z-index</span>: <span class="hljs-number">999</span>;<br>&#125;<br><span class="hljs-selector-class">.tipBg</span> &#123;<br>  <span class="hljs-attribute">background</span>: black;<br>  <span class="hljs-comment">/* 背景透明度  */</span><br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动画及视野拓展"><a href="#动画及视野拓展" class="headerlink" title="动画及视野拓展"></a>动画及视野拓展</h2><p><a href="https://www.bilibili.com/video/BV1YJ411a7dy?p=23">学习视频地址</a></p><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1YJ411a7dy?p=1">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>前端基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript入门&amp;数据类型(一)</title>
    <link href="/2021/04/02/Javascript%E5%85%A5%E9%97%A8(%E4%B8%80)/"/>
    <url>/2021/04/02/Javascript%E5%85%A5%E9%97%A8(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<p>有句话叫，假设能够重新来过，我就只愿意学Javascript。为什么：因为它足够的简单，而且应用量极其强大，不仅在前端用的多，而且在后端用的也足够的多，整个nodejs不需要java也能够搭建起来服务器。但是支撑不了高并发，还是有个弊端。以下是对JavaScript基础学习总结。</p><hr><h3 id="入门-Javascript代码放置"><a href="#入门-Javascript代码放置" class="headerlink" title="入门(Javascript代码放置)"></a>入门(Javascript代码放置)</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- script标签内，写Javascript代码 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- &lt;script&gt;</span><br><span class="hljs-comment">    alert(&#x27;hello,world&#x27;)</span><br><span class="hljs-comment">  &lt;/script&gt; --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 外部引入 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 注意：script:必须成对出现 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/p1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 不用显示定义type,也默认就是javascript --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 这里也可以存放 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span> <br></code></pre></td></tr></table></figure><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>ECMAScript它可以理解是JavaScript的一个标准，最新版本已经到了es6版本~。但是大部分浏览器还只停留在支持es5代码上！开发环境–线上环境，版本不一致。<br><strong>javascript更简单了，只要你按照java的语法写javascript就一定不会出错。javascript可以不写分号结尾，但是有个问题，它编译打包会把多行变成一行。有个东西是eslink专门检查JavaScript语法的。有很多强语法的检查工具。</strong></p><h3 id="浏览器的使用-5个常用功能"><a href="#浏览器的使用-5个常用功能" class="headerlink" title="浏览器的使用(5个常用功能)"></a>浏览器的使用(5个常用功能)</h3><p>Elements  元素（爬网站用，把网站复刻一遍）<br>Console      调试js<br>Source   打断点<br>Network   抓包<br>Application   查看网站的cookie<br><img src="/image/4.1.png" alt="浏览器控制台"></p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Javascript严格区分大小写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-comment">//1.定义变量  变量类型  变量名= 变量值</span></span><br><span class="javascript">  <span class="hljs-keyword">var</span> score = <span class="hljs-number">71</span>;</span><br><span class="javascript">  <span class="hljs-comment">// var num = 1;</span></span><br><span class="javascript">  <span class="hljs-comment">//   alert(num);</span></span><br><span class="javascript">  <span class="hljs-comment">//2.条件控制</span></span><br>  if (1 &lt; 2) &#123;<br><span class="javascript">    alert(<span class="hljs-string">&quot;true&quot;</span>);</span><br>  &#125;<br><span class="javascript">  <span class="hljs-comment">// console.log(score) //在浏览器的控制台打印变量！</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="数据类型略讲"><a href="#数据类型略讲" class="headerlink" title="数据类型略讲"></a>数据类型略讲</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span>  王者荣耀=<span class="hljs-string">&#x27;永恒砖石&#x27;</span>(可以使用中文定义，但最好不要使用)<br></code></pre></td></tr></table></figure><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>js不区分小数和整数，Number</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">123</span>    <span class="hljs-regexp">//</span>整数<span class="hljs-number">123</span><br><span class="hljs-number">123.1</span>   <span class="hljs-regexp">//</span>浮点数<span class="hljs-number">123.1</span><br><span class="hljs-number">1.123</span>e3   <span class="hljs-regexp">//</span>科学计数法<br>-<span class="hljs-number">99</span>   <span class="hljs-regexp">//</span>复数<br>NaN   <span class="hljs-regexp">//</span>not  a number<br>Infinity   <span class="hljs-regexp">//</span>表示无限大<br></code></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme"><span class="hljs-symbol">&#x27;abc</span>&#x27;  <span class="hljs-string">&quot;abc&quot;</span><br></code></pre></td></tr></table></figure><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>true,   false</p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">&amp;&amp;  两个都为真，结果为真</span><br><span class="hljs-string">||  一个为真，一个为假</span><br>！  真即假，假即真<br></code></pre></td></tr></table></figure><h3 id="比较运算符！！！重要！"><a href="#比较运算符！！！重要！" class="headerlink" title="比较运算符！！！重要！"></a>比较运算符！！！<strong>重要！</strong></h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">=  </span><br><span class="hljs-section">==   等于(类型不一样，值一样，也会判断为true)</span><br><span class="hljs-section">===   绝对等于 (类型一样，值一样，结果为true)</span><br></code></pre></td></tr></table></figure><p><strong>这是JS的缺陷，坚持不要使用 == 比较</strong><br>须知：</p><ul><li>NaN === NaN,这个与所有的数值都不相等，包括自己</li><li>只能通过isNaN(NaN)来判断这个数是否是NaN</li></ul><p>浮点数问题:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">console</span>.log((<span class="hljs-number">1</span>/<span class="hljs-number">3</span>)   ==== (<span class="hljs-number">1</span>-<span class="hljs-number">1</span>/<span class="hljs-number">3</span>))  (false)<br></code></pre></td></tr></table></figure><p>尽量避免使用浮点数进行运算，存在精度问题！</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Math</span>.abs(<span class="hljs-number">1</span>/<span class="hljs-number">3</span>-(<span class="hljs-number">1</span>-<span class="hljs-number">2</span>/<span class="hljs-number">3</span>))&lt;<span class="hljs-number">0</span>.<span class="hljs-number">00000001</span>  (true)<br></code></pre></td></tr></table></figure><h3 id="null-和undefined"><a href="#null-和undefined" class="headerlink" title="null 和undefined"></a>null 和undefined</h3><ul><li>null  空</li><li>undefined  未定义</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>Java的数值必须是相同类型的对象~，JS中不需要这样！</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//  保证代码的可读性，尽量使用[]</span><br><span class="hljs-keyword">var</span>  arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Hello&#x27;</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">true</span>];<br><br><span class="hljs-keyword">new</span>  <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Hello&#x27;</span>)<br></code></pre></td></tr></table></figure><p>去数组下标：如果越界了，就会</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象的大括号，数组是中括号</p><blockquote><p>每个属性之间使用都好隔开，最好一个不需要添加</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> person= &#123;<br>    name:<span class="hljs-string">&quot;hh&quot;</span>,<br>    age: <span class="hljs-number">3</span>,<br>    tags:<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;js&#x27;</span>,<span class="hljs-string">&#x27;java&#x27;</span>,<span class="hljs-string">&#x27;web&#x27;</span>,<span class="hljs-string">&#x27;...&#x27;</span>]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>取对象的值</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">person.age<br>&gt;<span class="hljs-number">3</span><br>person.tags<br>&gt;<span class="hljs-selector-attr">[<span class="hljs-string">&quot;js&quot;</span>, <span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;web&quot;</span>, <span class="hljs-string">&quot;...&quot;</span>]</span><br></code></pre></td></tr></table></figure><h2 id="严格检查模式strict"><a href="#严格检查模式strict" class="headerlink" title="严格检查模式strict"></a>严格检查模式strict</h2><p>前提：IDEA 需要设置支持ES6语法’use  strict’;严格检查模式，预防Javascript的随意性导致产生的一些问题,必须写在Javascript的第一行,局部变量建议使用let去定义~</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-string">&#x27;use  strict&#x27;</span>;</span><br><span class="javascript">  <span class="hljs-comment">// 全局变量</span></span><br>    i = 1;<br><span class="javascript">  <span class="hljs-comment">//   ES6 let</span></span><br><span class="javascript">  <span class="hljs-comment">//   let i = 1;</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1JJ41177di?p=1">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS&amp;结构伪类选择器&amp;属性选择器(重要)&amp;美化网页元素</title>
    <link href="/2021/04/01/CSS%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
    <url>/2021/04/01/CSS%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<p>以下是对CSS(结构伪类选择器(避免使用，class,id选择器),属性选择器(重要)等)的学习</p><hr><h2 id="结构伪类选择器-避免使用，class-id选择器"><a href="#结构伪类选择器-避免使用，class-id选择器" class="headerlink" title="结构伪类选择器(避免使用，class,id选择器)"></a>结构伪类选择器(避免使用，class,id选择器)</h2><p>带冒号都是伪类选择器<br>1 ul li:first-child</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* ul的第一个子元素 */</span><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-comment">/* ul的最后一个元素 */</span><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span> &#123;<br>  <span class="hljs-attribute">background</span>: turquoise;<br>&#125;<br></code></pre></td></tr></table></figure><p>2  p:nth-child(1) (nth父元素)</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">    <span class="hljs-comment">/* 选中p1: 定位到父元素，选择当前的第一个元素 </span><br><span class="hljs-comment">选择当前p元素的父级元素，选择父级元素的第一个,并且是当前元素才生效</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-comment">/* p:nth-child(1)&#123;</span><br><span class="hljs-comment">      background: violet;</span><br><span class="hljs-comment">  &#125; */</span><br></code></pre></td></tr></table></figure><p>3 p:nth-of-type(1) </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">/*  选中父元素，下的p元素的第一个，按类型选类型  */</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-attribute">background</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><p>4 a:hover(鼠标悬浮的颜色 (重要))</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">background</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="属性选择器-重要"><a href="#属性选择器-重要" class="headerlink" title="属性选择器(重要)"></a>属性选择器(重要)</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">    <span class="hljs-selector-class">.demo</span> <span class="hljs-selector-tag">a</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">float</span>: left;</span><br><span class="css">      <span class="hljs-attribute">display</span>: block;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;</span><br><span class="css">      <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;</span><br><span class="css">      <span class="hljs-attribute">background</span>: lightgreen;</span><br><span class="css">      <span class="hljs-attribute">text-align</span>: center;</span><br><span class="css">      <span class="hljs-attribute">color</span>: gainsboro;</span><br><span class="css">      <span class="hljs-attribute">text-decoration</span>: none;</span><br><span class="css">      <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">5px</span>;</span><br><span class="css">      <span class="hljs-attribute">font</span>: bold <span class="hljs-number">20px</span>/<span class="hljs-number">50px</span> Arial;</span><br><span class="css">      <span class="hljs-attribute">line-height</span>: <span class="hljs-number">50px</span>;</span><br>    &#125;<br>    /* 属性名， 属性名= 属性值（正则）<br>=绝对等于<br>*=包含这个元素<br>^= 以这个开头<br>$= 以这个结尾<br> */<br><br><span class="css">    <span class="hljs-comment">/* 存在id属性的元素   a[]&#123;&#125; */</span></span><br><span class="css">    <span class="hljs-comment">/* a[id]&#123;</span></span><br><span class="css">    <span class="hljs-attribute">background</span>: yellow;</span><br>&#125; */<br><span class="css">    <span class="hljs-comment">/*id=first的元素  */</span></span><br><span class="css">    <span class="hljs-comment">/* a[id=first]&#123;</span></span><br><span class="css">    <span class="hljs-attribute">background</span>: violet;</span><br>&#125; */<br><span class="css">    <span class="hljs-comment">/* class 中有links的元素 */</span></span><br><span class="css">    <span class="hljs-comment">/* a[class*=&quot;links&quot;]&#123;</span></span><br><span class="css">    <span class="hljs-attribute">background</span>: yellow;</span><br>&#125; */<br><br><span class="css">    <span class="hljs-comment">/* 选中href中以http开头的元素 */</span></span><br><span class="css">    <span class="hljs-comment">/* a[href^=http]&#123;</span></span><br><span class="css"><span class="hljs-attribute">background</span>: yellow;</span><br>    &#125; */<br><span class="css">    <span class="hljs-comment">/* 选中href中以doc结尾的元素 */</span></span><br><span class="css">    <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href$=<span class="hljs-string">&#x27;doc&#x27;</span>]</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">background</span>: yellow;</span><br>    &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links item first&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;first&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links item active&quot;</span><span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;test&quot;</span> &gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;images/123.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links item&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;images/123.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links item&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;images/123.jpg&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links item&quot;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;abc&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links item&quot;</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/a.pdf&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links item&quot;</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/a.pdf&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links item&quot;</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;abc.doc&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links item&quot;</span>&gt;</span>9<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;abcd.doc&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links item&quot;</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="美化网页元素"><a href="#美化网页元素" class="headerlink" title="美化网页元素"></a>美化网页元素</h2><ol><li>有效的传递页面信息</li><li>美化页面，页面漂亮，才能吸引用户</li><li>凸显页面的主题</li><li>提高用户的体验</li></ol><h3 id="span标签：重点要突出的字，使用span套起来"><a href="#span标签：重点要突出的字，使用span套起来" class="headerlink" title="span标签：重点要突出的字，使用span套起来"></a>span标签：重点要突出的字，使用span套起来</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!-- font-family:字体</span><br><span class="hljs-comment">   font-size:字体大小</span><br><span class="hljs-comment">   font-weight:字体粗细</span><br><span class="hljs-comment">   color:字体颜色</span><br><span class="hljs-comment">--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">   <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">     <span class="hljs-attribute">font-family</span>: Impact, Haettenschweiler, <span class="hljs-string">&#x27;Arial Narrow Bold&#x27;</span>, sans-serif;</span><br><span class="css">     <span class="hljs-attribute">color</span>: blue;</span><br>   &#125;<br><span class="css">   <span class="hljs-selector-tag">h1</span> &#123;</span><br><span class="css">     <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50px</span>;</span><br>   &#125;<br>   .p1 &#123;<br><span class="css">     <span class="hljs-attribute">font-weight</span>: lighter;</span><br>   &#125;<br> <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><ol><li>颜色 color rgb rgba</li><li>文本对齐的方式  text-align(重要)</li><li>首行缩进  text-indent: 2em; (重要)</li><li>行高    line-height(单行文字上下居中)(重要)</li><li>装饰   text-decoration</li><li>文本图片水平对齐  vertical-align: middle;<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">   颜色：</span><br><span class="hljs-comment">           单词</span><br><span class="hljs-comment">           RGB  0~F</span><br><span class="hljs-comment">           RGBA  A :0~1</span><br><span class="hljs-comment">           text-align:  排版，居中</span><br><span class="hljs-comment">           text-indent: 2em;  段落首行缩进</span><br><span class="hljs-comment">       line-height: 300px;  </span><br><span class="hljs-comment">       行高，和块的高度一致，就可以上下居中  </span><br><span class="hljs-comment">--&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">   <span class="hljs-selector-tag">h1</span> &#123;</span><br><span class="css">     <span class="hljs-attribute">color</span>: red;</span><br><span class="css">     <span class="hljs-attribute">text-align</span>: center;</span><br>   &#125;<br>   .p1 &#123;<br><span class="css">     <span class="hljs-attribute">text-indent</span>: <span class="hljs-number">2em</span>;</span><br>   &#125;<br><br>   .p3 &#123;<br><span class="css">     <span class="hljs-attribute">background</span>: chartreuse;</span><br><span class="css">     <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">     <span class="hljs-attribute">line-height</span>: <span class="hljs-number">300px</span>;</span><br>   &#125;<br><span class="css">   <span class="hljs-comment">/* 下划线 */</span></span><br>   .l1 &#123;<br><span class="css">     <span class="hljs-attribute">text-decoration</span>: underline;</span><br>   &#125;<br><span class="css">   <span class="hljs-comment">/* 中划线 */</span></span><br>   .l2 &#123;<br><span class="css">     <span class="hljs-attribute">text-decoration</span>: line-through;</span><br>   &#125;<br><span class="css">   <span class="hljs-comment">/*上划线  */</span></span><br>   .l3 &#123;<br><span class="css">     <span class="hljs-attribute">text-decoration</span>: overline;</span><br>   &#125;<br><span class="css">   <span class="hljs-selector-tag">img</span>,</span><br><span class="css">   <span class="hljs-selector-tag">span</span> &#123;</span><br><span class="css">     <span class="hljs-attribute">vertical-align</span>: middle;</span><br>   &#125;<br> <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;l1&quot;</span>&gt;</span>123123<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;l2&quot;</span>&gt;</span>123123<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;l3&quot;</span>&gt;</span>123123<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>故事介绍<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span><br>     平静安详的元泱境界，每隔333年，总会有一个神秘而恐怖的异常生物重生，它就是魁拔！魁拔的每一次出现，都会给元泱境界带来巨大的灾难！<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>     在偏远的兽国窝窝乡，蛮大人和蛮吉每天为取得象征成功和光荣的妖侠纹耀而刻苦修炼，却把他们生活的村庄搅得鸡犬不宁。村民们绞尽脑汁把他们赶走。<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p3&quot;</span>&gt;</span><br>     I have searched a thousand years,And I have cried a thousand tears.<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="超链接伪类"><a href="#超链接伪类" class="headerlink" title="超链接伪类"></a>超链接伪类</h3>正常情况下， a:hover<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css">    <span class="hljs-comment">/* 默认的颜色 */</span><br>  <span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">text-decoration</span>: none;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;<br>  &#125;<br>  <span class="hljs-comment">/* 鼠标悬浮的颜色 (重要)*/</span><br>  <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">color</span>: orange;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50px</span>;<br>  &#125;<br>  <span class="hljs-comment">/* 鼠标按住未释放的状态 */</span><br>  <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>    <span class="hljs-attribute">color</span>: green;<br>  &#125;<br><br>  <span class="hljs-comment">/*  text-shadow   阴影颜色，水平偏移，垂直偏移，阴影半径*/</span><br>  <span class="hljs-selector-id">#price</span> &#123;<br>    <span class="hljs-attribute">text-shadow</span>: blue <span class="hljs-number">10px</span> <span class="hljs-number">10px</span> <span class="hljs-number">2px</span>;<br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h3 id="列表样式"><a href="#列表样式" class="headerlink" title="列表样式"></a>列表样式</h3><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">/* <span class="hljs-string">ul</span>  <span class="hljs-string">li</span> */<br>/* <br><span class="hljs-built_in">list-style::</span><br><span class="hljs-built_in">none</span>  去掉原点<br><span class="hljs-string">circle</span>  空心圆<br><span class="hljs-string">decimal</span>  数字<br><span class="hljs-string">square</span>  正方形<br>*/<br><span class="hljs-string">ul</span>  <span class="hljs-string">li</span>&#123;<br>    <span class="hljs-string">height</span>: <span class="hljs-string">30px</span>;<br>    <span class="hljs-built_in">list-style:</span> <span class="hljs-string">none</span>;<br>    <span class="hljs-string">text-indent</span>: <span class="hljs-string">1em</span>;<br>      &#125;<br></code></pre></td></tr></table></figure><h3 id="图片平铺方式渐变-background-repeat"><a href="#图片平铺方式渐变-background-repeat" class="headerlink" title="图片平铺方式渐变(background-repeat)"></a>图片平铺方式渐变(background-repeat)</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span></span><br><span class="xml">  div </span><span class="xquery">&#123;</span><br><span class="xquery">    width: <span class="hljs-number">1000</span>px;</span><br><span class="xquery">    height: <span class="hljs-number">700</span>px;</span><br><span class="xquery">    border: <span class="hljs-number">1</span>px solid red;</span><br><span class="xquery">    background-image: url(<span class="hljs-string">&#x27;image/1.jpg&#x27;</span>);</span><br><span class="xquery">    /* 默认是全部平铺的 */</span><br><span class="xquery">  &#125;</span><br><span class="xml">  <span class="hljs-comment">&lt;!-- 沿x轴平铺 --&gt;</span></span><br><span class="xml">  .div1 </span><span class="xquery">&#123;</span><br><span class="xquery">    background-repeat: repeat-x;</span><br><span class="xquery">  &#125;</span><br><span class="xml">      <span class="hljs-comment">&lt;!-- 沿y轴平铺 --&gt;</span></span><br><span class="xml">  .div2 </span><span class="xquery">&#123;</span><br><span class="xquery">    background-repeat: repeat-y;</span><br><span class="xquery">  &#125;</span><br><span class="xml">  .div3 </span><span class="xquery">&#123;</span><br><span class="xquery">    background-repeat: no-repeat;</span><br><span class="xquery">  &#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="背景渐变"><a href="#背景渐变" class="headerlink" title="背景渐变"></a>背景渐变</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--径向渐变，圆形渐变  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#00dbde</span>;</span><br><span class="css">    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">45deg</span>, <span class="hljs-number">#00dbde</span> <span class="hljs-number">0%</span>, <span class="hljs-number">#fc00ff</span> <span class="hljs-number">100%</span>);</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><a href="https://www.grabient.com/">开源项目网址</a></li></ol><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1YJ411a7dy?p=1">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>前端基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS导入方式&amp;三种基本选择器&amp;层次选择器</title>
    <link href="/2021/04/01/Css%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <url>/2021/04/01/Css%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">css的优势：<br><span class="hljs-number">1</span>.内容和表现分离<br><span class="hljs-number">2</span>.网页结构表现统一，可以实现复用。<br><span class="hljs-number">3</span>.样式十分丰富。<br><span class="hljs-number">4</span>.建议使用独立于<span class="hljs-selector-tag">html</span>的css文件。<br><span class="hljs-number">5</span>.利用SEO,容易被搜索引擎收录。<br></code></pre></td></tr></table></figure><p>以下是对CSS(CSS导入方式(三种),三种基本选择器,层次选择器)的学习</p><hr><h2 id="CSS导入方式-三种"><a href="#CSS导入方式-三种" class="headerlink" title="CSS导入方式(三种)"></a>CSS导入方式(三种)</h2><ol><li>行内样式<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 行内样式：在标签元素中，编写一个style属性，编写样式即可 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;&quot;</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>内部样式<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 内部样式 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">        <span class="hljs-selector-tag">h1</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">color</span>:green;</span><br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>外部样式–1.链接式<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 外部样式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/css/style.css&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>外部样式–2.导入式(不常用，以前网页先加载框架Html，后渲染出页面)<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">@import是CSS2.1特有的<br><span class="hljs-comment">&lt;!-- 导入式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css"><span class="hljs-keyword">@import</span> url(css/style.css);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><strong>优先级:就近原则</strong><br><strong>优先级:行内样式&gt;内部样式&gt;外部样式</strong></li></ol><h2 id="三种基本选择器"><a href="#三种基本选择器" class="headerlink" title="三种基本选择器"></a>三种基本选择器</h2><ol><li>标签选择器<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">    <span class="hljs-comment">/* 标签选择器，会选择到页面所有的这个标签的元素 */</span></span><br><span class="css">    <span class="hljs-selector-tag">h1</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">background</span>: blue;</span><br><span class="css">        <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">24px</span>;</span><br><span class="css">        <span class="hljs-attribute">color</span>: hotpink;</span><br>    &#125;<br><span class="css">    <span class="hljs-selector-tag">p</span>&#123;</span><br><span class="css">        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">80px</span>;</span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>类选择器<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    /*  类选择器的格式，.class的名称&#123;&#125;<br>    好处，可以多个标签归类，是同一个class,可以复用<br>      */<br>    .aa.cc&#123;<br><span class="css">        <span class="hljs-attribute">color</span>:hotpink;</span><br>    &#125;<br>    .bb&#123;<br><span class="css">        <span class="hljs-attribute">color</span>: indianred;</span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>id选择器(全局唯一)<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>/*   id选择器  ：id必须保证全局唯一<br>  #id名称&#123;&#125;*/<br>#aa&#123;<br><span class="css">   <span class="hljs-attribute">color</span>: lawngreen; </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h3>优先级:不遵循就近原则，固定的<br><strong>id选择器&gt;class选择器&gt;标签选择器</strong></li></ol><h2 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h2><ol><li>后代选择器：在某个元素的后面(都会作用)<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">    <span class="hljs-comment">/* body  p&#123;</span><br><span class="hljs-comment">        background: red;</span><br><span class="hljs-comment">    &#125; */</span><br>例：<span class="hljs-selector-tag">body</span>后的所有<span class="hljs-selector-tag">p</span>标签背景都会变为红色<br></code></pre></td></tr></table></figure></li><li>子选择器：(就作用一代)<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">   <span class="hljs-comment">/* body&gt;p&#123;</span><br><span class="hljs-comment">       background:blue;</span><br><span class="hljs-comment">   &#125; */</span><br>例：<span class="hljs-selector-tag">body</span>后面的第一代<span class="hljs-selector-tag">p</span>标签才有效果，其他嵌套的没有<br></code></pre></td></tr></table></figure></li><li>相邻兄弟选择器：只有一个，相邻(向下)<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">    <span class="hljs-comment">/* .active+p&#123;</span><br><span class="hljs-comment">        background:blue;</span><br><span class="hljs-comment">    &#125; */</span><br>例：类active标签的向下的一个<span class="hljs-selector-tag">P</span>标签才会作用<br></code></pre></td></tr></table></figure></li><li>通用兄弟选择器<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">当前选中元素的向下的所有兄弟元素 */<br>    <span class="hljs-selector-class">.active</span> ~ <span class="hljs-selector-tag">p</span> &#123;<br>      <span class="hljs-attribute">background</span>: tomato;<br>    &#125;<br>例：类active后面向下的所有<span class="hljs-selector-tag">P</span>标签都会作用<br></code></pre></td></tr></table></figure></li></ol><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1YJ411a7dy?p=1">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>前端基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git的使用--如何将本地项目上传到Github&amp;Git创建新分支</title>
    <link href="/2021/03/31/Git%E7%9A%84%E4%BD%BF%E7%94%A8--%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0Github&amp;Git%E5%88%9B%E5%BB%BA%E6%96%B0%E5%88%86%E6%94%AF/"/>
    <url>/2021/03/31/Git%E7%9A%84%E4%BD%BF%E7%94%A8--%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0Github&amp;Git%E5%88%9B%E5%BB%BA%E6%96%B0%E5%88%86%E6%94%AF/</url>
    
    <content type="html"><![CDATA[<p>如何将本地项目上传到Github（两种简单、方便的方法）</p><hr><h3 id="创建分支与切换分支"><a href="#创建分支与切换分支" class="headerlink" title="创建分支与切换分支"></a>创建分支与切换分支</h3><h4 id="第一种-已尝试"><a href="#第一种-已尝试" class="headerlink" title="第一种(已尝试)"></a>第一种(已尝试)</h4><ol><li><p>Github上新建一个仓库<br><img src="/image/8.png" alt="新建一个仓库"></p></li><li><p>复制仓库地址先(两个都行)<br><img src="/image/8.1.png" alt="仓库地址"></p></li><li><p>桌面右键Git进入文件夹目录<br><img src="/image/8.2.png" alt="Git"></p></li><li><p>接下来输入如下代码（关键步骤），把github上面的仓库克隆到本地</p></li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">git</span>  <span class="hljs-selector-tag">clone</span>  <span class="hljs-selector-tag">git</span>@<span class="hljs-selector-tag">github</span><span class="hljs-selector-class">.com</span>:<span class="hljs-selector-tag">Pengzhenglong</span>/<span class="hljs-selector-tag">html</span><span class="hljs-selector-tag">-css-js</span><span class="hljs-selector-class">.git</span><br>(git<span class="hljs-variable">@github</span>.<span class="hljs-attribute">com</span>:Pengzhenglong/html-css-js.git换成你第二步复制的地址链接)<br></code></pre></td></tr></table></figure><p><img src="/image/8.3.png" alt="克隆仓库"><br> 这个步骤以后你的本地项目文件夹下面就会多出个文件夹，该文件夹名即为你github上面的项目名，如图我多出了个html-css-js文件夹，我们把本地项目文件夹下的所有文件（除了新多出的那个文件夹不用），其余都复制到那个新多出的文件夹下。</p><p><img src="/image/8.4.png" alt="文件图片"></p><ol start="5"><li><p>接着继续输入命令 cd html-css-js，进入html-css-js文件夹</p></li><li><p>接下来依次输入以下代码即可完成其他剩余操作</p></li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git add . （注：别忘记后面的.，此操作是把html-css-js文件夹下面的文件都添加进来）           <br><br>git commit  -m  ”提交信息”  （注：“提交信息”里面换成你需要，如“<span class="hljs-built_in">first</span> commit”）       <br><br>git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> master   （注：此操作目的是把本地仓库<span class="hljs-built_in">push</span>到github上面，此步骤需要你输入帐号和密码）(由于我之前设置了免密操作所以我这台电脑不需要输入账号密码)<br></code></pre></td></tr></table></figure><p><img src="/image/8.5.png" alt="Git操作"></p><p><img src="/image/8.6.png" alt="上传成功"></p><h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><blockquote><p>参考链接:<br><code>https://blog.csdn.net/u014135752/article/details/79951802</code></p></blockquote><h5 id="Git创建新分支并提交到github"><a href="#Git创建新分支并提交到github" class="headerlink" title="Git创建新分支并提交到github"></a>Git创建新分支并提交到github</h5><p>因为需求的变更，需要把原来的代码做一下备份，再进行下一步的开发，所以 这是就将原来的代码创建一个新的分支来保存原来的代码，以防后面需要回滚，这里记录一下操作的步骤</p><ol><li>可以先查看一下当前所在分支</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span><br></code></pre></td></tr></table></figure><ol start="2"><li>创建本地分支并切换到新创建的分支</li></ol><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">创建分支(本地)<br>git  <span class="hljs-keyword">branch </span> xxx<br></code></pre></td></tr></table></figure><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">git</span> <span class="hljs-variable">checkout</span> -<span class="hljs-variable">b</span> <span class="hljs-function"><span class="hljs-title">dev</span>(<span class="hljs-variable">dev</span> 可以命名为自己想取的名字)</span><br></code></pre></td></tr></table></figure><ol start="3"><li>已经创建成功了，可以看一下</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span><br></code></pre></td></tr></table></figure><ol start="4"><li>将新创建的分支信息推送到github</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> HEAD -u<br></code></pre></td></tr></table></figure><ol start="5"><li><p>可以到github看一下<br><img src="/image/8.8.png" alt="Github"></p></li><li><p>git checkout branchname   //切换分支  branchname为你的分支名字</p></li><li><p>分支操作</p></li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">然后切换到主分支<br>$ git checkout <span class="hljs-keyword">master</span> <span class="hljs-title"></span><br><span class="hljs-title"></span><br><span class="hljs-title">然后将新分支提交的改动合并到主分支上</span><br><span class="hljs-title">$</span> git merge newbranch  <br><br>然后就可以push代码了<br>$ git push -u origin <span class="hljs-literal">master</span><br><br>最后还可以删除这个分支<br>$ git branch -D newbranch<br></code></pre></td></tr></table></figure><h4 id="开发项目码云与Git分支的使用"><a href="#开发项目码云与Git分支的使用" class="headerlink" title="开发项目码云与Git分支的使用"></a>开发项目码云与Git分支的使用</h4><ol><li>在码云上你的项目中新建分支</li></ol><p><img src="/image/4.2.png" alt="创建分支">  </p><ol start="2"><li>本地项目文件右键Git  Bash Here</li></ol><p>命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">git  pull  <span class="hljs-regexp">//</span>将线上的分支拉到本地<br><br>git  checkout  index <span class="hljs-regexp">//i</span>ndex为你自己建的分支名字，现在你所在的分支就在index分支上，本地开发的代码都在这个分支上<br><br><span class="hljs-regexp">//</span>开发完成后<br><br>git  add .  <span class="hljs-regexp">//</span>添加文件到暂存区<br>git  commit -m <span class="hljs-string">&#x27;name&#x27;</span>  <span class="hljs-regexp">//</span>name可以你自己起<br>git  push <span class="hljs-regexp">//</span>本地分支的内容提交到线上了<br>git  checkout  master  <span class="hljs-regexp">//</span>切换为主分支<br>git  merge  index  <span class="hljs-regexp">//</span>将新增的内容合并到主分支上<br>git  push  <span class="hljs-regexp">//</span>将master分支代码提交到线上<br><br></code></pre></td></tr></table></figure><ol start="3"><li>查看所有分支</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git branch -a<br>* br-<span class="hljs-number">2.1</span>.<span class="hljs-number">2.2</span><br>  master<br>  remotes<span class="hljs-regexp">/origin/</span>HEAD -&gt; origin/master<br>  remotes<span class="hljs-regexp">/origin/</span>br-<span class="hljs-number">2.1</span>.<span class="hljs-number">2.1</span><br>  remotes<span class="hljs-regexp">/origin/</span>br-<span class="hljs-number">2.1</span>.<span class="hljs-number">2.2</span><br>  remotes<span class="hljs-regexp">/origin/</span>br-<span class="hljs-number">2.1</span>.<span class="hljs-number">3</span><br>  remotes<span class="hljs-regexp">/origin/m</span>aster<br></code></pre></td></tr></table></figure><h3 id="Git的基本操作指令"><a href="#Git的基本操作指令" class="headerlink" title="Git的基本操作指令"></a>Git的基本操作指令</h3><p><img src="/image/8.9.png" alt="Git"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">切换分支命令:<br><br>git checkout (branchname)   <span class="hljs-regexp">//</span>切换分支<br>$ git init    <span class="hljs-regexp">//</span> 初始化仓库。<br>$ git add .    <span class="hljs-regexp">//</span>添加文件到暂存区。<br>$ git commit  <span class="hljs-regexp">//</span>将暂存区内容添加到仓库中。<br>$ git push   <span class="hljs-regexp">//</span>上传远程代码并合并<br>$ git pull   <span class="hljs-regexp">//</span>下载远程代码并合并<br></code></pre></td></tr></table></figure><h4 id="删除分支操作"><a href="#删除分支操作" class="headerlink" title="删除分支操作"></a>删除分支操作</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">删除本地分支：<br>git branch  <span class="hljs-regexp">//</span><span class="hljs-number">1</span>.查看本地分支列表<br>git branch -d 分支名称   <span class="hljs-regexp">//</span><span class="hljs-number">2</span>.删除本地分支<br><br>删除远程分支：<br>git branch -a    <span class="hljs-regexp">//</span><span class="hljs-number">1</span>.查看远程分支列表<br>git push origin --<span class="hljs-keyword">delete</span> 远程分支名称   <span class="hljs-regexp">//</span><span class="hljs-number">2</span>.删除远程分支<br></code></pre></td></tr></table></figure><h4 id="git强制提交"><a href="#git强制提交" class="headerlink" title="git强制提交"></a>git强制提交</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">log</span>  查看<span class="hljs-keyword">commit</span>信息<br>git  <span class="hljs-keyword">reset</span>  <span class="hljs-comment">--hard  （commit号）  回滚到某个commit</span><br><br>提示要先git  pull 可以强制提交<br>git  push  <span class="hljs-comment">--force origin  分支名</span><br></code></pre></td></tr></table></figure><h4 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h4><p>分支名称如果开发新功能时你就命名成feature/xxxx(xxxx表示具体描述)  修复bug时就fix/xxxx  fix/整个模块的名字</p><h3 id="如何修改当前项目git的用户名和邮箱"><a href="#如何修改当前项目git的用户名和邮箱" class="headerlink" title="如何修改当前项目git的用户名和邮箱"></a>如何修改当前项目git的用户名和邮箱</h3><p>查看本地设置:</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">git</span> <span class="hljs-comment">config</span> --<span class="hljs-comment">local</span> --<span class="hljs-comment">list</span><br></code></pre></td></tr></table></figure><p>查看设置本地属性（本地用户和email）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git config <span class="hljs-keyword">user</span>.name<br>git config <span class="hljs-keyword">user</span>.email<br></code></pre></td></tr></table></figure><p>解决方法:</p><h4 id="修改当前的project"><a href="#修改当前的project" class="headerlink" title="修改当前的project"></a>修改当前的project</h4><p>修改当前project的用户名的命令:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git config <span class="hljs-keyword">user</span>.name  &quot;你的目标用户名&quot;<br></code></pre></td></tr></table></figure><p>修改当前project提交邮箱的命令:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">git config user.email <span class="hljs-string">&quot;你的目标邮箱名&quot;</span><br></code></pre></td></tr></table></figure><h3 id="git-stash暂存开发分支，拉去合并线上分支-开发后要合并线上分支-提pr-解决冲突"><a href="#git-stash暂存开发分支，拉去合并线上分支-开发后要合并线上分支-提pr-解决冲突" class="headerlink" title="git  stash暂存开发分支，拉去合并线上分支(开发后要合并线上分支(提pr)解决冲突)"></a>git  stash暂存开发分支，拉去合并线上分支(开发后要合并线上分支(提pr)解决冲突)</h3><h4 id="git-pull-和-git-fetch-的区别"><a href="#git-pull-和-git-fetch-的区别" class="headerlink" title="git pull 和 git fetch 的区别"></a>git pull 和 git fetch 的区别</h4><ol><li><p>git fetch 只是将远程仓库的变化下载下来，并没有和本地分支合并。（fetch  只是下拉远程分支，怎么合并，可以自己再做选择）</p></li><li><p>git pull 会将远程仓库的变化下载下来，并和当前分支合并。pull=fetch+merge</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">git  stash  <br>git  status<br>git  <span class="hljs-keyword">add</span> .<br>git  <span class="hljs-keyword">fetch</span>  <span class="hljs-operator">-</span><span class="hljs-keyword">all</span> <br>git  <span class="hljs-keyword">merge</span>  origin<span class="hljs-operator">/</span>分支名<br>git  stash  pop<br></code></pre></td></tr></table></figure><p>还有一种是你刚刚有一条提交记录，惊觉还有没有提交的，需要在提交上去，又不想产生一条新的记录</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git review</span><br></code></pre></td></tr></table></figure><p>然后在git  push 上去</p><h4 id="git-review"><a href="#git-review" class="headerlink" title="git review"></a>git review</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk">git status <span class="hljs-regexp">//</span>用于查询当前目录的状态，反馈回的信息很详尽<br>git log <span class="hljs-regexp">//</span>查看commit的各个版本<br>git log --pretty=oneline <span class="hljs-regexp">//</span>同上，初略显示，只显示一行<br><br>git add &lt;file&gt;... <span class="hljs-regexp">//</span>把工作区的更改提交到stage<br>git rm &lt;file&gt;...  <span class="hljs-regexp">//</span>删除文件，把工作区的删除文件提交到stage<br>git commit -m <span class="hljs-string">&quot;版本名&quot;</span> <span class="hljs-regexp">//</span>将工作区的更改提交到master分支，本地的最高层<br><br>git reset --hard HEAD^ <span class="hljs-regexp">//</span>回退到上一个版本<br>git reset --hard HEAD^^^ <span class="hljs-regexp">//</span>回退到上三个版本<br>git reset --hard HEAD~<span class="hljs-number">100</span> <span class="hljs-regexp">//</span>回退到上<span class="hljs-number">100</span>个版本<br>git reset --hard &lt;版本id&gt;  <span class="hljs-regexp">//</span>回退到这个id版本<br><br>git reset HEAD &lt;file&gt;...  <span class="hljs-regexp">//</span>撤销该文件的git add提交<br><br>git checkout -- &lt;file&gt;... <span class="hljs-regexp">//</span>清除工作区这个文件的更改,恢复到最近一次git add或者git commit时的情形<br></code></pre></td></tr></table></figure><h3 id="Git默认拉取的是master分支，拉取指定分支代码命令"><a href="#Git默认拉取的是master分支，拉取指定分支代码命令" class="headerlink" title="Git默认拉取的是master分支，拉取指定分支代码命令"></a>Git默认拉取的是master分支，拉取指定分支代码命令</h3><p>拉取指定分支代码解决方案：</p><p>以拉取1.0分支的代码为例， 要拉取其余分支代码类似操作</p><ol><li>使用git命令拉取<br>命令：git clone -b 1.o XXX</li></ol><p>其中1.0就是分支的名称<br><img src="/image/56.png" alt="拉取指定分支">  </p><h3 id="git-tag标签的使用"><a href="#git-tag标签的使用" class="headerlink" title="git  tag标签的使用"></a>git  tag标签的使用</h3><p>tag是git版本库的一个标记，指向某个commit的指针。</p><p>tag主要用于发布版本的管理，一个版本发布之后，我们可以为git打上 v.1.0.1 v.1.0.2 …这样的标签。</p><p>tag感觉跟branch有点相似，但是本质上和分工上是不同的：</p><p>tag 对应某次commit, 是一个点，是不可移动的。<br>branch 对应一系列commit，是很多点连成的一根线，有一个HEAD 指针，是可以依靠 HEAD 指针移动的。<br>所以，两者的区别决定了使用方式，改动代码用 branch ,不改动只查看用 tag。<br>tag 和 branch 的相互配合使用，有时候起到非常方便的效果，例如：已经发布了 v1.0 v2.0 v3.0 三个版本，这个时候，我突然想不改现有代码的前提下，在 v2.0 的基础上加个新功能，作为 v4.0 发布。就可以检出 v2.0 的代码作为一个 branch ，然后作为开发分支。</p><h4 id="tag的简单使用（一般在git-commit后打tag）"><a href="#tag的简单使用（一般在git-commit后打tag）" class="headerlink" title="tag的简单使用（一般在git  commit后打tag）"></a>tag的简单使用（一般在git  commit后打tag）</h4><p>创建 tag 是基于本地分支的 commit，而且与分支的推送是两回事，就是说分支已经推送到远程了，但是你的 tag 并没有，如果把 tag 推送到远程分支上，需要另外执行 tag 的推送命令。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">//本地新增无备注的<span class="hljs-keyword">tag</span>（默认在当前分支最后一个commit上添加<span class="hljs-keyword">tag</span>）<br>git <span class="hljs-keyword">tag</span>   <span class="hljs-title">//git</span>查询本地所有<span class="hljs-keyword">tag</span><br>git <span class="hljs-keyword">tag</span> <span class="hljs-title">标签名   //后面是标签命名</span><br><span class="hljs-title">git</span> <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span>.<span class="hljs-number">1.0</span>  <br><br>//本地新增有备注的<span class="hljs-keyword">tag</span>（默认在当前分支最后一个commit上添加<span class="hljs-keyword">tag</span>）<br>git <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> 标签名 -m “备注内容”<br>git <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> v1.<span class="hljs-number">1.1</span> -m <span class="hljs-string">&quot;测试&quot;</span>   <br><br>// //在指定commit上新增<span class="hljs-keyword">tag</span><br>git <span class="hljs-keyword">tag</span> <span class="hljs-title">标签名 commit</span>（前几位也可以，尝试过最低<span class="hljs-number">3</span>位报错，最好<span class="hljs-number">5</span>位以上）<br>git <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span>.<span class="hljs-number">1.0</span>  <span class="hljs-number">105851905</span>c8a0f9cc040cf845b35c1ced1963fcc    <br><br><br><br> // 将<span class="hljs-keyword">tag</span>推送到远程分支<br>git push origin 标签名<br>git push origin v1.<span class="hljs-number">1.0</span>   <br><br><br>//删除本地分支标签<br>git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> 标签名<br>git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> v1.<span class="hljs-number">1.0</span>  <br><br><br>//删除远程分支标签<br>git push origin :refs/tags/标签名<br>git push origin :refs/tags/v1.<span class="hljs-number">1.0</span>   <br></code></pre></td></tr></table></figure><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>git rebase相对来说是比较复杂的一个命令了,但只要掌握了使用方式,你会深深地喜欢上他,如果有时间我也许会细细地讲一下,现将git rebase的正确使用步骤总结如下:</p><h5 id="Git-操作"><a href="#Git-操作" class="headerlink" title="Git 操作"></a>Git 操作</h5><p>假设Git目前只有一个分支master。开发人员的工作流程是</p><ul><li>git clone master branch</li><li>在自己本地checkout -b local创建一个本地开发分支</li><li>在本地的开发分支上开发和测试</li><li>阶段性开发完成后（包含功能代码和单元测试），可以准备提交代码</li><li>首先切换到master分支，git pull拉取最新的分支状态</li><li>然后切回local分支</li><li>通过git rebase -i 将本地的多次提交合并为一个，以简化提交历史。本地有多个提交时,如果不进行这一步,在git rebase master时会多次解决冲突(最坏情况下,每一个提交都会相应解决一个冲突)</li><li>git rebase master 将master最新的分支同步到本地，这个过程可能需要手动解决冲突(如果进行了上一步的话,只用解决一次冲突)</li><li>然后切换到master分支，git merge将本地的local分支内容合并到master分支</li><li>git push将master分支的提交上传</li><li>本地开发分支可以灵活管理</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git checkout <span class="hljs-literal">master</span><br>git pull<br>git checkout local<br>git rebase -i HEAD~<span class="hljs-number">2</span>  //合并提交 --- <span class="hljs-number">2</span>表示合并两个<br>git rebase <span class="hljs-literal">master</span>----&gt;解决冲突---&gt;git rebase --continue<br>git checkout <span class="hljs-literal">master</span><br>git merge local<br>git push<br><br></code></pre></td></tr></table></figure><h3 id="git-diff命令的使用"><a href="#git-diff命令的使用" class="headerlink" title="git diff命令的使用"></a>git diff命令的使用</h3><p>git diff是一个git提供的一个非常有用的命令，使用git diff可清晰的显示出文件被修改的内容。</p><h4 id="工作区、版本库"><a href="#工作区、版本库" class="headerlink" title="工作区、版本库"></a>工作区、版本库</h4><p>要理解git diff命令，就必须先理解工作区、暂存区与版本库的概念。</p><p>工作区就是所在目录，比如我的TestGit文件夹：<br><img src="/imageO/34.png" alt="TestGit"></p><p>在上图的.git文件中，存放的就是版本库，版本库中存储了很多东西，最重要的就是stage（或者叫index）暂存区、git自动创建的一个分支master，以及指向master的一个指针HEAD。</p><p>添加修改到版本库的过程如图所示：<br><img src="/imageO/35.png" alt="添加修改版本库"></p><ol><li><p>工作区 –&gt; 暂存区<br>使用git add命令将工作区文件添加到缓存区。</p></li><li><p>暂存区 –&gt; 仓库<br>使用git commit命令将暂存区中的文件提交到仓库。</p></li><li><p>git diff命令<br>根据所要对比区域不同，git diff有如下几种用法。</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">命令             作用<br>git diff       <span class="hljs-regexp">//</span>查看工作区与暂存区的差异<br>git diff --cached     <span class="hljs-regexp">//</span>查看暂存区与仓库的差异<br>git diff HEAD <span class="hljs-regexp">//</span>查看工作区与仓库的差异<br></code></pre></td></tr></table></figure><h3 id="分支管理规范"><a href="#分支管理规范" class="headerlink" title="分支管理规范"></a><strong>分支管理规范</strong></h3><p>分批次研发规范流程</p><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><ol><li>需求、UE评审，确定需求优先级</li><li>基本确定需求间的依赖关系，确定不同提测批次的需求模块</li><li>不同批次研发排期确定和提测时间确定</li><li>第一批次需求开发开始</li><li>第一批次需求自测 + 提测</li><li>第二批次需求开发开始</li><li>第二批次需求自测 + 提测</li><li>以此类推……<h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5></li></ol><ul><li><p>有些隐晦的依赖关系可能在开发时才被发现，影响到了需求分批次的正确性，此时需要及时和项目后台负责人说明情况，调整受影响批次的需求内容</p></li><li><p>后续批次的研发，并不一定要等到第一批次提测结束后才开始，当然，提测时会被QA打断，影响编码效率，所以上一批次提测期间，后续批次的研发排期，需要自行判断延长，比如 1天 当 0.5天算</p><h4 id="前端分支管理规范demo"><a href="#前端分支管理规范demo" class="headerlink" title="前端分支管理规范demo"></a>前端分支管理规范demo</h4></li><li><p>需求评审 + UE评审 + 分批次提测模块划分</p></li><li><p>开始开发前，从develop拉取分支</p><ul><li> release/vx.x.x — 用于最终提测</li><li>test/vx.x.x — 用于自测</li><li>feature/xxx — 用于开发单个功能需求</li></ul></li><li><p>第一批次feature开发联调完毕，合并到 test 分支，部署到开发环境进行自测，自测bug在 feature 分支修复后合并到 test 分支</p></li><li><p>自测结束，各feature分支合并到release分支，发起提测，提测bug从 release 拉取 fix 分支修复</p></li><li><p>第二批次feature开发联调完毕，合并到test分支，部署到开发环境进行自测，自测bug在 feature 分支修复后合并到 test 分支</p></li><li><p>自测结束，各feature分支合并到release分支，发起提测，提测bug从 release 拉取 fix 分支修复</p></li><li><p>以此类推……</p></li><li><p>全部提测通过，release分支合并到develop分支，打tag，删除各feature分支、test分支</p><h3 id="commit提交规范"><a href="#commit提交规范" class="headerlink" title="commit提交规范"></a><strong>commit提交规范</strong></h3><ul><li>1，每日下班前记得提交代码，避免遗失；</li><li>2，提交代码时必须标注必要的描述信息；</li><li>3，描述信息的规范：类型：具体信息，如：fix：修复子菜单未选中问题</li><li>描述类型如下：<ul><li>feat: 新特性</li><li>fix: 修改问题</li><li>refactor: 代码重构</li><li>docs: 文档修改</li><li>chore: 其他修改</li><li>test: 测试用例修改</li><li>style: 代码格式修改等等</li></ul></li></ul></li></ul><h4 id="分支命名规范"><a href="#分支命名规范" class="headerlink" title="分支命名规范"></a><strong>分支命名规范</strong></h4><ul><li>1，功能分支命名：feature/版本日期_功能_作者，如：feature/20200924_createNode_ybl</li><li>2，版本发布分支命名：release/发布日期，如：release/20200924</li></ul><h4 id="gitflow流程"><a href="#gitflow流程" class="headerlink" title="gitflow流程"></a><strong>gitflow流程</strong></h4><p><img src="/img/git.png" alt="image"></p><ul><li><strong>功能开发</strong><ul><li>所有的新功能开发应该通过创建<strong>feature</strong>分支的方式去开发，需要从最新代码的<strong>develop</strong>分支里进行创建，例如feature/add-user，开发完成之后需要发起<strong>Merge Request</strong>合并回develop分支；</li><li>强调下：独立的功能尽量使用独立的feature分支来开发，切忌把多个功能合并使用一个feature分支来开发；</li><li>不同的feature分支完成开发和联调后，需要严格执行自测，并且根据项目的需要来决定是否单独提测该feature分支。</li></ul></li><li><strong>功能提测</strong><ul><li>确认需要发布的功能集合以及对应的版本号后，将相应的feature分支统一合并回develop分支，并且从develop分支上新建相应的release分支，例如：release/v1.2.0；</li><li>release分支在测试过程中<strong>出现的bug</strong>，可以通过新建hotfix分支的方式去并行修复问题，完成后需要通过<strong>Merge Request</strong>合并回当前release分支；</li><li>release分支在测试过程中<strong>出现新的需求</strong>，可以通过feature分支的方式去开发，完成后需要通过<strong>Merge Request</strong>合并回当前release分支；</li></ul></li><li><strong>发布上线</strong><ul><li>待release分支测试验收通过后，在当前release分支上打出相应的tag（例如v1.2.0），然后将代码分别合并到master和develop分支中，并且需要将当前release分支相关历史的feature分支或hotfix分支进行删除。</li></ul></li><li><strong>线上问题修复</strong><ul><li>若线上发现有严重的bug，需要从具体tag（如v1.1.0）的提交版本中创建相应的hotfix分支（例如hotfix/v1.1.0）；</li><li>当问题修复完成并且通过测试验证，需要在当前分支打tag（例如v1.1.0-P1），并且需要将当前hotfix分支分别通过<strong>Merge Request</strong>合并回master、develop分支上。</li></ul></li></ul><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h4><ul><li>1，定期清理已合并且无用的<strong>feature</strong>分支，留版本发布的<strong>release/xxx</strong>分支；<ul><li>清理远程分支git remote  prune origin   </li><li>清理本地分支git branch -D 分支名</li></ul></li><li>2，记得发布后打tag；</li></ul><blockquote><p>参考链接<br><a href="https://www.runoob.com/git/git-basic-operations.html">菜鸟教程</a><br><a href="https://www.cnblogs.com/jmhwsrr/p/14085463.html">git diff命令的使用</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git(SSH本地免密)+Github迁移到Gitee</title>
    <link href="/2021/03/31/Git(SSH%E6%9C%AC%E5%9C%B0%E5%85%8D%E5%AF%86)+Github%E8%BF%81%E7%A7%BB%E5%88%B0Gitee/"/>
    <url>/2021/03/31/Git(SSH%E6%9C%AC%E5%9C%B0%E5%85%8D%E5%AF%86)+Github%E8%BF%81%E7%A7%BB%E5%88%B0Gitee/</url>
    
    <content type="html"><![CDATA[<p>Git上传到Github每次都要密码验证，很麻烦，想一下可以使用SSH免密操作，同时上传到Github和Gitee,也可以将项目迁移至Gitee.</p><hr><h2 id="Github配置-SSH-key"><a href="#Github配置-SSH-key" class="headerlink" title="Github配置 SSH key"></a>Github配置 SSH key</h2><p>window10系统桌面右键<code>Git Bash Here</code></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>注：<strong>后面的 <code>your_email@youremail.com</code> 改为你在 Github 上注册的邮箱</strong>，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。<br>成功的话会在C:\Users\ASUS下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。<br>之后进入Github中自己的设置中，左边选择 SSH and GPG keys，然后点击 New SSH key 按钮,title 设置标题，可以随便填，粘贴在你电脑上生成的 key。<br>验证：为了验证是否成功，输入以下命令：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">$ ssh -T git@github.com<br>The authenticity <span class="hljs-keyword">of</span> host <span class="hljs-symbol">&#x27;github</span>.com (<span class="hljs-number">52.74</span>.<span class="hljs-number">223.119</span>)&#x27; can<span class="hljs-symbol">&#x27;t</span> be established.<br>RSA key fingerprint <span class="hljs-keyword">is</span> SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.<br>Are you sure you want <span class="hljs-keyword">to</span> continue connecting (yes/no/[fingerprint])? yes                   # 输入 yes<br><span class="hljs-literal">Warning</span>: Permanently added <span class="hljs-symbol">&#x27;github</span>.com,<span class="hljs-number">52.74</span>.<span class="hljs-number">223.119</span>&#x27; (RSA) <span class="hljs-keyword">to</span> the list <span class="hljs-keyword">of</span> known hosts.<br>Hi tianqixin! You<span class="hljs-symbol">&#x27;ve</span> successfully authenticated, but GitHub does <span class="hljs-keyword">not</span> provide shell <span class="hljs-keyword">access</span>. # 成功信息<br></code></pre></td></tr></table></figure><h2 id="Gitee-配置-SSH-key"><a href="#Gitee-配置-SSH-key" class="headerlink" title="Gitee 配置 SSH key"></a>Gitee 配置 SSH key</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">登陆Gitee的账号：<br>点击用户头像-&gt;进入个人设置<br>选择安全设置-&gt;SSH公钥<br>选择新增公钥<br>填写标题：公钥标题key<br>填写公钥：把我们刚刚复制的公钥粘贴到这里(刚刚Github生成的密钥)<br>添加后输入输入账号密码进行确认<br></code></pre></td></tr></table></figure><p>验证：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">使用Git Bash输入：<br>ssh -T git@github.com<br>第一次连接时会问你是否继续连接，输入 <span class="hljs-literal">yes</span> 即可；<br>接下来验证Gitee的ssh连接：<br>ssh -T git@gitee.com<br>同样输入 <span class="hljs-literal">yes</span> 即可。<br></code></pre></td></tr></table></figure><p>参考链接：</p><blockquote><p><a href="https://www.runoob.com/git/git-remote-repo.html">https://www.runoob.com/git/git-remote-repo.html</a><br><a href="https://blog.csdn.net/pilihaotian/article/details/103337959">https://blog.csdn.net/pilihaotian/article/details/103337959</a></p></blockquote><h2 id="Github迁移到Gitee"><a href="#Github迁移到Gitee" class="headerlink" title="Github迁移到Gitee"></a>Github迁移到Gitee</h2><h3 id="1-直接从Github中导入到Gitee"><a href="#1-直接从Github中导入到Gitee" class="headerlink" title="1.直接从Github中导入到Gitee"></a>1.直接从Github中导入到Gitee</h3><p><img src="/image/3.png" alt="Gitee迁移"></p><h3 id="2-Gitee上新建一个项目将本地项目上传。"><a href="#2-Gitee上新建一个项目将本地项目上传。" class="headerlink" title="2.Gitee上新建一个项目将本地项目上传。"></a>2.Gitee上新建一个项目将本地项目上传。</h3><p>修改配置文件：<br>在站点根目录下找到_config.yml文件，将里边的deploy节点修改成下边的形式，其中repository等于username ，即</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">deploy:<br>  type: git<br>  repo: <br>    github: git@github<span class="hljs-selector-class">.com</span>:<span class="hljs-selector-attr">[username]</span>/<span class="hljs-selector-attr">[username]</span><span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.git</span>,master<br>    gitee: git@gitee<span class="hljs-selector-class">.com</span>:<span class="hljs-selector-attr">[username]</span>/<span class="hljs-selector-attr">[username]</span><span class="hljs-selector-class">.git</span>,master<br></code></pre></td></tr></table></figure><p>配置了这后免密了能同时上传到Github和Gitee</p><h3 id="1-注：配置文件的缩进很重要"><a href="#1-注：配置文件的缩进很重要" class="headerlink" title="1.注：配置文件的缩进很重要"></a>1.注：配置文件的缩进很重要</h3><p><img src="/image/3.1.png" alt="配置文件">  </p><h3 id="2-名字一样很重要！！！不然页面渲染加载不出来。"><a href="#2-名字一样很重要！！！不然页面渲染加载不出来。" class="headerlink" title="2.名字一样很重要！！！不然页面渲染加载不出来。"></a>2.名字一样很重要！！！不然页面渲染加载不出来。</h3><p>对于 Gitee，你可以选择建立一个私人仓库来部署自己的Hexo博客，不过和 Github 不同的地方在于：<br>Github 的仓库名要命名为： {username}.github.io<br>而 Coding.net 的仓库名要命名为：{username}<br>这里的 username 指的是你在这两个网站上的用户名，只有以这种命名形式的仓库，才能够不通过子域名的形式来访问我们的博客。<br>比如说，我的 Github 和Gitee 的账号都是jack，那么在部署博客成功后，我就可以通过下边的url来访问我的Hexo博客：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>jack.github.io/<br>https:<span class="hljs-regexp">//</span>jack.gitee.io<br></code></pre></td></tr></table></figure><ol><li>一开始我的个人空间地址与username不一样，导致网页加载不出来  </li></ol><p><img src="/image/3.2.png" alt="网站加载页面"><br>2. 最终将Gitee个人中心修改和username一致才成功加载页面 </p><p><img src="/image/3.3.png" alt="修改地址"></p><ol start="3"><li>Git上传更新到Gitee和Github上发现Github博客更新了，但是Gitee页面没有更新。<br>解决方法：<br>打开博客的仓库 -&gt; 服务 -&gt; 点击 Gitee Pages-&gt; 点击【更新】即可    </li></ol><p><img src="/image/3.5.png" alt="修改地址"></p><h3 id="总结：配置文件格式很重要，缩进及编码要注意，否者项目启动不了。博客命名和Github-Gitee的命名一致很重要，不然也会报错。"><a href="#总结：配置文件格式很重要，缩进及编码要注意，否者项目启动不了。博客命名和Github-Gitee的命名一致很重要，不然也会报错。" class="headerlink" title="总结：配置文件格式很重要，缩进及编码要注意，否者项目启动不了。博客命名和Github,Gitee的命名一致很重要，不然也会报错。"></a>总结：配置文件格式很重要，缩进及编码要注意，否者项目启动不了。博客命名和Github,Gitee的命名一致很重要，不然也会报错。</h3>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Html&amp;表格&amp;表单(重点)</title>
    <link href="/2021/03/30/%E9%87%8D%E5%AD%A6Html(%E4%BA%8C)/"/>
    <url>/2021/03/30/%E9%87%8D%E5%AD%A6Html(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ol><li>表格table    行  tr  rows( rowspan  跨行) </li><li>列  td(colspan  跨列)  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1px&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- colspan  跨列 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>1-4<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- rowspan  跨行 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>2-1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-4<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="媒体元素"><a href="#媒体元素" class="headerlink" title="媒体元素"></a>媒体元素</h2>音频和视频(src :资源路径,constrols: 控制条,autuplay: 自动播放)<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../html/audio/FN=告白气球_周杰伦_128K.mp3&quot;</span>  <span class="hljs-attr">controls</span>  <span class="hljs-attr">autoplay</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span>    <br><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../html/audio/BLACKPINK - &#x27;Lovesick Girls&#x27; M_V MAKING FILM.mp4&quot;</span>  <span class="hljs-attr">controls</span>  <span class="hljs-attr">autoplay</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>页面头部<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>网页主体<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>网页脚部<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="内联框架"><a href="#内联框架" class="headerlink" title="内联框架"></a>内联框架</h2>iframe:内联框架，src :地址,w- h :宽度高度   <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;iframe <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;http:www.baidu.com&quot;</span>  <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attribute">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span>  <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;800px&quot;</span>  <span class="hljs-attribute">height</span>=<span class="hljs-string">&quot;800px&quot;</span>&gt;&lt;/iframe&gt;<br></code></pre></td></tr></table></figure><h2 id="学习表单-重点"><a href="#学习表单-重点" class="headerlink" title="学习表单(重点)"></a>学习表单(重点)</h2></li></ol><ol><li><p>表单form(post和get提交)<br> action:表单提交的位置，可以是网站，也可以是一个请求处理地址<br> method: post,get提交方式<br> get方式提交：我们可以在url中看到我们的提交信息，不安全，高效<br> post: 比较安全，传输大文件.<br> <img src="/image/2.2.PNG" alt="表单语法"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;1.我的第一个网页.html&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;GET&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>名字：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> , <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>   <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入用户名&quot;</span> <span class="hljs-attr">required</span>  <span class="hljs-attr">maxlength</span>=<span class="hljs-string">&quot;8&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 密码值：input  type=&quot;password&quot; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pwd&quot;</span> <span class="hljs-attr">hidden</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span> <br></code></pre></td></tr></table></figure></li><li><p>文本框和单选框<br>文本输入框:</p><pre><code>     input  type = &quot;text&quot;         value =&quot;我好帅&quot;  默认初始值        maxlength=&quot;8 &quot;   最长能写几个字符            size = &quot;30&quot;      文本框的长度    </code></pre><blockquote><p>单选标签: input  type= “radio”</p></blockquote></li><li><p>按钮和多选框<br>按钮: </p><pre><code>     input type=&quot;button&quot;  普通按钮      input type=&quot;image&quot;   图像按钮         input type=&quot;submit&quot;  提示按钮        input type=&quot;reset&quot;   重置按钮    </code></pre><blockquote><p>多选框:   input type=”checkbox”</p></blockquote></li><li><p> 列表框文本域和文件域</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--文本域 cols=&quot;30&quot; rows=&quot;10&quot;--&gt;</span> <br>         <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>反馈<br>            <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;textarea&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span>文本内容<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 文件域 input type=&quot;file&quot; name=&quot;files&quot;--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;files&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传&quot;</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;upload&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>              <br></code></pre></td></tr></table></figure></li><li><p>搜索框和滑块验证</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!--滑块input type=&quot;range&quot; --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>滑块；<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;range&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;voice&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;0&quot;</span>  <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;100&quot;</span>  <span class="hljs-attr">step</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 搜索框 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>搜索：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;search&quot;</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;search&quot;</span>  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mark&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <br></code></pre></td></tr></table></figure></li><li><p>表单的应用和元素<br>readonly只读<br>disabled 禁用<br>hidden   隐藏<br><img src="/image/2.1.PNG" alt="表单元素"></p></li><li><p>表单的初级验证<br>优点：数据安全，减轻压力</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">常用方式<br>placeeholder 提示信息(文本框中有提示信息)<br><span class="hljs-built_in">require</span> 非空判断<br>pattern  正则表达式<br></code></pre></td></tr></table></figure></li><li><p>其他</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 增强鼠标可用性   了解--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;mark&quot;</span>&gt;</span>你点我试试<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>  &gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>//正则验证<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>自定义邮箱：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;diymail&quot;</span>  <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1x4411V75C">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4></li></ol>]]></content>
    
    
    <categories>
      
      <category>Html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Html&amp;基本标签&amp;列表</title>
    <link href="/2021/03/30/%E9%87%8D%E5%AD%A6Html(%E4%B8%80)/"/>
    <url>/2021/03/30/%E9%87%8D%E5%AD%A6Html(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<p>之前对Html有过学习和了解，但没有系统学习，基础还是很重要的所以现在重新学习，一起共勉。</p><hr><h2 id="Html基础"><a href="#Html基础" class="headerlink" title="Html基础"></a>Html基础</h2><h3 id="1-基本信息"><a href="#1-基本信息" class="headerlink" title="1.基本信息"></a>1.基本信息</h3><ol><li>DOCTYPE 告诉浏览器，我们要使用什么规范</li><li>head标签代表网页头部</li><li>meta描述性标签，它用来描述我们网站的一些信息</li><li>meta一般用来做SEO</li><li>title标签代表网页的主体<h3 id="2-基本标签"><a href="#2-基本标签" class="headerlink" title="2.基本标签"></a>2.基本标签</h3></li><li>h1-h6 一级-六级标签</li><li>p 段落标签</li><li>hr 水平标签</li><li>br 换行标签</li><li>strong 粗体标签</li><li>em 斜体</li><li>&amp;nbsp(空格)  @copy(版权所)有 &amp;gt(大于号) &amp;lt(小于号)—-特殊标签<h3 id="3-图像标签"><a href="#3-图像标签" class="headerlink" title="3.图像标签"></a>3.图像标签</h3></li><li> <code>&lt;img  src=&quot;../html/img/1.png&quot;  alt=&quot;女孩&quot;  title=&quot;悬停文字&quot; width=&quot;500px&quot; height=&quot;500px&quot;  &gt;  </code> (src:图片地址(必填)相对地址（推荐使用）;绝对地址../  –上一级目录 alt:  图片名字（必填）)<h3 id="4-链接标签"><a href="#4-链接标签" class="headerlink" title="4.链接标签"></a>4.链接标签</h3></li><li><code>&lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_self&quot;&gt;点击我跳转到百度&lt;/a&gt;</code>a 标签,href : 必填，表示要跳转到那个页面,_blank  在新标签中打开,_self  在自己的的网页打开.</li><li>锚链接1.需要一个锚标记2.跳转到标记<br><code> &lt;a  href=&quot;#top&quot;&gt;回到顶部&lt;/a&gt;  &lt;a  name=&quot;down&quot;&gt;down&lt;/a&gt;</code>   </li><li>功能性链接 邮箱链接：mailto<br><code>&lt;a  href=&quot;mailto:232324265@qq.com&quot;&gt;点击联系我&lt;/a&gt;</code> <h3 id="5-列表学习"><a href="#5-列表学习" class="headerlink" title="5.列表学习"></a>5.列表学习</h3></li><li>有序列表<br>应用范围:  试卷，问答…. <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>python<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>运维<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>前端<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>c<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>无序列表<br>应用范围：导航，侧边栏….     <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>python<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>运维<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>前端<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>c<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>自定义列表<br>dl:列表 dt: 列表名称 dd: 列表内容<br>运用在 公司网页底部  <pre><code>&lt;dl&gt;&lt;dt&gt;学科&lt;/dt&gt;&lt;dd&gt;java&lt;/dd&gt;&lt;dd&gt;python&lt;/dd&gt;&lt;dd&gt;位置&lt;/dd&gt;   &lt;dd&gt;西安&lt;/dd&gt;&lt;/dl&gt;</code></pre></li></ol><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1x4411V75C">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>Html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo+fluid搭建博客个人总结</title>
    <link href="/2021/03/30/hexo+fluid%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <url>/2021/03/30/hexo+fluid%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>大一大二学习了前端和后端的知识，在B站和各种网站上一通乱学，都没学精，现在发现学习了什么都记不得了。最近看了一位老师的视频学习到了你学进去的知识更重要的是输出，因为你输出了才真正是你学到的。今天开始用博客记录我学习的知识，一起共勉。</p><hr><h2 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1.安装node.js"></a>1.安装node.js</h2><p><a href="https://nodejs.org/en/">官方网站</a>安装即可,安装步骤非常简单，一直next，下一步就可以了，默认安装就行。</p><h2 id="验证安装-命令"><a href="#验证安装-命令" class="headerlink" title="验证安装  命令:"></a>验证安装  命令:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">node -v <span class="hljs-comment">#查看node版本  </span><br>npm -v <span class="hljs-comment">#查看npm版本</span><br></code></pre></td></tr></table></figure><h2 id="安装淘宝cnpm"><a href="#安装淘宝cnpm" class="headerlink" title="安装淘宝cnpm"></a>安装淘宝cnpm</h2><p>为了速度更快些，使用淘宝cnpm管理器  </p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl">命令：npm install -g cnpm --<span class="hljs-keyword">registry</span>=<span class="hljs-keyword">http</span>://<span class="hljs-keyword">registry</span>.npm.taobao.org  <br>安装完成查看cnpm是否成功，查看版本信息 cnpm -v<br></code></pre></td></tr></table></figure><h2 id="2-安装hexo框架"><a href="#2-安装hexo框架" class="headerlink" title="2.安装hexo框架"></a>2.安装hexo框架</h2><p>命令：<code>cnpm install -g hexo-cli</code></p><p>安装完成查看版本: <code>hexo -v</code></p><h2 id="使用Hexo创建博客"><a href="#使用Hexo创建博客" class="headerlink" title="使用Hexo创建博客"></a>使用Hexo创建博客</h2><h3 id="Linux系统命令"><a href="#Linux系统命令" class="headerlink" title="Linux系统命令"></a>Linux系统命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir blog <span class="hljs-comment">#创建blog目录  </span><br><span class="hljs-built_in">cd</span> blog  <span class="hljs-comment">#进入blog目录  </span><br>sudo hexo init  <span class="hljs-comment">#生成博客 初始化博客  </span><br>hexo s <span class="hljs-comment">#启动本地博客服务  </span><br>http://localhost:4000/ <span class="hljs-comment">#本地访问地址  </span><br>hexo n <span class="hljs-string">&quot;我的第一篇文章&quot;</span> <span class="hljs-comment">#创建新的文章</span><br></code></pre></td></tr></table></figure><h3 id="Window系统"><a href="#Window系统" class="headerlink" title="Window系统"></a>Window系统</h3><p>博客目录下/source/_posts下直接新建.md文件</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><blockquote><p>官方文档地址  <a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p></blockquote><h2 id="3-主题Fluid的更换"><a href="#3-主题Fluid的更换" class="headerlink" title="3.主题Fluid的更换"></a>3.主题Fluid的更换</h2><h3 id="获取主题最新版本"><a href="#获取主题最新版本" class="headerlink" title="获取主题最新版本"></a>获取主题最新版本</h3><h3 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h3><p>Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-theme-fluid  </span><br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 _config.fluid.yml，将主题的 _config.yml 内容复制进去。</p><h3 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h3><p>下载最新release版本解压到 themes 目录，并将解压出的文件夹重命名为 fluid。<br>指定主题<br>如下修改 Hexo 博客目录中的 _config.yml：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">theme:</span> fluid  <span class="hljs-meta"># 指定主题   </span><br><span class="hljs-symbol">language:</span> <span class="hljs-built_in">zh</span>-CN  <span class="hljs-meta"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><h3 id="创建「关于页」"><a href="#创建「关于页」" class="headerlink" title="创建「关于页」"></a>创建「关于页」</h3><p>首次使用主题的「关于页」需要手动创建：(注：此处必须创建，否则about页面无)</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> about   <br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 /source/about/index.md，添加 layout 属性。<br>修改后的文件示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">about</span>   <br><span class="hljs-attr">date:</span> <span class="hljs-number">2021-03-23 19:20:33</span>   <br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span>   <br><span class="hljs-string">这里写关于页的正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><h3 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h3><p>修改hexo根目录下的 _config.yml 文件 ： theme: fluid<br>百度了很多更改Fluid背景图片和文字的方法没有找到，官方文档一开始看的有点看不懂，没有静下心看，导致耽误了很久。   </p><h3 id="官方文档-https-hexo-fluid-dev-com-docs-start"><a href="#官方文档-https-hexo-fluid-dev-com-docs-start" class="headerlink" title="官方文档  https://hexo.fluid-dev.com/docs/start/"></a>官方文档  <code>https://hexo.fluid-dev.com/docs/start/</code></h3><p>更改地址在theme/fluid/_config.yml 或者 _config.fluid.yml中修改全局配置。</p><h2 id="4-使用Git上传至Github"><a href="#4-使用Git上传至Github" class="headerlink" title="4. 使用Git上传至Github"></a>4. 使用Git上传至Github</h2><p><a href="https://git-scm.com/">Git官网</a>  下载直接安装，一直点下一步<br>使用教程 参考链接<code>https://www.runoob.com/git/git-tutorial.html</code>(推荐使用免密SSH公钥)</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">hexo</span> c<span class="hljs-comment">#清理一下</span><br>hexo g<span class="hljs-comment">#生成</span><br>hexo d<span class="hljs-comment">#部署到远程Github仓库</span><br></code></pre></td></tr></table></figure><h2 id="5-部署到Github上"><a href="#5-部署到Github上" class="headerlink" title="5.部署到Github上"></a>5.部署到Github上</h2><p>Github创建一个新的仓库 <code>YourGithubName.github.io</code><br>#在blog目录下安装git部署插件<code>cnpm install --save hexo-deployer-git</code><br>#配置_config.yml   </p><pre><code># Deployment   ## Docs: https://hexo.io/docs/deployment.html    deploy:         type: git         repo: https://github.com/YourGithubName/   YourGithubName.github.io.git      branch: master   </code></pre><p>#部署到Github仓库里<code>hexo d</code><br>#访问这个地址可以查看博客<code>https://YourGithubName.github.io/</code></p><h3 id="注-YourGithubName必须与你的Github名字一模一样，否者页面打不开。"><a href="#注-YourGithubName必须与你的Github名字一模一样，否者页面打不开。" class="headerlink" title="注:YourGithubName必须与你的Github名字一模一样，否者页面打不开。"></a>注:YourGithubName必须与你的Github名字一模一样，否者页面打不开。</h3><h2 id="总结：看官方文档是学习最快最好的方式，一开始看不懂没关系，一个字慢慢看，一定会有收获的。切勿囫囵吞枣。"><a href="#总结：看官方文档是学习最快最好的方式，一开始看不懂没关系，一个字慢慢看，一定会有收获的。切勿囫囵吞枣。" class="headerlink" title="总结：看官方文档是学习最快最好的方式，一开始看不懂没关系，一个字慢慢看，一定会有收获的。切勿囫囵吞枣。"></a>总结：看官方文档是学习最快最好的方式，一开始看不懂没关系，一个字慢慢看，一定会有收获的。切勿囫囵吞枣。</h2><h4 id="基于B站视频搭建-特别感谢up主-CodeSheep"><a href="#基于B站视频搭建-特别感谢up主-CodeSheep" class="headerlink" title="基于B站视频搭建 特别感谢up主 CodeSheep"></a>基于<a href="https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.788.recommend_more_video.-1">B站视频</a>搭建 特别感谢up主 <a href="https://space.bilibili.com/384068749?spm_id_from=333.788.b_765f7570696e666f.1">CodeSheep</a></h4>]]></content>
    
    
    <categories>
      
      <category>Myblog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Myblog</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

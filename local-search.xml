<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>字符串-回文字符串</title>
    <link href="/2022/03/21/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0(5)%20-%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/03/21/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0(5)%20-%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<hr><h4 id="字符串的一些方法"><a href="#字符串的一些方法" class="headerlink" title="字符串的一些方法"></a>字符串的一些方法</h4><p>似乎字符串的一些算法题都是借助于<strong>数组的还有用指针的还有正则</strong></p><h4 id="大小写转化"><a href="#大小写转化" class="headerlink" title="大小写转化"></a>大小写转化</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">str</span>.toUpperCase<br><span class="hljs-built_in">str</span>.toLocaleLowerCase<br></code></pre></td></tr></table></figure><h4 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h4><p>一定要记住reverse是Array原型上的方法，不要搞错</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing">function reverseStr(<span class="hljs-built_in">str</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>.<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-built_in">reverse</span>().<span class="hljs-built_in">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>split()： 方法用于把一个字符串分割成字符串数组。<br>reverse()： 方法用于颠倒数组中元素的顺序。<br>join() ：方法也就是把数组中的所有元素以字符串的形式输出</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">var str = &#x27;<span class="hljs-number">112254</span>,<span class="hljs-number">3344</span>5,<span class="hljs-number">5669</span>9&#x27;;<br>var s=str.split(&#x27;,&#x27;);<br>console.<span class="hljs-built_in">log</span>(s.length);<br>console.<span class="hljs-built_in">log</span>(s[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><h3 id="判断回文字符串"><a href="#判断回文字符串" class="headerlink" title="判断回文字符串"></a>判断回文字符串</h3><p>方法一： 利用Array的reverse方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing">functin isHuiwenStr(<span class="hljs-built_in">str</span>) &#123;<br>    <span class="hljs-keyword">return</span> srt.<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-built_in">reverse</span>().<span class="hljs-built_in">join</span>(<span class="hljs-string">&#x27;&#x27;</span>) === <span class="hljs-built_in">str</span><br>&#125;<br></code></pre></td></tr></table></figure><p>方法二： 回文字符串是对称的</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs glsl">functin isHuiwenStr(str) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">length</span> = str.<span class="hljs-built_in">length</span><br>    <span class="hljs-keyword">const</span> midIndex = Math.<span class="hljs-built_in">floor</span>(<span class="hljs-built_in">length</span> / <span class="hljs-number">2</span>)<br><br>    <span class="hljs-keyword">for</span>(let i = <span class="hljs-number">0</span>; i &lt; midIndex; i++) &#123;<br>        <span class="hljs-keyword">if</span>(str[i] !== str[<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span> - i]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="非空字符串删除一个元素，判断能否成为回文字符串"><a href="#非空字符串删除一个元素，判断能否成为回文字符串" class="headerlink" title="非空字符串删除一个元素，判断能否成为回文字符串"></a>非空字符串删除一个元素，判断能否成为回文字符串</h3><p>描述：给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。<br>    function isTransHuiwenStr(str) {<br>        const arr = str.split(‘’)<br>        for(let i = 0; i &lt; str.length; i++) {<br>            const copy = […arr]<br>            copy.splice(i, 1)<br>            if (copy.reverse().join(‘’) === copy.join(‘’)) {<br>                return true<br>            }<br>        }<br>        return false<br>    }</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6972471622724747277">字符串-回文字符串</a></p>]]></content>
    
    
    <categories>
      
      <category>js算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js算法学习</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快排&amp;&amp;排序算法</title>
    <link href="/2022/03/16/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0(4)/"/>
    <url>/2022/03/16/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0(4)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="Js实现冒泡排序"><a href="#Js实现冒泡排序" class="headerlink" title="Js实现冒泡排序"></a>Js实现冒泡排序</h3><p>// 是一种计算机科学领域的较简单的排序算法<br>// 它重复的走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小，首字母）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是该元素列已经排序完成。</p><p>冒泡排序是效率最低的排序算法，由于算法嵌套了两轮循环，所以<strong>时间复杂度委O(n^2)</strong></p><p>最好的情况给出一个已经排序的数组进行冒泡排序，时间复杂度为O(n)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml">// 冒泡排序<br>function bubbleSort(arr) &#123;<br>  let len = arr.length;<br>  // 遍历数组的长度，以确定循环次数<br>  for (let i = 0; i &lt; len;i++) &#123;<br>    // 遍历数组len次，忽略后面的i项<br>    for (let j = 0; j &lt; len - 1 - i; j++) &#123;<br>      // 将每一项与后一项进行对比，不符合要求的就换位<br>      if (arr[j] &gt; arr[j + 1]) &#123;<br>        <span class="hljs-comment">&lt;!-- es6数组解构赋值 --&gt;</span><br>        [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]]<br>      &#125;<br>    &#125;<br>  &#125;<br>  return arr<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现一个快排"><a href="#实现一个快排" class="headerlink" title="实现一个快排"></a>实现一个快排</h3><p>快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行上述递归排序，以此达到整个数据变成有序序列，时间复杂度为 O(n log n)。</p><p>// 1.Quickersort通过数组选取一个元素表示为基准点，把数组中的所有其他元素分为两类-（大于和小于此基准点的数组）<br>// 2.然后把作为这一轮排序结果的两个数组（数组元素都小于基准点的数组和数组元素都大于基准点的数组）再进行相同的排序。即分别再选个基准点，然后基于基准点分为两个数组元素分别小于和大于基准点的数组。<br>// 3.最终，由于最后数组中没有元素或只有一个元素，因此不用再比较了。剩下的值都已经基于基准点拍好序了。<br><strong>（时间复杂度（平均）O(nlog2n))</strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">const</span> quickSort1 = arr =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (arr.<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//数组小于等于1时的情况</span><br>    <span class="hljs-keyword">return</span> arr;<br>  &#125;<br>  <span class="hljs-keyword">const</span> midIndex = Math.<span class="hljs-built_in">floor</span>(arr.<span class="hljs-built_in">length</span> / <span class="hljs-number">2</span>)<span class="hljs-comment">//取中间的元素为基准点</span><br>   <span class="hljs-comment">// 使用splice截取中间值，第一个参数为截取的索引，第二个参数为截取的长度；</span><br>    <span class="hljs-comment">// 如果此处使用arrArr=arr[index]; 那么将会出现无限递归的错误；</span><br>    <span class="hljs-comment">// splice影响原数组</span><br>  <span class="hljs-keyword">const</span> arrArr = arr.splice(midIndex, <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">const</span> midIndexVal = arrArr[<span class="hljs-number">0</span>]<br>  <span class="hljs-keyword">const</span> left = []<br>  <span class="hljs-keyword">const</span> right = []<br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] &lt; midIndexVal) &#123;<br>      left.push(arr[i]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      right.push(arr[i])<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> quickSort1(left).concat(midIndexVal, quickSort1(right));<span class="hljs-comment">//重复进行上面的步骤，直到剩下小于等于一个元素。</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5>]]></content>
    
    
    <categories>
      
      <category>js算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js算法学习</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Js类型转换装箱与拆箱</title>
    <link href="/2022/03/11/Js%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/"/>
    <url>/2022/03/11/Js%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/</url>
    
    <content type="html"><![CDATA[<p>众所周知，JS 是一门弱类型语言。它不需要事先具体声明变量的类型，因为会在程序运行过程中，类型会被自动推断确定。因此，可以用同一个变量保存不同类型的数据：</p><p>var a = 1;<br>a = ‘abc’;<br>a = {<br>  x: 1<br>};</p><hr><h3 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h3><p>a.x 或者 a[‘x’] 中“.”和“[]”操作符是专门用来获取引用类型属性值的。然而在 JS 中基本类型变量也是可以使用“点”的，这给初学者造成一定困惑，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>a.x = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">console</span>.log(a);<span class="hljs-comment">// 1 </span><br> <span class="hljs-built_in">console</span>.log(a.x);<span class="hljs-comment">// undefined  </span><br></code></pre></td></tr></table></figure><p>其实，上述代码运行过程中发生了所谓的“装箱”操作。<br>比如第二行：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a.x</span> = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">var <span class="hljs-keyword">temp</span> = <span class="hljs-built_in">new</span> Number(a)<br><span class="hljs-keyword">temp</span>.x = <span class="hljs-number">2</span><br><span class="hljs-keyword">temp</span> = <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p>因为 2 是基本类型，在取其属性时，先用对应的 Number 构造函数包裹成一个临时对象，然后再对临时对象取属性值操作，随后这个临时对象便销毁。</p><h3 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h3><p><a href="https://juejin.cn/post/6844903838575493127">【JS迷你书】类型转换之拆箱操作</a></p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6844903827347341325">【JS迷你书】类型转换之装箱操作</a></p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整理Ts常见知识</title>
    <link href="/2022/03/11/Ts%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/03/11/Ts%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>总结了最近的一些面试题和之前的知识点</p><hr><h3 id="typescript-中-interface-和-type-的区别"><a href="#typescript-中-interface-和-type-的区别" class="headerlink" title="typescript 中 interface 和 type 的区别"></a>typescript 中 interface 和 type 的区别</h3><h4 id="相同点-都可以描述一个对象或者函数-amp-amp-都允许拓展（extends）"><a href="#相同点-都可以描述一个对象或者函数-amp-amp-都允许拓展（extends）" class="headerlink" title="相同点 (都可以描述一个对象或者函数&amp;&amp;都允许拓展（extends）)"></a>相同点 (都可以描述一个对象或者函数&amp;&amp;都允许拓展（extends）)</h4><h5 id="都可以描述一个对象或者函数"><a href="#都可以描述一个对象或者函数" class="headerlink" title="都可以描述一个对象或者函数"></a>都可以描述一个对象或者函数</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span><br><span class="hljs-symbol">interface</span> <span class="hljs-symbol">User</span> &#123;<br>  name: <span class="hljs-built_in">string</span><br>  age: number<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-symbol">SetUser</span> &#123;<br>  (name: <span class="hljs-built_in">string</span>, age: number): <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>type</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">type</span> <span class="hljs-keyword">User</span> <span class="hljs-title">= &#123;</span><br><span class="hljs-title">  name</span>: <span class="hljs-keyword">string</span><br>  age: <span class="hljs-keyword">number</span><br>&#125;;<br><br><span class="hljs-keyword">type</span> SetUser = (name: <span class="hljs-keyword">string</span>, age: <span class="hljs-keyword">number</span>)=&gt; void;<br></code></pre></td></tr></table></figure><h5 id="都允许拓展（extends）"><a href="#都允许拓展（extends）" class="headerlink" title="都允许拓展（extends）"></a>都允许拓展（extends）</h5><p>interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">interface</span><br><span class="hljs-symbol">interface</span> <span class="hljs-symbol">Name</span> &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-symbol">User</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Name</span> &#123;<br>  age: number;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">type</span><br><span class="hljs-symbol">type</span> <span class="hljs-symbol">Name</span> = &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-symbol">User</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Name</span> &#123;<br>  age: number;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">type</span></span><br><span class="hljs-class"><span class="hljs-title">type</span> <span class="hljs-title">Name</span> </span>= &#123;<br>  name: string;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">User</span> </span>= <span class="hljs-type">Name</span> &amp; &#123; age: number  &#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">interface</span></span><br><span class="hljs-class"><span class="hljs-title">interface</span> <span class="hljs-title">Name</span> </span>&#123;<br>  name: string;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">User</span> </span>= <span class="hljs-type">Name</span> &amp; &#123;<br>  age: number;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="不同点-type-可以声明基本类型别名，联合类型，元组等类型-type-语句中还可以使用-typeof-获取实例的-类型进行赋值-interface-能够声明合并"><a href="#不同点-type-可以声明基本类型别名，联合类型，元组等类型-type-语句中还可以使用-typeof-获取实例的-类型进行赋值-interface-能够声明合并" class="headerlink" title="不同点 (type 可以声明基本类型别名，联合类型，元组等类型,type 语句中还可以使用 typeof 获取实例的 类型进行赋值 ,interface 能够声明合并)"></a>不同点 (type 可以声明基本类型别名，联合类型，元组等类型,type 语句中还可以使用 typeof 获取实例的 类型进行赋值 ,interface 能够声明合并)</h4><h5 id="type-可以而-interface-不行"><a href="#type-可以而-interface-不行" class="headerlink" title="type 可以而 interface 不行"></a>type 可以而 interface 不行</h5><p>type 可以声明基本类型别名，联合类型，元组等类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 基本类型别名</span><br><span class="hljs-keyword">type</span> Name = <span class="hljs-keyword">string</span><br><br><span class="hljs-comment">// 联合类型</span><br><span class="hljs-keyword">interface</span> Dog &#123;<br>    wong();<br>&#125;<br><span class="hljs-keyword">interface</span> Cat &#123;<br>    miao();<br>&#125;<br><br><span class="hljs-keyword">type</span> Pet = Dog | Cat<br><br><span class="hljs-comment">// 具体定义数组每个位置的类型</span><br><span class="hljs-keyword">type</span> PetList = [Dog, Pet]<br><br></code></pre></td></tr></table></figure><p>type 语句中还可以使用 typeof 获取实例的 类型进行赋值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 当你想获取一个变量的类型时，使用 typeof</span><br><span class="hljs-keyword">let</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-keyword">type</span> B = <span class="hljs-keyword">typeof</span> div<br></code></pre></td></tr></table></figure><p>其他骚操作</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">StringOrNumber</span> = string | number;  <br><span class="hljs-keyword">type</span> <span class="hljs-type">Text</span> = string | &#123; text: string &#125;;  <br><span class="hljs-keyword">type</span> <span class="hljs-type">NameLookup</span> = <span class="hljs-type">Dictionary</span>&lt;string, <span class="hljs-type">Person</span>&gt;;  <br><span class="hljs-keyword">type</span> <span class="hljs-type">Callback</span>&lt;<span class="hljs-type">T</span>&gt; = (data: <span class="hljs-type">T</span>) =&gt; void;  <br><span class="hljs-keyword">type</span> <span class="hljs-type">Pair</span>&lt;<span class="hljs-type">T</span>&gt; = [<span class="hljs-type">T</span>, <span class="hljs-type">T</span>];  <br><span class="hljs-keyword">type</span> <span class="hljs-type">Coordinates</span> = <span class="hljs-type">Pair</span>&lt;number&gt;;  <br><span class="hljs-keyword">type</span> <span class="hljs-type">Tree</span>&lt;<span class="hljs-type">T</span>&gt; = <span class="hljs-type">T</span> | &#123; left: <span class="hljs-type">Tree</span>&lt;<span class="hljs-type">T</span>&gt;, right: <span class="hljs-type">Tree</span>&lt;<span class="hljs-type">T</span>&gt; &#125;;<br></code></pre></td></tr></table></figure><h5 id="interface-可以而-type-不行"><a href="#interface-可以而-type-不行" class="headerlink" title="interface 可以而 type 不行"></a>interface 可以而 type 不行</h5><p>interface 能够声明合并</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">interface <span class="hljs-keyword">User</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  name</span>: <span class="hljs-keyword">string</span><br>  age: <span class="hljs-keyword">number</span><br>&#125;<br><br>interface <span class="hljs-keyword">User</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  sex</span>: <span class="hljs-keyword">string</span><br>&#125;<br><br>/*<br><span class="hljs-keyword">User</span> <span class="hljs-title">接口为 &#123;</span><br><span class="hljs-title">  name</span>: <span class="hljs-keyword">string</span><br>  age: <span class="hljs-keyword">number</span><br>  sex: <span class="hljs-keyword">string</span><br>&#125;<br>*/<br><br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一般来说，如果不清楚什么时候用interface/type，能用 interface 实现，就用 interface , 如果不能就用 type 。其他更多详情参看 官方规范文档</p><h5 id="转载文章"><a href="#转载文章" class="headerlink" title="转载文章"></a>转载文章</h5><p><a href="https://juejin.cn/post/6844903749501059085">Typescript 中的 interface 和 type 到底有什么区别</a></p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算属性和watch的原理</title>
    <link href="/2022/03/10/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8Ccomputed%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <url>/2022/03/10/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8Ccomputed%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="Watcher是什么？Watcher的种类有哪些？"><a href="#Watcher是什么？Watcher的种类有哪些？" class="headerlink" title="Watcher是什么？Watcher的种类有哪些？"></a>Watcher是什么？Watcher的种类有哪些？</h3><p>大家要注意，这里说的是Watcher，要跟vue里使用的watch属性区分一下哦</p><h4 id="1-什么是Watcher呢？"><a href="#1-什么是Watcher呢？" class="headerlink" title="1.什么是Watcher呢？"></a>1.什么是Watcher呢？</h4><p>举个例子，请看下面代码：</p><p>// 例子代码，与本章代码无关</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span>&gt;&#123;&#123;<span class="hljs-built_in">name</span>&#125;&#125;&lt;/<span class="hljs-keyword">div</span>&gt;<br><br>data() &#123;<br><span class="hljs-built_in">        return</span> &#123;<br>            <span class="hljs-built_in">name</span>: &#x27;林三心&#x27;<br>        &#125;<br>    &#125;,<br>    computed: &#123;<br>        info () &#123;<br><span class="hljs-built_in">            return</span> this.<span class="hljs-built_in">name</span><br>        &#125;<br>    &#125;,<br>    watch: &#123;<br>        <span class="hljs-built_in">name</span>(newVal) &#123;<br>            console.<span class="hljs-built_in">log</span>(newVal)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>上方代码可知，name变量被三处地方所依赖，分别是html里，computed里，watch里。只要name一改变，html里就会重新渲染，computed里就会重新计算，watch里就会重新执行。那么是谁去通知这三个地方name修改了呢？那就是Watcher了</p><h4 id="2-Watcher的种类有哪些呢？"><a href="#2-Watcher的种类有哪些呢？" class="headerlink" title="2.Watcher的种类有哪些呢？"></a>2.Watcher的种类有哪些呢？</h4><p>上面所说的三处地方就刚刚好代表了三种Watcher，分别是：</p><ol><li>渲染Watcher：变量修改时，负责通知HTML里的重新渲染</li><li>computed Watcher：变量修改时，负责通知computed里依赖此变量的computed属性变量的修改</li><li>user Watcher：变量修改时，负责通知watch属性里所对应的变量函数的执行</li></ol><h3 id="Vue–Observer、Dep、Watcher"><a href="#Vue–Observer、Dep、Watcher" class="headerlink" title="Vue–Observer、Dep、Watcher"></a>Vue–Observer、Dep、Watcher</h3><ol><li><p>Observer 将数据定义为响应式，每个 Observer 实例都有自己的 Dep 来管理依赖。实例化 Wacther 的时候进行求值会触发 getter ，进而执行 dep.depend() 将当前 Wacther 加入 Dep 维护的依赖列表，这就是依赖收集过程</p></li><li><p>数据发生变化触发 setter 执行 dep.notify，Dep 会执行所有依赖的 update 方法并加入异步更新队列，这就是触发依赖过程。<br><a href="https://pengzhenglong.github.io/2022/02/25/Vue--Observer%E3%80%81Dep%E3%80%81Watcher/#Dep-%E3%80%8C%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E3%80%8D">博客</a></p></li></ol><h4 id="4-Watcher为何也要反过来收集Dep？"><a href="#4-Watcher为何也要反过来收集Dep？" class="headerlink" title="4.Watcher为何也要反过来收集Dep？"></a>4.Watcher为何也要反过来收集Dep？</h4><p>上面说到了，dep是name的管家，他的职责是：name更新时，dep会带着主人的命令去通知subs里的Watcher去做该做的事，那么，dep收集Watcher很合理。那为什么watcher也需要反过来收集dep呢？</p><blockquote><p>这是因为computed属性里的变量没有自己的dep，也就是他没有自己的管家，看以下例子：</p></blockquote><p>这里先说一个知识点：如果html里不依赖name这个变量，那么无论name再怎么变，他都不会主动去刷新视图，因为html没引用他（说专业点就是：name的dep里没有渲染Watcher），注意，这里说的是不会主动，但这并不代表他不会被动去更新。什么情况下他会被动去更新呢？那就是computed有依赖他的属性变量。</p><p>// 例子代码，与本章代码无关</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">person</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><span class="xml">computed: &#123;</span><br><span class="xml">    person &#123;</span><br><span class="xml">        return `名称：$&#123;this.name&#125;`</span><br><span class="xml">        &#125;</span><br><span class="xml">    &#125;</span><br></code></pre></td></tr></table></figure><p>这里的person事依赖于name的，但是person是没有自己的dep的（因为他是computed属性变量），而name是有的。好了，继续看，请注意，此例子html里只有person的引用没有name的引用，所以name一改变，按理说虽然person跟着变了，但是html不会重新渲染，因为name虽然有dep，有更新视图的能力，但是奈何人家html不引用他啊！person想要自己去更新视图，但他却没这个能力啊，毕竟他没有dep这个管家！这个时候computed Watcher里收集的name的dep就派上用场了，可以借助这些dep去更新视图，达到更新html里的person的效果。具体会在下面computed里实现。</p><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>计算属性实现原理<br>这里还是按照惯例，将定义的computed属性的每一项使用Watcher类进行实例化，不过这里是按照computed-watcher的形式，来看下如何实例化的：</p><p>这里的变量watcher就是之前computed对应的computed-watcher实例，接下来会执行Watcher类专门为计算属性定义的两个方法，在执行evaluate方法进行求值的过程中又会触发computed内可以访问到的响应式数据的get，它们会将当前的computed-watcher作为依赖收集到自己的dep里，计算完毕之后将dirty置为false，表示已经计算过了。<br>然后执行depend让计算属性内的响应式数据订阅当前的render-watcher，所以computed内的响应式数据会收集computed-watcher和render-watcher两个watcher，当computed内的状态发生变更触发set后，首先通知computed需要进行重新计算，然后通知到视图执行渲染，再渲染中会访问到computed计算后的值，最后渲染到页面。</p><p>Ps: 计算属性内的值须是响应式数据才能触发重新计算。</p><blockquote><p>watch总结：为什么计算属性有缓存功能？因为当计算属性经过计算后，内部的标志位会表明已经计算过了，再次访问时会直接读取计算后的值；为什么计算属性内的响应式数据发生变更后，计算属性会重新计算？因为内部的响应式数据会收集computed-watcher，变更后通知计算属性要进行计算，也会通知页面重新渲染，渲染时会读取到重新计算后的值。</p></blockquote><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844903926819454983#heading-6">Vue原理解析（九）：搞懂computed和watch原理，减少使用场景思考时间</a><br><a href="https://juejin.cn/post/6974293549135167495#heading-24">「Vue源码学习(四)」立志写一篇人人都看的懂的computed，watch原理</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何中断已经发出去的请求&amp;&amp;大文件上传处理</title>
    <link href="/2022/03/08/%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    <url>/2022/03/08/%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p>总结了最近的一些面试题和之前的知识点</p><hr><h3 id="Axios-如何取消重复请求？"><a href="#Axios-如何取消重复请求？" class="headerlink" title="Axios 如何取消重复请求？"></a>Axios 如何取消重复请求？</h3><p>在 Web 项目开发过程中，我们经常会遇到重复请求的场景，如果系统不对重复的请求进行处理，则可能会导致系统出现各种问题。比如重复的 post 请求可能会导致服务端产生两笔记录。那么重复请求是如何产生的呢？这里我们举 2 个常见的场景：</p><p>假设页面中有一个按钮，用户点击按钮后会发起一个 AJAX 请求。如果未对该按钮进行控制，当用户快速点击按钮时，则会发出重复请求。<br>假设在考试结果查询页面中，用户可以根据 “已通过”、“未通过” 和 “全部” 3 种查询条件来查询考试结果。如果请求的响应比较慢，当用户在不同的查询条件之前快速切换时，就会产生重复请求。</p><h4 id="一、如何取消请求"><a href="#一、如何取消请求" class="headerlink" title="一、如何取消请求"></a>一、如何取消请求</h4><p>Axios 是一个基于 Promise 的 HTTP 客户端，同时支持浏览器和 Node.js 环境。它是一个优秀的 HTTP 客户端，被广泛地应用在大量的 Web 项目中。对于浏览器环境来说，Axios 底层是利用 XMLHttpRequest 对象来发起 HTTP 请求。如果要取消请求的话，我们可以通过调用<strong> XMLHttpRequest 对象上的 abort 方法</strong>来取消请求：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">let xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>xhr.open(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;https://developer.mozilla.org/&quot;</span>, <span class="hljs-literal">true</span>);<br>xhr.send();<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> xhr.abort(), <span class="hljs-number">300</span>);<br></code></pre></td></tr></table></figure><p>而对于 Axios 来说，我们可以通过 Axios 内部提供的<strong> CancelToken </strong>来取消请求：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle">const CancelToken = axios.CancelToken;<br>const <span class="hljs-keyword">source</span> = CancelToken.<span class="hljs-keyword">source</span>();<br><br>axios.post(<span class="hljs-string">&#x27;/user/12345&#x27;</span>, &#123;<br>  name: <span class="hljs-string">&#x27;semlinker&#x27;</span><br>&#125;, &#123;<br>  cancelToken: <span class="hljs-keyword">source</span>.token<br>&#125;)<br><br><span class="hljs-keyword">source</span>.cancel(<span class="hljs-string">&#x27;Operation canceled by the user.&#x27;</span>); <span class="hljs-comment">// 取消请求，参数是可选的</span><br></code></pre></td></tr></table></figure><p>此外，你也可以通过调用 CancelToken 的构造函数来创建 CancelToken，具体如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> CancelToken = axios.CancelToken;<br><span class="hljs-keyword">let</span> cancel;<br><br>axios.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;/user/12345&#x27;</span>, &#123;<br>  cancelToken: <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function">function <span class="hljs-title">executor</span>(<span class="hljs-params">c</span>)</span> &#123;<br>    cancel = c;<br>  &#125;)<br>&#125;);<br><br>cancel(); <span class="hljs-comment">// 取消请求</span><br></code></pre></td></tr></table></figure><p>现在我们已经知道在 Axios 中如何使用 CancelToken 来取消请求了，那么 CancelToken 内部是如何工作的呢？这里我们先记住这个问题，后面揭开 CancelToken 背后的秘密。接下来，我们来分析一下如何判断重复请求。</p><h4 id="二、如何判断重复请求"><a href="#二、如何判断重复请求" class="headerlink" title="二、如何判断重复请求"></a>二、如何判断重复请求</h4><p>当<strong>请求方式、请求 URL 地址和请求参数都一样时，我们就可以认为请求是一样的</strong>。因此在每次发起请求时，我们就可以根据当前请求的请求方式、请求 URL 地址和请求参数来生成一个唯一的 key，同时为每个请求创建一个专属的 CancelToken，然后把 key 和 cancel 函数以键值对的形式保存到 Map 对象中，使用 Map 的好处是可以快速的判断是否有重复的请求：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">import qs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;qs&#x27;</span><br><br><span class="hljs-keyword">const</span> pendingRequest = <span class="hljs-keyword">new</span> Map();<br><span class="hljs-comment">// GET -&gt; params；POST -&gt; data</span><br><span class="hljs-keyword">const</span> requestKey = [<span class="hljs-function"><span class="hljs-keyword">method</span>, <span class="hljs-title">url</span>, <span class="hljs-title">qs</span>.<span class="hljs-title">stringify</span><span class="hljs-params">(<span class="hljs-keyword">params</span>)</span>, <span class="hljs-title">qs</span>.<span class="hljs-title">stringify</span><span class="hljs-params">(data)</span>].<span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-string">&#x27;&amp;&#x27;</span>)</span>;</span> <br><span class="hljs-keyword">const</span> cancelToken = <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">executor</span><span class="hljs-params">(cancel)</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">  if(!pendingRequest.has(requestKey))&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">    pendingRequest.set(requestKey, cancel);</span></span><br><span class="hljs-function"><span class="hljs-comment">  &#125;</span></span><br><span class="hljs-function">&#125;)</span><br></code></pre></td></tr></table></figure><p>当出现重复请求的时候，我们就可以使用 cancel 函数来取消前面已经发出的请求，在取消请求之后，我们还需要把取消的请求从<strong> pendingRequest</strong> 中移除。现在我们已经知道如何取消请求和如何判断重复请求，下面我们来介绍如何取消重复请求。</p><h4 id="三、如何取消重复请求"><a href="#三、如何取消重复请求" class="headerlink" title="三、如何取消重复请求"></a>三、如何取消重复请求</h4><p>因为我们需要对所有的请求都进行处理，所以我们可以考虑使用 Axios 的拦截器机制来实现取消重复请求的功能。Axios 为开发者提供了请求拦截器和响应拦截器，它们的作用如下：</p><ol><li>请求拦截器：该类拦截器的作用是在请求发送前统一执行某些操作，比如在请求头中添加 token 字段。</li><li>响应拦截器：该类拦截器的作用是在接收到服务器响应后统一执行某些操作，比如发现响应状态码为 401 时，自动跳转到登录页。</li></ol><p><img src="/imageO/Cancle.jpg" alt="流程"></p><h4 id="四、CancelToken-的工作原理"><a href="#四、CancelToken-的工作原理" class="headerlink" title="四、CancelToken 的工作原理"></a>四、CancelToken 的工作原理</h4><p>在前面的示例中，我们是通过调用 CancelToken 构造函数来创建 CancelToken 对象：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> axios.CancelToken(<span class="hljs-function"><span class="hljs-params">(cancel)</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (!pendingRequest.has(requestKey)) &#123;<br>    pendingRequest.set(requestKey, cancel);<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>所以接下来，我们来分析 CancelToken 构造函数，该函数被定义在 lib/cancel/CancelToken.js 文件中：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// lib/cancel/CancelToken.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">CancelToken(<span class="hljs-params">executor</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (typeof executor !== &#x27;<span class="hljs-keyword">function</span>&#x27;) &#123;<br>    throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">TypeError(&#x27;<span class="hljs-params">executor</span> <span class="hljs-params">must</span> <span class="hljs-params">be</span> <span class="hljs-params">a</span> <span class="hljs-params">function</span>.&#x27;)</span>;<br>  &#125;<br><br>  var resolvePromise;<br>  this.promise = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span> <span class="hljs-params">promiseExecutor</span>(<span class="hljs-params">resolve</span>)</span> &#123;<br>    resolvePromise = resolve;<br>  &#125;);<br><br>  var token = this;<br>  executor(<span class="hljs-keyword">function</span> cancel(message) &#123; <span class="hljs-comment">// 设置cancel对象</span><br>    <span class="hljs-keyword">if</span> (token.reason) &#123;<br>      return; <span class="hljs-comment">// Cancellation has already been requested</span><br>    &#125;<br>    token.reason = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Cancel(<span class="hljs-params">message</span>)</span>;<br>    resolve<span class="hljs-constructor">Promise(<span class="hljs-params">token</span>.<span class="hljs-params">reason</span>)</span>;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>由以上代码可知，cancel 对象是一个函数，当我们调用该函数后，会创建 Cancel 对象并调用 resolvePromise 方法。该方法执行后，CancelToken 对象上 promise 属性所指向的 promise 对象的状态将变为 resolved。那么这样做的目的是什么呢？这里我们从 lib/adapters/xhr.js 文件中找到了答案：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> lib<span class="hljs-regexp">/adapters/</span>xhr.js <br><span class="hljs-keyword">if</span> (config.cancelToken) &#123;<br>  config.cancelToken.promise.then(<span class="hljs-keyword">function</span> onCanceled(cancel) &#123;<br>    <span class="hljs-keyword">if</span> (!request) &#123; return; &#125;<br>    request.abort(); <span class="hljs-regexp">//</span> 取消请求<br>    reject(cancel);<br>    request = null;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/imageO/Token.jpg" alt="流程"><br>本文介绍了在 Axios 中如何取消重复请求及 CancelToken 的工作原理，需要注意的是已取消的请求可能已经达到服务端，针对这种情形，服务端的对应接口需要进行幂等控制</p><h4 id="转载文章"><a href="#转载文章" class="headerlink" title="转载文章"></a>转载文章</h4><p><a href="https://juejin.cn/post/6955610207036801031#heading-8">Axios 如何取消重复请求？</a></p><h3 id="前端上传大文件怎么处理"><a href="#前端上传大文件怎么处理" class="headerlink" title="前端上传大文件怎么处理"></a>前端上传大文件怎么处理</h3><p>背景<br>当我们在做文件的导入功能的时候,如果导入的文件过大,可能会导所需要的时间够长,且失败后需要重新上传,我们需要前后端结合的方式解决这个问题</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>我们需要做几件事情如下:</p><ol><li><strong>对文件做切片</strong>,即将一个请求拆分成多个请求，每个请求的时间就会缩短，且如果某个请求失败，只需要重新发送这一次请求即可，无需从头开始</li><li><strong>通知服务器合并切片</strong>,在上传完切片后,前端通知服务器做合并切片操作</li><li><strong>控制多个请求的并发量</strong>,防止多个请求同时发送,造成浏览器内存溢出,导致页面卡死</li><li><strong>做断点续传</strong>,当多个请求中有请求发送失败,例如出现网络故障、页面关闭等,我们得对失败的请求做处理,让它们重复发送</li></ol><h5 id="步骤1-切片-合并切片"><a href="#步骤1-切片-合并切片" class="headerlink" title="步骤1-切片,合并切片"></a>步骤1-切片,合并切片</h5><p>在JavaScript中，<strong>文件FIle对象是Blob对象的子类，Blob对象包含一个重要的方法slice通过这个方法</strong>，我们就可以对二进制文件进行拆分,具体代码如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=s, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.24.0/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fileInput&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uploadBtn&quot;</span>&gt;</span>上传<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-comment">// 请求基准地址</span></span><br><span class="javascript">axios.defaults.baseURL = <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span></span><br><span class="javascript"><span class="hljs-comment">// 选中的文件</span></span><br><span class="javascript"><span class="hljs-keyword">var</span> file = <span class="hljs-literal">null</span></span><br><span class="javascript"><span class="hljs-comment">// 选择文件</span></span><br><span class="javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;fileInput&#x27;</span>).onchange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">&#123;target: &#123;files&#125;&#125;</span>)</span>&#123;</span><br>    file = files[0]<br>&#125;<br><span class="javascript"><span class="hljs-comment">// 开始上传</span></span><br><span class="javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;uploadBtn&#x27;</span>).onclick = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">if</span> (!file) <span class="hljs-keyword">return</span></span><br><span class="javascript">    <span class="hljs-comment">// 创建切片</span></span><br><span class="javascript">    <span class="hljs-comment">// let size = 1024 *1024* 10 //10MB 切片大小</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> size = <span class="hljs-number">1024</span> *<span class="hljs-number">50</span>  <span class="hljs-comment">//50KB 切片大小</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> fileChunks = []</span><br><span class="javascript">    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span> <span class="hljs-comment">//切片序号</span></span><br><span class="javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> cur = <span class="hljs-number">0</span>; cur &lt; file.size; cur += size)&#123;</span><br>        fileChunks.push(&#123;<br>            hash: index++,<br>            chunk: file.slice(cur, cur + size)<br>        &#125;)<br>    &#125;<br><span class="javascript">    <span class="hljs-comment">// 上传切片</span></span><br><span class="javascript">    <span class="hljs-keyword">const</span> uploadList = fileChunks.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> formData = <span class="hljs-keyword">new</span> FormData()</span><br><span class="javascript">        formData.append(<span class="hljs-string">&#x27;filename&#x27;</span>, file.name)</span><br><span class="javascript">        formData.append(<span class="hljs-string">&#x27;hash&#x27;</span>, item.hash)</span><br><span class="javascript">        formData.append(<span class="hljs-string">&#x27;chunk&#x27;</span>, item.chunk)</span><br><span class="javascript">        <span class="hljs-keyword">return</span> axios(&#123;</span><br><span class="javascript">            method: <span class="hljs-string">&#x27;post&#x27;</span>,</span><br><span class="javascript">            url: <span class="hljs-string">&#x27;/upload&#x27;</span>,</span><br>            data: formData<br>        &#125;)<br>    &#125;)<br><span class="javascript">    <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(uploadList)</span><br><span class="javascript">    <span class="hljs-comment">// 合并切片</span></span><br><span class="javascript">    <span class="hljs-keyword">await</span> axios(&#123;</span><br><span class="javascript">        method: <span class="hljs-string">&#x27;get&#x27;</span>,</span><br><span class="javascript">        url: <span class="hljs-string">&#x27;/merge&#x27;</span>,</span><br>        params: &#123;<br>            filename: file.name<br>        &#125;<br>    &#125;);<br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;上传完成&#x27;</span>)</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="步骤2-并发控制"><a href="#步骤2-并发控制" class="headerlink" title="步骤2-并发控制"></a>步骤2-并发控制</h5><p>结合<strong>Promise.race和异步函数</strong>实现,多个请求同时并发的数量,防止浏览器内存溢出,具体代码如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=s, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.24.0/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fileInput&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uploadBtn&quot;</span>&gt;</span>上传<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-comment">// 请求基准地址</span></span><br><span class="javascript">axios.defaults.baseURL = <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span></span><br><span class="javascript"><span class="hljs-comment">// 选中的文件</span></span><br><span class="javascript"><span class="hljs-keyword">var</span> file = <span class="hljs-literal">null</span></span><br><span class="javascript"><span class="hljs-comment">// 选择文件</span></span><br><span class="javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;fileInput&#x27;</span>).onchange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">&#123;target: &#123;files&#125;&#125;</span>)</span>&#123;</span><br>    file = files[0]<br>&#125;<br><span class="javascript"><span class="hljs-comment">// 开始上传</span></span><br><span class="javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;uploadBtn&#x27;</span>).onclick = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">if</span> (!file) <span class="hljs-keyword">return</span></span><br><span class="javascript">    <span class="hljs-comment">// 创建切片</span></span><br><span class="javascript"><span class="hljs-comment">// let size = 1024*1024*10; //10MB 切片大小</span></span><br><span class="javascript"><span class="hljs-keyword">let</span> size = <span class="hljs-number">1024</span>*<span class="hljs-number">50</span> <span class="hljs-comment">//50KB 切片大小</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> fileChunks = []</span><br><span class="javascript">    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span> <span class="hljs-comment">//切片序号</span></span><br><span class="javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> cur = <span class="hljs-number">0</span>; cur &lt; file.size; cur += size)&#123;</span><br>        fileChunks.push(&#123;<br>            hash: index++,<br>            chunk: file.slice(cur, cur + size)<br>        &#125;);<br>    &#125;<br><span class="javascript">    <span class="hljs-comment">// 控制并发</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> pool = []<span class="hljs-comment">//并发池</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> max = <span class="hljs-number">3</span> <span class="hljs-comment">//最大并发量</span></span><br><span class="javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;fileChunks.length;i++)&#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> item = fileChunks[i]</span><br><span class="javascript">        <span class="hljs-keyword">let</span> formData = <span class="hljs-keyword">new</span> FormData()</span><br><span class="javascript">        formData.append(<span class="hljs-string">&#x27;filename&#x27;</span>, file.name)</span><br><span class="javascript">        formData.append(<span class="hljs-string">&#x27;hash&#x27;</span>, item.hash)</span><br><span class="javascript">        formData.append(<span class="hljs-string">&#x27;chunk&#x27;</span>, item.chunk)</span><br><span class="javascript">        <span class="hljs-comment">// 上传切片</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> task = axios(&#123;</span><br><span class="javascript">            method: <span class="hljs-string">&#x27;post&#x27;</span>,</span><br><span class="javascript">            url: <span class="hljs-string">&#x27;/upload&#x27;</span>,</span><br>            data: formData<br>        &#125;)<br><span class="javascript">        task.then(<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span>&#123;</span><br><span class="javascript">            <span class="hljs-comment">//请求结束后将该Promise任务从并发池中移除</span></span><br><span class="javascript">            <span class="hljs-keyword">let</span> index = pool.findIndex(<span class="hljs-function"><span class="hljs-params">t</span>=&gt;</span> t===task)</span><br>            pool.splice(index)<br>        &#125;)<br>        pool.push(task)<br>        if(pool.length === max)&#123;<br><span class="javascript">            <span class="hljs-comment">//每当并发池跑完一个任务，就再塞入一个任务</span></span><br><span class="javascript">            <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.race(pool)</span><br>        &#125;<br>    &#125;<br><span class="javascript">    <span class="hljs-comment">//所有任务完成,合并切片</span></span><br><span class="javascript">    <span class="hljs-keyword">await</span> axios(&#123;</span><br><span class="javascript">        method: <span class="hljs-string">&#x27;get&#x27;</span>,</span><br><span class="javascript">        url: <span class="hljs-string">&#x27;/merge&#x27;</span>,</span><br>        params: &#123;<br>            filename: file.name<br>        &#125;<br>    &#125;);<br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;上传完成&#x27;</span>)</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="步骤3-断点续传"><a href="#步骤3-断点续传" class="headerlink" title="步骤3-断点续传"></a>步骤3-断点续传</h5><p>在单个请求失败后,触发<strong>catch</strong>的方法的时候,讲当前请求放到失败列表中,在本轮请求完成后,重复对失败请求做处理,具体代码如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=s, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.24.0/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fileInput&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;uploadBtn&quot;</span>&gt;</span>上传<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-comment">// 请求基准地址</span></span><br><span class="javascript">axios.defaults.baseURL = <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span></span><br><span class="javascript"><span class="hljs-comment">// 选中的文件</span></span><br><span class="javascript"><span class="hljs-keyword">var</span> file = <span class="hljs-literal">null</span></span><br><span class="javascript"><span class="hljs-comment">// 选择文件</span></span><br><span class="javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;fileInput&#x27;</span>).onchange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">&#123;target: &#123;files&#125;&#125;</span>)</span>&#123;</span><br>    file = files[0]<br>&#125;<br><span class="javascript"><span class="hljs-comment">// 开始上传</span></span><br><span class="javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;uploadBtn&#x27;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">if</span> (!file) <span class="hljs-keyword">return</span>;</span><br><span class="javascript">    <span class="hljs-comment">// 创建切片</span></span><br><span class="javascript"><span class="hljs-comment">// let size = 1024*1024*10; //10MB 切片大小</span></span><br><span class="javascript"><span class="hljs-keyword">let</span> size = <span class="hljs-number">1024</span>* <span class="hljs-number">50</span>; <span class="hljs-comment">//50KB 切片大小</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> fileChunks = [];</span><br><span class="javascript">    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span> <span class="hljs-comment">//切片序号</span></span><br><span class="javascript">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> cur = <span class="hljs-number">0</span>; cur &lt; file.size; cur += size)&#123;</span><br>        fileChunks.push(&#123;<br>            hash: index++,<br>            chunk: file.slice(cur, cur + size)<br>        &#125;)<br>    &#125;<br><span class="javascript">    <span class="hljs-comment">// 控制并发和断点续传</span></span><br><span class="javascript">    <span class="hljs-keyword">const</span> uploadFileChunks = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">list</span>)</span>&#123;</span><br>        if(list.length === 0)&#123;<br><span class="javascript">            <span class="hljs-comment">//所有任务完成,合并切片</span></span><br><span class="javascript">            <span class="hljs-keyword">await</span> axios(&#123;</span><br><span class="javascript">                method: <span class="hljs-string">&#x27;get&#x27;</span>,</span><br><span class="javascript">                url: <span class="hljs-string">&#x27;/merge&#x27;</span>,</span><br>                params: &#123;<br>                    filename: file.name<br>                &#125;<br>            &#125;);<br><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;上传完成&#x27;</span>)</span><br><span class="javascript">            <span class="hljs-keyword">return</span></span><br>        &#125;<br><span class="javascript">        <span class="hljs-keyword">let</span> pool = []<span class="hljs-comment">//并发池</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> max = <span class="hljs-number">3</span> <span class="hljs-comment">//最大并发量</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> finish = <span class="hljs-number">0</span><span class="hljs-comment">//完成的数量</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> failList = []<span class="hljs-comment">//失败的列表</span></span><br><span class="javascript">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;list.length;i++)&#123;</span><br><span class="javascript">            <span class="hljs-keyword">let</span> item = list[i]</span><br><span class="javascript">            <span class="hljs-keyword">let</span> formData = <span class="hljs-keyword">new</span> FormData()</span><br><span class="javascript">            formData.append(<span class="hljs-string">&#x27;filename&#x27;</span>, file.name)</span><br><span class="javascript">            formData.append(<span class="hljs-string">&#x27;hash&#x27;</span>, item.hash)</span><br><span class="javascript">            formData.append(<span class="hljs-string">&#x27;chunk&#x27;</span>, item.chunk)</span><br><span class="javascript">            <span class="hljs-comment">// 上传切片</span></span><br><span class="javascript">            <span class="hljs-keyword">let</span> task = axios(&#123;</span><br><span class="javascript">                method: <span class="hljs-string">&#x27;post&#x27;</span>,</span><br><span class="javascript">                url: <span class="hljs-string">&#x27;/upload&#x27;</span>,</span><br>                data: formData<br>            &#125;)<br><span class="javascript">            task.then(<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span>&#123;</span><br><span class="javascript">                <span class="hljs-comment">//请求结束后将该Promise任务从并发池中移除</span></span><br><span class="javascript">                <span class="hljs-keyword">let</span> index = pool.findIndex(<span class="hljs-function"><span class="hljs-params">t</span>=&gt;</span> t===task)</span><br>                pool.splice(index)<br><span class="javascript">            &#125;).catch(<span class="hljs-function">()=&gt;</span>&#123;</span><br>                failList.push(item)<br><span class="javascript">            &#125;).finally(<span class="hljs-function">()=&gt;</span>&#123;</span><br>                finish++<br><span class="javascript">                <span class="hljs-comment">//所有请求都请求完成</span></span><br>                if(finish===list.length)&#123;<br>                    uploadFileChunks(failList)<br>                &#125;<br>            &#125;)<br>            pool.push(task)<br>            if(pool.length === max)&#123;<br><span class="javascript">                <span class="hljs-comment">//每当并发池跑完一个任务，就再塞入一个任务</span></span><br><span class="javascript">                <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.race(pool)</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    uploadFileChunks(fileChunks)<br><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h4><h5 id="步骤1-安装依赖"><a href="#步骤1-安装依赖" class="headerlink" title="步骤1.安装依赖"></a>步骤1.安装依赖</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> i express@<span class="hljs-number">4</span>.<span class="hljs-number">17</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">npm</span> i multiparty@<span class="hljs-number">4</span>.<span class="hljs-number">2</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h6 id="步骤2-接口实现"><a href="#步骤2-接口实现" class="headerlink" title="步骤2.接口实现"></a>步骤2.接口实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> multiparty = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;multiparty&#x27;</span>)<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> &#123; Buffer &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;buffer&#x27;</span>)<br><span class="hljs-comment">// 上传文件最终路径</span><br><span class="hljs-keyword">const</span> STATIC_FILES = path.join(__dirname, <span class="hljs-string">&#x27;./static/files&#x27;</span>)<br><span class="hljs-comment">// 上传文件临时路径</span><br><span class="hljs-keyword">const</span> STATIC_TEMPORARY = path.join(__dirname, <span class="hljs-string">&#x27;./static/temporary&#x27;</span>)<br><span class="hljs-keyword">const</span> server = express()<br><span class="hljs-comment">// 静态文件托管</span><br>server.use(express.static(path.join(__dirname, <span class="hljs-string">&#x27;./dist&#x27;</span>)))<br><span class="hljs-comment">// 切片上传的接口</span><br>server.post(<span class="hljs-string">&#x27;/upload&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> form = <span class="hljs-keyword">new</span> multiparty.Form();<br>    form.parse(req, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, fields, files</span>) </span>&#123;<br>        <span class="hljs-keyword">let</span> filename = fields.filename[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">let</span> hash = fields.hash[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">let</span> chunk = files.chunk[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">let</span> dir = <span class="hljs-string">`<span class="hljs-subst">$&#123;STATIC_TEMPORARY&#125;</span>/<span class="hljs-subst">$&#123;filename&#125;</span>`</span><br>        <span class="hljs-comment">// console.log(filename, hash, chunk)</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (!fs.existsSync(dir)) fs.mkdirSync(dir)<br>            <span class="hljs-keyword">const</span> buffer = fs.readFileSync(chunk.path)<br>            <span class="hljs-keyword">const</span> ws = fs.createWriteStream(<span class="hljs-string">`<span class="hljs-subst">$&#123;dir&#125;</span>/<span class="hljs-subst">$&#123;hash&#125;</span>`</span>)<br>            ws.write(buffer)<br>            ws.close()<br>            res.send(<span class="hljs-string">`<span class="hljs-subst">$&#123;filename&#125;</span>-<span class="hljs-subst">$&#123;hash&#125;</span> 切片上传成功`</span>)<br>        &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>            <span class="hljs-built_in">console</span>.error(error)<br>            res.status(<span class="hljs-number">500</span>).send(<span class="hljs-string">`<span class="hljs-subst">$&#123;filename&#125;</span>-<span class="hljs-subst">$&#123;hash&#125;</span> 切片上传失败`</span>)<br>        &#125;<br>    &#125;)<br>&#125;)<br><span class="hljs-comment">//合并切片接口</span><br>server.get(<span class="hljs-string">&#x27;/merge&#x27;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> &#123; filename &#125; = req.query<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">const</span> bufferList = fs.readdirSync(<span class="hljs-string">`<span class="hljs-subst">$&#123;STATIC_TEMPORARY&#125;</span>/<span class="hljs-subst">$&#123;filename&#125;</span>`</span>).map(<span class="hljs-function">(<span class="hljs-params">hash,index</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">const</span> buffer = fs.readFileSync(<span class="hljs-string">`<span class="hljs-subst">$&#123;STATIC_TEMPORARY&#125;</span>/<span class="hljs-subst">$&#123;filename&#125;</span>/<span class="hljs-subst">$&#123;index&#125;</span>`</span>)<br>            len += buffer.length<br>            <span class="hljs-keyword">return</span> buffer<br>        &#125;);<br>        <span class="hljs-comment">//合并文件</span><br>        <span class="hljs-keyword">const</span> buffer = Buffer.concat(bufferList, len);<br>        <span class="hljs-keyword">const</span> ws = fs.createWriteStream(<span class="hljs-string">`<span class="hljs-subst">$&#123;STATIC_FILES&#125;</span>/<span class="hljs-subst">$&#123;filename&#125;</span>`</span>)<br>        ws.write(buffer);<br>        ws.close();<br>        res.send(<span class="hljs-string">`切片合并完成`</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-built_in">console</span>.error(error);<br>    &#125;<br>&#125;)<br><br>server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;http://localhost:3000/&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h5><p>如果使用腾讯云或阿里云文件上传的服务,它们提供了npm库,例如腾讯云的cos-js-sdk-v5,它自身提供的切片相关的配置</p><h5 id="转载文章-1"><a href="#转载文章-1" class="headerlink" title="转载文章"></a>转载文章</h5><p><a href="https://juejin.cn/post/7053658552472174605#heading-7">前端上传大文件怎么处理</a></p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Object.defineProperty和Proxy，Vue3.0为什么采用Proxy？</title>
    <link href="/2022/03/07/defineproPerty&amp;&amp;proxy/"/>
    <url>/2022/03/07/defineproPerty&amp;&amp;proxy/</url>
    
    <content type="html"><![CDATA[<p>Vue3.0 中，响应式数据部分弃用了 Object.defineProperty，使用Proxy来代替它。本文将主要通过以下三个方面来分析为什么 Vue 选择弃用 Object.defineProperty。</p><ol><li>Object.defineProperty 真的无法监测数组下标的变化吗？</li><li>分析 Vue2.x 中对数组 Observe 部分源码。</li><li>对比Object.defineProperty和 Proxy。</li></ol><hr><h3 id="无法监控到数组下标的变化？"><a href="#无法监控到数组下标的变化？" class="headerlink" title="无法监控到数组下标的变化？"></a>无法监控到数组下标的变化？</h3><p>在一些技术博客上，我看到过这样一种说法，认为 Object.defineProperty 有一个缺陷是无法监听数组变化：</p><p>无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。所以 Vue 才设置了 7 个变异数组（push、pop、shift、unshift、splice、sort、reverse）的 hack 方法来解决问题。</p><p>Object.defineProperty的第一个缺陷是无法监听数组变化。然而 Vue 的文档提到了 Vue 是可以检测到数组变化的，但是只有以下八种方法，vm.items[indexOfItem] = newValue 这种是无法检测的。</p><blockquote><p>这种说法是有问题的，事实上，Object.defineProperty 本身是可以监控到数组下标的变化的，只是在 Vue 的实现中，从性能 / 体验的性价比考虑，放弃了这个特性。<br>下面我们通过一个例子来为 Object.defineProperty 正名：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">data, key, value</span>) </span>&#123;<br>  <span class="hljs-built_in">Object</span>.defineProperty(data, key, &#123;<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>     get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineGet</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`get key: <span class="hljs-subst">$&#123;key&#125;</span> value: <span class="hljs-subst">$&#123;value&#125;</span>`</span>)<br>      <span class="hljs-keyword">return</span> value<br>    &#125;,<br>     set: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineSet</span>(<span class="hljs-params">newVal</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`set key: <span class="hljs-subst">$&#123;key&#125;</span> value: <span class="hljs-subst">$&#123;newVal&#125;</span>`</span>)<br>      value = newVal<br>    &#125;<br>  &#125;)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span>(<span class="hljs-params">data</span>) </span>&#123;<br>  <span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>&#123;<br>    defineReactive(data, key, data[key])<br>  &#125;)<br>&#125;<br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>observe(arr)<br></code></pre></td></tr></table></figure><p>上面的代码对数组 arr 的每个属性通过 Object.defineProperty 进行劫持，下面我们对数组 arr 进行操作，看看哪些行为会触发数组的 getter 和 setter 方法。</p><ol><li>通过下标获取某个元素和修改某个元素的值</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">arr</span>[<span class="hljs-number">1</span>]<br><span class="hljs-attribute">6</span> get key: <span class="hljs-number">1</span> value: <span class="hljs-number">2</span><br><span class="hljs-attribute">2</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">1</span>]=<span class="hljs-number">5</span><br><span class="hljs-attribute">10</span> set key: <span class="hljs-number">1</span> value: <span class="hljs-number">5</span><br><span class="hljs-attribute">5</span><br></code></pre></td></tr></table></figure><p>可以看到，通过下标获取某个元素会触发 getter 方法, 设置某个值会触发 setter 方法。</p><p>接下来，我们再试一下数组的一些操作方法，看看是否会触发。</p><ol start="2"><li>数组的 push 方法</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">arr</span>.push(<span class="hljs-number">4</span>)<br><span class="hljs-attribute">4</span><br></code></pre></td></tr></table></figure><p>push 并未触发 setter 和 getter方法，数组的下标可以看做是对象中的 key ，这里 push 之后相当于增加了下索引为 3 的元素，但是并未对新的下标进行 observe ，所以不会触发。<br>3. 数组的 unshift 方法</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">arr</span>.unshift(<span class="hljs-number">0</span>)<br><span class="hljs-attribute">get</span> key: <span class="hljs-number">2</span> value: <span class="hljs-number">3</span><br><span class="hljs-attribute">get</span> key: <span class="hljs-number">1</span> value: <span class="hljs-number">5</span><br><span class="hljs-attribute">set</span> key: <span class="hljs-number">2</span> value: <span class="hljs-number">5</span><br><span class="hljs-attribute">get</span> key: <span class="hljs-number">0</span> value: <span class="hljs-number">1</span><br><span class="hljs-attribute">set</span> key: <span class="hljs-number">1</span> value: <span class="hljs-number">1</span><br><span class="hljs-attribute">set</span> key: <span class="hljs-number">0</span> value: <span class="hljs-number">0</span><br><span class="hljs-attribute">5</span><br></code></pre></td></tr></table></figure><p>我擦，发生了什么？</p><p>unshift 操作会导致原来索引为 0、1、2、3 的值发生变化，这就需要将原来索引为 0、1、2、3 的值取出来，然后重新赋值，所以取值的过程触发了 getter ，赋值时触发了 setter 。</p><p>下面我们尝试通过索引获取一下对应的元素：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">arr</span>[<span class="hljs-number">0</span>]<br> <span class="hljs-attribute">get</span> key: <span class="hljs-number">0</span> value: <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">1</span>]<br> <span class="hljs-attribute">get</span> key: <span class="hljs-number">1</span> value: <span class="hljs-number">1</span><br><span class="hljs-attribute">1</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">2</span>]<br> <span class="hljs-attribute">get</span> key: <span class="hljs-number">2</span> value: <span class="hljs-number">5</span><br><span class="hljs-attribute">5</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">3</span>]<br><span class="hljs-attribute">3</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">4</span>]<br><span class="hljs-attribute">4</span><br></code></pre></td></tr></table></figure><p>只有索引为 0、1、2 的属性才会触发 getter 。</p><p>这里我们可以对比对象来看，arr 数组初始值为 [1, 2, 3]，即只对索引为 0，1，2 执行了 observe 方法，所以无论后来数组的长度发生怎样的变化，依然只有索引为 0、1、2 的元素发生变化才会触发。<strong>其他的新增索引，就相当于对象中新增的属性，需要再手动 observe 才可以。</strong><br>4. 数组的 pop 方法</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs maxima">arr.<span class="hljs-built_in">pop</span>()<br><span class="hljs-number">4</span><br>arr.<span class="hljs-built_in">pop</span>()<br><span class="hljs-number">3</span><br>arr.<span class="hljs-built_in">pop</span>()<br> <span class="hljs-built_in">get</span> <span class="hljs-built_in">key</span>: <span class="hljs-number">2</span> value: <span class="hljs-number">5</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>当移除的元素为引用为 2 的元素时，会触发 getter 。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">arr</span>[<span class="hljs-number">2</span>]<br><span class="hljs-attribute">undefined</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">2</span>]=<span class="hljs-number">3</span><br><span class="hljs-attribute">3</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">2</span>]<br><span class="hljs-attribute">3</span><br></code></pre></td></tr></table></figure><p>删除了索引为 2 的元素后，再去修改或获取它的值时，不会再触发 setter 和 getter 。</p><p>这和对象的处理是同样的，数组的索引被删除后，就相当于对象的属性被删除一样，不会再去触发 observe。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Object.defineProperty 在数组中的表现和在对象中的表现是一致的，数组的索引就可以看做是对象中的 key。</p><ol><li>通过索引访问或设置对应元素的值时，可以触发 getter 和 setter 方法。</li><li>通过 push 或 unshift 会增加索引，对于新增加的属性，需要再手动初始化才能被 observe。</li><li>通过 pop 或 shift 删除元素，会删除并更新索引，也会触发 setter 和 getter 方法。</li></ol><p>所以，Object.defineProperty是有监控数组下标变化的能力的，只是 Vue2.x 放弃了这个特性。</p><h3 id="Vue-对数组的-observe-做了哪些处理？"><a href="#Vue-对数组的-observe-做了哪些处理？" class="headerlink" title="Vue 对数组的 observe 做了哪些处理？"></a>Vue 对数组的 observe 做了哪些处理？</h3><p>Vue 的 Observer 类定义在 core/observer/index.js 中。<br><img src="/imageO/Observer.png" alt="Observer"><br>可以看到，Vue 的 Observer 对数组做了单独的处理。<br>hasProto 判断数组的实例是否有 proto 属性，如果有 proto 属性就会执行 protoAugment 方法，将 arrayMethods 重写到原型上。hasProto 的定义如下：<br><img src="/imageO/Observer1.png" alt="Observer"><br>arrayMethods 是对数组的方法进行重写，定义在 core/observer/array.js 中，下面是这部分源码的分析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * not type checking this file because flow doesn&#x27;t play well with</span><br><span class="hljs-comment"> * dynamically accessing methods on Array prototype</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> &#123; def &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../util/index&#x27;</span><br><span class="hljs-comment">// 复制数组构造函数的原型，Array.prototype 也是一个数组。</span><br><span class="hljs-keyword">const</span> arrayProto = <span class="hljs-built_in">Array</span>.prototype<br><span class="hljs-comment">// 创建对象，对象的 __proto__ 指向 arrayProto，所以 arrayMethods 的 __proto__ 包含数组的所有方法。</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> arrayMethods = <span class="hljs-built_in">Object</span>.create(arrayProto)<br><span class="hljs-comment">// 下面的数组是要进行重写的方法</span><br><span class="hljs-keyword">const</span> methodsToPatch = [<br>  <span class="hljs-string">&#x27;push&#x27;</span>,<br>  <span class="hljs-string">&#x27;pop&#x27;</span>,<br>  <span class="hljs-string">&#x27;shift&#x27;</span>,<br>  <span class="hljs-string">&#x27;unshift&#x27;</span>,<br>  <span class="hljs-string">&#x27;splice&#x27;</span>,<br>  <span class="hljs-string">&#x27;sort&#x27;</span>,<br>  <span class="hljs-string">&#x27;reverse&#x27;</span><br>]<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Intercept mutating methods and emit events</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 遍历 methodsToPatch 数组，对其中的方法进行重写</span><br>methodsToPatch.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>&#123;<br>  <span class="hljs-comment">// cache original method</span><br>  <span class="hljs-keyword">const</span> original = arrayProto[method]<br>  <span class="hljs-comment">// def 方法定义在 lang.js 文件中，是通过 object.defineProperty 对属性进行重新定义。</span><br>  <span class="hljs-comment">// 即在 arrayMethods 中找到我们要重写的方法，对其进行重新定义</span><br>  def(arrayMethods, method, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mutator</span> (<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> result = original.apply(<span class="hljs-built_in">this</span>, args)<br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-built_in">this</span>.__ob__<br>    <span class="hljs-keyword">let</span> inserted<br>    <span class="hljs-keyword">switch</span> (method) &#123;<br>      <span class="hljs-comment">// 上面已经分析过，对于 push，unshift 会新增索引，所以需要手动 observe</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;push&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;unshift&#x27;</span>:<br>        inserted = args<br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-comment">// splice 方法，如果传入了第三个参数，也会有新增索引，所以也需要手动 observe</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;splice&#x27;</span>:<br>        inserted = args.slice(<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>    <span class="hljs-comment">// push，unshift，splice 三个方法触发后，在这里手动 observe，其他方法的变更会在当前的索引上进行更新，所以不需要再执行 ob.observeArray</span><br>    <span class="hljs-keyword">if</span> (inserted) ob.observeArray(inserted)<br>    <span class="hljs-comment">// notify change</span><br>    ob.dep.notify()<br>    <span class="hljs-keyword">return</span> result<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="Object-defineProperty-VS-Proxy-重点"><a href="#Object-defineProperty-VS-Proxy-重点" class="headerlink" title="Object.defineProperty VS Proxy(重点)"></a>Object.defineProperty VS Proxy(重点)</h3><p>上面已经知道 Object.defineProperty 对数组和对象的表现是一致的，那么它和 Proxy 对比存在哪些优缺点呢？</p><ol><li>Object.defineProperty <strong>只能劫持对象的属性，而 Proxy 是直接代理对象。</strong></li></ol><p>由于 Object.defineProperty 只能对属性进行劫持，需要遍历对象的每个属性，如果属性值也是对象，则需要深度遍历。而 Proxy 直接代理对象，不需要遍历操作。</p><ol start="2"><li>Object.defineProperty <strong>对新增属性需要手动进行 Observe。</strong></li></ol><p>由于 Object.defineProperty 劫持的是对象的属性，所以新增属性时，需要重新遍历对象，对其新增属性再使用 Object.defineProperty 进行劫持。</p><p>也正是因为这个原因，使用 Vue 给 data 中的数组或对象新增属性时，需要使用 vm.$set 才能保证新增的属性也是响应式的。</p><p>下面看一下 Vue 的 set 方法是如何实现的，set 方法定义在 core/observer/index.js ，下面是核心代码。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Set a property on an object. Adds the new property and</span><br><span class="hljs-comment"> * triggers change notification if the property doesn&#x27;t</span><br><span class="hljs-comment"> * already exist.</span><br><span class="hljs-comment"> */</span><br>export function <span class="hljs-built_in">set</span> (target: <span class="hljs-keyword">Array</span>&lt;any&gt; | <span class="hljs-keyword">Object</span>, <span class="hljs-built_in">key</span>: any, val: any): any &#123;<br>  <span class="hljs-comment">// 如果 target 是数组，且 key 是有效的数组索引，会调用数组的 splice 方法，</span><br>  <span class="hljs-comment">// 我们上面说过，数组的 splice 方法会被重写，重写的方法中会手动 Observe</span><br>  <span class="hljs-comment">// 所以 vue 的 set 方法，对于数组，就是直接调用重写 splice 方法</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(<span class="hljs-built_in">key</span>)) &#123;<br>    target.length = Math.<span class="hljs-built_in">max</span>(target.length, <span class="hljs-built_in">key</span>)<br>    target.<span class="hljs-built_in">splice</span>(<span class="hljs-built_in">key</span>, <span class="hljs-number">1</span>, val)<br>    <span class="hljs-keyword">return</span> val<br>  &#125;<br>  <span class="hljs-comment">// 对于对象，如果 key 本来就是对象中的属性，直接修改值就可以触发更新</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span> in target &amp;&amp; !(<span class="hljs-built_in">key</span> in <span class="hljs-keyword">Object</span>.prototype)) &#123;<br>    target[<span class="hljs-built_in">key</span>] = val<br>    <span class="hljs-keyword">return</span> val<br>  &#125;<br>  <span class="hljs-comment">// vue 的响应式对象中都会添加了 __ob__ 属性，所以可以根据是否有 __ob__ 属性判断是否为响应式对象</span><br>  <span class="hljs-keyword">const</span> ob = (target: any).__ob__<br>  <span class="hljs-comment">// 如果不是响应式对象，直接赋值</span><br>  <span class="hljs-keyword">if</span> (!ob) &#123;<br>    target[<span class="hljs-built_in">key</span>] = val<br>    <span class="hljs-keyword">return</span> val<br>  &#125;<br>  <span class="hljs-comment">// 调用 defineReactive 给数据添加了 getter 和 setter，</span><br>  <span class="hljs-comment">// 所以 vue 的 set 方法，对于响应式的对象，就会调用 defineReactive 重新定义响应式对象，defineReactive 函数</span><br>  defineReactive(ob.value, <span class="hljs-built_in">key</span>, val)<br>  ob.dep.notify()<br>  <span class="hljs-keyword">return</span> val<br>&#125;<br></code></pre></td></tr></table></figure><p>在 set 方法中，对 target 是数组和对象分别做了处理。target 是数组时，会调用重写过的 splice 方法进行手动 Observe 。</p><p>对于对象，如果 key 本来就是对象的属性，则直接修改值触发更新，否则调用 defineReactive 方法重新定义响应式对象。</p><p>如果采用 proxy 实现，Proxy 通过 set(target, propKey, value, receiver) 拦截对象属性的设置，是可以拦截到对象的新增属性的。<br>不止如此，Proxy 对数组的方法也可以监测到，不需要像上面 vue2.x 源码中那样进行 hack。</p><ol start="3"><li>Proxy支持 13 种拦截操作，这是 defineProperty 所不具有的。</li></ol><p>get(target, propKey, receiver)：拦截对象属性的读取，比如 proxy.foo 和proxy[‘foo’]。<br>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v 或 proxy[‘foo’] = v，返回一个布尔值。<br>has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值。<br>deleteProperty(target, propKey)：拦截 delete proxy[propKey] 的操作，返回一个布尔值。<br>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys() 的返回结果仅包括目标对象自身的可遍历属性。<br>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。<br>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。<br>preventExtensions(target)：拦截 Object.preventExtensions(proxy)，返回一个布尔值。<br>getPrototypeOf(target)：拦截 Object.getPrototypeOf(proxy)，返回一个对象。<br>isExtensible(target)：拦截 Object.isExtensible(proxy)，返回一个布尔值。<br>setPrototypeOf(target, proto)：拦截 Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。<br>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。<br>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</p><ol start="4"><li>新标准性能红利</li></ol><p>Proxy 作为新标准，从长远来看，JS 引擎会继续优化 Proxy，但 getter 和 setter 基本不会再有针对性优化。<br>5. Proxy 兼容性差<br>可以看到，Proxy 对于 IE 浏览器来说简直是灾难。</p><p>并且目前并没有一个完整支持 Proxy 所有拦截方法的 Polyfill 方案，有一个 Google 编写的 proxy-polyfill 也只支持了 get、set、apply、construct 四种拦截，可以支持到 IE9+ 和 Safari 6+。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>Object.defineProperty 并非不能监控数组下标的变化，Vue2.x 中无法通过数组索引来实现响应式数据的自动更新是 Vue 本身的设计导致的，不是 defineProperty 的锅。</li><li>Object.defineProperty 和 Proxy 本质差别是，defineProperty 只能对属性进行劫持，所以出现了需要递归遍历，新增属性需要手动 Observe 的问题。</li><li>Proxy 作为新标准，浏览器厂商势必会对其进行持续优化，但它的兼容性也是块硬伤，并且目前还没有完整的 polyfill 方案。</li></ol><h4 id="转载文章"><a href="#转载文章" class="headerlink" title="转载文章"></a>转载文章</h4><p><a href="https://mp.weixin.qq.com/s/O8iL4o8oPpqTm4URRveOIA">为什么Vue3.0不再使用defineProperty实现数据监听？</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http1.0，http1.1，http2，http3</title>
    <link href="/2022/03/06/Http/"/>
    <url>/2022/03/06/Http/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="http1-0"><a href="#http1-0" class="headerlink" title="http1.0"></a>http1.0</h3><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上,是一种<strong>无状态、无连接</strong>的应用层协议，几年后被HTTP1.1代替并广泛使用</p><h3 id="http1-1"><a href="#http1-1" class="headerlink" title="http1.1"></a>http1.1</h3><p>http1.1基于文本解析,把所有请求和响应作为纯文本<br>http1.1加入了缓存处理（强缓存和协商缓存）<br>http1.1拥有长连接，并支持请求管道化（pipelining），<br>http1.1流控制基于tcp连接。当连接建立时，两端通过系统默认机制建立缓冲区。并通过ack报文来通知对方接收窗口大小，因为http1.1 依靠传输层来避免流溢出，每个tcp连接需要一个独立的流控制机制</p><h4 id="缓存处理（强缓存和协商缓存）"><a href="#缓存处理（强缓存和协商缓存）" class="headerlink" title="缓存处理（强缓存和协商缓存）"></a>缓存处理（强缓存和协商缓存）</h4><p>浏览器缓存能优化性能，而浏览器缓存分为强缓存和协商缓存，都是从客户端读取缓存<br>强缓存</p><ol><li>强缓存不发送请求，直接读取资源，可以获得返回200的状态码</li><li>利用http头中的Expires和Cache-Control两个字段来控制，都用来表示资源的缓存时间，Expires能设置失效时间，而Cache-Control能做到更多选项更细致，如果同时设置的话，其优先级高于Expires</li></ol><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><ol><li>通过服务器来确定缓存资源是否可用，通过request header判断是否命中请求，命中后返回304状态码，并返回新的request header通知客户端从缓存里取</li><li>普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存</li><li>如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求，回到1</li></ol><h3 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h3><ol><li>http2相比于http1.1，<strong>性能</strong>大幅度提升</li><li>http2通过一个连接来<strong>多路复用</strong></li><li>http2拥有<strong>头部压缩</strong></li><li>http2拥有<strong>新的二进制格式</strong>，使用二进制框架层把所有消息封装成二进制，且仍然保持http语法</li><li>http2允许客户端和服务器端实现他们自己的流控制机制，而不是依赖传输层,两端在传输层交换可用的缓冲区大小，来让他们在多路复用流上设置自己的接收窗口</li><li>http2让服务器可以将响应主动<strong>“推送”</strong>到客户端缓存中</li></ol><h4 id="htpp2头部压缩"><a href="#htpp2头部压缩" class="headerlink" title="htpp2头部压缩"></a>htpp2头部压缩</h4><p>http2头部压缩又称为HAPCK，设计简单而灵活，是因为HPACK格式有意地简单且不灵活能降低由于实现错误而导致的互操作性或安全问题的风险<br>http1.1没有头部压缩，随着请求增加，冗余头部字段会不必要地占用带宽，从而显着增加延迟，而头部压缩可消除冗余报头字段，限制已知安全攻击的漏洞，并且在受限环境中使用有限的内存要求</p><p>http2多路复用</p><p>http 性能优化的关键并不在于高带宽，而是低延迟</p><p>tcp 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度,这种调谐则被称为 tcp 慢启动,由于这种原因，让原本就具有突发性和短时性的 http 连接变的十分低效</p><p>http/2 通过让所有数据流共用同一个连接，可以更有效地使用 tcp 连接，让高带宽也能真正的服务于 http 的性能提升。而http1.1存在低性能的线头阻塞，一旦有一个请求超时，便会出现阻塞等待的情况</p><h3 id="http3"><a href="#http3" class="headerlink" title="http3"></a>http3</h3><p>之前说了http2，那么http3就是为了解决http2相关问题而诞生，它基于一个新的传输层协议QUIC，而http3就是建立一个在<strong>QUIC</strong>上运行的HTTP新规范，而http3之前的版本都是基于TCP，QUIC就是为了替代TCP，解决TCP的一些缺陷<br>tcp</p><p>不支持流级复用，TCP会将所有对象序列化在同一个流中，因此，它不知道TCP段的对象级分区，无法在同一个流中复用数据包<br>会产生冗余通信，tco三次连接握手会有冗余的消息交换序列<br>可能会间歇性地挂起数据传输，tcp中有个因为序列顺序处理丢失的问题的缺陷称为行头阻塞</p><h3 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h3><p>同样拥有头部压缩，并优化了对乱序发送的支持，也优化了压缩率<br>放弃tcp，通过udp建立，提高了连接建立的速度，降低了延迟<br>tcp本身是无法解决队头拥塞，quic则解决了这个问题<br>Connection ID使得http3支持连接迁移以及NAT的重绑定</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://juejin.cn/post/7001510315514937375">一文总结http1.0，http1.1，http2，http3，面试强心剂</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片格式&amp;&amp;各自优缺点和使用场景</title>
    <link href="/2022/03/04/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F--%E5%90%84%E8%87%AA%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/2022/03/04/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F--%E5%90%84%E8%87%AA%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="前置知识：二进制位数与色彩的关系"><a href="#前置知识：二进制位数与色彩的关系" class="headerlink" title="前置知识：二进制位数与色彩的关系"></a>前置知识：二进制位数与色彩的关系</h3><p>　　在计算机中，像素用二进制数来表示。不同的图片格式中像素与二进制位数之间的对应关系是不同的，<br>　　一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越清晰，文件体积相应也会越大</p><h3 id="JPG-JPEG"><a href="#JPG-JPEG" class="headerlink" title="JPG / JPEG"></a>JPG / JPEG</h3><p>　　优点<br>　　　　①：体积小<br>　　　　②：加载快<br>　　　　③：支持颜色种类多<br>　　 缺点<br>　　　　①：有损压缩<br>　　　　②：不支持透明</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>　　JPG 适用于呈现色彩丰富的图片，在日常开发中，JPG 图片经常作为大的背景图、轮播图或 Banner 图出现</p><h4 id="注：JPEG和JPG指代同一种图片格式，前者是后者的全称，后者是简称"><a href="#注：JPEG和JPG指代同一种图片格式，前者是后者的全称，后者是简称" class="headerlink" title="注：JPEG和JPG指代同一种图片格式，前者是后者的全称，后者是简称"></a>注：JPEG和JPG指代同一种图片格式，前者是后者的全称，后者是简称</h4><h3 id="PNG-8-PNG-24"><a href="#PNG-8-PNG-24" class="headerlink" title="PNG-8 / PNG-24"></a>PNG-8 / PNG-24</h3><p>　　优点<br>　　　　①：支持透明，弥补了JPG的不足<br>　　　　 ②：无损压缩，图片质量更高<br>　　缺点<br>　　　　①：什么都好，就是体积太大</p><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>　主要用它来呈现小的 Logo 和需要透明效果的图片（比如透明背景图，透明Logo图）</p><h4 id="注：PNG-8和PNG-24区别在于支持色彩多少的不同。前者最多支持256种颜色，后者支持1600万种颜色"><a href="#注：PNG-8和PNG-24区别在于支持色彩多少的不同。前者最多支持256种颜色，后者支持1600万种颜色" class="headerlink" title="注：PNG-8和PNG-24区别在于支持色彩多少的不同。前者最多支持256种颜色，后者支持1600万种颜色"></a>注：PNG-8和PNG-24区别在于支持色彩多少的不同。前者最多支持256种颜色，后者支持1600万种颜色</h4><h3 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h3><p>　　优点<br>　　　　①：体积小<br>　　　　②：支持透明<br>　　　　③：支持动图<br>　缺点<br>　　　①：最多只支持256种颜色，成像效果较差</p><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>主要用于需要有动画效果的图片</p><h3 id="SVG（矢量图形）"><a href="#SVG（矢量图形）" class="headerlink" title="SVG（矢量图形）"></a>SVG（矢量图形）</h3><p>　　优点<br>　　　　①：即使无限放大，图片依然不失真<br>　　　　②：相对于JPG和PNG，体积更小<br>　　缺点<br>　　　　①：对性能有一定影响</p><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>　　SVG 是文本文件，我们既可以像写代码一样定义 SVG，把它写在 HTML 里、成为 DOM 的一部分，<br>　　也可以把对图形的描述写入以 .svg 为后缀的独立文件（SVG 文件在使用上与普通图片文件无异）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span>   <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">r</span>=<span class="hljs-string">&quot;50&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>　将 SVG 写入独立文件后引入 HTML</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;文件名.svg&quot;</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="HTML-5-Canvas-vs-SVG"><a href="#HTML-5-Canvas-vs-SVG" class="headerlink" title="HTML 5 Canvas vs. SVG"></a>HTML 5 Canvas vs. SVG</h3><p>Canvas 和 SVG 都允许您在浏览器中创建图形，但是它们在根本上是不同的。</p><h4 id="Canvas-与-SVG-的比较"><a href="#Canvas-与-SVG-的比较" class="headerlink" title="Canvas 与 SVG 的比较"></a>Canvas 与 SVG 的比较</h4><p>下表列出了 canvas 与 SVG 之间的一些不同之处。</p><h4 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h4><p>依赖分辨率<br>不支持事件处理器<br>弱的文本渲染能力<br>能够以 .png 或 .jpg 格式保存结果图像<br>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</p><h4 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h4><p>不依赖分辨率<br>支持事件处理器<br>最适合带有大型渲染区域的应用程序（比如谷歌地图）<br>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）<br>不适合游戏应用</p><h3 id="补充——Base64"><a href="#补充——Base64" class="headerlink" title="补充——Base64"></a>补充——Base64</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>　　雪碧图（又被称为CSS Sprites、CSS 精灵、图像精灵）<br>　　 是一种将小图标和背景图像合并到一张图片上，然后利用 CSS 的背景定位来显示其中每一部分的技术，从而减少http请求</p><h4 id="Base64严格意义上来说并不是一种图片格式，而是作为小图标解决方案而存在的，可以理解为是雪碧图的一种补充"><a href="#Base64严格意义上来说并不是一种图片格式，而是作为小图标解决方案而存在的，可以理解为是雪碧图的一种补充" class="headerlink" title="Base64严格意义上来说并不是一种图片格式，而是作为小图标解决方案而存在的，可以理解为是雪碧图的一种补充"></a>Base64严格意义上来说并不是一种图片格式，而是作为小图标解决方案而存在的，可以理解为是雪碧图的一种补充</h4><p>　　Base64 通过对图片进行编码，可以直接将编码结果写入 HTML 或者 CSS，从而减少 HTTP 请求的次数<br>　　比如现在有一个放大镜图标</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">　　 图片路径是：&lt;https:<span class="hljs-regexp">//u</span>ser-gold-cdn.xitu.io<span class="hljs-regexp">/2018/</span><span class="hljs-number">9</span><span class="hljs-regexp">/15/</span><span class="hljs-number">165</span>db7e94699824b?w=<span class="hljs-number">22</span>&amp;h=<span class="hljs-number">22</span>&amp;f=png&amp;s=<span class="hljs-number">3680</span>&gt;<br></code></pre></td></tr></table></figure><p>　   按照一贯思路，我们加载图片需要把图片链接写入 img 标签，然后向服务器发送请求</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;img src=&quot;https://user-gold-cdn.xitu.io/<span class="hljs-number">2018</span>/<span class="hljs-number">9</span>/<span class="hljs-number">15</span>/<span class="hljs-number">165</span>db7e94699824b?w=<span class="hljs-number">22</span><span class="hljs-variable">&amp;h</span>=<span class="hljs-number">22</span><span class="hljs-variable">&amp;f</span>=png<span class="hljs-variable">&amp;s</span>=<span class="hljs-number">3680</span>&quot;&gt;</span><br></code></pre></td></tr></table></figure><p>　 但如果我们对这个图片进行 Base64 编码，会得到一个下图所示的字符串：</p><p> 　　原来浏览器是可以理解这个字符串的，它自动将这个字符串解码为一张图片，而不需再去发送 HTTP 请求</p><h4 id="转载文章"><a href="#转载文章" class="headerlink" title="转载文章"></a>转载文章</h4><p><a href="https://www.cnblogs.com/tu-0718/p/10091432.html">前端常用图片格式优缺点及使用场景简述</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CommonJS和ES6模块</title>
    <link href="/2022/03/01/CommonJS%E5%92%8CES6%E6%A8%A1%E5%9D%97/"/>
    <url>/2022/03/01/CommonJS%E5%92%8CES6%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="一、CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用"><a href="#一、CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用" class="headerlink" title="一、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用"></a>一、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</h3><h4 id="commonjs的用法，我们一起来看一下"><a href="#commonjs的用法，我们一起来看一下" class="headerlink" title="commonjs的用法，我们一起来看一下"></a>commonjs的用法，我们一起来看一下</h4><p>1.首先创建一个lib.js的文件</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> lib.js<br>const counter = <span class="hljs-number">3</span>;<br>const incCounter = <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>  counter++<br>&#125;<br><br><span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = &#123;<br>  counter,<br>  incCounter<br>&#125;<br><br></code></pre></td></tr></table></figure><p>2.再次创建一个main.js,使用commonjs的方式导入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">var</span> lib = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./lib&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(lib)<br><span class="hljs-built_in">console</span>.log(lib.counter);  <span class="hljs-comment">// 3</span><br>lib.incCounter();<br><span class="hljs-built_in">console</span>.log(lib.counter); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><blockquote><p>lib.js模块加载以后，它的内部变化就影响不到输出的lib.counter了。这是因为mod.counter是一个原始类型的值，会被缓存；</p></blockquote><h4 id="esmodule的用法，我们一起来看一下"><a href="#esmodule的用法，我们一起来看一下" class="headerlink" title="esmodule的用法，我们一起来看一下"></a>esmodule的用法，我们一起来看一下</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// lib.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> counter = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incCounter</span> (<span class="hljs-params"></span>) </span>&#123;<br>  counter++;<br>&#125;<br><br><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; counter, incCounter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./util.mjs&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(counter);  <span class="hljs-comment">//3</span><br>incCounter()<br><span class="hljs-built_in">console</span>.log(counter)  <span class="hljs-comment">//4</span><br><br></code></pre></td></tr></table></figure><blockquote><p>ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。</p></blockquote><h5 id="补充：通过esmodule导入的变量是不能重新赋值修改的"><a href="#补充：通过esmodule导入的变量是不能重新赋值修改的" class="headerlink" title="补充：通过esmodule导入的变量是不能重新赋值修改的"></a>补充：通过esmodule导入的变量是不能重新赋值修改的</h5><h3 id="二、CommonJS-模块是运行时加载，ES6-模块是编译时输出接口"><a href="#二、CommonJS-模块是运行时加载，ES6-模块是编译时输出接口" class="headerlink" title="二、CommonJS 模块是运行时加载，ES6 模块是编译时输出接口"></a>二、CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// CommonJS模块</span><br><span class="hljs-keyword">let</span> &#123; stat, exists, readFile &#125; = require(&#x27;fs&#x27;);<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">let</span> _fs = require(&#x27;fs&#x27;);<br><span class="hljs-keyword">let</span> stat =<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_fs</span>.</span></span>stat;<br><span class="hljs-keyword">let</span> exists = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_fs</span>.</span></span>exists;<br><span class="hljs-keyword">let</span> readfile =<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_fs</span>.</span></span>readfile;<br></code></pre></td></tr></table></figure><p>上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。因此commonjs属于再运行时才会加载模块的方式。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> &#123; stat, <span class="hljs-keyword">exists</span>, readFile &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;<br></code></pre></td></tr></table></figure><p>上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高;</p><h3 id="三、CommonJS-模块的require-是同步加载模块，ES6-模块的import命令是异步加载，有一个独立的模块依赖的解析阶段"><a href="#三、CommonJS-模块的require-是同步加载模块，ES6-模块的import命令是异步加载，有一个独立的模块依赖的解析阶段" class="headerlink" title="三、CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段"></a>三、CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段</h3><blockquote><p>同步加载：所谓同步加载就是加载资源或者模块的过程会阻塞后续代码的执行；<br>异步加载：不会阻塞后续代码的执行；</p></blockquote><p>我们来看一个案例,创建如下的目录；</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">| <span class="hljs-comment">-- a.js</span><br>| <span class="hljs-comment">-- index.js</span><br>| <span class="hljs-comment">-- c.js</span><br></code></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> a.js<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a.js文件的执行&#x27;</span>);<br>const importFun = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./c&#x27;</span>).c);<br>&#125;<br><br>importFun()<br><br><span class="hljs-built_in">module</span>.<span class="hljs-built_in">exports</span> = &#123;<br>  importFun<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">const</span> A = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;index.js的执行&#x27;</span>);<br><br><span class="hljs-comment">// c.js</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;c.js的运行&#x27;</span>);<br><br><span class="hljs-keyword">const</span> c = <span class="hljs-number">3</span><br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  c<br>&#125;<br><br></code></pre></td></tr></table></figure><p>执行命令 node index.js</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> a.js文件的执行<br><span class="hljs-regexp">//</span> c.js的运行<br><span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br><span class="hljs-regexp">//</span> index.js的执行<br></code></pre></td></tr></table></figure><p>我们会发现,require的内容会阻塞后续代码的执行。因为c.js先打印出来，然后在是index.js的打印，所以说require()是同步加载的；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// a.js</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a.js文件的执行&#x27;</span>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> importFun = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./c.js&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">&#123;c&#125;</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(c)<br>  &#125;)<br>&#125;<br><br>importFun()<br><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> &#123;importFun&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;index.js的执行&#x27;</span>);<br><br><span class="hljs-comment">// c.js</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;c.js的运行&#x27;</span>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> c = <span class="hljs-number">3</span><br><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 结果<br><span class="hljs-regexp">//</span> a.js文件的执行<br><span class="hljs-regexp">//</span> index.js的执行<br><span class="hljs-regexp">//</span> c.js的运行<br><span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>可以看的出来:import()是异步加载资源的，因为c.js是在index.js的后面打印出来的，并不会阻塞后续代码的执行；</p><h3 id="总结：以上便是commonjs和esmodule的几个区别"><a href="#总结：以上便是commonjs和esmodule的几个区别" class="headerlink" title="总结：以上便是commonjs和esmodule的几个区别"></a>总结：以上便是commonjs和esmodule的几个区别</h3><p>1: CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用<br>2: CommonJS 模块是运行时加载，ES6 模块是编译时输出接口<br>3: CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段</p><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>鉴于浏览器支持度的问题，如果要使用 ES6 的语法，一般都会借助 Babel，可对于 import 和 export 而言，只借助 Babel 就可以吗？</p><p>让我们看看 Babel 是怎么编译 import 和 export 语法的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// ES6</span><br><span class="hljs-keyword">var</span> firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<br><span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<br><span class="hljs-keyword">var</span> year = <span class="hljs-number">1958</span>;<br><br><span class="hljs-keyword">export</span> &#123;firstName, lastName, year&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Babel 编译后</span><br><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">exports</span>, <span class="hljs-string">&quot;__esModule&quot;</span>, &#123;<br>  value: <span class="hljs-literal">true</span><br>&#125;);<br><span class="hljs-keyword">var</span> firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<br><span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<br><span class="hljs-keyword">var</span> year = <span class="hljs-number">1958</span>;<br><br><span class="hljs-built_in">exports</span>.firstName = firstName;<br><span class="hljs-built_in">exports</span>.lastName = lastName;<br><span class="hljs-built_in">exports</span>.year = year;<br></code></pre></td></tr></table></figure><p>是不是感觉有那么一点奇怪？编译后的语法更像是 CommonJS 规范，再看 import 的编译结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES6</span><br><span class="hljs-keyword">import</span> &#123;firstName, lastName, year&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./profile&#x27;</span>;<br>复制代码<br><span class="hljs-comment">// Babel 编译后</span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">var</span> _profile = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./profile&#x27;</span>);<br></code></pre></td></tr></table></figure><p>你会发现 Babel 只是把 ES6 模块语法转为 CommonJS 模块语法，然而<strong>浏览器是不支持这种模块语法的，所以直接跑在浏览器会报错的，如果想要在浏览器中运行，还是需要使用打包工具将代码打包。</strong></p><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>Babel 将 ES6 模块转为 CommonJS 后， webpack 又是怎么做的打包的呢？它该如何将这些文件打包在一起，从而能保证正确的处理依赖，以及能在浏览器中运行呢？</p><p>首先为什么浏览器中不支持 CommonJS 语法呢？</p><p>这是因为浏览器环境中并没有 module、 exports、 require 等环境变量。</p><p>换句话说，webpack 打包后的文件之所以在浏览器中能运行，就是靠模拟了这些变量的行为。</p><p>那怎么模拟呢？</p><p>我们以 CommonJS 项目中的 square.js 为例，它依赖了 multiply 模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;加载了 square 模块&#x27;</span>)<br><br><span class="hljs-keyword">var</span> multiply = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./multiply.js&#x27;</span>);<br><br><span class="hljs-keyword">var</span> square = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) </span>&#123;&amp;emsp;<br>    <span class="hljs-keyword">return</span> multiply.multiply(num, num);<br>&#125;;<br><br><span class="hljs-built_in">module</span>.exports.square = square;<br></code></pre></td></tr></table></figure><p>webpack 会将其包裹一层，注入这些变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;加载了 square 模块&#x27;</span>);<br><br>    <span class="hljs-keyword">var</span> multiply = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./multiply&quot;</span>);<br>    <span class="hljs-built_in">module</span>.exports = &#123;<br>        square: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> multiply.multiply(num, num);<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>那 webpack 又会将 CommonJS 项目的代码打包成什么样呢？我写了一个精简的例子，你可以直接复制到浏览器中查看效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 自执行函数</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">modules</span>) </span>&#123;<br><br>    <span class="hljs-comment">// 用于储存已经加载过的模块</span><br>    <span class="hljs-keyword">var</span> installedModules = &#123;&#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">require</span>(<span class="hljs-params">moduleName</span>) </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (installedModules[moduleName]) &#123;<br>            <span class="hljs-keyword">return</span> installedModules[moduleName].exports;<br>        &#125;<br><br>        <span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = installedModules[moduleName] = &#123;<br>            <span class="hljs-built_in">exports</span>: &#123;&#125;<br>        &#125;;<br><br>        modules[moduleName](<span class="hljs-built_in">module</span>, <span class="hljs-built_in">module</span>.exports, <span class="hljs-built_in">require</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports;<br>    &#125;<br><br>    <span class="hljs-comment">// 加载主模块</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;main&quot;</span>);<br><br>&#125;)(&#123;<br>    <span class="hljs-string">&quot;main&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) </span>&#123;<br><br>        <span class="hljs-keyword">var</span> addModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./add&quot;</span>);<br>        <span class="hljs-built_in">console</span>.log(addModule.add(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br><br>        <span class="hljs-keyword">var</span> squareModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./square&quot;</span>);<br>        <span class="hljs-built_in">console</span>.log(squareModule.square(<span class="hljs-number">3</span>));<br><br>    &#125;,<br>    <span class="hljs-string">&quot;./add&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;加载了 add 模块&#x27;</span>);<br><br>        <span class="hljs-built_in">module</span>.exports = &#123;<br>            add: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>                <span class="hljs-keyword">return</span> x + y;<br>            &#125;<br>        &#125;;<br>    &#125;,<br>    <span class="hljs-string">&quot;./square&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;加载了 square 模块&#x27;</span>);<br><br>        <span class="hljs-keyword">var</span> multiply = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./multiply&quot;</span>);<br>        <span class="hljs-built_in">module</span>.exports = &#123;<br>            square: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) </span>&#123;<br>                <span class="hljs-keyword">return</span> multiply.multiply(num, num);<br>            &#125;<br>        &#125;;<br>    &#125;,<br><br>    <span class="hljs-string">&quot;./multiply&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;加载了 multiply 模块&#x27;</span>);<br><br>        <span class="hljs-built_in">module</span>.exports = &#123;<br>            multiply: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>                <span class="hljs-keyword">return</span> x * y;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">最终的执行结果为：<br><br>加载了 <span class="hljs-built_in">add</span> 模块<br><span class="hljs-number">2</span><br>加载了 square 模块<br>加载了 <span class="hljs-built_in">multiply</span> 模块<br><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://juejin.cn/post/7048139060983889950#heading-1">CommonJS和ES6模块有什么区别!</a><br><a href="https://juejin.cn/post/6844903712553435149#heading-11">ES6 系列之模块加载方案</a></p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node相关&amp;&amp;Koa与Express的区别</title>
    <link href="/2022/03/01/Koa%E4%B8%8EExpress%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/03/01/Koa%E4%B8%8EExpress%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="node有哪些相关的文件路径？"><a href="#node有哪些相关的文件路径？" class="headerlink" title="node有哪些相关的文件路径？"></a>node有哪些相关的文件路径？</h3><p>答案是：Node 中的文件路径有 __dirname,__filename, process.cwd(), ./ 或者 ../下面用一个例子来介绍这几种文件路径的区别</p><p>__dirname: 总是返回被执行的 js 所在文件夹的绝对路径<br>__filename: 总是返回被执行的 js 的绝对路径<br>process.cwd(): 总是返回运行 node 命令时所在的文件夹的绝对路径</p><h3 id="node的http模块创建服务与Express或Koa框架有何不同"><a href="#node的http模块创建服务与Express或Koa框架有何不同" class="headerlink" title="node的http模块创建服务与Express或Koa框架有何不同?"></a>node的http模块创建服务与Express或Koa框架有何不同?</h3><p>答案是：express是一个服务端框架,框架简单封装了node的http模块,express支持node原生的写法,express不仅封装好服务器，还封装了中间件、路由等特征，方便开发web服务器，</p><blockquote><p>换句话说express = http模块 + 中间件 + 路由</p></blockquote><h3 id="Express和Koa框架中间件有什么不同？"><a href="#Express和Koa框架中间件有什么不同？" class="headerlink" title="Express和Koa框架中间件有什么不同？"></a>Express和Koa框架中间件有什么不同？</h3><p>答案：中间件： app.use方法就是往中间件队列中塞入新的中间件，express中间件处理方式是线性的，next过后继续寻找下一个中间件，当然如果没有调用next()的话，就不会调用下一个函数了，调用就会被终止</p><h5 id="express-中间件：是通过-next-的机制，即上一个中间件会通过-next-触发下一个中间件"><a href="#express-中间件：是通过-next-的机制，即上一个中间件会通过-next-触发下一个中间件" class="headerlink" title="express 中间件：是通过 next 的机制，即上一个中间件会通过 next 触发下一个中间件"></a>express 中间件：是通过 next 的机制，即上一个中间件会通过 next 触发下一个中间件</h5><h5 id="koa2-中间件：是通过-async-await-实现的，中间件执行顺序是“洋葱圈”模型（推荐）"><a href="#koa2-中间件：是通过-async-await-实现的，中间件执行顺序是“洋葱圈”模型（推荐）" class="headerlink" title="koa2 中间件：是通过 async await 实现的，中间件执行顺序是“洋葱圈”模型（推荐）"></a>koa2 中间件：是通过 async await 实现的，中间件执行顺序是“洋葱圈”模型（推荐）</h5><p><img src="/imageO/YC.jpg" alt="洋葱模型"></p><h3 id="Koa与Express的区别"><a href="#Koa与Express的区别" class="headerlink" title="Koa与Express的区别"></a>Koa与Express的区别</h3><h4 id="Koa"><a href="#Koa" class="headerlink" title="Koa"></a>Koa</h4><ul><li>基于node的一个web开发框架，利用co作为底层运行框架，利用Generator的特性，实现“无回调”的异步处理；</li><li>ES7;</li><li>更小、更富有表现力、更健壮的基石；</li><li>利用async函数、Koa丢弃回调函数，增强错误处理；</li><li>很小的体积，因为没有捆绑任何中间件；</li><li>类似堆栈的方式组织和执行；</li><li>低级中间件层中提供高级“语法糖”，提高了互操性、稳健性；</li></ul><h4 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h4><ul><li>Node的基础框架，基础Connect中间件，自身封装了路由、视图处理等功能；</li><li>线性逻辑，路由和中间件完美融合，清晰明了；</li><li>弊端是callback回调方式，不可组合、异常不可捕获；</li><li>ES5;</li><li>connect的执行流程： connect的中间件模型是线性的，即一个一个往下执行；</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><h5 id="Handler的处理"><a href="#Handler的处理" class="headerlink" title="Handler的处理"></a>Handler的处理</h5><p>Express普通回调函数，在同一线程上完成当前进程的所有Http请求；<br>Koa利用Generator Function作为响应器，co作为底层运行框架，利用Generator特性，实现“协程响应”；</p><h5 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h5><p>Express的路由是自身集成的；<br>Koa的需要引入中间件Koa-router；</p><h5 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h5><p>koa采用new Koa()<br>express采用传统的函数形式function；</p><h5 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h5><p>Koa没有回调<br>express有回调；</p><h5 id="Http-Request"><a href="#Http-Request" class="headerlink" title="Http Request"></a>Http Request</h5><p>koa1使用this取代Express的req、res；</p><h5 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h5><p>Koa新增了一个Context对象，用来代替Express的Request和Response，作为请求的上下文对象。<br>还有Node原生提供的req、res、socket等对象；</p><h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><p>Express的生命周期不确定：express内部执行异步函数，不能确定什么时候执行完；<br>Koa确定：koa是基于await/async，在执行下一步操作的时候，必须等待前端await执行完；</p><h5 id="异步流程"><a href="#异步流程" class="headerlink" title="异步流程"></a>异步流程</h5><p> Express采用callback来处理异步(ES5)；<br> Koa1采用generator(ES6)；<br> Koa2采用async/await(ES7)；</p><h5 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h5><p> Express使用callback捕获异常，深层次的异常捕获不了；<br> Koa使用try catch，很好的解决异常捕获；</p><h5 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h5><h6 id="koa2的中间件"><a href="#koa2的中间件" class="headerlink" title="koa2的中间件"></a>koa2的中间件</h6><p>   1、通过async await实现的，中间件执行的顺序是“洋葱圈”模型。<br>   2、中间件之间通过next函数联系，当一个中间件调用next()后，会将控制权交给下一个中间件，直到下一个中间件不再执行next()后，会沿路返回，将控制权交给前一个中间件。</p><h6 id="Express中间件"><a href="#Express中间件" class="headerlink" title="Express中间件"></a>Express中间件</h6><p>  1、一个接一个顺序执行，response响应写在最后一个中间件中。<br>  2、特点：<br>   a.app.use用来注册中间件；<br>   b.遇到http请求，根据path和method判断触发哪些中间件；<br>   c.实现next机制，即上一个中间件会通过next触发下一个中间件；</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://juejin.cn/post/6844904196265754638#comment">面试官问你关于node的那些事（基础篇）</a><br><a href="https://juejin.cn/post/6875152985949732872">前端面试—Koa与Express的区别</a></p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Js数组基本问题</title>
    <link href="/2022/02/28/Js%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/02/28/Js%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>总结了最近的一些面试题和之前的知识点</p><hr><h3 id="JS判断数组中是否包含某个值"><a href="#JS判断数组中是否包含某个值" class="headerlink" title="JS判断数组中是否包含某个值"></a>JS判断数组中是否包含某个值</h3><h4 id="方法一：array-indexOf"><a href="#方法一：array-indexOf" class="headerlink" title="方法一：array.indexOf"></a>方法一：array.indexOf</h4><p>此方法判断数组中是否存在某个值，如果存在，则返回数组元素的下标，否则返回-1。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-attribute">var</span> index=arr.indexOf(<span class="hljs-number">3</span>);<br><span class="hljs-attribute">console</span>.log(index);<br></code></pre></td></tr></table></figure><h4 id="方法二：array-includes-searcElement-fromIndex"><a href="#方法二：array-includes-searcElement-fromIndex" class="headerlink" title="方法二：array.includes(searcElement[,fromIndex])"></a>方法二：array.includes(searcElement[,fromIndex])</h4><p>此方法判断数组中是否存在某个值，如果存在返回true，否则返回false</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-attribute">if</span>(arr.includes(<span class="hljs-number">3</span>))<br>    <span class="hljs-attribute">console</span>.log(<span class="hljs-string">&quot;存在&quot;</span>);<br><span class="hljs-attribute">else</span><br>    <span class="hljs-attribute">console</span>.log(<span class="hljs-string">&quot;不存在&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="方法三：array-find-callback-thisArg"><a href="#方法三：array-find-callback-thisArg" class="headerlink" title="方法三：array.find(callback[,thisArg])"></a>方法三：array.find(callback[,thisArg])</h4><p>返回数组中满足条件的第一个元素的值，如果没有，返回undefined</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-keyword">var</span> result = arr.find(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> item &gt; <span class="hljs-number">3</span><br>&#125;);<br>console.log(result);<br></code></pre></td></tr></table></figure><p>如果元素是对象：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">var</span> items=[<br>    &#123;<span class="hljs-attribute">id:</span><span class="hljs-string">1,name</span>:<span class="hljs-string">&#x27;yxy&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attribute">id:</span><span class="hljs-string">2,name</span>:<span class="hljs-string">&#x27;whc&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attribute">id:</span><span class="hljs-string">3,name</span>:<span class="hljs-string">&#x27;hzj&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attribute">id:</span><span class="hljs-string">4,name</span>:<span class="hljs-string">&#x27;fyq&#x27;</span>&#125;<br>];<br><span class="hljs-keyword">var</span> result = items.find(item=&gt;&#123;<br>    <span class="hljs-keyword">return</span> item.id == <span class="hljs-number">3</span>;<br>&#125;);<br><span class="hljs-built_in">console</span>.log(result);<br></code></pre></td></tr></table></figure><h4 id="方法四：array-findeIndex-callback-thisArg"><a href="#方法四：array-findeIndex-callback-thisArg" class="headerlink" title="方法四：array.findeIndex(callback[,thisArg])"></a>方法四：array.findeIndex(callback[,thisArg])</h4><p>返回数组中满足条件的第一个元素的下标，如果没有找到，返回**-1**</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-keyword">var</span> result = arr.findIndex(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> item &gt; <span class="hljs-number">3</span><br>&#125;);<br>console.log(result);<br></code></pre></td></tr></table></figure><h4 id="方法五：当然不能忘了养大我们的for循环和if"><a href="#方法五：当然不能忘了养大我们的for循环和if" class="headerlink" title="方法五：当然不能忘了养大我们的for循环和if"></a>方法五：当然不能忘了养大我们的for循环和if</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-built_in">var</span> k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">var</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-built_in">length</span>;i++)&#123;<br>    <span class="hljs-keyword">if</span>(arr[i]==<span class="hljs-number">3</span>)<br>        k=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(k)<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;存在&quot;</span>);<br><span class="hljs-keyword">else</span><br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;不存在&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="JS如何实现数组扁平化？"><a href="#JS如何实现数组扁平化？" class="headerlink" title="JS如何实现数组扁平化？"></a>JS如何实现数组扁平化？</h3><h4 id="ES6的flat"><a href="#ES6的flat" class="headerlink" title="ES6的flat"></a>ES6的flat</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ary = arr<span class="hljs-selector-class">.flat</span>(Infinity)<br>console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-attr">[1, [2, 3, [4, 5]</span>]]<span class="hljs-selector-class">.flat</span>(Infinity))<br></code></pre></td></tr></table></figure><p>Array.protype.flat()用于将数组“拉平”，变成一维数组，返回一个新数组。flat()默认只会拉平一层，flat（n）拉平n层，Infinity无限次。好用归好用，但效率我们就心里明白，这也是我们面试官最不想听到的答案了。</p><h4 id="正则处理"><a href="#正则处理" class="headerlink" title="正则处理"></a>正则处理</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>第一种处理<br>ary = str.replace(<span class="hljs-regexp">/(\[|\])/g</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br><br><span class="hljs-regexp">//</span>第二种处理<br>str = str.replace(<span class="hljs-regexp">/(\[|\]))/g</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>str = <span class="hljs-string">&#x27;[&#x27;</span> + str + <span class="hljs-string">&#x27;]&#x27;</span>;<br>ary = JSON.parse(str);<br></code></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-keyword">let</span> arr = <span class="hljs-literal">[<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]</span>]];<br><br> <span class="hljs-keyword">function</span> flattern(arr,result =<span class="hljs-literal">[]</span>) &#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">arr</span>[<span class="hljs-params">i</span>])</span>) &#123;<br>                flattern(arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, result)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result.push(arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)<br>            &#125;<br>        &#125;<br>        return result;<br>    &#125;<br>console.log(flattern(arr));<br></code></pre></td></tr></table></figure><p>这也是我当时面试想到最简单的解决方案，思路很简单，通过遍历最外层数组的每一个元素，看看是否还是数组，如果是的话，继续递归执行，不是的话，放到最后的结果数组当中</p><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prev, next</span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> prev.concat(<span class="hljs-built_in">Array</span>.isArray(next) ? flatten(next) : next)<br>    &#125;, [])<br>&#125;<br><span class="hljs-built_in">console</span>.log(flatten(arr))<br><br><span class="hljs-comment">//reduce搭配扩展运算符</span><br><span class="hljs-keyword">const</span> flatten = <span class="hljs-function">(<span class="hljs-params">array</span>) =&gt;</span> array.reduce(<span class="hljs-function">(<span class="hljs-params">acc,cur</span>)=&gt;</span><br>    (<span class="hljs-built_in">Array</span>.isArray(cur)?[...acc,...flatten(cur)]:[...acc,cur]),[])<br></code></pre></td></tr></table></figure><p>提到数组的方法，就会联想到非常常用的2个高阶函数map和reduce。其实思路上和上面递归的很相似。</p><h4 id="ES6扩展运算符"><a href="#ES6扩展运算符" class="headerlink" title="ES6扩展运算符"></a>ES6扩展运算符</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>],<span class="hljs-number">8</span>],<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,[<span class="hljs-number">11</span>,[<span class="hljs-number">12</span>,<span class="hljs-number">13</span>]]];<br><span class="hljs-keyword">const</span> flatten = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">while</span>(arr.some(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span><span class="hljs-built_in">Array</span>.isArray(item)))&#123;<br>        arr=[].concat(...arr);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-built_in">console</span>.log(flatten(arr)); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]</span><br></code></pre></td></tr></table></figure><p>由于扩展运算符一次只能展开一层数组</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">var arr = <span class="hljs-comment">[1, <span class="hljs-comment">[2, <span class="hljs-comment">[3, 4]</span>]</span>]</span>;<br>console.log(<span class="hljs-comment">[]</span>.concat(...arr)); // <span class="hljs-comment">[1, 2, <span class="hljs-comment">[3, 4]</span>]</span><br></code></pre></td></tr></table></figure><p>因此考虑只要数组中还有数组，就使用扩展运算符展开一次。</p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl">function flatten(arr)&#123;<br><br>    //arr.join(<span class="hljs-string">&#x27;,&#x27;</span>).<span class="hljs-keyword">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>);  <span class="hljs-keyword">join</span>也可以实现  <br>    <span class="hljs-keyword">return</span> arr.toString().<span class="hljs-keyword">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>).map(function(item)&#123;<br>        <span class="hljs-keyword">return</span> +item;  <span class="hljs-regexp">//</span>+将字符转换为数字<br> &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果数组的元素都是数字，可以考虑使用 toString 方法，因为：toString会将数组中的数以逗号形式结合起来。toString之后再split转成数组，并将其转换回数字。所以这种场景只适用于数组内全部是数字的情况，因为中间是全部转换为字符串了。</p><h5 id="转载文章"><a href="#转载文章" class="headerlink" title="转载文章"></a>转载文章</h5><p><a href="https://juejin.cn/post/6978115075672375326">🔥🔥JS如何实现数组扁平化？不同的方法有什么区别？</a></p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中父子组件生命周期执行顺</title>
    <link href="/2022/02/28/Vue%E4%B8%AD%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E9%A1%BA/"/>
    <url>/2022/02/28/Vue%E4%B8%AD%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E9%A1%BA/</url>
    
    <content type="html"><![CDATA[<p>问题背景</p><p>在单一组件中，钩子的执行顺序是beforeCreate-&gt; created -&gt; mounted-&gt;… -&gt;destroyed，但当父子组件嵌套时，父组件和子组件各拥有各自独立的钩子函数，这些父子组件的这些钩子是如何交融执行，且执行顺序又是怎样的呢?</p><hr><h3 id="父子组件生命周期执行顺序"><a href="#父子组件生命周期执行顺序" class="headerlink" title="父子组件生命周期执行顺序"></a>父子组件生命周期执行顺序</h3><p>组件，分别在他们的钩子函数中打印日志，观察执行顺序。得到的结果如图所示，父组件先创建，然后子组件创建；子组件先挂载，然后父组件挂载。</p><p>父beforeCreate-&gt; 父create -&gt; 子beforeCreate-&gt; 子created -&gt; 子mounted -&gt; 父mounted</p><blockquote><p>子组件挂载完成后，父组件还未挂载。所以组件数据回显的时候，在父组件mounted中获取api的数据，子组件的mounted是拿不到的。子组件挂载完成后，父组件还未挂载。所以组件数据回显的时候，在父组件mounted中获取api的数据，子组件的mounted是拿不到的。</p></blockquote><h4 id="仔细看看父子组件生命周期钩子的执行顺序，会发现created这个钩子是按照从外内顺序执行，所以父子组件传递接口数据的解决方案是"><a href="#仔细看看父子组件生命周期钩子的执行顺序，会发现created这个钩子是按照从外内顺序执行，所以父子组件传递接口数据的解决方案是" class="headerlink" title="仔细看看父子组件生命周期钩子的执行顺序，会发现created这个钩子是按照从外内顺序执行，所以父子组件传递接口数据的解决方案是"></a>仔细看看父子组件生命周期钩子的执行顺序，会发现created这个钩子是按照从外内顺序执行，所以父子组件传递接口数据的解决方案是</h4><p>在created中发起请求获取数据，依次在子组件的created或者mounted中会接收到这个数据。</p><h3 id="父子组件生命周期执行顺序-1"><a href="#父子组件生命周期执行顺序-1" class="headerlink" title="父子组件生命周期执行顺序"></a>父子组件生命周期执行顺序</h3><p>加载渲染过程</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">父<span class="hljs-function"><span class="hljs-title">beforeCreate</span>-&gt;</span>父<span class="hljs-function"><span class="hljs-title">created</span>-&gt;</span>父<span class="hljs-function"><span class="hljs-title">beforeMount</span>-&gt;</span>子<span class="hljs-function"><span class="hljs-title">beforeCreate</span>-&gt;</span>子<span class="hljs-function"><span class="hljs-title">created</span>-&gt;</span>子<span class="hljs-function"><span class="hljs-title">beforeMount</span>-&gt;</span>子<span class="hljs-function"><span class="hljs-title">mounted</span>-&gt;</span>父mounted<br></code></pre></td></tr></table></figure><h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">父<span class="hljs-function"><span class="hljs-title">beforeUpdate</span>-&gt;</span>子<span class="hljs-function"><span class="hljs-title">beforeUpdate</span>-&gt;</span>子<span class="hljs-function"><span class="hljs-title">updated</span>-&gt;</span>父updated<br></code></pre></td></tr></table></figure><h3 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">父<span class="hljs-function"><span class="hljs-title">beforeDestroy</span>-&gt;</span>子<span class="hljs-function"><span class="hljs-title">beforeDestroy</span>-&gt;</span>子<span class="hljs-function"><span class="hljs-title">destroyed</span>-&gt;</span>父destroyed<br></code></pre></td></tr></table></figure><h3 id="注意-在父组件传递接口的数据给子组件时，一定要在子组件标签上加上v-if-”传递的接口数据”"><a href="#注意-在父组件传递接口的数据给子组件时，一定要在子组件标签上加上v-if-”传递的接口数据”" class="headerlink" title="注意 在父组件传递接口的数据给子组件时，一定要在子组件标签上加上v-if=”传递的接口数据”"></a>注意 在父组件传递接口的数据给子组件时，一定要在子组件标签上加上v-if=”传递的接口数据”</h3><p>在父组件的created中发请求获取数据，通过prop传递给子组件。子组件在created或者mounted中拿父组件传递过来的数据  这样处理是有问题的。</p><p>在父组件调用接口传递数据给子组件时，接口响应显然是异步的。这会导致无论你在父组件哪个钩子发请求，在子组件哪个钩子接收数据。都是取不到的。当子组件的mounted都执行完之后，此时可能父组件的请求才返回数据。会导致，从父组件传递给子组件的数据是undefined。</p><h4 id="解决方法1-v-if"><a href="#解决方法1-v-if" class="headerlink" title="解决方法1:v-if"></a>解决方法1:v-if</h4><p>在渲染子组件的时候加上一个条件,data1是父组件调用接口返回的数据。当有数据的时候在去渲染子组件。这样就会形成天然的阻塞。在父组件的created中的请求返回数据后，才会执行子组件的created，mounted。最后执行父组件的mounted。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">children</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;data1&quot;</span> <span class="hljs-attr">:data</span>=<span class="hljs-string">&quot;data1&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">children</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="在子组件中-watch-监听，父组件获取到值，这个值就会变化，自然是可以监听到的"><a href="#在子组件中-watch-监听，父组件获取到值，这个值就会变化，自然是可以监听到的" class="headerlink" title="在子组件中 watch 监听，父组件获取到值，这个值就会变化，自然是可以监听到的"></a>在子组件中 watch 监听，父组件获取到值，这个值就会变化，自然是可以监听到的</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe">watch:<span class="hljs-type"></span>&#123;<br>    data:<span class="hljs-type"></span>&#123;<br>      deep:<span class="hljs-type">true</span>,<br>      handler:<span class="hljs-type">function</span>(<span class="hljs-keyword">new</span><span class="hljs-type">Val</span>,oldVal) &#123;<br>        <span class="hljs-built_in">this</span>.$nextTick(() =&gt; &#123;<br>          <span class="hljs-built_in">this</span>.data = <span class="hljs-keyword">new</span><span class="hljs-type">Val</span><br><span class="hljs-type"></span>          <span class="hljs-built_in">this</span>.data = <span class="hljs-keyword">new</span><span class="hljs-type">Val</span>.url ? <span class="hljs-keyword">new</span><span class="hljs-type">Val</span>.url : <span class="hljs-type"></span>&#x27;<span class="hljs-string">&#x27;</span><br><span class="hljs-string">        &#125;)</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>从父组件点击调用接口并显示子组件，子组件拿到数据并监听在watch中调用方法并显示</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844904113914773518#comment">Vue中父子组件生命周期执行顺序回顾</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS项目优化问题</title>
    <link href="/2022/02/26/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/"/>
    <url>/2022/02/26/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>总结了最近的一些面试题和之前的知识点</p><hr><h3 id="防止表单重复提交的解决方案"><a href="#防止表单重复提交的解决方案" class="headerlink" title="防止表单重复提交的解决方案"></a>防止表单重复提交的解决方案</h3><p>用户在操作表单Post数据时往往会出现表单数据重复提交的问题，尤其在Web开发中此类问题比较常见。刷新页面，后退操作以前的页面，单机多次按钮都会导致数据重复提交。此类问题是因为浏览器重复提交HTTP请求导致。</p><h4 id="1、-在数据库添加唯一字段"><a href="#1、-在数据库添加唯一字段" class="headerlink" title="1、 在数据库添加唯一字段"></a>1、 在数据库添加唯一字段</h4><p>在数据库建表的时候在ID字段添加主键约束，账号，名称的信息添加唯一性约束。确保数据库只可以添加一条数据。<br>此方法从根本上的防止了数据重复提交。</p><h4 id="2、-用js为添加按钮禁用"><a href="#2、-用js为添加按钮禁用" class="headerlink" title="2、 用js为添加按钮禁用"></a>2、 用js为添加按钮禁用</h4><p>当用户提交表单之后，可以使用js将提交按钮隐藏（disable属性），防止用户多次点击按钮提交数据。<br>注意：如果客户端禁用了js，则此方法无效。</p><h4 id="3、-使用Post-Redirect-Get"><a href="#3、-使用Post-Redirect-Get" class="headerlink" title="3、 使用Post/Redirect/Get"></a>3、 使用Post/Redirect/Get</h4><p>Post/Redirect/Get简称PRG，是一种可以防止表单数据重复提交的一种Web设计模式，像用户刷新提交响应页面等比较典型的重复提交表单数据的问题可以使用PRG模式来避免。例如：当用户提交成功之后，执行客户端重定向，跳转到提交成功页面。<br>注意：PRG设计模式并不适用所有的重复提交情况，比如：</p><p>1）由于服务器响应缓慢，用户刷新提交POST请求造成的重复提交。</p><p>2）用户点击后退按钮，返回到数据提交界面，导致的数据重复提交。</p><p>3）用户多次点击提交按钮，导致的数据重复提交。</p><p>4）用户恶意避开客户端预防多次提交手段，进行重复数据提交。</p><h4 id="4、-使用Session设置令牌"><a href="#4、-使用Session设置令牌" class="headerlink" title="4、 使用Session设置令牌"></a>4、 使用Session设置令牌</h4><p>客户端请求页面时，服务器为每次产生的Form表单分配唯一的随机标识号，并且在Form的一个隐藏字段中设置这个标识号，同时在当前用户的Session中保存这个标识号。当提交表单时，服务器比较hidden和session中的标识号是否相同，相同则继续，处理完后清空Session，否则服务器忽略请求。</p><p>注意：恶意用户可利用这一性质，不断重复访问页面，以致Session中保存的标识号不断增多，最终严重消耗服务器内存。可以采用在Session中记录用户发帖的时间，然后通过一个时间间隔来限制用户连续发帖的数量来解决这一问题。</p><h5 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h5><p><a href="https://juejin.cn/post/6968747879682801672">防止表单重复提交的解决方案整理</a></p><h3 id="面试题：渲染十万条数据解决方案"><a href="#面试题：渲染十万条数据解决方案" class="headerlink" title="面试题：渲染十万条数据解决方案"></a>面试题：渲染十万条数据解决方案</h3><p>虚拟列表是最主流的解决方案，不渲染所有的数据，只渲染可视区域中的数据。当用户滑（滚）动时，通过监听 scroll 来判断是上滑还是下拉，从而更新数据。同理 IntersectionObserver 和 getBoundingClientRect 都能实现</p><p>延迟渲染，也叫懒加载。顾名思义，最开始不渲染所有数据，只渲染可视区域中的数据（同虚拟列表一致）。当滚动到页面底部时，添加数据（concat），视图渲染新增DOM</p><p>时间分片主要是分批渲染DOM，使用 requestAnimationFrame 来让动画更加流畅</p><h4 id="虚拟列表（也叫按需渲染或可视区域渲染）"><a href="#虚拟列表（也叫按需渲染或可视区域渲染）" class="headerlink" title="虚拟列表（也叫按需渲染或可视区域渲染）"></a>虚拟列表（也叫按需渲染或可视区域渲染）</h4><h5 id="什么是虚拟列表"><a href="#什么是虚拟列表" class="headerlink" title="什么是虚拟列表"></a>什么是虚拟列表</h5><p>虚拟列表是按需显示的一种实现，即只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，是对长列表渲染的优化手段<br>说的明白一点，就是展示可视区域中的内容，当你向上向下滚动时，通过 DOM API 替换可视区域中的数据，做到动态加载十万条数据</p><h5 id="两种解决思路"><a href="#两种解决思路" class="headerlink" title="两种解决思路"></a>两种解决思路</h5><p>关于无限滚动，早期通过监听 scroll 事件，这是最常见的解决方案。可去 图片懒加载 中查看，简单来说，就是通过子项的 offsetTop（偏移高度）与 innerHeight（视窗高度）+ scrollTop（滚动高度）做对比来实现，当偏移高度 &lt; 视窗高度+滚动高度时，说明已经滚到下方，就可展示图片<br>在 图片懒加载 中我们也提及 IntersectionObserver（交叉观察者）API，以此来解决 scroll 所不具备的效果，即  IntersectionObserver API 是异步的，不随目标元素的滚动同步触发，性能消耗小。当然还可以通过 getBoundingClientRect 来实现，getBoundingClientRect 方法返回元素的大小机器相对于视窗的位置</p><h6 id="scroll-解决方案"><a href="#scroll-解决方案" class="headerlink" title="scroll 解决方案"></a>scroll 解决方案</h6><p>先说 scroll 解决方案，简单来说，就是对其传来的数据进行分割展示，用到 slice 方法，它会返回一个新的数组<br>我们假设单个列表高度为 30px，一页展示的列表数量为 const count = Math.ceil(列表高度 / 30)，展示的数据就是 visibleData = data.slice(start, start + count)（start 一开始为0）<br>当滚动时，动态修改 start 和 visibleData</p><p>虚拟列表scroll无virtual-list-phantom</p><p>这种方法的精髓在于设置开始渲染的点和展示的数据，当他滚动时动态修改，但是因为 scroll 会频繁触发，当渲染的数据变多后会有性能问题</p><h6 id="IntersectionObserver-解决方案"><a href="#IntersectionObserver-解决方案" class="headerlink" title="IntersectionObserver 解决方案"></a>IntersectionObserver 解决方案</h6><p>通过 IntersectionObserver 的特性，当目标对象中的 entry.isIntersecting 为 true 或者 intersectionRatio &gt; 0 （元素与祖先元素交叉、可见）时，说明本来不可见的元素浮现在视图中，表示它向上或向下滑动，我们动态设置视图中的顶部和底部 id 即可对其判断。当下滑时 entry.traget.id === ‘bottom’，我们修改 start 和 end；同理，当上滑时entry.traget.id === ‘top 时，我们也一样修改 start 和 end</p><h4 id="延迟渲染（即懒渲染）"><a href="#延迟渲染（即懒渲染）" class="headerlink" title="延迟渲染（即懒渲染）"></a>延迟渲染（即懒渲染）</h4><h5 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h5><p>不多介绍，一句话解释：最开始不渲染所有数据，只展示视图上可见的数据，当滚动到页面底部时，加载更多数据<br>实现原理：通过监听父级元素的 scroll 事件，当然也可以通过 IntersectionObserver 或 getBoundingClientRect 等 API 实现<br>但 scroll 事件会频繁触发，所以需要手写节流；滚动元素内有大量 DOM ，容易造成卡顿，建议使用 IntersectionObserver</p><h4 id="时间分片"><a href="#时间分片" class="headerlink" title="时间分片"></a>时间分片</h4><p>参考 如何高性能的渲染十万条数据(时间分片)  所举例子，对于大量数据渲染时，JS 运算并不是性能的瓶颈，性能的瓶颈主要在于渲染阶段。也就是说 JS 执行是很快的，页面卡顿是因为同时渲染大量 DOM 所引起的，可采用分批渲染的方式来解决</p><p>我的理解是，通过递归来渲染DOM，刚开始可以是20个，20个渲染完后再渲染剩下的，循环如此，将其全部渲染完。又因为浏览器的渲染机制是“宏任务—微任务—GUI渲染—宏任务…”。遂第一个 loop 执行后，先等页面渲染完，再执行下一轮的 setTimeout（宏任务）</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>渲染十万条数据有三种解决方案，为虚拟列表、懒加载、时间分片。最优选是虚拟列表，DOM 树上只挂载有限的DOM；懒加载和时间分片的缺点在于插入大量的DOM，占内存运行时会造成卡顿<br>无论是虚拟列表还是懒加载，传统的做法是 scroll + 节流，这种做法的优势是老 API，兼容性刚刚的，缺点是，滑多了还是会引起性能问题，当然 IntersectionObserver 也是一样的，无非是换了个 API 做“元素是否出现在视图”判断，最好的方案是用 IntersectionObserver（交叉观察器），异步加载、性能消耗小</p><p><a href="https://juejin.cn/post/7065218958663614500#heading-3">面试题：渲染十万条数据解决方案</a></p><h3 id="实现图片懒加载-Lazyload"><a href="#实现图片懒加载-Lazyload" class="headerlink" title="实现图片懒加载(Lazyload)"></a>实现图片懒加载(Lazyload)</h3><p>懒加载的意义（为什么要使用懒加载）<br>对页面加载速度影响最大的就是图片，一张普通的图片可以达到几M的大小，而代码也许就只有几十KB。当页面图片很多时，页面的加载速度缓慢，几S钟内页面没有加载完成，也许会失去很多的用户。<br>所以，对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样子对于页面加载性能上会有很大的提升，也提高了用户体验。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>将页面中的img标签src指向一张小图片或者字符串，然后定义data-src（这个属性可以自定义命名，我才用data-src）属性指向真实的图片。src指向一张默认的图片，否则当src为空时也会向服务器发送一次请求。可以指向loading的地址。</p><p>注：图片要指定宽高</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;default.jpg&quot;</span> <span class="hljs-attribute">data-src</span>=<span class="hljs-string">&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot;</span> /&gt;复制代码当载入页面时，先把可视区域内的img标签的<br></code></pre></td></tr></table></figure><p>data-src属性值负给src，然后监听滚动事件，把用户即将看到的图片加载。这样便实现了懒加载。<br>JavaScript</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> num = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;img&#x27;</span>).length;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> img = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&quot;img&quot;</span>);</span><br><span class="javascript">    <span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>; <span class="hljs-comment">//存储图片加载到的位置，避免每次都从第一张图片开始遍历</span></span><br><br><span class="javascript">    lazyload(); <span class="hljs-comment">//页面载入完毕加载可是区域内的图片</span></span><br><br><span class="javascript">    <span class="hljs-built_in">window</span>.onscroll = lazyload;</span><br><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyload</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">//监听页面滚动事件</span></span><br><span class="javascript">        <span class="hljs-keyword">var</span> seeHeight = <span class="hljs-built_in">document</span>.documentElement.clientHeight; <span class="hljs-comment">//可见区域高度</span></span><br><span class="javascript">        <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-built_in">document</span>.documentElement.scrollTop || <span class="hljs-built_in">document</span>.body.scrollTop; <span class="hljs-comment">//滚动条距离顶部高度</span></span><br><span class="javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = n; i &lt; num; i++) &#123;</span><br>            if (img[i].offsetTop &lt; seeHeight + scrollTop) &#123;<br><span class="javascript">                <span class="hljs-keyword">if</span> (img[i].getAttribute(<span class="hljs-string">&quot;src&quot;</span>) == <span class="hljs-string">&quot;default.jpg&quot;</span>) &#123;</span><br><span class="javascript">                    img[i].src = img[i].getAttribute(<span class="hljs-string">&quot;data-src&quot;</span>);</span><br>                &#125;<br>                n = i + 1;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="使用节流函数进行性能优化"><a href="#使用节流函数进行性能优化" class="headerlink" title="使用节流函数进行性能优化"></a>使用节流函数进行性能优化</h4><p>如果直接将函数绑定在scroll事件上，当页面滚动时，函数会被高频触发，这非常影响浏览器的性能。</p><p>我想实现限制触发频率，来优化性能。</p><p>节流函数：只允许一个函数在N秒内执行一次。<br><a href="https://juejin.cn/post/6844903455048335368">实现图片懒加载(Lazyload)</a></p><h3 id="图片预加载"><a href="#图片预加载" class="headerlink" title="图片预加载"></a>图片预加载</h3><p>预加载</p><h4 id="1-什么是预加载"><a href="#1-什么是预加载" class="headerlink" title="1.什么是预加载"></a>1.什么是预加载</h4><p>资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能在将来会被使用到。预加载简单来说就是将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。</p><h4 id="2-为什么要用预加载"><a href="#2-为什么要用预加载" class="headerlink" title="2.为什么要用预加载"></a>2.为什么要用预加载</h4><p>在网页全部加载之前，对一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，直到所有内容加载完毕。</p><h4 id="3-实现预加载的几种办法"><a href="#3-实现预加载的几种办法" class="headerlink" title="3.实现预加载的几种办法"></a>3.实现预加载的几种办法</h4><h5 id="使用HTML标签"><a href="#使用HTML标签" class="headerlink" title="使用HTML标签"></a>使用HTML标签</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;http://pic26.nipic.com/20121213/6168183 0044449030002.jpg&quot;</span> <span class="hljs-attribute">style</span>=<span class="hljs-string">&quot;display:none&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h5 id="使用Image对象"><a href="#使用Image对象" class="headerlink" title="使用Image对象"></a>使用Image对象</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">&lt;script src=<span class="hljs-string">&quot;./myPreload.js&quot;</span>&gt;&lt;/script&gt;<br><span class="hljs-comment">//myPreload.js文件</span><br>var image= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>()<br>image.src=<span class="hljs-string">&quot;http://pic26.nipic.com/20121213/6168183 004444903000 2.jpg&quot;</span><br></code></pre></td></tr></table></figure><h6 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h6><p><a href="https://juejin.cn/post/6844903614138286094#heading-5">懒加载和预加载</a></p><h3 id="判断图片是否加载完成的六种方式"><a href="#判断图片是否加载完成的六种方式" class="headerlink" title="判断图片是否加载完成的六种方式"></a>判断图片是否加载完成的六种方式</h3><p>一、load事件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>img - load event<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;img1&quot;</span><span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://pic1.win4000.com/wallpaper/f/51c3bb99a21ea.jpg&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">        img1.onload =<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">            p1.innerHTML =<span class="hljs-string">&#x27;loaded&#x27;</span></span><br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试，所有浏览器都显示出了“loaded”，说明所有浏览器都支持img的load事件<br>二、img的complete属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>img - complete attribute<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;img1&quot;</span><span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://pic1.win4000.com/wallpaper/f/51c3bb99a21ea.jpg&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>loading...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">functionimgLoad</span>(<span class="hljs-params">img, callback</span>)</span> &#123;</span><br><span class="javascript">            vartimer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br>                if(img.complete) &#123;<br>                    callback(img)<br><span class="javascript">                    <span class="hljs-built_in">clearInterval</span>(timer)</span><br>                &#125;<br>            &#125;, 50)<br>        &#125;<br><span class="javascript">        imgLoad(img1,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">            p1.innerHTML(<span class="hljs-string">&#x27;加载完毕&#x27;</span>)</span><br>        &#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>轮询不断监测img的complete属性，如果为true则表明图片已经加载完毕，停止轮询。该属性所有浏览器都支持。<br><a href="https://www.cnblogs.com/zhusf/p/10607957.html">参考文章</a></p><h3 id="原生JS实现轮播图-方法总结"><a href="#原生JS实现轮播图-方法总结" class="headerlink" title="原生JS实现轮播图 方法总结"></a>原生JS实现轮播图 方法总结</h3><ol><li><p>方法一：<br>利用绝对定位absolute偏移量的改变来实现<br>具有往左往右滑动的效果</p></li><li><p>方法二：<br>利用 display/opacity/visibility状态切换来实现<br>没有往左往右滑动的效果</p></li><li><p>方法三<br>旋转木马轮播图<br>存储每个图片的位置信息（absolute位置信息+z-index属性+opacity透明度 等等）到一个数组。对数组进行pop push shift unshift等操作再引用到DOM元素上，产生轮播效果。<br><a href="https://juejin.cn/post/6850418121606594568">参考</a></p></li></ol><h3 id="实现一个div元素的拖拽-（addEventListen-removeEventListen"><a href="#实现一个div元素的拖拽-（addEventListen-removeEventListen" class="headerlink" title="实现一个div元素的拖拽  （addEventListen/removeEventListen)"></a>实现一个div元素的拖拽  （addEventListen/removeEventListen)</h3><p>1.js 如何实现拖动滑块( mousedown，mousemove，mouseup)<br>实现拖动滑块，先分析，滑块可以拖动应该改变滑块在页面中的坐标，那就采用定位拿到元素的 top 和 left 对它们进行赋值，接下来就是准备事件，既然是鼠标拖动应该具备 mousedown，mousemove，mouseup 三种事件，通过 mousedown 鼠标按下事件选中滑块，mousemove 事件拖动滑块，在拖动滑块的时候获取鼠标在可视窗口的坐标赋值给滑块的 top 和 left<br><a href="https://juejin.cn/post/7001022287981838350">参考</a></p><p>2.实现思路：<br>鼠标按下开始拖拽<br>记录摁下鼠标时的鼠标位置以及元素位置<br>拖动鼠标记下当前鼠标的位置<br>鼠标当前位置-摁下时鼠标位置= 鼠标移动距离<br>元素位置= 鼠标移动距离+鼠标摁下时元素的位置<br><a href="https://www.cnblogs.com/yinping/p/10697083.html">参考</a></p><h3 id="白屏合理性优化"><a href="#白屏合理性优化" class="headerlink" title="白屏合理性优化"></a>白屏合理性优化</h3><p>1、 DNS解析优化<br>针对DNS Lookup环节，我们可以针对性的进行DNS解析优化。</p><p>DNS缓存优化<br>DNS预加载策略<br>稳定可靠的DNS服务器</p><p>2、 TCP网络链路优化<br>针对网络链路的优化，好像除了花钱没有什么更好的方式！<br>3、 服务端处理优化<br>服务端的处理优化，是一个非常庞大的话题，会涉及到如Redis缓存、数据库存储优化或是系统内的各种中间件以及Gzip压缩等…<br>4、 浏览器下载、解析、渲染页面优化<br>根据浏览器对页面的下载、解析、渲染过程，可以考虑一下的优化处理：<br>尽可能的精简HTML的代码和结构<br>尽可能的优化CSS文件和结构<br>一定要合理的放置JS代码，尽量不要使用内联的JS代码<br><a href="https://juejin.cn/post/6943471935934185503">「面试」-优化白屏</a></p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue--Observer、Dep、Watcher</title>
    <link href="/2022/02/25/Vue--Observer%E3%80%81Dep%E3%80%81Watcher/"/>
    <url>/2022/02/25/Vue--Observer%E3%80%81Dep%E3%80%81Watcher/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="Vue-初始化"><a href="#Vue-初始化" class="headerlink" title="Vue 初始化"></a>Vue 初始化</h3><p>我觉得搞清楚这些，首先要知道 vue 初始化的过程。我们从 new Vue() 开始，构造函数会执行 this._init，在_init 中会进行合并配置、初始化生命周期、事件、渲染等，最后执行 vm.$mount 进行挂载。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> src<span class="hljs-regexp">/core/i</span>nstance/index.js<br><span class="hljs-keyword">function</span> Vue (options) &#123;<br>    <span class="hljs-regexp">//</span> ...<br>    this._init(options)<br>&#125;<br><br><span class="hljs-regexp">//</span> src<span class="hljs-regexp">/core/i</span>nstance/init.js<br>Vue.prototype._init = <span class="hljs-keyword">function</span> (options?: Object) &#123;<br>    <span class="hljs-regexp">//</span> 合并配置<br>    <span class="hljs-regexp">//</span> ...<br>    <br>    <span class="hljs-regexp">//</span> 一系列初始化<br>    <span class="hljs-regexp">//</span> ...<br>    initState(vm)<br>    <span class="hljs-regexp">//</span> ...<br>    <br>    <span class="hljs-keyword">if</span> (vm.<span class="hljs-variable">$options</span>.el) &#123;<br>      vm.<span class="hljs-variable">$mount</span>(vm.<span class="hljs-variable">$options</span>.el)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里主要来看 <strong>initState(vm)</strong>，响应式的核心均在于此，会进行<strong>props、data、computed、watch</strong>  的初始化操作。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> src<span class="hljs-regexp">/core/i</span>nstance/state.js<br>export <span class="hljs-keyword">function</span> initState (vm: Component) &#123;<br>    vm._watchers = []<br>    const opts = vm.<span class="hljs-variable">$options</span><br>    <span class="hljs-keyword">if</span> (opts.props) initProps(vm, opts.props) <span class="hljs-regexp">//</span> 初始化 props<br>    <span class="hljs-regexp">//</span> ...<br>    <span class="hljs-keyword">if</span> (opts.data) &#123;<br>        initData(vm) <span class="hljs-regexp">//</span> 初始化 data<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        observe(vm._data = &#123;&#125;, true <span class="hljs-regexp">/* asRootData */</span>)<br>    &#125;<br>    <span class="hljs-regexp">//</span> ...<br>&#125;<br></code></pre></td></tr></table></figure><p>了解了初始化过程，接下来就引出 Observer。</p><h3 id="Obserber-「数据的观察者」"><a href="#Obserber-「数据的观察者」" class="headerlink" title="Obserber 「数据的观察者」"></a>Obserber 「数据的观察者」</h3><p>在上面的 initData 中会执行 observe 方法进而实例化 Observer。Observer 的实例化过程就是递归地把 data 对象和子对象添加 <strong>ob</strong> 属性同时通过我们熟知的 defindReactive 为属性定义 getter/setter。</p><p>那么 Observer 顾名思义是观察者，观察的就是 data，它通过数据劫持使 data 的读写都处于它的监管之下。那么在观察到数据发生变化时会做出怎样的操作呢？</p><p>来到 defindReactive 的核心代码，会看到 getter 里的 dep.depend() 和 setter 里的 dep.notify()，这就是依赖收集和触发更新的起点。这里的 dep 是 defindReactive 内定义的一个常量，getter/setter 函数内持有对它的闭包引用，Dep 就是引出的下一个概念。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// src/core/observer/index.js</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep()<br><span class="hljs-comment">// ...</span><br>Object.defineProperty(obj, key, &#123;<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>    <span class="hljs-keyword">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveGetter</span> <span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        dep.depend()<br>        <span class="hljs-comment">//...</span><br>    &#125;,<br>    <span class="hljs-keyword">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveSetter</span> <span class="hljs-params">(newVal)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        dep.notify()<br>    &#125;,<br></code></pre></td></tr></table></figure><h3 id="Dep-「依赖管理」"><a href="#Dep-「依赖管理」" class="headerlink" title="Dep 「依赖管理」"></a>Dep 「依赖管理」</h3><p>先看下 Dep 类的定义</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs perl">// src/core/observer/dep.js<br>export default class Dep &#123;<br>    constructor () &#123;<br>        this.id = uid++<br>        this.subs = []<br>    &#125;<br><br>    addSub (<span class="hljs-function"><span class="hljs-keyword">sub</span>: <span class="hljs-title">Watcher</span>) </span>&#123;&#125;<br><br>    removeSub (<span class="hljs-function"><span class="hljs-keyword">sub</span>: <span class="hljs-title">Watcher</span>) </span>&#123;&#125;<br><br>    depend () &#123;&#125;<br>    <br>    notify () &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 Dep 有一个实例属性 subs 数组，实例方法 addSub/removeSub 添加和删除数组中的某项。由此可以确定 dep 实例并非依赖而是依赖的管理者，subs 数组即为依赖(订阅者)列表，它们就是接下来登场的 Watcher</p><h3 id="Watcher-「订阅者」"><a href="#Watcher-「订阅者」" class="headerlink" title="Watcher 「订阅者」"></a>Watcher 「订阅者」</h3><p>从上面知道 Observer Dep 都已经在 initState 中实例化了，响应式数据和依赖管理都准备好了，接下来就需要 Wacther 来订阅了。那么 Wacther 什么时候实例化呢，回到开头的初始化过程最后 vm.$mount 挂载，在这之后会执行 mountComponent 方法，Watcher 就是在这里实例化的（暂不关注 computed watcher 和 watch 选项的 watcher）。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> src<span class="hljs-regexp">/core/i</span>nstance/lifecycle.js<br>export <span class="hljs-keyword">function</span> mountComponent () &#123;<br>    <span class="hljs-regexp">//</span> ...<br>    new Watcher(vm, updateComponent, noop, &#123;<br>        <span class="hljs-regexp">//</span> ...<br>    &#125;, true <span class="hljs-regexp">/* isRenderWatcher */</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>Watcher 的定义如下，实例化时会执行 get 方法对传入的 updateComponent 进行求值，updateComponent 也就是 _render 函数，执行_render 函数会读取 data 数据从而触发 getter 进行依赖收集。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> src<span class="hljs-regexp">/core/</span>observer/watcher.js<br>export default class Watcher &#123;<br>    <br>    <span class="hljs-regexp">//</span> 对 getter 求值，进行依赖收集<br>    get () &#123;&#125;<br>    <br>    <span class="hljs-regexp">//</span> 触发更新<br>    update() &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，我们可以总结一下三者的关系：</p><ol><li><p>Observer 将数据定义为响应式，每个 Observer 实例都有自己的 Dep 来管理依赖。实例化 Wacther 的时候进行求值会触发 getter ，进而执行 dep.depend() 将当前 Wacther 加入 Dep 维护的依赖列表，这就是依赖收集过程。</p></li><li><p>数据发生变化触发 setter 执行 dep.notify，Dep 会执行所有依赖的 update 方法并加入异步更新队列，这就是触发依赖过程。<br><img src="/imageO/Dep.jpg" alt="dep"></p></li></ol><h4 id="转载文章"><a href="#转载文章" class="headerlink" title="转载文章"></a>转载文章</h4><p><a href="https://juejin.cn/post/6844904128028622861">Observer、Dep、Watcher 傻傻搞不清楚</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整理一些最近面试遇到的问题（春招）</title>
    <link href="/2022/02/22/%E9%9D%A2%E8%AF%95%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/02/22/%E9%9D%A2%E8%AF%95%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>总结了最近的一些面试题和之前的知识点</p><hr><h3 id="同花顺一面（凉经）-2022-3-7-10-00-1h5min"><a href="#同花顺一面（凉经）-2022-3-7-10-00-1h5min" class="headerlink" title="同花顺一面（凉经） 2022.3.7 10:00  1h5min"></a>同花顺一面（凉经） 2022.3.7 10:00  1h5min</h3><h4 id="HTML-语义化"><a href="#HTML-语义化" class="headerlink" title="HTML 语义化"></a>HTML 语义化</h4><p>概念：HTML5的语义化指的是合理正确的使用语义化的标签来创建页面结构。【正确的标签做正确的事】<br>语义化标签：header nav main article section aside footer<br>语义化的优点:<br>在没CSS样式的情况下，页面整体也会呈现很好的结构效果<br>代码结构清晰，易于阅读，<br>利于开发和维护 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。<br>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重</p><h4 id="说一下跨域，如何解决跨域"><a href="#说一下跨域，如何解决跨域" class="headerlink" title="说一下跨域，如何解决跨域"></a>说一下跨域，如何解决跨域</h4><p><a href="https://pengzhenglong.github.io/2022/01/07/%E8%AE%A1%E7%BD%91+%E6%B5%8F%E8%A7%88%E5%99%A8+http+%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96%EF%BC%9F">博客</a></p><h4 id="讲讲Dom渲染性能消耗-没理解–讲了diff算法去了"><a href="#讲讲Dom渲染性能消耗-没理解–讲了diff算法去了" class="headerlink" title="讲讲Dom渲染性能消耗 (没理解–讲了diff算法去了)"></a>讲讲Dom渲染性能消耗 (没理解–讲了diff算法去了)</h4><blockquote><p>js 操作 Dom 很耗性能，其实是在说很耗浏览器性能，具体和 js计算 性能没多大的关系</p></blockquote><p>优化方案<br>DOM操作的背后，隐藏这不止止是文中所描述的这些代价。为了给用户更好的浏览体验，可以有以下优化的方案：<br>减少DOM操作如果在一个局部方法中需要多次访问同一个dom，则先暂存它的引用<br>采用更高效的API或者更高效的写法<br>1）用querySelectorAll()替代getElementByXX()。<br>2）开启动画的GPU加速，把渲染计算交给GPU<br>3）用事件委托来减少事件处理器的数量。<br>4）<strong>使用react、vue等页面框架来编写View页面。react采用虚拟dom，尽可能的讲多次重排浓缩成一次。<br>减少重排</strong><br>CSS及动画处理<br>1）用更高效的css3效果，通过类名控制动画，尽量避免直接操作DOM属性；<br>2）在动画的元素多嵌套一层div，尽量用绝对定位或者固定定位使其脱离文档流，再进行动画处理；<br>3）尽量在滚动的时候，停止动画；<br>4）动画实现的速度选择。以1px移动最为平滑，但是reflow就会果与频繁，建议以3px移动则会好很多。<br><a href="https://zhuanlan.zhihu.com/p/86153264">知乎</a></p><h4 id="v-if-v-show"><a href="#v-if-v-show" class="headerlink" title="v-if  v-show"></a>v-if  v-show</h4><h4 id="数组的key的作用"><a href="#数组的key的作用" class="headerlink" title="数组的key的作用"></a>数组的key的作用</h4><p><a href="https://pengzhenglong.github.io/2022/01/10/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#Vue%E4%B8%AD%E7%9A%84key%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E2%BD%A4%EF%BC%9F">博客</a></p><h4 id="vue-data为什么不是一个对象"><a href="#vue-data为什么不是一个对象" class="headerlink" title="vue  data为什么不是一个对象"></a>vue  data为什么不是一个对象</h4><p><a href="https://pengzhenglong.github.io/2022/01/10/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#%E4%B8%BA%E4%BB%80%E4%B9%88vue%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84data%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F">博客</a></p><h4 id="计算属性的原理"><a href="#计算属性的原理" class="headerlink" title="计算属性的原理"></a>计算属性的原理</h4><h4 id="双向数据绑定原理-defineProperty-proxy"><a href="#双向数据绑定原理-defineProperty-proxy" class="headerlink" title="双向数据绑定原理  defineProperty  proxy"></a>双向数据绑定原理  defineProperty  proxy</h4><p><a href="https://pengzhenglong.github.io/2022/01/10/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#Vue%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">博客</a></p><h4 id="vue3有了解吗-为什么可以监听数组"><a href="#vue3有了解吗-为什么可以监听数组" class="headerlink" title="vue3有了解吗  为什么可以监听数组"></a>vue3有了解吗  为什么可以监听数组</h4><p><a href="https://pengzhenglong.github.io/2022/01/10/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#defineProperty-%E5%92%8C-Proxy-%E7%9A%84%E5%8C%BA%E5%88%AB">博客</a></p><h4 id="defineProperty-proxy的区别-源码"><a href="#defineProperty-proxy的区别-源码" class="headerlink" title="defineProperty  proxy的区别 源码"></a>defineProperty  proxy的区别 源码</h4><h4 id="react-–不了解"><a href="#react-–不了解" class="headerlink" title="react  –不了解"></a>react  –不了解</h4><h4 id="选择器-权重"><a href="#选择器-权重" class="headerlink" title="选择器  权重"></a>选择器  权重</h4><p><a href="https://pengzhenglong.github.io/2022/02/15/CSS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#css%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7">博客</a></p><h4 id="动画了解吗"><a href="#动画了解吗" class="headerlink" title="动画了解吗"></a>动画了解吗</h4><h5 id="js动画了解吗-css动画-canvas"><a href="#js动画了解吗-css动画-canvas" class="headerlink" title="js动画了解吗  css动画  canvas"></a>js动画了解吗  css动画  canvas</h5><h5 id="Js-动画与-CSS-动画区别及相应实现"><a href="#Js-动画与-CSS-动画区别及相应实现" class="headerlink" title="Js 动画与 CSS 动画区别及相应实现"></a>Js 动画与 CSS 动画区别及相应实现</h5><p><a href="https://pengzhenglong.github.io/2022/02/15/CSS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#Js-%E5%8A%A8%E7%94%BB%E4%B8%8E-CSS-%E5%8A%A8%E7%94%BB%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%AE%9E%E7%8E%B0">博客</a></p><h4 id="给一张图片用canvas怎么画出来-（api）"><a href="#给一张图片用canvas怎么画出来-（api）" class="headerlink" title="给一张图片用canvas怎么画出来  （api）"></a>给一张图片用canvas怎么画出来  （api）</h4><p>drawImage()向画布上绘制图像、画布或视频。</p><h4 id="css预处理-sass-less-stylus-有什么区别-哪个更好用"><a href="#css预处理-sass-less-stylus-有什么区别-哪个更好用" class="headerlink" title="css预处理  sass  less  stylus 有什么区别  哪个更好用"></a>css预处理  sass  less  stylus 有什么区别  哪个更好用</h4><h5 id="下面从特性上比较三者异同"><a href="#下面从特性上比较三者异同" class="headerlink" title="下面从特性上比较三者异同"></a>下面从特性上比较三者异同</h5><ol><li>变量：<br>Sass声明变量必须是『$』开头，后面紧跟变量名和变量值，而且变量名和变量值需要使用冒号：分隔开。<br>Less 声明变量用『@』开头，其余等同 Sass。<br>Stylus 中声明变量没有任何限定，结尾的分号可有可无，但变量名和变量值之间必须要有『等号』。但需要注意的是，如果用“@”符号来声明变量，Stylus会进行编译，但不会赋值给变量。就是说，Stylus 不要使用『@』声明变量。Stylus 调用变量的方法和Less、Sass完全相同。</li><li>作用域：<br>css 预编译器把变量赋予作用域，也就是存在生命周期。就像 js 一样，它会先从局部作用域查找变量，依次向上级作用域查找。<br><strong>Sass：三者最差，不存在全局变量的概念。也就是说在 Sass 中定义了相同名字的变量时你就要小心蛋疼了。<br>Less：我认为跟 JS 一样，逐级查找，向上冒泡。<br>Stylus：完全等同 Less。Stylus 和 Sass 则更倾向于指令式。</strong></li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>个人认为：<br>Sass和Less语法严谨、Stylus相对自由。因为Less长得更像 css，所以它可能学习起来更容易。<br>Sass 和 Compass、Stylus 和 Nib 都是好基友。<br>Sass 和 Stylus 都具有类语言的逻辑方式处理：条件、循环等，而 Less 需要通过When等关键词模拟这些功能，这方面 Less 比不上 Sass 和 Stylus。<br>Less 在丰富性以及特色上都不及 Sass 和 Stylus，若不是因为 Bootstrap 引入了 Less，可能它不会像现在这样被广泛应用（个人愚见）。<br>身边有几个朋友在 css 预编译器的选择上犹豫不决，其实我认为选择什么无所谓，关键在于你的熟练程度以及团队合作方面的有利性。<br>当然，在大致学习、使用和研究了这三种 css 预编译器之后，我想我会选择 Stylus，它的语法自由度很高，而且写出来的代码非常简洁，这点十分吸引我。</p><h4 id="es6新特性-let-const-模板字符串-扩展运算符-箭头函数-promise-async-await"><a href="#es6新特性-let-const-模板字符串-扩展运算符-箭头函数-promise-async-await" class="headerlink" title="es6新特性   let  const  模板字符串  扩展运算符  箭头函数  promise  async  await"></a>es6新特性   let  const  模板字符串  扩展运算符  箭头函数  promise  async  await</h4><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>在代码块内，使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区</p><h4 id="promise-讲讲-async-await"><a href="#promise-讲讲-async-await" class="headerlink" title="promise  讲讲  async   await"></a>promise  讲讲  async   await</h4><p><a href="https://pengzhenglong.github.io/2022/01/05/JS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F">博客</a></p><h4 id="浏览器事件循环机制"><a href="#浏览器事件循环机制" class="headerlink" title="浏览器事件循环机制"></a>浏览器事件循环机制</h4><p><a href="https://pengzhenglong.github.io/2022/01/05/JS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/#EventLoop-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">博客</a></p><h4 id="闭包讲讲-闭包优化-使用场景-防抖节流"><a href="#闭包讲讲-闭包优化-使用场景-防抖节流" class="headerlink" title="闭包讲讲   闭包优化 使用场景 (防抖节流)"></a>闭包讲讲   闭包优化 使用场景 (防抖节流)</h4><p><a href="https://pengzhenglong.github.io/2022/01/05/JS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/#%E9%97%AD%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%EF%BC%9F">博客</a><br><a href="https://pengzhenglong.github.io/2022/01/05/JS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/#%E9%98%B2%E6%8A%96-amp-amp-%E8%8A%82%E6%B5%81">防抖节流</a></p><h4 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制  *"></a>垃圾回收机制  *</h4><p><a href="https://pengzhenglong.github.io/2022/01/05/JS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/#JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">博客</a></p><h4 id="基本数据类型-BigInt讲讲（项目中有用过吗）-Symbol"><a href="#基本数据类型-BigInt讲讲（项目中有用过吗）-Symbol" class="headerlink" title="基本数据类型   BigInt讲讲（项目中有用过吗）  Symbol"></a>基本数据类型   BigInt讲讲（项目中有用过吗）  Symbol</h4><p><a href="https://pengzhenglong.github.io/2022/01/05/JS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/#js%E7%A7%8D8%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">博客</a></p><h4 id="深拷贝-浅拷贝"><a href="#深拷贝-浅拷贝" class="headerlink" title="深拷贝 浅拷贝"></a>深拷贝 浅拷贝</h4><p><a href="https://pengzhenglong.github.io/2022/01/05/JS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D">博客</a></p><h4 id="网站性能优化-实习时给公司维护的网站-懒加载-（src先设置为字符串，后改变图片路径src）"><a href="#网站性能优化-实习时给公司维护的网站-懒加载-（src先设置为字符串，后改变图片路径src）" class="headerlink" title="网站性能优化(实习时给公司维护的网站)  懒加载 （src先设置为字符串，后改变图片路径src）"></a>网站性能优化(实习时给公司维护的网站)  懒加载 （src先设置为字符串，后改变图片路径src）</h4><p>预加载：</p><ol><li>使用html标签，设置为dispaly:none</li><li>使用Image对象<br><a href="https://pengzhenglong.github.io/2022/01/05/JS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/#%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD">博客</a></li></ol><h4 id="pc端和移动端-适配-媒体查询"><a href="#pc端和移动端-适配-媒体查询" class="headerlink" title="pc端和移动端 适配  媒体查询"></a>pc端和移动端 适配  媒体查询</h4><h5 id="判断屏幕宽度（现在有一个折叠屏宽度怎么区分呢）他说要怎么区分，我答的是如何适配（好像不是）"><a href="#判断屏幕宽度（现在有一个折叠屏宽度怎么区分呢）他说要怎么区分，我答的是如何适配（好像不是）" class="headerlink" title="判断屏幕宽度（现在有一个折叠屏宽度怎么区分呢）他说要怎么区分，我答的是如何适配（好像不是）"></a>判断屏幕宽度（现在有一个折叠屏宽度怎么区分呢）他说要怎么区分，我答的是如何适配（好像不是）</h5><h4 id="单位-px-em-rem-vh-vw"><a href="#单位-px-em-rem-vh-vw" class="headerlink" title="单位  px  em  rem  vh  vw"></a>单位  px  em  rem  vh  vw</h4><h4 id="浏览器输入url发生了什么-tcp连接3次握手，四次挥手（详细讲讲）"><a href="#浏览器输入url发生了什么-tcp连接3次握手，四次挥手（详细讲讲）" class="headerlink" title="浏览器输入url发生了什么  tcp连接3次握手，四次挥手（详细讲讲）"></a>浏览器输入url发生了什么  tcp连接3次握手，四次挥手（详细讲讲）</h4><p><a href="https://pengzhenglong.github.io/2021/05/27/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%BF%87%E7%A8%8B%E9%9D%A2%E8%AF%95/#URL%E7%9A%84%E8%BE%93%E5%85%A5%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E4%BA%8B%E4%BB%B6">博客</a></p><h4 id="tcp与udp的区别-再讲一下两个主要的区别"><a href="#tcp与udp的区别-再讲一下两个主要的区别" class="headerlink" title="tcp与udp的区别   (再讲一下两个主要的区别)"></a>tcp与udp的区别   (再讲一下两个主要的区别)</h4><p><a href="https://pengzhenglong.github.io/2022/01/07/%E8%AE%A1%E7%BD%91+%E6%B5%8F%E8%A7%88%E5%99%A8+http+%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB">博客</a></p><h4 id="我们现在视频传输的协议是？-答的是https-百度是udp"><a href="#我们现在视频传输的协议是？-答的是https-百度是udp" class="headerlink" title="我们现在视频传输的协议是？  答的是https    百度是udp"></a>我们现在视频传输的协议是？  答的是https    百度是udp</h4><h4 id="Https和Http的区别"><a href="#Https和Http的区别" class="headerlink" title="Https和Http的区别"></a>Https和Http的区别</h4><p><a href="https://pengzhenglong.github.io/2022/01/07/%E8%AE%A1%E7%BD%91+%E6%B5%8F%E8%A7%88%E5%99%A8+http+%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/#1-http-%E5%92%8C-https-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">博客</a></p><h4 id="项目中用的两个库的有遇到什么难点"><a href="#项目中用的两个库的有遇到什么难点" class="headerlink" title="项目中用的两个库的有遇到什么难点"></a>项目中用的两个库的有遇到什么难点</h4><h4 id="typescript-中-interface-和-type-的区别"><a href="#typescript-中-interface-和-type-的区别" class="headerlink" title="typescript 中 interface 和 type 的区别"></a>typescript 中 interface 和 type 的区别</h4><blockquote><p>相同点 (都可以描述一个对象或者函数&amp;&amp;都允许拓展（extends）)<br>不同点 (<br>  type可以interface不可以：：<br>type 可以声明基本类型别名，联合类型，元组等类型,type 语句中还可以使用 typeof 获取实例的 类型进行赋值 ,<br>  interface可以type不可以：<br>interface 能够声明合并)<br><a href="https://juejin.cn/post/6844903749501059085">参考</a><br>一般来说，如果不清楚什么时候用interface/type，能用 interface 实现，就用 interface , 如果不能就用 type</p></blockquote><h4 id="开始做题（一个数如何转换为千分位（1756346-gt-1-756-346），手撕防抖节流）-没时间了讲讲思路"><a href="#开始做题（一个数如何转换为千分位（1756346-gt-1-756-346），手撕防抖节流）-没时间了讲讲思路" class="headerlink" title="开始做题（一个数如何转换为千分位（1756346-&gt; 1,756,346），手撕防抖节流）(没时间了讲讲思路)"></a>开始做题（一个数如何转换为千分位（1756346-&gt; 1,756,346），手撕防抖节流）(没时间了讲讲思路)</h4><h5 id="千分位分割"><a href="#千分位分割" class="headerlink" title="千分位分割"></a>千分位分割</h5><p>方法一：Number.prototype.toLocaleString()<br>返回这个数字在特定语言环境下的表示字符串。<br>该方法的详细介绍请看mdn developer.mozilla.org / zh - CN / docs /…</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> <span class="hljs-built_in">num</span> = <span class="hljs-number">123456789</span>;<br><span class="hljs-built_in">num</span>.toLocaleString()// <span class="hljs-string">&quot;123,456,789&quot;</span><br></code></pre></td></tr></table></figure><p>该方法的很方便，但是兼容性不是很好</p><p>方法二: 通过正则匹配</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num = <span class="hljs-string">&#x27;12345678&#x27;</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/(?=\B(\d&#123;3&#125;)+$)/g</span><br><span class="hljs-built_in">console</span>.log(num.replace(reg, <span class="hljs-string">&quot;,&quot;</span>)) <span class="hljs-comment">//12,345,678</span><br></code></pre></td></tr></table></figure><p>方法三: 自定义方法分隔</p><p>实现思路：</p><p>将用户传入的数字转为字符串。<br>使用字符串的split方法将其分隔成数组，然后在使用reverse方法进行反转数组。<br>通过用户传入的分割位数来确定需要将数值分为几组。<br>定义一个新数组用来存放添加分隔符的数组。<br>通过分组数来循环确定分隔符的位置。<br>传入的分割位数刚好将数组分组，可能分割符出现在第一位，这时我们需要删除该分隔符，然后反转该添加完分隔符的数组，最后通过join方法转为字符串。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">num, sep, size</span>) </span>&#123;<br>  num += <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">let</span> numArr = num.split(<span class="hljs-string">&quot;&quot;</span>).reverse();<br>  <span class="hljs-keyword">let</span> group = <span class="hljs-built_in">parseInt</span>(numArr.length / <span class="hljs-built_in">size</span>);<br>  <span class="hljs-keyword">let</span> resArr = []<br>  <span class="hljs-comment">// 设置一个变量来控制数组分割的起始和终止</span><br>  <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (group) &#123;<br>    <span class="hljs-comment">// 确定分隔符的位置</span><br>    resArr = [...resArr, ...numArr.slice(<span class="hljs-built_in">size</span> * i, <span class="hljs-built_in">size</span> * (i + <span class="hljs-number">1</span>)), sep]<br>    group--;<br>    i++;<br>  &#125;<br>  <span class="hljs-comment">// 表示参与分割的数组元素个数</span><br>  <span class="hljs-keyword">const</span> restIndex = resArr.length - <span class="hljs-built_in">parseInt</span>(numArr.length / <span class="hljs-built_in">size</span>);<br><br>  <span class="hljs-comment">// 将没参与分组的元素添加到已经添加分隔符的数组中</span><br>  resArr = [...resArr, ...numArr.slice(restIndex)]<br>  <span class="hljs-comment">// 将分隔好的数组反转，并转为字符串。</span><br>  <span class="hljs-keyword">let</span> strNum = resArr.reverse().join(<span class="hljs-string">&#x27;&#x27;</span>)<br>  <span class="hljs-keyword">if</span> (strNum[<span class="hljs-number">0</span>] === sep) &#123;<br>    strNum = strNum.slice(<span class="hljs-number">1</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> strNum;<br>&#125;<br><span class="hljs-built_in">console</span>.log(fn(<span class="hljs-number">12345678</span>, <span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">//12,345,678</span><br></code></pre></td></tr></table></figure><h5 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!-- 防抖 --&gt;<br><span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">debounce</span> (<span class="hljs-params">fn,delay</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span>  timer  = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timer)<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      fn.apply(<span class="hljs-built_in">this</span>)<br>    &#125;,delay)<br>  &#125;<br>&#125;<br>&lt;!-- 节流 --&gt;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn,delay</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span>  flag= <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(flag) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>         fn.call(<span class="hljs-built_in">this</span>)<br>         flag= <span class="hljs-literal">true</span>;<br>      &#125;,delay);<br>    &#125;<br>    flag= <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://pengzhenglong.github.io/2021/05/16/JS&%E9%98%B2%E6%8A%96&%E8%8A%82%E6%B5%81/">博客：防抖节流</a><br><a href="https://juejin.cn/post/7042192025868828702#heading-2">防抖</a></p><h4 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h4><blockquote><p>不要停留在使用层，多看看源码，要理解，http,tcp知识不熟练，沟通能力，表达</p></blockquote><h3 id="金桔科技（2022-3-8-53min-业务场景题偏多）"><a href="#金桔科技（2022-3-8-53min-业务场景题偏多）" class="headerlink" title="金桔科技（2022.3.8 53min  业务场景题偏多）"></a>金桔科技（2022.3.8 53min  业务场景题偏多）</h3><p>登录权限怎么处理 （动态路由）<br>全局引入，按需引入组件<br>1.项目中引入了第三方组件，该组件要升级了怎么处理，升级了要怎么检查（有什么好的替代方案)</p><h3 id="杭州后起智能科技（2022-3-8-20min）"><a href="#杭州后起智能科技（2022-3-8-20min）" class="headerlink" title="杭州后起智能科技（2022.3.8 20min）"></a>杭州后起智能科技（2022.3.8 20min）</h3><ol><li>有100个请求，一次发10个，允许最大容错3个超过3个就抛出异常   怎么处理</li><li>keep-alive  原理  （使用阶段）</li></ol><h3 id="优倍快一面深圳（5-8k）-讲的磕磕盼盼的，不清楚（表达能力不行）"><a href="#优倍快一面深圳（5-8k）-讲的磕磕盼盼的，不清楚（表达能力不行）" class="headerlink" title="优倍快一面深圳（5-8k）(讲的磕磕盼盼的，不清楚（表达能力不行）)"></a>优倍快一面深圳（5-8k）(讲的磕磕盼盼的，不清楚（表达能力不行）)</h3><p>项目上的难点，（说一下）（图片上传那+大文件怎么上传+js怎么压缩一张图片）（图片为什么转换为base64+图片怎么转化为base64的过程+裁剪这一块怎么弄的，FileReader+怎么裁剪的+怎么压缩一张图片）</p><h4 id="预览图片"><a href="#预览图片" class="headerlink" title="预览图片"></a>预览图片</h4><h5 id="1-使用-URL-createObjectURL-预览"><a href="#1-使用-URL-createObjectURL-预览" class="headerlink" title="1. 使用 URL.createObjectURL 预览"></a>1. 使用 URL.createObjectURL 预览</h5><p> URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的 URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。用法用下：</p><p>objectURL = URL.createObjectURL(object);</p><p>其中，object 参数指 用于创建 URL 的 File 对象、Blob 对象或者 MediaSource 对象。</p><h5 id="2-使用-FileReader-预览"><a href="#2-使用-FileReader-预览" class="headerlink" title="2. 使用 FileReader 预览"></a>2. 使用 FileReader 预览</h5><p>FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。同理的，我们也可以通过 input.files[0] 获取到当前选中的图片的 File 对象。</p><p>特别注意，FileReader 和 是异步读取文件或数据的！</p><h5 id="两种方法的对比"><a href="#两种方法的对比" class="headerlink" title="两种方法的对比"></a>两种方法的对比</h5><p>我个人更加倾向于使用 URL.createObjectURL() 。主要原先它的 API 简洁，同步读取，并且他返回的是一个 URL ，比 FileReaer 返回的base64 更加精简。兼容性上，两者都差不多，都是在 WD 的阶段。性能上的对比, 在 chrome 上, 选择了一张 2M 的图片, URL.createObjectURL() 用时是 0 , 而 FileReader 用时 20ms 左右。 0 感觉不太合理，虽然这个方法立刻就会返回一个 URL ，但是我猜测实际上这个 URL 指定的内容还没有生成好，应该是异步生成的，然后才渲染出来的。所以并没有很好的办法来对比他们的性能。</p><p><a href="https://juejin.cn/post/6844903982574338061#heading-3">掘金</a><br>canvas了解吗  (drawImg  api 绘画图片)<br>js大文件上传（切片上传 - 并发控制-断点续传）<br><a href="https://pengzhenglong.github.io/2022/03/08/%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%B9%B6%E5%8F%91/">博客</a><br>Ts访问修饰符<br>class<br>interface  和type<br>promise  /generotor /await  (await后面接受的是什么 )<br>第一行是await   第二行是promise.then,执行顺序是</p><blockquote><p>正常情况下，async中的await命令是一个Promise对象，返回该对象的结果。<br>但如果不是Promise对象的话，就会直接返回对应的值，相当于Promise.resolve()<br>如果在async函数中抛出了错误，则终止错误结果，不会继续向下执行。</p></blockquote><p>then方法为什么可以链式调用</p><blockquote><p>Promise可以链式调用，不过promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用, 它并不像一般我们任务的链式调用一样return this。<br>父子组件的生命周期<br>data为什么是函数而不是对象<br>v-if  v-show  都会触发重绘回流<br>keep-alive  原理</p></blockquote><p>vue数据双向绑定（对数组也是这样的吗）怎么重写数组的方法</p><h6 id="实现一个轮播组件（使用display-none-这样能加动画吗）"><a href="#实现一个轮播组件（使用display-none-这样能加动画吗）" class="headerlink" title="实现一个轮播组件（使用display:none 这样能加动画吗）"></a>实现一个轮播组件（使用display:none 这样能加动画吗）</h6><p>方法一：<br>利用绝对定位absolute偏移量的改变来实现<br>具有往左往右滑动的效果演示代码：</p><p>方法二：<br>利用 display/opacity/visibility状态切换来实现<br>没有往左往右滑动的效果演示代码：</p><p>方法三<br>旋转木马轮播图<br>存储每个图片的位置信息（absolute位置信息+z-index属性+opacity透明度 等等）到一个数组。对数组进行pop push shift unshift等操作再引用到DOM元素上，产生轮播效果。<br><a href="https://juejin.cn/post/6850418121606594568">掘金</a></p><p>使用es5实现一个继承</p><h5 id="创建子类Child，使用原型和构造函数的方式继承父类People的方法，并调用say函数说出姓名和年龄-es5方法"><a href="#创建子类Child，使用原型和构造函数的方式继承父类People的方法，并调用say函数说出姓名和年龄-es5方法" class="headerlink" title="创建子类Child，使用原型和构造函数的方式继承父类People的方法，并调用say函数说出姓名和年龄(es5方法)"></a>创建子类Child，使用原型和构造函数的方式继承父类People的方法，并调用say函数说出姓名和年龄(es5方法)</h5><p>父类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">People</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>     <span class="hljs-built_in">this</span>.name=name;<br>     <span class="hljs-built_in">this</span>.age=age;<br>     <span class="hljs-built_in">this</span>.say=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>         <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我的名字是:&quot;</span>+<span class="hljs-built_in">this</span>.name+<span class="hljs-string">&quot;我今年&quot;</span>+<span class="hljs-built_in">this</span>.age+<span class="hljs-string">&quot;岁！&quot;</span>);<br>     &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>原型继承：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Child(<span class="hljs-params">name</span>, <span class="hljs-params">age</span>)</span>&#123;<br>    this.name = name;<br>    this.age = age;<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype = <span class="hljs-keyword">new</span> <span class="hljs-constructor">People()</span>;<br>var child = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Child(&#x27;Rainy&#x27;, 20)</span>;<br>child.say<span class="hljs-literal">()</span><br></code></pre></td></tr></table></figure><p>构造函数继承：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span><span class="hljs-params">(name, age)</span></span>&#123;<br>    People.call(<span class="hljs-keyword">this</span>)<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&#x27;Rainy&#x27;</span>, <span class="hljs-number">20</span>);<br>child.say()<br></code></pre></td></tr></table></figure><p>组合继承：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Child(<span class="hljs-params">name</span>, <span class="hljs-params">age</span>)</span>&#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">People</span>.</span></span>call(this);<br>    this.name = name;<br>    this.age = age;<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">People</span>.</span></span>prototype;<br>var child = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Child(&#x27;Rainy&#x27;, 20)</span>;<br>child.say<span class="hljs-literal">()</span><br></code></pre></td></tr></table></figure><p>组合继承优化：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Child(<span class="hljs-params">name</span>, <span class="hljs-params">age</span>)</span>&#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">People</span>.</span></span>call(this);<br>    this.name = name;<br>    this.age = age;<br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>create(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">People</span>.</span></span>prototype);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype.constructor = Child;<br>var child = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Child(&#x27;Rainy&#x27;, 20)</span>;<br>child.say<span class="hljs-literal">()</span><br></code></pre></td></tr></table></figure><h6 id="es6-class继承"><a href="#es6-class继承" class="headerlink" title="es6  class继承"></a>es6  class继承</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.x = x<br>        <span class="hljs-built_in">this</span>.y = y<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x + <span class="hljs-string">&#x27;&#x27;</span> + <span class="hljs-built_in">this</span>.y<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y, color</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>(x, y) <span class="hljs-comment">//调用父类的constructor(x, y)</span><br>        <span class="hljs-built_in">this</span>.color = color<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.color + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">super</span>.toString() <span class="hljs-comment">// 调用父类的toString()</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> colorPoint = <span class="hljs-keyword">new</span> ColorPoint(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(colorPoint.toString())  <span class="hljs-comment">// red 12</span><br><br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/ctt08225/article/details/88255411">参考连接</a></p><p>原型链是什么<br>懒加载和预加载（怎么判断一张图片是否加载成功）</p><p>实现一个div元素的拖拽   (（addEventListen/removeEventListen)mousedown，mousemove，mouseup)<br><a href="https://pengzhenglong.github.io/2022/02/26/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAdiv%E5%85%83%E7%B4%A0%E7%9A%84%E6%8B%96%E6%8B%BD-%EF%BC%88addEventListen-removeEventListen">博客</a><br>防抖节流（没怎么讲清楚）</p><p>实现一个三角形  (采用相邻边框连接处均分的原理)</p><p>怎么求多个数组之间的交集  （暴力解法/set）</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">如何求出两个数组的交集和差集？<br>let intersection = <span class="hljs-keyword">a</span>.<span class="hljs-built_in">filter</span>(v =&gt; b.includes(v))<br>let <span class="hljs-built_in">difference</span> = <span class="hljs-keyword">a</span>.concat(b).<span class="hljs-built_in">filter</span>(v =&gt; !<span class="hljs-keyword">a</span>.includes(v) || !b.includes(v))<br></code></pre></td></tr></table></figure><p>set有什么特性</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">Set</span>类似于数组，但是它里面每一项的值是唯一的，没有重复的值，<span class="hljs-keyword">Set</span>是一个构造函数，用来生成<span class="hljs-keyword">set</span>的数据结构<br><span class="hljs-keyword">Set</span>中两个对象永远是不相等的，即使键和值都是一样的<br></code></pre></td></tr></table></figure><blockquote><p>总结：讲的磕磕盼盼的，不清楚（表达能力不行）</p></blockquote><h3 id="优倍快二面"><a href="#优倍快二面" class="headerlink" title="优倍快二面"></a>优倍快二面</h3><p>W3C标准及规范(简历上写了）<br><a href="https://blog.csdn.net/weixin_39407291/article/details/90172851">参考</a><br>为什么要遵循规范</p><blockquote><p>答案这一个就够了：利人利己，便于维护！如果你写的代码不符合“规范”，查找代码的错误时或者后期的维护会让你痛恨自己当初怎么会写出那么乱的代码。<br>react  和vue的区别<br>什么是好的网页(往用户体验来说)<br>mysql了解吗<br>(迅速结束了，两面反问都没有,体验很差)</p></blockquote><h3 id="沃太能源-苏州-（一面3-16-20：00-–25分钟）"><a href="#沃太能源-苏州-（一面3-16-20：00-–25分钟）" class="headerlink" title="沃太能源(苏州)（一面3.16   20：00  –25分钟）"></a>沃太能源(苏州)（一面3.16   20：00  –25分钟）</h3><h4 id="面试问你用组件库有什么体会，面试官主要想听到的是啥-用组件库有遇到什么问题难点-好几次面试"><a href="#面试问你用组件库有什么体会，面试官主要想听到的是啥-用组件库有遇到什么问题难点-好几次面试" class="headerlink" title="面试问你用组件库有什么体会，面试官主要想听到的是啥(用组件库有遇到什么问题难点 -好几次面试)"></a>面试问你用组件库有什么体会，面试官主要想听到的是啥(用组件库有遇到什么问题难点 -好几次面试)</h4><blockquote></blockquote><p>401（没有权限访问） 403 状态码（服务端拒绝访问）   同步请求，异步请求</p><h3 id="浙江木链（3-16-一面电话）女面试官—40分钟）已凉"><a href="#浙江木链（3-16-一面电话）女面试官—40分钟）已凉" class="headerlink" title="浙江木链（3.16 一面电话）女面试官—40分钟）已凉"></a>浙江木链（3.16 一面电话）女面试官—40分钟）已凉</h3><ol><li>两栏布局<br>（1. flex  2.左边浮动 width :200px，右边margin-left :200px  width:auto   ）</li><li>BFC解决什么问题</li><li>margin塌陷   ()</li><li>C3动画  transition  animation</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">区别：<br>（<span class="hljs-number">1</span>）<span class="hljs-attribute">transform</span>仅描述元素的静态样式，常常配合<span class="hljs-attribute">transition</span>和<span class="hljs-attribute">animation</span>使用<br>（<span class="hljs-number">2</span>）<span class="hljs-attribute">transition</span>通常和hover等事件配合使用，<span class="hljs-attribute">animation</span>是自发的，立即播放<br>（<span class="hljs-number">3</span>）<span class="hljs-attribute">animation</span>可设置循环次数<br>（<span class="hljs-number">4</span>）<span class="hljs-attribute">animation</span>可设置每一帧的样式和时间，<span class="hljs-attribute">transition</span>只能设置头尾<br>（<span class="hljs-number">5</span>）<span class="hljs-attribute">transition</span>可与js配合使用，js设定要变化的样式，<span class="hljs-attribute">transition</span>负责动画效果<br></code></pre></td></tr></table></figure><ol start="5"><li>使用过css预处理嘛</li><li>判断js数据类型<br>toString判断的原理</li><li>讲一下原型链</li><li>数组常用的方法  find  filter(返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组。)  every  some</li><li>判断一个数组中有符合我需求的元素用哪个比较合适<br>indexof    find(返回数组中满足条件的第一个元素的值，如果没有，返回undefined)</li></ol><blockquote><p>返回一个布尔值   includes  some every<br><a href="https://pengzhenglong.github.io/2022/02/28/Js%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/#JS%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%80%BC">博客</a></p></blockquote><ol start="10"><li>遍历一个对象<br>for  of   Object.key  Object.value  Object.entries</li><li>工作中遍历对象都用for  in 嘛，遍历用的比较多的方法是</li><li>promise  promise.all</li><li>async  await</li><li>js事件循环 evenLoop</li><li>$nextTick是宏任务还是微任务</li><li>生命周期  还有父子组件的生命周期  执行</li><li>vue3   ref  refs  reactive  toref()  简单讲讲</li></ol><h5 id="既用到扩展运算符取到数据有让他是响应式的-toRefs"><a href="#既用到扩展运算符取到数据有让他是响应式的-toRefs" class="headerlink" title="既用到扩展运算符取到数据有让他是响应式的  (toRefs)"></a>既用到扩展运算符取到数据有让他是响应式的  (toRefs)</h5><h6 id="注意reactive封装的响应式对象，不要通过解构的方式return，这是不具有响应式的。可以通过-toRefs-处理，然后再解构返回，这样才具有响应式"><a href="#注意reactive封装的响应式对象，不要通过解构的方式return，这是不具有响应式的。可以通过-toRefs-处理，然后再解构返回，这样才具有响应式" class="headerlink" title="注意reactive封装的响应式对象，不要通过解构的方式return，这是不具有响应式的。可以通过 toRefs 处理，然后再解构返回，这样才具有响应式"></a>注意reactive封装的响应式对象，不要通过解构的方式return，这是不具有响应式的。可以通过 toRefs 处理，然后再解构返回，这样才具有响应式</h6><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> <span class="hljs-keyword">state</span> = reactive(&#123;...&#125;);<br>return &#123;...<span class="hljs-keyword">state</span>&#125;; // 这种方式将丢失响应式，是一种错误的方式<br>return <span class="hljs-keyword">to</span>Refs(<span class="hljs-keyword">state</span>); // works<br></code></pre></td></tr></table></figure><ol><li>vue2 组件传值<br>那组件调用特别深，用什么传值方式<br>Provide  inject  $listeners $attars</li><li>vuex  mutation为什么不可以包含异步回调，action 为什么可以<br><a href="https://pengzhenglong.github.io/2022/01/10/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#vuex-mutation%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%EF%BC%8Caction-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5">博客</a></li><li>简历中项目经历（拿错简历了哈哈哈）<br>有封装过功能模块吗</li><li>有什么遇到项目中遇到的棘手的问题</li><li>开发中项目有什么优化的点（项目中引用轻量级的库）</li><li>反问</li></ol><h3 id="北京梧桐花开一面（2022-3-20-20min"><a href="#北京梧桐花开一面（2022-3-20-20min" class="headerlink" title="北京梧桐花开一面（2022.3.20 20min)"></a>北京梧桐花开一面（2022.3.20 20min)</h3><ol><li>定制插件项目（简历上的讲一下）</li><li>双向数据绑定</li><li>生命周期（父子组件生命周期）</li><li>做过手机端的vue吗（如何适配手机端– 媒体查询-rem）</li></ol><h4 id="5-了解Ts，Ts的好处是？"><a href="#5-了解Ts，Ts的好处是？" class="headerlink" title="5. 了解Ts，Ts的好处是？"></a>5. 了解Ts，Ts的好处是？</h4><h5 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h5><p>静态类型化是一种功能，可以在开发人员编写脚本是检测错误，有了这项功能，就会允许开发人员编写更健壮的代码并对其进行维护，以便使得代码质量更好、更清晰。<br>(从代码可知变量num是number类型，如果我们给num赋予其他类型的值就会报错。)</p><h5 id="大型项目的优势"><a href="#大型项目的优势" class="headerlink" title="大型项目的优势"></a>大型项目的优势</h5><p>对于大型项目的开发，有时为了优化改进项目，对代码进行小小更改。这些小小的变化可能会产生严重的、意想不到的后果，因此有必要撤销这些变化。使用TypeScript工具来进行重构更变的容易、快捷。</p><h5 id="更好的协作"><a href="#更好的协作" class="headerlink" title="更好的协作"></a>更好的协作</h5><p>对于大型项目的开发一般会有很多开发人员一起开发，此时乱码和错误的机也会增加。类型安全是一种在编码期间检测错误的功能，而不是在编译项目时检测错误。这为开发团队创建了一个更高效的编码和调试过程。</p><h4 id="typescript-中-interface-和-type-的区别-1"><a href="#typescript-中-interface-和-type-的区别-1" class="headerlink" title="typescript 中 interface 和 type 的区别"></a>typescript 中 interface 和 type 的区别</h4><blockquote><p>相同点 (都可以描述一个对象或者函数&amp;&amp;都允许拓展（extends）)<br>不同点 (<br>  type可以interface不可以：：<br>type 可以声明基本类型别名，联合类型，元组等类型,type 语句中还可以使用 typeof 获取实例的 类型进行赋值 ,<br>  interface可以type不可以：<br>interface 能够声明合并)<br><a href="https://juejin.cn/post/6844903749501059085">参考</a><br>一般来说，如果不清楚什么时候用interface/type，能用 interface 实现，就用 interface , 如果不能就用 type</p></blockquote><h4 id="6-使用mongodb的优势"><a href="#6-使用mongodb的优势" class="headerlink" title="6. 使用mongodb的优势"></a>6. 使用mongodb的优势</h4><p>为什么使用mongodb   好处(连接mongose)</p><blockquote><p>学习成本较低，非常简单</p></blockquote><p>在需求不明确/需求变化频繁（表结构不明确）的情况下，使用MongoDB的开发和维护成本最低（MongoDB语法简单，修改表结构简单）。<br>部署简单<br>应该不需要事务/不存在大量的复杂事务逻辑操作，不需要复杂的锁</p><blockquote><p>逻辑比较单一、简单，不存在数据结构化查询（表之间join）的情况</p></blockquote><p>模式自由</p><blockquote><p>面向集合存储，易存储对象类型的数据</p></blockquote><p>所谓“面向集合”（Collenction-Oriented），意思是数据被分组存储在数据集中，被称为一个集合（Collenction)。每个集合在数据库中都有一个唯一的标识名，并且可以包含无限数目的文档。集合的概念类似关系型数据库（RDBMS）里的表（table），不同的是它不需要定义任何模式（schema)。</p><h4 id="使用组件库遇到的问题（难点）"><a href="#使用组件库遇到的问题（难点）" class="headerlink" title="使用组件库遇到的问题（难点）"></a>使用组件库遇到的问题（难点）</h4><p>能复用通用 –ElementUi 的tab是三个都渲染了(为了高度和宽度一样)</p><ol><li>性能问题（按需引入） tree shaking  打包体积<br>开发中有没有遇见过数据修改了页面不刷新的情况 （$set()）</li><li>从业务组件（对功能组件的具体实现）和功能组件（不涉及业务逻辑，比如下拉框，列表）两方面来说<br>定向了什么业务，然后  ，你的功能组件，入参怎么设计的，有什么抽象的属性，使用于什么…</li></ol>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue diff算法</title>
    <link href="/2022/02/20/Vue--diff%E7%AE%97%E6%B3%95/"/>
    <url>/2022/02/20/Vue--diff%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="1-当数据发生变化时，vue是怎么更新节点的？"><a href="#1-当数据发生变化时，vue是怎么更新节点的？" class="headerlink" title="1. 当数据发生变化时，vue是怎么更新节点的？"></a>1. 当数据发生变化时，vue是怎么更新节点的？</h3><p>要知道渲染真实DOM的开销是很大的，比如有时候我们修改了某个数据，如果直接渲染到真实dom上会引起整个dom树的重绘和重排，有没有可能我们只更新我们修改的那一小块dom而不要更新整个dom呢？diff算法能够帮助我们。</p><p>我们先根据真实DOM生成一颗<strong>virtual DOM</strong>，当virtual DOM某个节点的数据改变后会生成一个新的<strong>Vnode</strong>，然后<strong>Vnode和oldVnode</strong>作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使oldVnode的值为Vnode。</p><p>diff的过程就是调用名为<strong>patch的函数</strong>，比较新旧节点，一边比较一边给真实的DOM打补丁。</p><h3 id="2-virtual-DOM和真实DOM的区别？"><a href="#2-virtual-DOM和真实DOM的区别？" class="headerlink" title="2. virtual DOM和真实DOM的区别？"></a>2. virtual DOM和真实DOM的区别？</h3><p>virtual DOM是将真实的DOM的数据抽取出来，以对象的形式模拟树形结构。比如dom是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对应的virtual DOM（伪代码）：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">var</span> Vnode = &#123;<br>    <span class="hljs-built_in">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>    children: <span class="hljs-meta">[</span><br>        &#123; <span class="hljs-built_in">tag</span>: <span class="hljs-string">&#x27;p&#x27;</span>, text: <span class="hljs-string">&#x27;123&#x27;</span> &#125;<br>    <span class="hljs-meta">]</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>（温馨提示：<strong>VNode和oldVNode都是对象</strong>，一定要记住）</p><h3 id="3-diff的比较方式？"><a href="#3-diff的比较方式？" class="headerlink" title="3. diff的比较方式？"></a>3. diff的比较方式？</h3><p>在采取diff算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>456<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面的代码会分别比较同一层的两个div以及第二层的p和span，但是不会拿div和span作比较。在别处看到的一张很形象的图：<br><img src="/imageO/Dom.jpg" alt="如图"></p><h3 id="diff流程图"><a href="#diff流程图" class="headerlink" title="diff流程图"></a>diff流程图</h3><p>当数据发生改变时，set方法会让调用 <strong> Dep.notify  </strong>通知所有订阅者Watcher，订阅者就会调用<strong>patch</strong>给真实的DOM打补丁，更新相应的视图。</p><p><img src="/imageO/Patch.jpg" alt="Patch"></p><h3 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h3><h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><p>来看看patch是怎么打补丁的（代码只保留核心部分）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> patch (oldVnode, vnode) &#123;<br>    <span class="hljs-comment">// some code</span><br>    <span class="hljs-keyword">if</span> (same<span class="hljs-constructor">Vnode(<span class="hljs-params">oldVnode</span>, <span class="hljs-params">vnode</span>)</span>) &#123;<br>     patch<span class="hljs-constructor">Vnode(<span class="hljs-params">oldVnode</span>, <span class="hljs-params">vnode</span>)</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>     const oEl = oldVnode.el <span class="hljs-comment">// 当前oldVnode对应的真实元素节点</span><br>     <span class="hljs-keyword">let</span> parentEle = api.parent<span class="hljs-constructor">Node(<span class="hljs-params">oEl</span>)</span>  <span class="hljs-comment">// 父元素</span><br>     create<span class="hljs-constructor">Ele(<span class="hljs-params">vnode</span>)</span>  <span class="hljs-comment">// 根据Vnode生成新元素</span><br>     <span class="hljs-keyword">if</span> (parentEle !== null) &#123;<br>            api.insert<span class="hljs-constructor">Before(<span class="hljs-params">parentEle</span>, <span class="hljs-params">vnode</span>.<span class="hljs-params">el</span>, <span class="hljs-params">api</span>.<span class="hljs-params">nextSibling</span>(<span class="hljs-params">oEl</span>)</span>) <span class="hljs-comment">// 将新元素添加进父元素</span><br>            api.remove<span class="hljs-constructor">Child(<span class="hljs-params">parentEle</span>, <span class="hljs-params">oldVnode</span>.<span class="hljs-params">el</span>)</span>  <span class="hljs-comment">// 移除以前的旧元素节点</span><br>            oldVnode = null<br>     &#125;<br>    &#125;<br>    <span class="hljs-comment">// some code </span><br>    return vnode<br>&#125;<br></code></pre></td></tr></table></figure><p>patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点</p><h5 id="判断两节点是否值得比较，值得比较则执行patchVnode"><a href="#判断两节点是否值得比较，值得比较则执行patchVnode" class="headerlink" title="判断两节点是否值得比较，值得比较则执行patchVnode"></a>判断两节点是否值得比较，值得比较则执行patchVnode</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> sameVnode (a, b) &#123;<br>  return (<br>    a.key<span class="hljs-operator"> === </span>b.key<span class="hljs-operator"> &amp;&amp;  </span><span class="hljs-comment">// key值</span><br>    a.tag<span class="hljs-operator"> === </span>b.tag<span class="hljs-operator"> &amp;&amp;  </span><span class="hljs-comment">// 标签名</span><br>    a.isComment<span class="hljs-operator"> === </span>b.isComment<span class="hljs-operator"> &amp;&amp;  </span><span class="hljs-comment">// 是否为注释节点</span><br>    <span class="hljs-comment">// 是否都定义了data，data包含一些具体信息，例如onclick , style</span><br>    is<span class="hljs-constructor">Def(<span class="hljs-params">a</span>.<span class="hljs-params">data</span>)</span><span class="hljs-operator"> === </span>is<span class="hljs-constructor">Def(<span class="hljs-params">b</span>.<span class="hljs-params">data</span>)</span><span class="hljs-operator"> &amp;&amp;  </span><br>    same<span class="hljs-constructor">InputType(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span> <span class="hljs-comment">// 当标签是&lt;input&gt;的时候，type必须相同</span><br>  )<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="不值得比较则用Vnode替换oldVnode"><a href="#不值得比较则用Vnode替换oldVnode" class="headerlink" title="不值得比较则用Vnode替换oldVnode"></a>不值得比较则用Vnode替换oldVnode</h5><p>如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。<br>虽然这两个节点不一样但是他们的子节点一样怎么办？别忘了，diff可是逐层比较的，如果第一层不一样那么就不会继续深入比较第二层了。（我在想这算是一个缺点吗？相同子节点不能重复利用了…）</p><h4 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h4><p>当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法。那么这个方法做了什么呢？</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">patchVnode (oldVnode, vnode) &#123;<br>    const el = vnode.el = oldVnode.el<br>    <span class="hljs-keyword">let</span> i, oldCh = oldVnode.children, ch = vnode.children<br>    <span class="hljs-keyword">if</span> (oldVnode<span class="hljs-operator"> === </span>vnode) return<br>    <span class="hljs-keyword">if</span> (oldVnode.text !== null<span class="hljs-operator"> &amp;&amp; </span>vnode.text !== null<span class="hljs-operator"> &amp;&amp; </span>oldVnode.text !== vnode.text) &#123;<br>        api.set<span class="hljs-constructor">TextContent(<span class="hljs-params">el</span>, <span class="hljs-params">vnode</span>.<span class="hljs-params">text</span>)</span><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        update<span class="hljs-constructor">Ele(<span class="hljs-params">el</span>, <span class="hljs-params">vnode</span>, <span class="hljs-params">oldVnode</span>)</span><br>     <span class="hljs-keyword">if</span> (oldCh<span class="hljs-operator"> &amp;&amp; </span>ch<span class="hljs-operator"> &amp;&amp; </span>oldCh !== ch) &#123;<br>            update<span class="hljs-constructor">Children(<span class="hljs-params">el</span>, <span class="hljs-params">oldCh</span>, <span class="hljs-params">ch</span>)</span><br>     &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch)&#123;<br>            create<span class="hljs-constructor">Ele(<span class="hljs-params">vnode</span>)</span> <span class="hljs-comment">//create el&#x27;s children dom</span><br>     &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldCh)&#123;<br>            api.remove<span class="hljs-constructor">Children(<span class="hljs-params">el</span>)</span><br>     &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="这个函数做了以下事情"><a href="#这个函数做了以下事情" class="headerlink" title="这个函数做了以下事情"></a>这个函数做了以下事情</h5><ol><li>找到对应的真实dom，称为el</li><li>判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return</li><li>如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。</li><li>如果oldVnode有子节点而Vnode没有，则删除el的子节点</li><li>如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el</li><li>如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要</li></ol><p>其他几个点都很好理解，我们详细来讲一下updateChildren</p><h4 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h4><p>代码量很大，不方便一行一行的讲解，所以下面结合一些示例图来描述一下。<br>先说一下这个函数做了什么</p><ol><li>将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来</li><li>oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。</li></ol><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844903607913938951#heading-2">详解vue的diff算法</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue Vue2与Vue3的v-model</title>
    <link href="/2022/02/18/Vue--v-model/"/>
    <url>/2022/02/18/Vue--v-model/</url>
    
    <content type="html"><![CDATA[<p>v-model 是 Vue 中使用频率特别高的一个指令，而 Vue3 中的 v-model 有了很大的变化，本文将详细讲述一下 Vue2 和 Vue3 中的 v-model 的区别。</p><hr><h3 id="Vue2-中的-v-model"><a href="#Vue2-中的-v-model" class="headerlink" title="Vue2 中的 v-model"></a>Vue2 中的 v-model</h3><p>如果对 Vue2 中的语法很熟悉，这部分可以不看。<br>首先来回顾一下 Vue2 中的 v-model，它主要用于表单元素和自定义组件上。v-model本质上是一个语法糖，会对用户的输入做一些特殊处理以达到更新数据，而所谓的处理其实就是给使用的元素默认绑定属性和事件。</p><p>当 v-model 使用在表单元素上时，会根据元素的不同而采用不同的处理：</p><ol><li>当<code>&lt;input type=&quot;text&quot;&gt;</code>文本 和 <code>&lt;textarea&gt;</code>上使用时，会默认给元素绑定名为 value 的<strong> prop </strong> 和名为 <strong> input </strong>的事件；</li><li>当<code>&lt;input type=&quot;checkbox&quot;&gt;</code>复选框 和 <code>&lt;input type=&quot;radio&quot;&gt;</code>单选框 上使用时，会默认绑定名为<strong> checked 的 prop 和名为 change  </strong> 的事件；</li><li>当 <code>&lt;select&gt;</code>选择框 上使用时，则绑定名为 value 的 prop 和名为   <strong> change</strong> 的事件。</li></ol><p>这些是 Vue 默认帮我们处理的，可以直接使用。但是你也会发现一些第三方组件也可以使用 v-model ，比如 Element 中的 Input 组件。这是因为这些组件自己实现了 v-model，原理其实就是上面说到的绑定属性和事件。<br>我们可以尝试实现一下 v-model，来开发一个简单的输入组件，就叫 MyInput 吧：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- MyInput 组件代码 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;value&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;input&#x27;,$event.target.value)&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>  props: &#123;<br><span class="javascript">    value: <span class="hljs-built_in">String</span>,  <span class="hljs-comment">// 默认接收一个名为 value 的 prop</span></span><br>  &#125;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>上面代码就实现了组件的 v-model 功能，当在这个组件上使用 v-model 时：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">my</span>-input v-model=<span class="hljs-string">&quot;msg&quot;</span>&gt;&lt;/<span class="hljs-keyword">my</span>-input&gt;<br></code></pre></td></tr></table></figure><p>其实就等同于：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;my-input :<span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;msg&quot;</span> @<span class="hljs-attribute">input</span>=<span class="hljs-string">&quot;msg = <span class="hljs-variable">$event</span>&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>Vue 还提供了 model 选项，用于将属性或事件名称改为其他名称，比如上面的 MyInput 组件，我们改一下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    &lt;input<br>      type=&quot;text&quot;<br>      :value=&quot;title&quot;<br>      @input=&quot;$emit(&#x27;change&#x27;, $event.target.value)&quot;<br>    /&gt;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>  model: &#123;<br><span class="javascript">    prop: <span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-comment">// 将默认的 prop 名 value 改为 title</span></span><br><span class="javascript">    event: <span class="hljs-string">&quot;change&quot;</span>, <span class="hljs-comment">// 将默认的事件名 input 改为 change</span></span><br>  &#125;,<br>  props: &#123;<br><span class="javascript">    title: <span class="hljs-built_in">String</span>, <span class="hljs-comment">// 注意 template 代码中也要修改为 title</span></span><br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此时使用组件：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;my-<span class="hljs-keyword">input</span> v-model=<span class="hljs-string">&quot;msg&quot;</span>&gt;&lt;/my-<span class="hljs-keyword">input</span>&gt;<br><br><span class="hljs-comment">// 等同于</span><br>&lt;my-<span class="hljs-keyword">input</span> :<span class="hljs-keyword">title</span>=<span class="hljs-string">&quot;msg&quot;</span> @change=<span class="hljs-string">&quot;msg = $event&quot;</span>&gt;&lt;/my-<span class="hljs-keyword">input</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="使用-sync-修饰符"><a href="#使用-sync-修饰符" class="headerlink" title="使用 .sync 修饰符"></a>使用 .sync 修饰符</h3><p>Vue 提供一个 .sync 的修饰符，效果跟 v-model 一样，也是便于子组件数据更改后自动更新父组件相关数据。实现 .sync 的方式与实现 v-model 异曲同工，区别就是抛出的事件名需要是 update:myPropName 的结构。<br>还是拿上面的 MyInput 说明，我们还是传入一个 title 的 prop，同时组件内部抛出 update:title 事件，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// MyInput 组件中，修改抛出的事件名为 update:title</span><br> &lt;input type=<span class="hljs-string">&quot;text&quot;</span> :value=<span class="hljs-string">&quot;title&quot;</span> <span class="hljs-meta">@input</span>=<span class="hljs-string">&quot;<span class="hljs-subst">$emit</span>(&#x27;update:title&#x27;, <span class="hljs-subst">$event</span>.target.value)&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>此时如果使用这个组件，正常应该是这样：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">&lt;my-input <span class="hljs-symbol">:title=<span class="hljs-string">&quot;msg&quot;</span></span> <span class="hljs-variable">@update</span><span class="hljs-symbol">:title=<span class="hljs-string">&quot;msg = $event&quot;</span>&gt;&lt;/my-input&gt;</span><br></code></pre></td></tr></table></figure><p>但此时可以使用 .sync 修饰符来简化：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">&lt;my-<span class="hljs-meta">input</span> :<span class="hljs-meta">title</span>.sync=<span class="hljs-string">&quot;msg&quot;</span>&gt;&lt;/my-<span class="hljs-meta">input</span>&gt;<br></code></pre></td></tr></table></figure><p>可以看到 .sync 和 v-model 所能达到的效果是一样的，用什么就看你什么场景，一般表单组件上都是用 v-model。</p><h3 id="Vue3-中的-v-model"><a href="#Vue3-中的-v-model" class="headerlink" title="Vue3 中的 v-model"></a>Vue3 中的 v-model</h3><p>上面说了那么多，为的就是接下来区别出 Vue3 中 v-model 带来的变化，主要变化有以下几处：</p><h4 id="修改默认-prop-名和事件名"><a href="#修改默认-prop-名和事件名" class="headerlink" title="修改默认 prop 名和事件名"></a>修改默认 prop 名和事件名</h4><p>当用在自定义组件上时，v-model 默认绑定的 prop 名从 value 变为 modelValue，而事件名也从默认的input 改为 update:modelValue 。在 Vue3 中编写上面那个 MyInput 组件时，就需要这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- MyInput 组件代码 Vue3 版 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    &lt;input<br>      type=&quot;text&quot;<br>      :value=&quot;modelValue&quot;<br>      @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;  // 事件名改为 update:modelValue<br>    /&gt;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>  props: &#123;<br><span class="javascript">    modelValue: <span class="hljs-built_in">String</span>, <span class="hljs-comment">// 默认 prop 从 value 改为 modelValue</span></span><br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>使用组件时：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;my-<span class="hljs-keyword">input</span> v-model=<span class="hljs-string">&quot;msg&quot;</span>&gt;&lt;/my-<span class="hljs-keyword">input</span>&gt;<br><br><span class="hljs-comment">// 等同于</span><br>&lt;my-<span class="hljs-keyword">input</span> :modelValue=<span class="hljs-string">&quot;msg&quot;</span> @<span class="hljs-keyword">update</span>:modelValue=<span class="hljs-string">&quot;msg = $event&quot;</span>&gt;&lt;/my-<span class="hljs-keyword">input</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="废除-model-选项和-sync-修饰符"><a href="#废除-model-选项和-sync-修饰符" class="headerlink" title="废除 model 选项和 .sync 修饰符"></a>废除 model 选项和 .sync 修饰符</h4><p>Vue3 中移除了 model 选项，这样就不可以在组件内修改默认 prop 名了。现在有一种更简单的方式，就是直接在 v-model 后面传递要修改的 prop 名：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-comment">// 要修改默认 prop 名，只需在 v-model 后面接上 :propName，例如修改为 title</span><br>&lt;my-<span class="hljs-keyword">input</span> v-model:<span class="hljs-keyword">title</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;&lt;/my-<span class="hljs-keyword">input</span>&gt;<br><br><span class="hljs-comment">// 等同于</span><br>&lt;my-<span class="hljs-keyword">input</span> :<span class="hljs-keyword">title</span>=<span class="hljs-string">&quot;msg&quot;</span> @update:<span class="hljs-keyword">title</span>=<span class="hljs-string">&quot;msg = $event&quot;</span>&gt;&lt;/my-<span class="hljs-keyword">input</span>&gt;<br></code></pre></td></tr></table></figure><p>注意组件内部也要修改 props：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    &lt;input<br>      type=&quot;text&quot;<br>      :value=&quot;title&quot;<br>      @input=&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;<br>    /&gt;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-comment">// 此时这里不需要 model 选项来修改了</span></span><br>  props: &#123;<br><span class="javascript">    title: <span class="hljs-built_in">String</span>, <span class="hljs-comment">// 修改为 title，注意 template 中也要修改</span></span><br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意组件内部也要修改 props：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    &lt;input<br>      type=&quot;text&quot;<br>      :value=&quot;title&quot;<br>      @input=&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;<br>    /&gt;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-comment">// 此时这里不需要 model 选项来修改了</span></span><br>  props: &#123;<br><span class="javascript">    title: <span class="hljs-built_in">String</span>, <span class="hljs-comment">// 修改为 title，注意 template 中也要修改</span></span><br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>同时，.sync 修饰符也被移除了，如果你尝试使用它，会报这样的错误：</p><blockquote><p>‘.sync’ modifier on ‘v-bind’ directive is deprecated. Use ‘v-model:propName’ instead</p></blockquote><p>错误提示中说明了，可以使用 v-model:propName 的方式来替代 .sync，因为本质上效果是一样的。</p><h4 id="使用多个-v-model"><a href="#使用多个-v-model" class="headerlink" title="使用多个 v-model"></a>使用多个 v-model</h4><p>Vue3 中支持使用多个 v-model，属于新增功能，我很喜欢这个功能，使得组件数据更新更灵活。例如有这样一个表单子组件，用户输入的多个数据都需要更新到父组件中显示，可以这样写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  表单子组件 Form --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form&quot;</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;name&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;update:name&#x27;,$event.target.value)&quot;</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;address&quot;</span>&gt;</span>地址<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;address&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;$emit(&#x27;update:address&#x27;,$event.target.value)&quot;</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>  props:&#123;<br><span class="javascript">    name: <span class="hljs-built_in">String</span>,</span><br><span class="javascript">    address: <span class="hljs-built_in">String</span></span><br>  &#125;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>父组件使用这个组件时：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">child-component</span> <span class="hljs-attr">v-model:name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">v-model:address</span>=<span class="hljs-string">&quot;address&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child-component</span>&gt;</span></span><br><span class="xml">    </span><br><span class="xml">// 将用户输入数据更新到父组件中显示</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">name</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">address</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="自定义-v-model-修饰符"><a href="#自定义-v-model-修饰符" class="headerlink" title="自定义 v-model 修饰符"></a>自定义 v-model 修饰符</h4><p>在 Vue2 中的 v-model 上，我们用过 .trim、.lazy 和 .number这三个内置修饰符，而 Vue3 则在这个基础上增加了自定义修饰符，即开发者可以自定义修饰符，以按需处理绑定值。<br>当我们在 v-model 后面加上自定义修饰符后，会通过名为 modelModifiers 的 prop 传递给子组件，子组件拿到这个修饰符名后，根据条件修改绑定值。我们来看一个例子，自定义一个修饰符 capitalize，用于将输入字符串的首字母大写。<br>假设自定义组件还是叫 MyInput，使用 v-model 时加上自定义修饰符 capitalize：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">my</span>-input v-model.capitalize=<span class="hljs-string">&quot;msg&quot;</span>&gt;&lt;/<span class="hljs-keyword">my</span>-input&gt;<br></code></pre></td></tr></table></figure><p>由于不是内置修饰符，所以需要我们自己在组件内部处理修饰符逻辑，编写组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- MyInput 组件 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;modelValue&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;emitValue&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>  props: &#123;<br><span class="javascript">    modelValue: <span class="hljs-built_in">String</span>,</span><br><span class="javascript">    modelModifiers: &#123;  <span class="hljs-comment">// 自定义修饰符会默认传入这个 prop 中</span></span><br><span class="javascript">      type: <span class="hljs-built_in">Object</span>,</span><br><span class="javascript">      <span class="hljs-keyword">default</span>: <span class="hljs-function">() =&gt;</span> (&#123;&#125;),</span><br>    &#125;,<br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-comment">// 当组件 v-model 后面加上了自定义修饰符，组件内部会在 modelModifiers 上获取到修饰符状态</span></span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.modelModifiers); <span class="hljs-comment">// &#123;capitalize: true&#125;</span></span><br>  &#125;,<br>  methods: &#123;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">emitValue</span>(<span class="hljs-params">e</span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> value = e.target.value;</span><br><span class="javascript">      <span class="hljs-comment">// 如果使用了自定义修饰符，即状态为 true，就处理值</span></span><br><span class="javascript">      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.modelModifiers.capitalize) &#123;</span><br>        value = value.charAt(0).toUpperCase() + value.slice(1);<br>      &#125;<br><span class="javascript">      <span class="hljs-comment">// emit value</span></span><br><span class="javascript">      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&quot;update:modelValue&quot;</span>, value);</span><br>    &#125;,<br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样就完成了一个将输入字符串首字母大写的v-model修饰符。</p><p>如果是 v-model 带上了参数，同时使用了自定义修饰符，比如这样：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">&lt;my-<span class="hljs-built_in">input</span> v-<span class="hljs-keyword">mode</span><span class="hljs-variable">l:title</span>.capitalize=<span class="hljs-string">&quot;msg&quot;</span>&gt;&lt;/my-<span class="hljs-built_in">input</span>&gt;<br></code></pre></td></tr></table></figure><p>那么传入组件内部的 prop 就不再是 modelModifiers 了，而是 titleModifiers。它的格式是 arg + ‘Modifiers’。此时这个组件应该这样写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- MyInput 组件 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;title&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;emitValue&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>  props: &#123;<br><span class="javascript">    title: <span class="hljs-built_in">String</span>,  <span class="hljs-comment">// modelValue -&gt; title</span></span><br><span class="javascript">    titleModifiers: &#123;  <span class="hljs-comment">// modelModifiers -&gt; titleModifiers</span></span><br><span class="javascript">      type: <span class="hljs-built_in">Object</span>,</span><br><span class="javascript">      <span class="hljs-keyword">default</span>: <span class="hljs-function">() =&gt;</span> (&#123;&#125;),</span><br>    &#125;,<br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.titleModifiers); <span class="hljs-comment">// &#123;capitalize: true&#125;</span></span><br>  &#125;,<br>  methods: &#123;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">emitValue</span>(<span class="hljs-params">e</span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> value = e.target.value;</span><br><br><span class="javascript">      <span class="hljs-comment">// 如果使用了自定义修饰符，就处理值</span></span><br><span class="javascript">      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.titleModifiers.capitalize) &#123;</span><br>        value = value.charAt(0).toUpperCase() + value.slice(1);<br>      &#125;<br><span class="javascript">      <span class="hljs-comment">// emit value</span></span><br><span class="javascript">      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&quot;update:title&quot;</span>, value);</span><br>    &#125;,<br>  &#125;,<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h4 id="转载文章"><a href="#转载文章" class="headerlink" title="转载文章"></a>转载文章</h4><p><a href="https://juejin.cn/post/6970210247726071845">v-model 在 Vue2 和 Vue3 中的区别</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端两种路由实现和使用场景--Hash模式&amp;&amp;History模式</title>
    <link href="/2022/02/17/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2022/02/17/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h3><p>路由这个概念最先是后端出现的，简单来说路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能。</p><h3 id="前端路由的诞生"><a href="#前端路由的诞生" class="headerlink" title="前端路由的诞生"></a>前端路由的诞生</h3><p>前端路由的出现要从 ajax 开始，有了 Ajax 后，用户交互就不用每次都刷新页面，体验带来了极大的提升。随着技术的发展，简单的异步已经不能满足需求，所以异步的更高级体验出现了——SPA(单页应用)。<br>SPA 的出现大大提高了 WEB 应用的交互体验。在与用户的交互过程中，不再需要重新刷新页面，获取数据也是通过 Ajax 异步获取，页面显示变的更加流畅。<br>但由于 SPA 中用户的交互是通过 JS 改变 HTML 内容来实现的，页面本身的 url 并没有变化，这导致了两个问题：</p><ul><li>SPA 无法记住用户的操作记录，无论是刷新、前进还是后退，都无法展示用户真实的期望内容。</li><li>SPA 中虽然由于业务的不同会有多种页面展示形式，但只有一个 url，对 SEO 不友好，不方便搜索引擎进行收录。</li></ul><p>前端路由就是为了解决上述问题而出现的。</p><h3 id="什么是前端路由"><a href="#什么是前端路由" class="headerlink" title="什么是前端路由"></a>什么是前端路由</h3><p>简单的说，就是在保证只有一个 HTML 页面，且与用户交互时不刷新和跳转页面的同时，为 SPA 中的每个视图展示形式匹配一个特殊的 url。在刷新、前进、后退和SEO时均通过这个特殊的 url 来实现。<br>为实现这一目标，我们需要做到以下二点：</p><ul><li>改变 url 且不让浏览器像服务器发送请求。</li><li>可以监听到 url 的变化</li></ul><p>接下来要介绍的 hash 模式和 history 模式，就是实现了上面的功能。</p><h3 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a>Hash模式</h3><p>原理</p><ul><li>早期的前端路由的实现就是基于location.hash来实现的，location.hash的值就是URL中#后面的内容 其实现原理就是监听#后面的内容来发起Ajax请求来进行局部更新，而不需要刷新整个页面。</li><li>使用hashchange事件来监听 URL 的变化，以下这几种情况改变 URL 都会触发 hashchange 事件：浏览器前进后退改变 URL、a标签改变 URL、window.location改变URL。</li></ul><p>使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//html</span><br>&lt;ul id=<span class="hljs-string">&quot;menu&quot;</span>&gt;<br>  &lt;li&gt;<br>    &lt;a href=<span class="hljs-string">&quot;#index&quot;</span>&gt;首页&lt;/a&gt;<br>  &lt;/li&gt;<br>  &lt;li&gt;<br>    &lt;a href=<span class="hljs-string">&quot;#news&quot;</span>&gt;资讯&lt;/a&gt;<br>  &lt;/li&gt;<br>  &lt;li&gt;<br>    &lt;a href=<span class="hljs-string">&quot;#user&quot;</span>&gt;个人中心&lt;/a&gt;<br>  &lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;div id=<span class="hljs-string">&quot;app&quot;</span>&gt;&lt;/div&gt;<br><br><span class="hljs-comment">//js</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hashChange</span>(<span class="hljs-params">e</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> app = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;app&#x27;</span>)<br>    <span class="hljs-keyword">switch</span> (location.hash) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#index&#x27;</span>:<br>        app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;这是首页内容&lt;/h1&gt;&#x27;</span><br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#news&#x27;</span>:<br>        app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;这是新闻内容&lt;/h1&gt;&#x27;</span><br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#user&#x27;</span>:<br>        app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;这是个人中心内容&lt;/h1&gt;&#x27;</span><br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-keyword">default</span>:<br>        app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;404&lt;/h1&gt;&#x27;</span><br>    &#125;<br>&#125;<br><span class="hljs-built_in">window</span>.onhashchange = hashChange<br>hashChange()<br></code></pre></td></tr></table></figure><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>兼容低版本浏览器，Angular1.x和Vue默认使用的就是hash路由</li><li>只有#符号之前的内容才会包含在请求中被发送到后端，也就是说就算后端没有对路由全覆盖，但是不会返回404错误<br>hash值的改变，都会在浏览器的访问历史中增加一个记录，所以可以通过浏览器的回退、前进按钮控制hash的切换 会覆盖锚点定位元素的功能</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>不太美观，#后面传输的数据复杂的话会出现问题</li></ul><h3 id="History模式"><a href="#History模式" class="headerlink" title="History模式"></a>History模式</h3><p>原理</p><ul><li>history 提供了 pushState 和 replaceState 两个方法来记录路由状态，这两个方法改变 URL 不会引起页面刷新</li><li>history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过pushState/replaceState或a标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState/replaceState的调用和a标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。</li><li>pushState(state, title, url) 和 replaceState(state, title, url)都可以接受三个相同的参数。<br>使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//html</span><br>&lt;ul id=<span class="hljs-string">&quot;menu&quot;</span>&gt;<br>  &lt;li&gt;<br>    &lt;a href=<span class="hljs-string">&quot;/index&quot;</span>&gt;首页&lt;/a&gt;<br>  &lt;/li&gt;<br>  &lt;li&gt;<br>    &lt;a href=<span class="hljs-string">&quot;/news&quot;</span>&gt;资讯&lt;/a&gt;<br>  &lt;/li&gt;<br>  &lt;li&gt;<br>    &lt;a href=<span class="hljs-string">&quot;/user&quot;</span>&gt;个人中心&lt;/a&gt;<br>  &lt;/li&gt;<br>&lt;/ul&gt;<br>&lt;div id=<span class="hljs-string">&quot;app&quot;</span>&gt;&lt;/div&gt;<br><br><span class="hljs-comment">//js</span><br><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#menu&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(e.target.nodeName ===<span class="hljs-string">&#x27;A&#x27;</span>)&#123;<br>    e.preventDefault()<br>    <span class="hljs-keyword">let</span> path = e.target.getAttribute(<span class="hljs-string">&#x27;href&#x27;</span>)  <span class="hljs-comment">//获取超链接的href，改为pushState跳转，不刷新页面</span><br>    <span class="hljs-built_in">window</span>.history.pushState(&#123;&#125;,<span class="hljs-string">&#x27;&#x27;</span>,path)  <span class="hljs-comment">//修改浏览器中显示的url地址</span><br>    render(path)  <span class="hljs-comment">//根据path，更改页面内容</span><br>  &#125;<br>&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">path</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> app = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;app&#x27;</span>)<br>  <span class="hljs-keyword">switch</span> (path) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/index&#x27;</span>:<br>      app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;这是首页内容&lt;/h1&gt;&#x27;</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/news&#x27;</span>:<br>      app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;这是新闻内容&lt;/h1&gt;&#x27;</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/user&#x27;</span>:<br>      app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;这是个人中心内容&lt;/h1&gt;&#x27;</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">default</span>:<br>      app.innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;404&lt;/h1&gt;&#x27;</span><br>  &#125;<br>&#125;<br><span class="hljs-built_in">window</span>.onpopstate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  render(location.pathname)<br>&#125;<br>render(<span class="hljs-string">&#x27;/index&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>使用简单，比较美观</li><li>pushState()设置新的URL可以是任意与当前URL同源的URL，而hash只能改变#后面的内容，因此只能设置与当前URL同文档的URL</li><li>pushState()设置的URL与当前URL一模一样时也会被添加到历史记录栈中，而hash#后面的内容必须被修改才会被添加到新的记录栈中</li><li>pushState()可以通过stateObject参数添加任意类型的数据到记录中，而hash只能添加短字符串</li><li>pushState()可额外设置title属性供后续使用</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>前端的URL必须和向发送请求后端URL保持一致，否则会报404错误</li><li>由于History API的缘故，低版本浏览器有兼容行问题</li></ul><h3 id="两种不同使用场景"><a href="#两种不同使用场景" class="headerlink" title="两种不同使用场景"></a>两种不同使用场景</h3><ul><li>从上文可见，hash模式下url会带有#，当你希望url更优雅时，可以使用history模式。</li><li>当使用history模式时，需要注意在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</li><li>当需要兼容低版本的浏览器时，建议使用hash模式。</li><li>当需要添加任意类型数据到记录时，可以使用history模式。</li></ul><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844904054087221256#comment">前端两种路由实现和使用场景</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS 面试题总结</title>
    <link href="/2022/02/15/CSS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2022/02/15/CSS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>总结了最近的一些面试题和之前的知识点</p><hr><h3 id="介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？"><a href="#介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？" class="headerlink" title="介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？"></a>介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？</h3><p>（1）有两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box）<br>(2) 盒模型：由四个属性组成的外边距(margin)、内边距(padding)、边界(border)、内容区(width和height);</p><h4 id="IE盒模型和W3C标准盒模型的区别"><a href="#IE盒模型和W3C标准盒模型的区别" class="headerlink" title="IE盒模型和W3C标准盒模型的区别"></a>IE盒模型和W3C标准盒模型的区别</h4><p>（1）W3C标准盒模型：属性width，height只包含内容content，不包含border和padding<br>（2）IE盒模型：属性width，height包含content、border和padding，指的是content+padding+border。</p><h4 id="CSS-如何设置这两种模型？"><a href="#CSS-如何设置这两种模型？" class="headerlink" title="CSS 如何设置这两种模型？"></a>CSS 如何设置这两种模型？</h4><p>box-sizing : content-box  //标准(W3C)盒子模型<br>box-sizing : border-box   //IE盒子模型</p><h3 id="CSS3-高斯模糊-filter-blur"><a href="#CSS3-高斯模糊-filter-blur" class="headerlink" title="CSS3    高斯模糊  filter  blur"></a>CSS3    高斯模糊  filter  blur</h3><h3 id="canvas和svg-使用场景及二者的区别"><a href="#canvas和svg-使用场景及二者的区别" class="headerlink" title="canvas和svg | 使用场景及二者的区别"></a>canvas和svg | 使用场景及二者的区别</h3><p>canvas是H5中新增的标签，官方解释说canvas是<strong>一块画布</strong>，可以在网页中绘制图像<br>svg即<strong>可缩放矢量图形，什么是矢量图形呢，也就是放大或者缩小不会失真的图形</strong>。 svg绘图时，每个图形都是以DOM节点的形式插入到页面中的，我们可以通过js来直接操作这些图形</p><h4 id="canvas和svg的区别"><a href="#canvas和svg的区别" class="headerlink" title="canvas和svg的区别"></a>canvas和svg的区别</h4><p>canvas绘画出来的图形一般成为位图，也就是放大缩小的情况下会出现失真的情况，svg绘制的图形是矢量图，不存在失真的情况</p><p>canvas绘制的图形不会出现在DOM结构中，svg绘制的会存在于DOM结构</p><p>canvas类似于动画，每次图形的改变都是先清除原来的图形，然后把新的图形画上去，svg则是可以直接通过js来进行某些操作</p><p>canvas依赖于分辨率，svg不依赖分辨率</p><p>canvas最适合图像密集型的游戏，其中的许多对象会被频繁重绘，svg不适合游戏应用</p><h3 id="图片格式-各自优缺点和使用场景"><a href="#图片格式-各自优缺点和使用场景" class="headerlink" title="图片格式,各自优缺点和使用场景"></a>图片格式,各自优缺点和使用场景</h3><p><a href="https://pengzhenglong.github.io/2022/03/04/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F--%E5%90%84%E8%87%AA%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/">图片格式&amp;&amp;各自优缺点和使用场景 _</a></p><h3 id="link标签和import标签的区别"><a href="#link标签和import标签的区别" class="headerlink" title="link标签和import标签的区别"></a>link标签和import标签的区别</h3><ol><li>link是属于html标签，而@import是css提供的</li><li>页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载</li><li>link是html标签，因此没有兼容性，而@import只有IE5以上才能识别</li><li>link方式样式的权重高于@import</li><li>使⽤dom控制样式时的差别。当使⽤javascript控制dom去改变样式的时候，只能使⽤link标签，因为@import不是 dom可以控制的。</li></ol><h3 id="为什么要清除浮动？怎么清除浮动？"><a href="#为什么要清除浮动？怎么清除浮动？" class="headerlink" title="为什么要清除浮动？怎么清除浮动？"></a>为什么要清除浮动？怎么清除浮动？</h3><h4 id="产生原因：子盒子浮动导致的父盒子内高度为-0-，父级盒子不能被撑开，发生高度塌陷的情况"><a href="#产生原因：子盒子浮动导致的父盒子内高度为-0-，父级盒子不能被撑开，发生高度塌陷的情况" class="headerlink" title="产生原因：子盒子浮动导致的父盒子内高度为 0 ，父级盒子不能被撑开，发生高度塌陷的情况"></a>产生原因：子盒子浮动导致的父盒子内高度为 0 ，父级盒子不能被撑开，发生高度塌陷的情况</h4><h4 id="带来的负作用"><a href="#带来的负作用" class="headerlink" title="带来的负作用"></a>带来的负作用</h4><ol><li>背景不能显示</li><li>边框不能撑开</li><li>margin和padding值不能正确显示</li></ol><h4 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h4><ol><li>给父盒子设置合适的高度</li><li>给父盒子添加样式 overflow：hidden/auto;（这个属性相当于触发BFC，让父级紧贴内容，包括使用了浮动的盒子）（为了去除兼容性问题，会添加zoom:1;）</li><li>在父盒子里面的子盒子后面添加一个子盒子，如div，添加样式 .clear{clear:both;}；</li><li>采用伪元素，给父元素追加::after，给父元素添加一个类.clearfix{content:””;clear:both;}</li></ol><h3 id="BFC-IFC-（块级格式化上下文-行级格式化上下文）"><a href="#BFC-IFC-（块级格式化上下文-行级格式化上下文）" class="headerlink" title="BFC/IFC  （块级格式化上下文/行级格式化上下文）"></a>BFC/IFC  （块级格式化上下文/行级格式化上下文）</h3><p>BFC指的是<strong>块级格式化上下文</strong>，</p><ol><li>一个元素形成了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也不会影响到BFC中的内部元素。</li><li>一个BFC就像是一个隔离区域，和其他区域互不影响。</li><li>一般来说根元素是一个BFC区域，浮动和绝对定位的元素也会形成BFC，display属性的值为inline-block、flex这些属性时也会创建BFC。</li><li>还有就是元素的overflow的值不为visible时都会创建BFC。</li></ol><h5 id="BFC的应用-overflow-hidden"><a href="#BFC的应用-overflow-hidden" class="headerlink" title="BFC的应用 (overflow:hidden)"></a>BFC的应用 (overflow:hidden)</h5><p>清除浮动：父元素设置overflow: hidden触发BFC实现清除浮动，防止父元素高度塌陷，后面的元素被覆盖，实现文字环绕等等。<br>消除相邻元素垂直方向的边距重叠：第二个子元素套一层，并设置overflow: hidden，构建BFC使其不影响外部元素。<br>消除父子元素边距重叠，父元素设置overflow: hidden</p><h5 id="触发BFC的方式"><a href="#触发BFC的方式" class="headerlink" title="触发BFC的方式"></a>触发BFC的方式</h5><p>float 不为 none，浮动元素所在的区域就是一个 BFC 区域。<br>position 的值不是 static 或 relative 的元素所在的区域就是一个 BFC 区域<br>display为 table-cell 的表格单元格元素所在的区域也是一个 BFC 区域<br>overflow 不为 visible 的元素所在的区域也是一个 BFC 区域</p><h4 id="margin重叠-及防止方法-overflow-hidden"><a href="#margin重叠-及防止方法-overflow-hidden" class="headerlink" title="margin重叠 及防止方法(overflow:hidden)"></a>margin重叠 及防止方法(overflow:hidden)</h4><p>防止外边距重叠解决方案：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">外层元素<span class="hljs-attribute">padding</span>代替<br>外层元素 <span class="hljs-attribute">overflow</span>:hidden;<br><br>内层元素绝对定位 postion:absolute:<br>内层元素 加float:left;或<span class="hljs-attribute">display</span>:inline-block;<br>内层元素<span class="hljs-attribute">padding</span>:<span class="hljs-number">1px</span>;<br>内层元素透明边框 <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid transparent;<br></code></pre></td></tr></table></figure><h4 id="IFC指的是行级格式化上下文，它有这样的一些布局规则"><a href="#IFC指的是行级格式化上下文，它有这样的一些布局规则" class="headerlink" title="IFC指的是行级格式化上下文，它有这样的一些布局规则"></a>IFC指的是<strong>行级格式化上下文</strong>，它有这样的一些布局规则</h4><p>（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。<br>（2）当一行不够的时候会自动切换到下一行。<br>（3）行级上下文的高度由内部最高的内联盒子的高度决定。</p><p><a href="https://pengzhenglong.github.io/2021/05/10/BFC/">博客：BFC–块级格式化上下文</a></p><h3 id="Flex-–请解释一下-CSS3-的-Flex-box（弹性盒布局模型），以及适用场景？"><a href="#Flex-–请解释一下-CSS3-的-Flex-box（弹性盒布局模型），以及适用场景？" class="headerlink" title="Flex –请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？"></a>Flex –请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？</h3><ol><li>flex布局是CSS3新增的一种布局方式，我们可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。</li><li>一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。</li><li>我们可以使用flex-direction来指定主轴的方向。（默认是x轴为主轴）</li><li>我们可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。</li><li>还可以使用flex-wrap来规定当一行排列不下时的换行方式。</li><li>对于容器中的项目，我们可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例。</li><li>还可以使用flex-shrink /flex-grow来指定当排列空间不足时，项目的缩小比例。</li></ol><p><a href="https://pengzhenglong.github.io/2021/04/14/CSS3flex%E5%B8%83%E5%B1%80/">博客：Flex布局</a></p><h3 id="flex中的缩写代表什么"><a href="#flex中的缩写代表什么" class="headerlink" title="flex中的缩写代表什么"></a>flex中的缩写代表什么</h3><p>flex是flex-grow,flex-shrink和flex-basis的缩写，flex属性值可以只指定一个属性的值，而另外的属性值采用各自在flex属性中的的初始值，但是有一点要注意的是：flex属性中flex-grow和flex-basis的初始值和它们原始的默认值不同，至于为什么不同，mdn中有明确的说过这样的设计是为了让「flex」缩写在最常见的情景下比较好用。<br>flex:1—-(flex-grow:0;flex-shrink:1;flex-basis:auto)  </p><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><p>一般常见的几种居中的方法有：</p><h4 id="对于宽高固定的元素"><a href="#对于宽高固定的元素" class="headerlink" title="对于宽高固定的元素"></a>对于宽高固定的元素</h4><p>（1）我们可以利用<strong>margin:0 auto</strong>来实现元素的水平居中。</p><p>（2）利用<strong>绝对定位，设置四个方向的值都为0，并将margin设置为auto</strong>，由于宽高固定，因此对应方向实现平分，可以实现水<br>平和垂直方向上的居中。</p><p>（3）利用<strong>绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值</strong>来调整元素<br>的中心点到页面的中心。</p><h5 id="对于宽高不定的元素，下面两种方法，可以实现元素的垂直和水平的居中"><a href="#对于宽高不定的元素，下面两种方法，可以实现元素的垂直和水平的居中" class="headerlink" title="对于宽高不定的元素，下面两种方法，可以实现元素的垂直和水平的居中"></a>对于宽高不定的元素，下面两种方法，可以实现元素的垂直和水平的居中</h5><p>（4）利用<strong>绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate</strong>来调整元素<br>的中心点到页面的中心。</p><p>（5）使用<strong>flex布局</strong>，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对<br>齐，然后它的子元素也可以实现垂直和水平的居中。</p><p>(6) <strong>gird布局</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">place-<span class="hljs-keyword">items</span>:center<br></code></pre></td></tr></table></figure><p>CSS 中的 place-items 是一个简写属性 ，它允许你在相关的布局（如 Grid 或 Flexbox）中可以同时沿着块级和内联方向对齐元素 (例如：align-items 和 justify-items 属性) 。如果未提供第二个值，则第一个值作为第二个值的默认值。</p><ol><li>文本水平居中：text-algin: center</li><li>文本垂直居中：line-height等于容器height；display: flex; algin-items: center;</li><li>div水平居中：</li></ol><ul><li>margin: 0 auto;</li><li>display: flex;   justify-content: center;</li></ul><p> 已知父元素宽度：margin-left: width / 2; transform: tranlateX(-50%)</p><p> 未知父元素宽度：position: absolute: top: 50%; transform: tranlateY(-50%)</p><p>div垂直居中：display: flex; algin-items: center;</p><p> 已知父元素高度：margin-top: height / 2; transform: tranlateY(-50%)</p><p> 未知父元素高度：position: absolute: top: 50%; transform: tranlateY(-50%)</p><h3 id="●-css布局"><a href="#●-css布局" class="headerlink" title="● css布局"></a>● css布局</h3><p>六种布局方式总结：圣杯布局、双飞翼布局、Flex布局、绝对定位布局、表格布局、网格布局。</p><ol><li>圣杯布局是指布局从上到下分为header、container、footer，然后container部分定为三栏布局。这种布局方式同样分为header、container、footer。圣杯布局的缺陷在于 center 是在 container 的padding中的，因此宽度小的时候会出现混乱。</li><li>双飞翼布局给center 部分包裹了一个 main 通过设置margin主动地把页面撑开。</li><li>Flex布局是由CSS3提供的一种方便的布局方式。</li><li>绝对定位布局是给container 设置position: relative和overflow: hidden，因为绝对定位的元素的参照物为第一个postion不为static的祖先元素。 left 向左浮动，right 向右浮动。center 使用绝对定位，通过设置left和right并把两边撑开。 center 设置top: 0和bottom: 0使其高度撑开。</li><li>表格布局的好处是能使三栏的高度统一。</li><li>网格布局可能是最强大的布局方式了，使用起来极其方便，但目前而言，兼容性并不好。网格布局，可以将页面分割成多个区域，或者用来定义内部元素的大小，位置，图层关系。</li></ol><h3 id="css-两栏布局的实现？"><a href="#css-两栏布局的实现？" class="headerlink" title="css 两栏布局的实现？"></a>css 两栏布局的实现？</h3><h4 id="两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式"><a href="#两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式" class="headerlink" title="两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式"></a>两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式</h4><p>回答：<br>两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。<br>以左边宽度固定为 200px 为例<br>-（1）利用<strong>浮动</strong>，将左边元素宽度设置为 200px，并且设置向左浮动。将右边元素的 margin-left 设置为 200px，宽度设置为 auto（默认为 auto，撑满整个父元素）。<br>-（2）第二种是利用<strong> flex </strong> 布局，将左边元素的放大和缩小比例设置为 0，基础大小设置为 200px。将右边的元素的放大比例设置为 1，缩小比例设置为 1，基础大小设置为 auto。<br>-（3）第三种是利用<strong> 绝对定位布局 </strong>的方式，将父级元素设置相对定位。左边元素设置为 absolute 定位，并且宽度设置为 200px。将右边元素的 margin-left 的值设置为 200px。<br>-（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为 200px，右边元素设置为绝对定位，左边定位为 200px，其余方向定位为 0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs css"><br><span class="hljs-comment">/*以左边宽度固定为200px为例*/</span><br><br><span class="hljs-comment">/*（1）利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br> <span class="hljs-attribute">float</span>: left;<br><br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br><br> <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br> <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br><br> <span class="hljs-attribute">width</span>: auto;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br> <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-comment">/*（2）第二种是利用flex布局，将左边元素的放大和缩小比例设置为0，基础大小设置为200px。将右边的元素的放大比例设置为1，缩小比例设置为1，基础大小设置为auto。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br> <span class="hljs-attribute">display</span>: flex;<br><br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br> <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">0</span>;<br> <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">0</span>;<br> <span class="hljs-attribute">flex-basis</span>: <span class="hljs-number">200px</span>;<br><br> <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br> <span class="hljs-attribute">flex</span>: auto;<br> <span class="hljs-comment">/*11auto*/</span><br><br> <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-comment">/*（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为absolute定位，并且宽度设置为</span><br><span class="hljs-comment">200px。将右边元素的margin-left的值设置为200px。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br> <span class="hljs-attribute">position</span>: relative;<br><br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br> <span class="hljs-attribute">position</span>: absolute;<br><br> <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br> <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br> <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br> <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-comment">/*（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br> <span class="hljs-attribute">position</span>: relative;<br><br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br> <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br> <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br> <span class="hljs-attribute">position</span>: absolute;<br><br> <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br> <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br> <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br> <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br><br> <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="css实现两栏固定中间自适应（和三栏布局一样）"><a href="#css实现两栏固定中间自适应（和三栏布局一样）" class="headerlink" title="css实现两栏固定中间自适应（和三栏布局一样）"></a>css实现两栏固定中间自适应（和三栏布局一样）</h3><p>1、利用<strong>绝对定位和margin</strong><br>2、利用<strong>浮动和margin–注意：中间一栏必须放到最后。</strong><br>3、CSS3 <strong>flex</strong></p><p><a href="https://pengzhenglong.github.io/2021/07/06/Css%E5%B8%83%E5%B1%80/#2%E3%80%81%E5%88%A9%E7%94%A8%E6%B5%AE%E5%8A%A8%E5%92%8Cmargin">博客：css实现两栏固定中间自适应</a></p><h3 id="css-三栏布局的实现？"><a href="#css-三栏布局的实现？" class="headerlink" title="css 三栏布局的实现？"></a>css 三栏布局的实现？</h3><h4 id="三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式"><a href="#三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式" class="headerlink" title="三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式"></a>三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式</h4><p>这里以左边宽度固定为100px，右边宽度固定为200px为例<br>（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</p><p>（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto。</p><p>（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意：中间一栏必须放到最后。</p><p>（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置margin负值将其移动到上一行，再利用相对定位，定位到两边。圣杯布局中间列的宽度不能小于两边任意列的宽度，而双飞翼布局则不存在这个问题。</p><p>（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的margin值来实现的，而不是通过父元素的padding来实现的。本质上来说，也是通过浮动和外边距负值来实现的。<br><a href="http://cavszhouyou.top/Demo-Display/ThreeColumnLayout/index.html">三栏布局demo</a></p><p>相关资料：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*这里以左边宽度固定为100px，右边宽度固定为200px为例。*/</span><br><br><span class="hljs-comment">/*（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br> <span class="hljs-attribute">position</span>: relative;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br> <span class="hljs-attribute">position</span>: absolute;<br><br> <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br> <span class="hljs-attribute">position</span>: absolute;<br> <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br> <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br><br> <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br> <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-comment">/*（2）利用flex布局的方式，左右两栏的放大和缩小比例都设置为0，基础大小设置为固定的大小，中间一栏设置为auto*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br> <span class="hljs-attribute">display</span>: flex;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br> <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br> <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br> <span class="hljs-attribute">flex</span>: auto;<br> <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-comment">/*（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br> <span class="hljs-attribute">float</span>: left;<br> <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br> <span class="hljs-attribute">float</span>: right;<br> <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-comment">/*（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br> <span class="hljs-attribute">position</span>: relative;<br> <span class="hljs-attribute">left</span>: -<span class="hljs-number">100px</span>;<br><br> <span class="hljs-attribute">float</span>: left;<br> <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br> <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br> <span class="hljs-attribute">position</span>: relative;<br> <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br><br> <span class="hljs-attribute">float</span>: right;<br> <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br> <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br> <span class="hljs-attribute">float</span>: left;<br><br> <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-comment">/*（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元</span><br><span class="hljs-comment">素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。*/</span><br><br><span class="hljs-selector-class">.outer</span> &#123;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br> <span class="hljs-attribute">float</span>: left;<br> <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br> <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br> <span class="hljs-attribute">float</span>: left;<br> <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br> <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.wrapper</span> &#123;<br> <span class="hljs-attribute">float</span>: left;<br><br> <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br> <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br> <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="transition（过渡）和animation（动画）的区别"><a href="#transition（过渡）和animation（动画）的区别" class="headerlink" title="transition（过渡）和animation（动画）的区别"></a>transition（过渡）和animation（动画）的区别</h3><p>Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，<br>他们的主要区别是<strong>transition需要触发一个事件才能改变属性</strong>，而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from …. to，而animation可以一帧一帧的。<br>animation可设置循环次数<br>animation可设置每一帧的样式和时间，transition只能设置头尾</p><h3 id="Js-动画与-CSS-动画区别及相应实现"><a href="#Js-动画与-CSS-动画区别及相应实现" class="headerlink" title="Js 动画与 CSS 动画区别及相应实现"></a>Js 动画与 CSS 动画区别及相应实现</h3><h4 id="CSS3-的动画的优点"><a href="#CSS3-的动画的优点" class="headerlink" title="CSS3 的动画的优点"></a>CSS3 的动画的优点</h4><p>在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化<br>代码相对简单</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>在动画控制上不够灵活<br>兼容性不好</p><h4 id="Js动画"><a href="#Js动画" class="headerlink" title="Js动画"></a>Js动画</h4><p>JavaScript 的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。对于一些复杂控制的动画，使用 javascript 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧</p><h4 id="那我们什么时候使用-CSS-动画，什么时候使用-JS-动画呢？"><a href="#那我们什么时候使用-CSS-动画，什么时候使用-JS-动画呢？" class="headerlink" title="那我们什么时候使用 CSS 动画，什么时候使用 JS 动画呢？"></a>那我们什么时候使用 CSS 动画，什么时候使用 JS 动画呢？</h4><p>我个人觉得<br>只要能用 CSS 实现的动画，就不要采用 JS 去实现，可以多采用 CSS 预处理器去做更多复杂的动画，就像我之前用 SCSS 做的流星雨动画一样<br>如果动画相较复杂，我们可以采用 JS + canvas 去尝试，能不能实现<br>最后再考虑纯 JS 实现<br><a href="https://juejin.cn/post/6999934705957077029#heading-8">为什么 CSS 动画比 JavaScript 高效？</a></p><h3 id="用纯-CSS-创建一个三角形的原理是什么？"><a href="#用纯-CSS-创建一个三角形的原理是什么？" class="headerlink" title="用纯 CSS 创建一个三角形的原理是什么？"></a>用纯 CSS 创建一个三角形的原理是什么？</h3><p>采用的是相邻边框连接处的均分原理。<br> 将元素的宽高设为0，只设置<br> border，把任意三条边隐藏掉（颜色设为transparent），剩下的就是一个三角形。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs maxima"> #<span class="hljs-built_in">demo</span> &#123;<br> <span class="hljs-built_in">width</span>: <span class="hljs-number">0</span>;<br> <span class="hljs-built_in">height</span>: <span class="hljs-number">0</span>;<br> <span class="hljs-built_in">border</span>-<span class="hljs-built_in">width</span>: 20px;<br> <span class="hljs-built_in">border</span>-<span class="hljs-built_in">style</span>: solid;<br> <span class="hljs-built_in">border</span>-<span class="hljs-built_in">color</span>: <span class="hljs-built_in">transparent</span> <span class="hljs-built_in">transparent</span> red <span class="hljs-built_in">transparent</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://pengzhenglong.github.io/2021/06/27/CSS%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2%E2%80%94border%E6%B3%95/">博客：CSS绘制三角形—border法</a></p><h3 id="什么是重绘和回流？（浏览器绘制过程）"><a href="#什么是重绘和回流？（浏览器绘制过程）" class="headerlink" title="什么是重绘和回流？（浏览器绘制过程）"></a>什么是重绘和回流？（浏览器绘制过程）</h3><h3 id="注意：回流一定会触发重绘，而重绘不一定会回流"><a href="#注意：回流一定会触发重绘，而重绘不一定会回流" class="headerlink" title="注意：回流一定会触发重绘，而重绘不一定会回流"></a>注意：回流一定会触发重绘，而重绘不一定会回流</h3><h4 id="什么是回流？"><a href="#什么是回流？" class="headerlink" title="什么是回流？"></a>什么是回流？</h4><p>当一个元素自身的宽高，布局，显示或隐藏，或元素内部的文字结构发生变化，导致需要重新构建页面的时候，就产生了回流</p><h4 id="什么是重绘？"><a href="#什么是重绘？" class="headerlink" title="什么是重绘？"></a>什么是重绘？</h4><p>当一个元素自身的宽高，布局，及显示或隐藏没有改变，而只是改变了元素的外观风格的时候，就产生了重绘</p><h4 id="什么时候会进行回流？"><a href="#什么时候会进行回流？" class="headerlink" title="什么时候会进行回流？"></a>什么时候会进行回流？</h4><ol><li><p>添加或者删除可见的DOM元素的时候</p></li><li><p>元素的位置发生改变</p></li><li><p>元素的尺寸发生改变</p></li><li><p>内容改变</p></li><li><p>页面第一次渲染的时候</p></li></ol><p>列举一些相关的CSS样式：width、height、line-height、padding、margin、diaplay、border、top、position、float、font-size、overflow等</p><h4 id="什么时候会进行重绘？"><a href="#什么时候会进行重绘？" class="headerlink" title="什么时候会进行重绘？"></a>什么时候会进行重绘？</h4><p>列举一些相关的CSS样式：color、background、background-size、visibility、box-shadow</p><h4 id="如何进行性能优化？"><a href="#如何进行性能优化？" class="headerlink" title="如何进行性能优化？"></a>如何进行性能优化？</h4><ol><li><p>用transform 代替 top，left ，margin-top， margin-left… 这些位移属性</p></li><li><p>不要使用 js 代码对dom 元素设置多条样式，选择用一个 className 代替之</p></li><li><p>不要在循环内获取dom 的样式例如：offsetWidth, offsetHeight, clientWidth, clientHeight等。浏览器有一个回流的缓冲机制，获取这些属性时会产生回流</p></li><li><p>避免设置多层内联样式，写个外部类这样只回流一次</p></li><li><p>让多次回流的元素脱离文档流比如动画，使用 position 属性的 fixed 值或 absolute 值</p></li><li><p>一起变化（同时修改所有需要变化的属性）</p></li></ol><h4 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h4><p>CSS</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><br>避免使用table布局。<br>尽可能在DOM树的最末端改变<span class="hljs-keyword">class</span>。<br>避免设置多层内联样式。<br>将动画效果应用到<span class="hljs-symbol">position</span>属性为<span class="hljs-symbol">absolute</span>或<span class="hljs-symbol">fixed</span>的元素上。<br>避免使用<span class="hljs-symbol">CSS</span>表达式（例如：<span class="hljs-symbol">calc</span>()）。<br></code></pre></td></tr></table></figure><p>JavaScript</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为<span class="hljs-keyword">class</span>并一次性更改<span class="hljs-symbol">class</span>属性。<br>避免频繁操作<span class="hljs-symbol">DOM</span>，创建一个<span class="hljs-symbol">documentFragment</span>，在它上面应用所有<span class="hljs-symbol">DOM</span>操作，最后再把它添加到文档中。<br>也可以先为元素设置<span class="hljs-symbol">display: <span class="hljs-symbol">none</span></span>，操作结束后再把它显示出来。因为在<span class="hljs-symbol">display</span>属性为<span class="hljs-symbol">none</span>的元素上进行的<span class="hljs-symbol">DOM</span>操作不会引发回流和重绘。<br>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。<br>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。<br></code></pre></td></tr></table></figure><p><a href="https://pengzhenglong.github.io/2021/07/24/%E9%87%8D%E7%BB%98%E5%9B%9E%E6%B5%81/">博客：浏览器的回流与重绘</a></p><h3 id="css选择器优先级"><a href="#css选择器优先级" class="headerlink" title="css选择器优先级"></a>css选择器优先级</h3><p>!important &gt; inline &gt; id &gt; class &gt; tag &gt; *&gt; inherit &gt; default</p><blockquote><p>总结排序：!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性  同一级别</p></blockquote><p>!important：大于其他<br>行内：1000<br>id选择器：100<br>类，伪类和属性选择器，如.content：10<br>类型选择器和伪元素选择器：1<br>tag  标签选择器 如（body  div  p li）<br>全局选择器(如：*号)<br>通配符、子选择器、相邻选择器：0</p><blockquote><p>同级别的后写的优先级高。</p></blockquote><p>相同class样式，css中后写的优先级高，和html中的class名字前后无关</p><h4 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h4><p>id选择器&gt;class选择器&gt;标签选择器</p><h4 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h4><ol><li>后代选择器：在某个元素的后面(都会作用)</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*body  p&#123;        background: red;    &#125;*/</span>例：<span class="hljs-selector-tag">body</span>后的所有<span class="hljs-selector-tag">p</span>标签背景都会变为红色<br></code></pre></td></tr></table></figure><ol start="2"><li>子选择器：(就作用一代)</li></ol> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*body&gt;p&#123;       background:blue;   &#125;*/</span>例：<span class="hljs-selector-tag">body</span>后面的第一代<span class="hljs-selector-tag">p</span>标签才有效果，其他嵌套的没有<br></code></pre></td></tr></table></figure><ol start="3"><li>相邻兄弟选择器：只有一个，相邻(向下)</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*.active+p&#123;        background:blue;    &#125;*/</span>例：类active标签的向下的一个P标签才会作用<br></code></pre></td></tr></table></figure><ol start="4"><li>通用兄弟选择器</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">当前选中元素的向下的所有兄弟元素 */    <span class="hljs-selector-class">.active</span> ~ <span class="hljs-selector-tag">p</span> &#123;      <span class="hljs-attribute">background</span>: tomato;    &#125;例：类active后面向下的所有<span class="hljs-selector-tag">P</span>标签都会作用<br></code></pre></td></tr></table></figure><h4 id="结构伪类选择器-避免使用，class-id选择器"><a href="#结构伪类选择器-避免使用，class-id选择器" class="headerlink" title="结构伪类选择器(避免使用，class,id选择器)"></a>结构伪类选择器(避免使用，class,id选择器)</h4><blockquote><p>带冒号都是伪类选择器<br>1 ul li:first-child</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*ul的第一个子元素*/</span><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first</span>-child &#123;  <span class="hljs-attribute">background</span>: tomato;&#125;<br><span class="hljs-comment">/*ul的最后一个元素*/</span><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span> &#123;  <span class="hljs-attribute">background</span>: turquoise;&#125;<br></code></pre></td></tr></table></figure><p>2 p:nth-child(1) (nth父元素)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*选中p1: 定位到父元素，选择当前的第一个元素 选择当前p元素的父级元素，选择父级元素的第一个,并且是当前元素才生效*/</span>    <br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>)&#123;      <span class="hljs-attribute">background</span>: violet;  &#125;*/<br></code></pre></td></tr></table></figure><p>3 p:nth-of-type(1)<br>4 a:hover(鼠标悬浮的颜色 (重要))<br>a:hover {  background: yellow;}</p><h4 id="属性选择器-重要"><a href="#属性选择器-重要" class="headerlink" title="属性选择器(重要)"></a>属性选择器(重要)</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs css"><br><span class="hljs-comment">/*属性名， 属性名= 属性值（正则）</span><br><span class="hljs-comment">=绝对等于</span><br><span class="hljs-comment">*=包含这个元素</span><br><span class="hljs-comment">^= 以这个开头</span><br><span class="hljs-comment">$= 以这个结尾</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    /*存在id属性的元素   a[]&#123;&#125;*/</span><br>    <span class="hljs-comment">/*a[id]&#123;</span><br><span class="hljs-comment">    background: yellow;</span><br><span class="hljs-comment">&#125;*/</span><br>    <span class="hljs-comment">/*id=first的元素*/</span><br>    <span class="hljs-comment">/*a[id=first]&#123;</span><br><span class="hljs-comment">    background: violet;</span><br><span class="hljs-comment">&#125;*/</span><br>    <span class="hljs-comment">/*class 中有links的元素*/</span><br>    <span class="hljs-comment">/*a[class*=&quot;links&quot;]&#123;</span><br><span class="hljs-comment">    background: yellow;</span><br><span class="hljs-comment">&#125;*/</span><br>    <span class="hljs-comment">/*选中href中以http开头的元素*/</span><br>    <span class="hljs-comment">/*a[href^=http]&#123;</span><br><span class="hljs-comment">background: yellow;</span><br><span class="hljs-comment">&#125;*/</span><br>    <span class="hljs-comment">/*选中href中以doc结尾的元素*/</span><br>    <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href$=<span class="hljs-string">&#x27;doc&#x27;</span>]</span> &#123;<br>      <span class="hljs-attribute">background</span>: yellow;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h3 id="画一条0-5px的线"><a href="#画一条0-5px的线" class="headerlink" title="画一条0.5px的线"></a>画一条0.5px的线</h3><p>1.采用meta viewport的方式</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix">&lt;meta <span class="hljs-attr">name=&quot;viewport&quot;</span> <span class="hljs-attr">content=&quot;width=device-width,</span> <span class="hljs-attr">initial-scale=0.5,</span> <span class="hljs-attr">minimum-scale=0.5,</span> <span class="hljs-attr">maximum-scale=0.5&quot;/&gt;</span><br></code></pre></td></tr></table></figure><p>这样子就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px<br>要记得viewport只针对于移动端，只在移动端上才能看到效果<br>2.采用transform: scale()的方式</p><p>transform: scale(0.5,0.5);<br>3.采用border-image的方式</p><h3 id="怎么让文本不自动换行？怎么让超过文本部分变成省略号？"><a href="#怎么让文本不自动换行？怎么让超过文本部分变成省略号？" class="headerlink" title="怎么让文本不自动换行？怎么让超过文本部分变成省略号？"></a>怎么让文本不自动换行？怎么让超过文本部分变成省略号？</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">white-space</span>:nowrap;<br><span class="hljs-attribute">overflow</span>:hidden;<br><span class="hljs-attribute">text-overflow</span>:ellipsis;<br></code></pre></td></tr></table></figure><h3 id="before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个元素的作用"><a href="#before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个元素的作用" class="headerlink" title="::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个元素的作用"></a>::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个元素的作用</h3><p>单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）<br>伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after、before等。<br>css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。</p><h3 id="绝对定位–position-的值-relative-和-absolute-定位原点是？"><a href="#绝对定位–position-的值-relative-和-absolute-定位原点是？" class="headerlink" title="绝对定位–position 的值 relative 和 absolute 定位原点是？"></a>绝对定位–position 的值 relative 和 absolute 定位原点是？</h3><p> 绝对定位是相对于元素<strong>最近的已定位的父亲元素</strong>来定位的（设置了绝对定位或者相对定位的父亲元素）。如果元素没有已定位的父亲元素，那么它的位置则是相对于最初的包含块（body），这点在做轮播时非常重要。</p><ol><li>absolute生成绝对定位的元素，相对于值不为static的第一个父元素的padding box进行定位，也可以理解为离自己这一级元素最近的一级5. 5.</li><li>fixed（老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。relative生成相对定位的元素，相对于其元素本身所在正常位置进行定位。</li><li>static默认值。没有定位，元素出现在正常的流中（忽略top,bottom,left,right,z-index声明）。</li><li>inherit规定从父元素继承position属性的值。</li><li>position设置为absolute或者relative的父元素的padding box的左上角为原点的。</li></ol><h4 id="答：relative定位的元素，是相对于元素本身的正常位置来进行定位的"><a href="#答：relative定位的元素，是相对于元素本身的正常位置来进行定位的" class="headerlink" title="答：relative定位的元素，是相对于元素本身的正常位置来进行定位的"></a>答：relative定位的元素，是相对于元素本身的正常位置来进行定位的</h4><p>absolute定位的元素，是相对于它的第一个position值不为static的祖先元素的padding box来进行定位的。这句话我们可以这样来理解，我们首先需要找到绝对定位元素的一个position的值不为static的祖先元素，然后相对于这个祖先元素的padding box来定位，也就是说在计算定位距离的时候，padding的值也要算进去。</p><h3 id="em-px-rem区别"><a href="#em-px-rem区别" class="headerlink" title="em\px\rem区别"></a>em\px\rem区别</h3><p>px：绝对单位，⻚⾯按精确像素展示。<br>em：<strong>相对单位</strong>，基准点为⽗节点字体的⼤⼩，如果⾃身定义了font-size按⾃身来计算（浏览器默认字体是 16px），整个⻚⾯内1em不是⼀个固定的值。<br>rem：<strong>相对单位</strong>，可理解为”root em”, 相对根节点html的字体⼤⼩来计算，CSS3新加属性<br>rem优缺点<br><a href="https://pengzhenglong.github.io/2021/06/16/Css%E5%8D%95%E4%BD%8Dpx%EF%BC%8Crem%EF%BC%8Cem%EF%BC%8Cvw%EF%BC%8Cvh%E7%9A%84%E5%8C%BA%E5%88%AB/">博客：</a></p><h5 id="优点：在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持rem了，兼容性也非常的好"><a href="#优点：在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持rem了，兼容性也非常的好" class="headerlink" title="优点：在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持rem了，兼容性也非常的好"></a>优点：在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持rem了，兼容性也非常的好</h5><h5 id="缺点：（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。（2）使用iframe引用也会出现问题。（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题"><a href="#缺点：（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。（2）使用iframe引用也会出现问题。（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题" class="headerlink" title="缺点：（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。（2）使用iframe引用也会出现问题。（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题"></a>缺点：（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。（2）使用iframe引用也会出现问题。（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题</h5><h3 id="CSS-哪些可以隐藏⻚⾯元素？"><a href="#CSS-哪些可以隐藏⻚⾯元素？" class="headerlink" title="CSS 哪些可以隐藏⻚⾯元素？"></a>CSS 哪些可以隐藏⻚⾯元素？</h3><p>display:none; visibility:hidden; opacity: 0; 等等</p><ol><li>opacity:0 ：本质上是将元素的透明度将为0，就看起来隐藏了，但是依然占据空间且可以交互</li><li>visibility:hidden : 与上⼀个⽅法类似的效果，占据空间，但是不可以交互了</li><li>overflow:hidden : 这个只隐藏元素溢出的部分，但是占据空间且不可交互</li><li>display:none : 这个是彻底隐藏了元素，元素从⽂档流中消失，既不占据空间也不交互，也不影响布局</li><li>z-index:-9999 : 原理是将层级放到底部，这样就被覆盖了，看起来隐藏了</li><li>transform: scale(0,0) : 平⾯变换，将元素缩放为0，但是依然占据空间，但不可交互</li></ol><h4 id="display-none与visible-hidden的区别"><a href="#display-none与visible-hidden的区别" class="headerlink" title="display:none与visible:hidden的区别"></a>display:none与visible:hidden的区别</h4><p>一般在面试中问display:none和visibility:hidden两者区别，面试者都能回答出：两者都是隐藏元素，前者不会占据空间，后者隐藏了依然占据空间。</p><p> visibility:隐藏对应的元素但不挤占该元素原来的空间。<br> display:隐藏对应的元素并且挤占该元素原来的空间。</p><p>两者区别：</p><ol><li>visibility具有继承性，给父元素设置visibility:hidden;子元素也会继承这个属性。但是如果重新给子元素设置visibility: visible,则子元素又会显示出来。这个和display: none有着质的区别</li><li>visibility: hidden不会影响计数器的计数，如图所示，visibility: hidden虽然让一个元素不见了，但是其计数器仍在运行。这和display: none完全不一样</li><li>visibility用来设置元素的可见状态。</li><li>display:none是会有回流，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”。</li><li>visibility: hidden; 不会有回流，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在，也即是说它仍具有高度、宽度等属性值。</li></ol><h3 id="●-双边距重叠问题（外边距折叠）"><a href="#●-双边距重叠问题（外边距折叠）" class="headerlink" title="● 双边距重叠问题（外边距折叠）"></a>● 双边距重叠问题（外边距折叠）</h3><p>参考回答：<br>多个相邻（兄弟或者父子关系）普通流的块元素垂直方向marigin会重叠<br>折叠的结果为：<br>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。<br>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。<br>两个外边距一正一负时，折叠结果是两者的相加的和。</p><h3 id="●-display：table和本身的table有什么区别"><a href="#●-display：table和本身的table有什么区别" class="headerlink" title="● display：table和本身的table有什么区别"></a>● display：table和本身的table有什么区别</h3><p>参考回答：<br>Display:table和本身table是相对应的，区别在于，display：table的css声明能够让一个html元素和它的子节点像table元素一样，使用基于表格的css布局，是我们能够轻松定义一个单元格的边界，背景等样式，而不会产生因为使用了table那样的制表标签导致的语义化问题。<br>之所以现在逐渐淘汰了table系表格元素，是因为用div+css编写出来的文件比用table边写出来的文件小，而且table必须在页面完全加载后才显示，div则是逐行显示，table的嵌套性太多，没有div简洁</p><h3 id="●-z-index的定位方法"><a href="#●-z-index的定位方法" class="headerlink" title="● z-index的定位方法"></a>● z-index的定位方法</h3><p>参考回答：<br>z-index属性设置元素的堆叠顺序，拥有更好堆叠顺序的元素会处于较低顺序元素之前，z-index可以为负，且z-index只能在定位元素上奏效，该属性设置一个定位元素沿z轴的位置，如果为正数，离用户越近，为负数，离用户越远，它的属性值有auto，默认，堆叠顺序与父元素相等，number，inherit，从父元素继承z-index属性的值</p><h3 id="●-对CSS的新属性有了解过的吗？"><a href="#●-对CSS的新属性有了解过的吗？" class="headerlink" title="● 对CSS的新属性有了解过的吗？"></a>● 对CSS的新属性有了解过的吗？</h3><p>CSS3的新特性中，在布局方面新增了flex布局，在选择器方面新增了例如first-of-type,nth-child等选择器，在盒模型方面添加了box-sizing来改变盒模型，在动画方面增加了animation，2d变换，3d变换等，在颜色方面添加透明，rbga等，在字体方面允许嵌入字体和设置字体阴影，最后还有媒体查询等</p><h3 id="●-line-height和height的区别"><a href="#●-line-height和height的区别" class="headerlink" title="● line-height和height的区别"></a>● line-height和height的区别</h3><p>line-height一般是指布局里面一段文字上下行之间的高度，是针对字体来设置的，height一般是指容器的整体高度</p><h3 id="●-设置一个元素的背景颜色，背景颜色会填充哪些区域？"><a href="#●-设置一个元素的背景颜色，背景颜色会填充哪些区域？" class="headerlink" title="● 设置一个元素的背景颜色，背景颜色会填充哪些区域？"></a>● 设置一个元素的背景颜色，背景颜色会填充哪些区域？</h3><p>background-color设置的背景颜色会填充元素的content、padding、border区域，</p><h3 id="●-inline-block、inline和block的区别；为什么img是inline还可以设置宽高"><a href="#●-inline-block、inline和block的区别；为什么img是inline还可以设置宽高" class="headerlink" title="● inline-block、inline和block的区别；为什么img是inline还可以设置宽高"></a>● inline-block、inline和block的区别；为什么img是inline还可以设置宽高</h3><ol><li>Block是块级元素，其前后都会有换行符，能设置宽度，高度，margin/padding水平垂直方向都有效。</li><li>Inline：设置width和height无效，margin在竖直方向上无效，padding在水平方向垂直方向都有效，前后无换行符</li><li>Inline-block：能设置宽度高度，margin/padding水平垂直方向 都有效，前后无换行符</li><li>在 CSS 中，可替换元素（replaced element）的展示效果不是由 CSS 来控制的。这些元素是一种外部对象，它们外观的渲染，是独立于 CSS 的。</li><li>替换元素<br>简单来讲，它们的内容不受当前文档的样式的影响。CSS 能够影响可替换元素的位置，但不会影响到可替换元素自身的内容。例如<code>&lt;iframe&gt;</code>元素，可能具备本身的样式表，但它们不会继承父文档的样式。<br>典型的可替换元素有：浏览器<code>&lt;iframe&gt;&lt;video&gt;&lt;embed&gt;&lt;img&gt;</code><br>有些元素仅在特定状况下被做为可替换元素处理，例如：<code>&lt;input&gt;</code></li></ol><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><h4 id="html第一行！doctype是做什么用的"><a href="#html第一行！doctype是做什么用的" class="headerlink" title="html第一行！doctype是做什么用的"></a>html第一行！doctype是做什么用的</h4><p>告诉浏览器用什么样的模式来解析文档。如html5则为声明为html5文档<br>DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。</p><h4 id="HTML5-新特性、语义化"><a href="#HTML5-新特性、语义化" class="headerlink" title="HTML5 新特性、语义化"></a>HTML5 新特性、语义化</h4><ol><li>概念：HTML5的语义化指的是合理正确的使用语义化的标签来创建页面结构。【正确的标签做正确的事】</li><li>语义化标签：header nav main article section aside footer</li><li>语义化的优点:<br>在没CSS样式的情况下，页面整体也会呈现很好的结构效果<br>代码结构清晰，易于阅读，<br>利于开发和维护 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。<br>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重</li></ol><h4 id="src和href的区别？-src相当于同步执行，href相当于并行处理"><a href="#src和href的区别？-src相当于同步执行，href相当于并行处理" class="headerlink" title="src和href的区别？(src相当于同步执行，href相当于并行处理)"></a>src和href的区别？(src相当于同步执行，href相当于并行处理)</h4><ol><li>src是指向外部资源的位置，指向的内容会嵌⼊到⽂档中当前标签所在的位置，在请求src资源时会将其指向的资源<br>下载并应⽤到⽂档内，如js脚本，img图⽚和frame等元素。<strong>当浏览器解析到该元素时，会暂停其他资源的下载和处理，知道将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在底部⽽不是头部。</strong></li><li>href是指向⽹络资源所在位置（的超链接），⽤来建⽴和当前元素或⽂档之间的连接，<strong>当浏览器识别到它他指向的<br>⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。</strong></li></ol><h4 id="前端需要注意哪些-SEO-？"><a href="#前端需要注意哪些-SEO-？" class="headerlink" title="前端需要注意哪些 SEO ？"></a>前端需要注意哪些 SEO ？</h4><p> （1）合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可。<br>（2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。<br> （3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被抓取。<br> （4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容<br> （5）少用 iframe：搜索引擎不会抓取 iframe 中的内容<br> （6）非装饰性图片必须加 alt<br> （7）提高网站速度：网站速度是搜索引擎排序的一个重要指标</p><h4 id="行内元素、块元素有哪些？它们有什么不同？"><a href="#行内元素、块元素有哪些？它们有什么不同？" class="headerlink" title="行内元素、块元素有哪些？它们有什么不同？"></a>行内元素、块元素有哪些？它们有什么不同？</h4><p>行内元素：b、span、a、u、em、i、img、input、select、label、textarea、button<br>块级元素：div、h、ol、ul、dl、li、table、td、th、tr、dd、dt、p、caption</p><h5 id="行内元素的特点"><a href="#行内元素的特点" class="headerlink" title="行内元素的特点"></a>行内元素的特点</h5><p>1、行内元素只能容纳文本或者其他行内元素。<br>2、宽度只与内容有关。<br>3、和其他元素都在一行上。<br>4、高，行高及外边距和内边距部分可改变。</p><h5 id="块级元素的特点"><a href="#块级元素的特点" class="headerlink" title="块级元素的特点"></a>块级元素的特点</h5><p>1、高度，行高以及外边距和内边距都可控制。<br>2、总是在新行上开始，占据一整行。<br>3、它可以容纳内联元素和其他块元素。<br>4、宽度始终是与浏览器宽度一样，与内容无关。</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>1、行内元素会在一条直线上分列，都是统一行的，程度偏向分列。<br>块级元素各盘踞一行，垂直偏向分列；块级元素重新行开端停止接着一个断行。<br>2、行内元素不可以包括块级元素，只能包容文本或许其余行内元素。<br>块级元素能够包括行内元素和块级元素，还能够包容内联元素和其余元素；。<br>3、行内元素与块级元素属性的分歧，主要在盒模子属性上。<br>行内元素设置width无效，height无效（能够设置line-height），margin、padding设置上下有效。</p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础面试题(一)- 0.1+0.2为什么不等于0.3&amp;&amp;typeof NaN ||null&amp;&amp;setTimeout输出--同步与异步</title>
    <link href="/2022/02/13/JS%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98(%E4%B8%80)/"/>
    <url>/2022/02/13/JS%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="介绍-js-的基本数据类型"><a href="#介绍-js-的基本数据类型" class="headerlink" title="介绍 js 的基本数据类型"></a>介绍 js 的基本数据类型</h3><p>js 一共有六种基本数据类型，分别是 <code>Undefined、Null、Boolean、Number、String</code>，还有在 ES6 中新增的<strong> Symbol </strong> 和 ES10 中新增的<strong> BigInt </strong> 类型。</p><blockquote><p>Symbol 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。<br>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number (2^53 -1)  能够表示的安全整数范围。</p></blockquote><h3 id="typeof-NaN-的结果是什么？"><a href="#typeof-NaN-的结果是什么？" class="headerlink" title="typeof NaN 的结果是什么？"></a>typeof NaN 的结果是什么？</h3><p>NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出<br>数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">typeof NaN; <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;number&quot;</span><br></code></pre></td></tr></table></figure><p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN<br>为 true。</p><h3 id="null是对象吗？为什么？"><a href="#null是对象吗？为什么？" class="headerlink" title="null是对象吗？为什么？"></a>null是对象吗？为什么？</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">typeof 运算符对基本数据类型的运算：<br>typeof <span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;string&#x27;</span><br>typeof NaN <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;number&#x27;</span><br>typeof <span class="hljs-number">1</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;number&#x27;</span><br>typeof true <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;boolean&#x27;</span><br>typeof undefined <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;undefined&#x27;</span><br>typeof Symbol() <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;symbol&#x27;</span><br>typeof null <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;object&#x27;</span><br></code></pre></td></tr></table></figure><p>结论: null不是对象。</p><p>解释: 虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。</p><h3 id="JavaScript-有几种类型的值？你能画一下他们的内存图吗？"><a href="#JavaScript-有几种类型的值？你能画一下他们的内存图吗？" class="headerlink" title="JavaScript 有几种类型的值？你能画一下他们的内存图吗？"></a>JavaScript 有几种类型的值？你能画一下他们的内存图吗？</h3><p>涉及知识点：</p><ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><ol><li><p>两种类型的区别是：存储位置不同。</p></li><li><p>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</p></li><li><p>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在<br>栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实<br>体。</p></li></ol><h4 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。<br><br>基本数据类型....（参考<span class="hljs-number">1</span>）<br><br>复杂数据类型指的是   <span class="hljs-built_in">Object</span>   类型，所有其他的如 <span class="hljs-built_in">Array</span>、<span class="hljs-built_in">Date</span> 等数据类型都可以理解为 <span class="hljs-built_in">Object</span> 类型的子类。<br><br>两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中<br>保存对应的指针来获取堆中的值。<br></code></pre></td></tr></table></figure><h3 id="0-1-0-2为什么不等于0-3？"><a href="#0-1-0-2为什么不等于0-3？" class="headerlink" title="0.1+0.2为什么不等于0.3？"></a>0.1+0.2为什么不等于0.3？</h3><p>当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。</p><p>对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。<br>(toPrecision vs toFixed  –toPrecision 是处理精度，精度是从左至右第一个不为0的数开始数起。<br>–toFixed 是小数点后指定位数取整，从小数点开始数起。)</p><p>我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以<br>使用 es6 的 Number.EPSILON</p><h3 id="setTimeout输出值的时候，如何实现i按序输出？"><a href="#setTimeout输出值的时候，如何实现i按序输出？" class="headerlink" title="setTimeout输出值的时候，如何实现i按序输出？"></a>setTimeout输出值的时候，如何实现i按序输出？</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br>//<span class="hljs-number">55555</span><br></code></pre></td></tr></table></figure><p>这道题挺经典的，输出结果是什么呢？结果是1000毫秒之后，输出5个5（隔一秒输出在1000上乘个i就行）<br><strong>原因是，for循环在主线程内，setTimeout是异步方法，在任务队列里面，只有主线程执行完后，任务队列才执行，此时i的值已经是5，所以得到结果是5个5</strong></p><p>那么怎么解决呢？其实思路很容易，只要每次循环把当前的i值传入setTimeout内即可</p><h4 id="方法1：使用let"><a href="#方法1：使用let" class="headerlink" title="方法1：使用let"></a>方法1：使用let</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br>//<span class="hljs-number">01234</span><br></code></pre></td></tr></table></figure><p>使用let 相当于每次循环的时候都新建了1个i并为其赋值</p><p>这是因为第一个代码块中setTimeout 的 console.log(i); 的i是 var 定义的，所以是函数级的作用域，不属于 for 循环体，属于 全局变量。等到 for 循环结束，i 已经等于 5 了，这个时候再执行 setTimeout 的五个回调函数（参考上面对事件机制的阐述），里面的 console.log(i); 的 i 去向上找作用域，只能找到 全局作用下 的 i，即 5。所以输出都是 5。</p><p>而let是代码块的作用域，即是局部变量，所以每一次 for 循环，console.log(i); 都引用到 for 代码块作用域下的i，因为这样被引用，所以 for 循环结束后，这些作用域在 setTimeout 未执行前都不会被释放。</p><h4 id="方法2：定义函数并传值"><a href="#方法2：定义函数并传值" class="headerlink" title="方法2：定义函数并传值"></a>方法2：定义函数并传值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params">i</span>) </span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(i)<br>        &#125;, <span class="hljs-number">1000</span>);        <br>    &#125;<br>    a(i)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法3：IIFE（立即执行函数）"><a href="#方法3：IIFE（立即执行函数）" class="headerlink" title="方法3：IIFE（立即执行函数）"></a>方法3：IIFE（立即执行函数）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    ~<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) </span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(i)<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;(i)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>MDN<br>IIFE（立即调用函数表达式）<br>IIFE（ 立即调用函数表达式）是一个在定义时就会立即执行的  JavaScript 函数。</p></blockquote><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name">function</span> () &#123;<br>    statements<br>&#125;)()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这是一个被称为 自执行匿名函数 的设计模式，主要包含两部分。第一部分是包围在 圆括号运算符 () 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。</p><p>第二部分再一次使用 () 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。</p><h4 id="方法4：使用闭包"><a href="#方法4：使用闭包" class="headerlink" title="方法4：使用闭包"></a>方法4：使用闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<br>        (<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span><br>            () =&gt; <span class="hljs-built_in">console</span>.log(i)<br>        )(i), <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法5：setTimeout第三个参数传入i-是的，你没看错，setTimeout还有第三个参数"><a href="#方法5：setTimeout第三个参数传入i-是的，你没看错，setTimeout还有第三个参数" class="headerlink" title="方法5：setTimeout第三个参数传入i(是的，你没看错，setTimeout还有第三个参数)"></a>方法5：setTimeout第三个参数传入i(是的，你没看错，setTimeout还有第三个参数)</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">for</span> (var i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">(i)</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(i),<span class="hljs-number">1000</span>,i);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6844903700356399112#heading-7">0.1+0.2 !== 0.3？</a><br><a href="https://github.com/camsong/blog/issues/9">JavaScript 浮点数陷阱及解法</a><br><a href="https://segmentfault.com/a/1190000014045184">经典面试题 for循环内setTimeout顺序输出的解法</a></p>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 3--Teleport and  Suspense</title>
    <link href="/2022/02/05/Vue3Study(3)--Teleport%20and%20%20Suspense/"/>
    <url>/2022/02/05/Vue3Study(3)--Teleport%20and%20%20Suspense/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="1、teleport是什么"><a href="#1、teleport是什么" class="headerlink" title="1、teleport是什么"></a>1、teleport是什么</h3><p>teleport，字面意思就是<strong>远距离传送</strong>，我们可以把它理解为传送门的意思。</p><p>大家都知道，传送门的意思就是从一个地方传送到了另外一个地方。而 vue3 为什么要用 teleport 来表达呢？</p><p>其实，有一个非常常见的需求就是，我们经常要通过点击一个按钮，来实现模态框的效果。而在 vue3 之前，我们基本上控制它都是点击后<strong>上下会形成一个父子组件</strong>的关系，这样子感觉独立性就没有那么强了。<br><img src="/imageO/teleport.jpg" alt="模拟框"><br>因此， vue3 为了解决该问题，就用了 teleport 来解决。 teleport 就仿佛一个传送门，像上图这样，比如我们点击了打开按钮，那么点击完了之后，使用传送门瞬间移动到另外一个地方（模态框 Model ）。再点击关闭按钮，传送门模态框 Modal 就消失了。</p><p>通过这样的解释，相信大家对 teleport 有了一个基础的认识。</p><h4 id="1-2、实现模态框功能"><a href="#1-2、实现模态框功能" class="headerlink" title="1.2、实现模态框功能"></a>1.2、实现模态框功能</h4><p>接下来我们就来用这个功能，实现一个模态框，控制组件的显示和隐藏。</p><h5 id="（1）设置锚点"><a href="#（1）设置锚点" class="headerlink" title="（1）设置锚点"></a>（1）设置锚点</h5><p>我们现在 vue3 项目下的 /public/index.html 设置一个锚点，来放置组件的内容。具体代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span><br>    &lt;strong<br>      &gt;We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work<br>      properly without JavaScript enabled. Please enable it to<br>      continue.&lt;/strong<br>    &gt;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;modal&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- built files will be auto injected --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="（2）定义子组件"><a href="#（2）定义子组件" class="headerlink" title="（2）定义子组件"></a>（2）定义子组件</h5><p>接下来我们在 /src/components 下定义一个子组件，命名为 Modal.vue 。具体代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;#modal&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isOpen&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span> this is a modal<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;buttonClick&quot;</span>&gt;</span>Close<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">teleport</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>  <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> &#123; defineComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineComponent(&#123;</span><br>  props: &#123;<br><span class="javascript">    isOpen: <span class="hljs-built_in">Boolean</span>,</span><br>  &#125;,<br>  emits: &#123;<br><span class="javascript">    <span class="hljs-string">&quot;close-modal&quot;</span>: <span class="hljs-literal">null</span>,</span><br>  &#125;,<br><span class="javascript">     <span class="hljs-comment">//props对应props的内容</span></span><br><span class="javascript">    <span class="hljs-comment">//context名字可以自定义，只要上下对应即可，用来触发emit的内容</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">props, context</span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">const</span> buttonClick = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">      context.emit(<span class="hljs-string">&quot;close-modal&quot;</span>);</span><br>    &#125;;<br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br>      buttonClick,<br>    &#125;;<br>  &#125;,<br>&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>#center &#123;<br><span class="css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="css">  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid black;</span><br><span class="css">  <span class="hljs-attribute">background</span>: white;</span><br><span class="css">  <span class="hljs-attribute">position</span>: fixed;</span><br><span class="css">  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;</span><br><span class="css">  <span class="hljs-attribute">right</span>: <span class="hljs-number">50%</span>;</span><br><span class="css">  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;</span><br><span class="css">  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>;</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="（3）定义父组件"><a href="#（3）定义父组件" class="headerlink" title="（3）定义父组件"></a>（3）定义父组件</h5><p>之后我们再来定义一个父组件，命名为 index.vue 。具体代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn1&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;openModal&quot;</span>&gt;</span>打开模态框<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modal</span> <span class="hljs-attr">:isOpen</span>=<span class="hljs-string">&quot;modalIsOpen&quot;</span> @<span class="hljs-attr">close-modal</span>=<span class="hljs-string">&quot;onModalClose&quot;</span>&gt;</span><br>      My Modal!!!<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">modal</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> &#123; ref, defineComponent&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="javascript"><span class="hljs-keyword">import</span> Modal <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/Modal.vue&#x27;</span></span><br><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineComponent(&#123;</span><br><span class="javascript">  name: <span class="hljs-string">&#x27;App&#x27;</span>,</span><br>  components: &#123;<br>    Modal<br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-comment">//添加响应式对象控制是否显示</span></span><br><span class="javascript">    <span class="hljs-keyword">const</span> modalIsOpen = ref(<span class="hljs-literal">false</span>)</span><br><span class="javascript">    <span class="hljs-comment">//打开模态框事件</span></span><br><span class="javascript">    <span class="hljs-keyword">const</span> openModal = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">      modalIsOpen.value = <span class="hljs-literal">true</span></span><br>    &#125;<br><span class="javascript">    <span class="hljs-comment">//关闭模态框事件</span></span><br><span class="javascript">    <span class="hljs-keyword">const</span> onModalClose = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">      modalIsOpen.value = <span class="hljs-literal">false</span></span><br>    &#125;<br>   <br><span class="javascript">    <span class="hljs-keyword">return</span>&#123;</span><br>      modalIsOpen,<br>      openModal,<br>      onModalClose<br>    &#125;<br>  &#125;<br>&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/imageO/teleport1.jpg" alt="运行效果"><br>大家可以看到，通过 teleport 的方式，现在的模态框成功显示在 id 为 app 的 div 同一层下，达到了相互独立，而不再是父子层级的结果。</p><p>在上面的案例中，我们学习到了通过使用 vue3 新推出的 teleport 特性，将组件渲染到另外一个 DOM 节点的方法，这样使得组件之间的独立性更强。</p><h3 id="2-用Suspense发起一个异步请求"><a href="#2-用Suspense发起一个异步请求" class="headerlink" title="2.用Suspense发起一个异步请求"></a>2.用Suspense发起一个异步请求</h3><h4 id="1、Suspense是什么"><a href="#1、Suspense是什么" class="headerlink" title="1、Suspense是什么"></a>1、Suspense是什么</h4><p>我们都知道，在<strong> web</strong> 世界中，经常遇到很多的异步请求困境。在发起异步请求时，我们往往需要去判断这些异步请求的状态，然后呢，根据这些请求来展示不同的界面。</p><p>那现在呢， <strong>vue3</strong> 推出了一个新的内置组件<strong> Suspense </strong> ， Suspense 是一个特殊的组件，它会有<strong>两个 template slot</strong> ，刚开始会渲染<strong> fallback</strong> 内容，直到达到某个条件以后，才会渲染正式的内容，也就是<strong> default </strong>的内容。这样呢，进行异步内容的渲染就会变得特别简单。</p><p>同时值得注意的是，如果使用 Suspense ，要返回一个 promise 而不是一个对象。</p><h4 id="2、用Suspense发起一个异步请求"><a href="#2、用Suspense发起一个异步请求" class="headerlink" title="2、用Suspense发起一个异步请求"></a>2、用Suspense发起一个异步请求</h4><p>接下来我们使用 Suspense 来发起一个异步请求。</p><p>首先我们在项目下定义一个子组件，命名为 AsyncShow.vue ，具体代码如下：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">result</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>  <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span></span><br><span class="xml">import &#123; defineComponent &#125; from &quot;vue&quot;;</span><br><span class="xml">export default defineComponent(&#123;</span><br><span class="xml">  setup() &#123;</span><br><span class="xml">    return new Promise((resolve) =&gt; &#123;</span><br><span class="xml">      setTimeout(() =&gt; &#123;</span><br><span class="xml">        return resolve(&#123;</span><br><span class="xml">          result: 42,</span><br><span class="xml">        &#125;);</span><br><span class="xml">      &#125;, 3000);</span><br><span class="xml">    &#125;);</span><br><span class="xml">  &#125;,</span><br><span class="xml">&#125;);</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>之后在项目下再定义一个父组件，命名为 DogShow.vue ，具体代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">async-show</span> /&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Loading !...<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> &#123; defineComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="javascript"><span class="hljs-keyword">import</span> AsyncShow <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/AsyncShow.vue&#x27;</span></span><br><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineComponent(&#123;</span><br><span class="javascript">  name: <span class="hljs-string">&#x27;App&#x27;</span>,</span><br>  components: &#123;<br>    AsyncShow,<br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;</span><br>    <br>  &#125;<br>&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最终浏览器的显示效果为：3秒后loading…变为42<br>大家可以看到，通过 Suspense ，可以很轻易的发起一个异步请求。刚开始是fallback状态，之后达到 3s 的时间之后，切换到default的状态，显示出对应的异步请求内容。</p><h4 id="3、用Suspense发起多个异步请求"><a href="#3、用Suspense发起多个异步请求" class="headerlink" title="3、用Suspense发起多个异步请求"></a>3、用Suspense发起多个异步请求</h4><p>我们不满足于现状，且互联网千奇百怪的，我们总不能一直只发送一个异步请求吧！所以，接下来我们就来实现发起多个异步请求的效果。</p><p>首先我们用一个免费的在线API ，来发起一个请求。接下来我们在项目的 components 文件下，再定义一个子组件，命名为 DogShow.vue ，具体代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;result &amp;&amp; result.message&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span></span><br><span class="javascript"><span class="hljs-keyword">import</span> &#123; defineComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineComponent(&#123;</span><br><span class="javascript">  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">const</span> rawData = <span class="hljs-keyword">await</span> axios.get(<span class="hljs-string">&#x27;https://dog.ceo/api/breeds/image/random&#x27;</span>)</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br>      result: rawData.data<br>    &#125;<br>  &#125;<br>&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p>接下来我们再把以上子组件的内容添加到父组件中，具体代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">async-show</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dog-show</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Loading !...<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> AsyncShow <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/AsyncShow.vue&#x27;</span></span><br><span class="javascript"><span class="hljs-keyword">import</span> DogShow <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/DogShow.vue&#x27;</span></span><br><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&#x27;App&#x27;</span>,</span><br>  components: &#123;<br>    AsyncShow,<br>    DogShow<br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;</span><br>    <br>  &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>大家可以看到，我们同时发起了两个异步请求，并且在Suspense中的default插槽里面同时使用。同样的，浏览器会先显示fallback的内容，之后等到时机到了，就显示我们请求的内容。</p><p>依据这样的例子，显示更多的请求也同样有效。这样对比起来，发送多个异步请求是不是就方便了许多。</p><h4 id="2-1、如何抓取错误"><a href="#2-1、如何抓取错误" class="headerlink" title="2.1、如何抓取错误"></a>2.1、如何抓取错误</h4><p>学完上面的内容，相信大家对Suspense的用法已经有所了解。那么，网络请求千奇百怪的，总不能每次都能够很顺畅的发起请求对吧。所以呢，我们来需要再来学习一下，当网络请求失败时，如何抓取Supsense包裹下的错误。</p><p>这个时候我们可以使用一个钩子函数，这个函数叫做 onErrorCaptured ，接下来我们来看下怎么抓取。</p><p>我们将父组件 index.vue 进行改造，具体代码如下：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">error</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">async-show</span> /&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dog-show</span> /&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Loading !...<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span></span><br><span class="xml">import &#123; onErrorCaptured &#125; from &#x27;vue&#x27;</span><br><span class="xml">import AsyncShow from &#x27;./components/AsyncShow.vue&#x27;</span><br><span class="xml">import DogShow from &#x27;./components/DogShow.vue&#x27;</span><br><br><span class="xml">export default &#123;</span><br><span class="xml">  name: &#x27;App&#x27;,</span><br><span class="xml">  components: &#123;</span><br><span class="xml">    AsyncShow,</span><br><span class="xml">    DogShow</span><br><span class="xml">  &#125;,</span><br><span class="xml">  setup() &#123;</span><br><span class="xml">    const error = ref(null)</span><br><span class="xml">    onErrorCaptured((e: any) =&gt; &#123;</span><br><span class="xml">      error.value = e</span><br><span class="xml">      return true</span><br><span class="xml">    &#125;)</span><br><span class="xml">    return&#123;</span><br><span class="xml">        error</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>此时我们再将 DogShow.vue 的接口进行修改，让其变成一个无效的API。代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> rawData = <span class="hljs-keyword">await</span> axios.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;https://dog.ceo/api/breeds/image&#x27;</span>)<br></code></pre></td></tr></table></figure><p>接下来我们就来看一下浏览器的运行效果：<br><img src="/imageO/Error.jpg" alt="error"><br>大家可以看到，修改成无效的 API 后，狗狗的图片也不显示了，最后最上方就是通过<strong> onErrorCaptured </strong> 这个生命周期捕捉到的错误，清晰明了。</p><h5 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6977869719546101796#heading-1">vue3的传送门teleport究竟有多神奇？suspense发起异步请求有多简约？</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 3--reactive, ref,toRef,toRefs用法和区别</title>
    <link href="/2022/01/30/Vue3Study(3)--ref+reactive+toRef+toRefs/"/>
    <url>/2022/01/30/Vue3Study(3)--ref+reactive+toRef+toRefs/</url>
    
    <content type="html"><![CDATA[<p>Vue3的CompositionAPI 创建响应式对象的方式：</p><ul><li>reactive</li><li>ref</li><li>toRef</li><li>toRefs</li></ul><hr><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><p>reactive 方法 根据传入的<strong>对象</strong> ，创建返回一个<strong>深度响应式对象</strong>。<strong>响应式对象</strong>看起来和传入的对象一样，但是，响应式对象属性值改动，不管层级有多深，都会触发响应式。新增和删除属性也会触发响应式。</p><p><img src="/imageO/reactive.jpg" alt="示例"></p><blockquote><p>重点：</p></blockquote><ul><li><p><strong>reactive 只能 给对象添加响应式</strong>，对于值类型，比如<code>String，Number，Boolean，Symbol</code>无能为力。</p></li><li><p>不能通过 …state 方式结构，这样会丢失响应式。下面这种方式是错误的</p></li></ul><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">//注意这里不能通过 ...<span class="hljs-keyword">state</span> 方式结构，这样会丢失响应式。<br> return &#123;<br>     ...<span class="hljs-keyword">state</span>  <br> &#125;<br></code></pre></td></tr></table></figure><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>上面我们提到 reactive 只能给对象，数组 添加响应式，如果想给值类型(String，Number，Boolean，Symbol)添加响应式，就要用到ref，所以ref作用如下：</p><ul><li>生成值类型响应式数据</li><li>通过.vue值修改</li><li>生成对象和数组类型的响应式对象**(对象和数组一般会选用reactive方式，比较便捷)**</li></ul><h3 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h3><ul><li>针对一个响应式对象（reactive 封装）的 prop（属性）创建一个ref，且保持响应式</li><li>两者 保持引用关系</li></ul><h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h3><p>toRefs 是一种用于破坏响应式对象并将其所有属性转换为 ref 的实用方法</p><ul><li>将响应式对象（reactive封装）转成普通对象</li><li>对象的每个属性(Prop)都是对应的ref</li><li>两者保持引用关系</li></ul><h3 id="如何选择-ref-和-reactive？建议"><a href="#如何选择-ref-和-reactive？建议" class="headerlink" title="如何选择 ref 和 reactive？建议"></a>如何选择 ref 和 reactive？建议</h3><ol><li>基础类型值(String，Number，Boolean，Symbol) 或单值对象(类似{ count: 1 }这样只有一个属性值的对象) 使用 ref</li><li>引用类型值(Object、Array)使用 reactive</li></ol><h4 id="使用toRefs-state-方式返回"><a href="#使用toRefs-state-方式返回" class="headerlink" title="使用toRefs(state)方式返回"></a>使用toRefs(state)方式返回</h4><p>注意reactive封装的响应式对象，不要通过解构的方式return，这是不具有响应式的。可以通过 toRefs 处理，然后再解构返回，这样才具有响应式</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> <span class="hljs-keyword">state</span> = reactive(&#123;...&#125;);<br>return &#123;...<span class="hljs-keyword">state</span>&#125;; // 这种方式将丢失响应式，是一种错误的方式<br>return <span class="hljs-keyword">to</span>Refs(<span class="hljs-keyword">state</span>); // works<br></code></pre></td></tr></table></figure><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs fortran">const <span class="hljs-keyword">data</span>: DataProps = reactive(&#123;<br>  <span class="hljs-built_in">count</span>: <span class="hljs-number">0</span>,<br>  increase: () =&gt; &#123;<br>    <span class="hljs-keyword">data</span>.<span class="hljs-built_in">count</span>++;<br>  &#125;,<br>  <span class="hljs-keyword">double</span>: computed(() =&gt; <span class="hljs-keyword">data</span>.<span class="hljs-built_in">count</span> * <span class="hljs-number">2</span>),<br>&#125;);<br>const refData = toRefs(<span class="hljs-keyword">data</span>);<br><span class="hljs-keyword">return</span> &#123;<br>  ...refData,<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/7034038818139275294#heading-1">Vue3： reactive, ref,toRef,toRefs用法和区别</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 3--Composition API 和 script setup</title>
    <link href="/2022/01/29/Vue3Study(2)/"/>
    <url>/2022/01/29/Vue3Study(2)/</url>
    
    <content type="html"><![CDATA[<p>说一下 Composition API<br>和 Options API 的区别？</p><p>Composition API 也叫组合式 API，它主要就是为了解决 Vue2 中 Options API 的问题。</p><p>一是在 Vue2 中只能固定用 data、computed、methods 等选项组织代码，在组件越来越复杂的时候，一个功能相关的属性和方法就会在文件上中下到处都有，很分散，变越来越难维护</p><p>二是 Vue2 中虽然可以用 minxin 来做逻辑的提取复用，但是 minxin 里的属性和方法名会和组件内部的命名冲突，还有当引入多个 minxin 的时候，我们使用的属性或方法是来于哪个 minxin 也不清楚</p><p>而 Composition API 刚才就解决了这两个问题，可以让我们自由的组织代码，同一功能相关的全部放在一起，代码有更好的可读性更便于维护，单独提取出来也不会造成命名冲突，所以也有更好的可扩展性</p><hr><h3 id="Option的弊端"><a href="#Option的弊端" class="headerlink" title="Option的弊端"></a>Option的弊端</h3><h4 id="Option的缺陷–反复横跳"><a href="#Option的缺陷–反复横跳" class="headerlink" title="Option的缺陷–反复横跳"></a>Option的缺陷–反复横跳</h4><p>相信大部分同学都维护过超过200行的.vue组件，新增或者修改一个需求，就需要分别在data，methods，computed里修改 ，滚动条反复上下移动，我称之为『反复横跳』 比如我们简单的加个拍脑门的需求 加个累加器 ，这种写代码上下反复横条的感觉， 相信大家都懂的</p><h4 id="Option的缺陷：mixin和this"><a href="#Option的缺陷：mixin和this" class="headerlink" title="Option的缺陷：mixin和this"></a>Option的缺陷：mixin和this</h4><p>反复横跳的本质，在于功能的分块组织，以及代码量太大了，如果我们能把代码控制在一屏，自然就解决了，vue2里的解决方案，是使用mixin来混合, 我们抽离一个counter.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      count:<span class="hljs-number">1</span><br>    &#125;<br>  &#125;,<br>  computed: &#123;<br>    <span class="hljs-function"><span class="hljs-title">double</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.count * <span class="hljs-number">2</span><br>    &#125;<br>  &#125;,<br>  methods:&#123;<br>    <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-built_in">this</span>.count++<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在App.vue中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Counter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./counter&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  mixins:[Counter],<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;<br> ...<br>  &#125;,<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>这样确实拆分了代码，但是有一个贼严重的问题，就是不打开counter.js，App.vue里的this上，count，add这些属性，是完全不知道从哪来的，你不知道是mixin，还是全局install，还是Vue.prototype.count设置的，数据来源完全模糊，调试爽死你，这也是option的一个大问题，this是个黑盒，template里写的count和double，完全不知道从哪来的</p><h4 id="mixin命名冲突"><a href="#mixin命名冲突" class="headerlink" title="mixin命名冲突"></a>mixin命名冲突</h4><p>如果有两个mixin，就更有意思了，比如我们又有一个需求，实时显示鼠标的坐标位置x，并且有一个乘以2的计算属性凑巧也叫double，再整一个mixin</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      x:<span class="hljs-number">0</span><br>    &#125;<br>  &#125;,<br>  methods:&#123;<br>    <span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params">e</span>)</span>&#123;<br>      <span class="hljs-built_in">this</span>.x = e.pageX<br>    &#125;<br>  &#125;,<br>  computed:&#123;<br>    <span class="hljs-function"><span class="hljs-title">double</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x*<span class="hljs-number">2</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-built_in">this</span>.update)<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">destroyed</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-built_in">this</span>.update)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是是一个独立维护的mixin，可能在N个地方用到，他根本不知道会不会有人和他冲突，然后用一下</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> Counter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./counter&#x27;</span><br><span class="hljs-keyword">import</span> Mouse <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mouse&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  mixins:[Counter,Mouse],<br>  ...... <br>&#125;<br></code></pre></td></tr></table></figure><p>两个mixin里都有double这个数，尴尬，看效果 ，lsp的count被覆盖了 很尴尬，而且在App.vue这里，你完全不知道这个double到底是哪个，调试很痛苦</p><h3 id="Composition-API-和-lt-script-setup-gt-上手"><a href="#Composition-API-和-lt-script-setup-gt-上手" class="headerlink" title="Composition API 和 &lt;script setup&gt; 上手"></a>Composition API 和 <code>&lt;script setup&gt;</code> 上手</h3><h4 id="Composition-API-拆分代码"><a href="#Composition-API-拆分代码" class="headerlink" title="Composition API 拆分代码"></a>Composition API 拆分代码</h4><p>之前的累加器和清单，虽然功能都很简单，但也属于两个功能模块。如果在一个页面里有这两个功能，那就需要在 data 和 methods 里分别进行配置。但这样的话，数据和方法相关的代码会写在一起，在组件代码行数多了以后就不好维护。所以，<strong>我们需要使用 Composition API 的逻辑来拆分代码，把一个功能相关的数据和方法都维护在一起。</strong><br>但是，所有功能代码都写在一起的话，也会带来一些问题：随着功能越来越复杂，script 内部的代码也会越来越多。因此，我们可以进一步对代码进行拆分，把功能独立的模块封装成一个独立的函数，真正做到按需拆分。<br>在下面，我们新建了一个函数 useTodos：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useTodos</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> title = ref(<span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-keyword">let</span> todos = ref([&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;学习Vue&quot;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;]);<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addTodo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    todos.value.push(&#123;<br>      title: title.value,<br>      done: <span class="hljs-literal">false</span>,<br>    &#125;);<br>    title.value = <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clear</span>(<span class="hljs-params"></span>) </span>&#123;<br>    todos.value = todos.value.filter(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> !v.done);<br>  &#125;<br>  <span class="hljs-keyword">let</span> active = computed(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> todos.value.filter(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> !v.done).length;<br>  &#125;);<br>  <span class="hljs-keyword">let</span> all = computed(<span class="hljs-function">() =&gt;</span> todos.value.length);<br>  <span class="hljs-keyword">let</span> allDone = computed(&#123;<br>    get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> active.value === <span class="hljs-number">0</span>;<br>    &#125;,<br>    set: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>      todos.value.forEach(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> &#123;<br>        todo.done = value;<br>      &#125;);<br>    &#125;,<br>  &#125;);<br>  <span class="hljs-keyword">return</span> &#123; title, todos, addTodo, clear, active, all, allDone &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数就是把那些和清单相关的所有数据和方法，都放在函数内部定义并且返回，这样这个函数就可以放在任意的地方来维护。</p><p>而我们的组件入口，也就是<code>&lt;script setup&gt;</code>中的代码，就可以变得非常简单和清爽了。在下面的代码中，我们只需要调用 useTodos，并且获取所需要的变量即可，具体的实现逻辑可以去 useTodos 内部维护，代码可维护性大大增强。</p><p>使用</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dust"><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span></span><br><span class="xml">import </span><span class="hljs-template-variable">&#123; ref, computed &#125;</span><span class="xml"> from &quot;vue&quot;;</span><br><br><span class="xml">let count = ref(1)</span><br><span class="xml">function add()</span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    count.value++</span><br><span class="hljs-template-variable">&#125;</span><br><br><span class="xml">let </span><span class="hljs-template-variable">&#123; title, todos, addTodo, clear, active, all, allDone &#125;</span><span class="xml"> = useTodos();</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>我们在使用 Composition API 拆分功能时，也就是执行 useTodos 的时候，ref、computed 等功能都是从 Vue 中单独引入，而不是依赖<strong> this </strong> 上下文。其实你可以把组件内部的任何一段代码，从组件文件里抽离出一个独立的文件进行维护。</p><h4 id="获取鼠标位置函数封装"><a href="#获取鼠标位置函数封装" class="headerlink" title="获取鼠标位置函数封装"></a>获取鼠标位置函数封装</h4><p>现在，我们引入追踪鼠标位置的需求进行讲解，比如我们项目中可能有很多地方需要显示鼠标的坐标位置，那我们就可以在项目的 src/utils 文件夹下面新建一个 mouse.js。我们先从 Vue 中引入所需要的 ref 函数，然后暴露一个函数，函数内部和上面封装的 useTodos 类似，不过这次独立成了文件，放在 utils 文件下独立维护，提供给项目的所有组件使用。</p><p>想获取鼠标的位置，我们就需要监听 mousemove 事件。这需要在组件加载完毕后执行，在 Composition API 中，我们可以直接引入 onMounted 和 onUnmounted 来实现生命周期的功能。<br>看下面的代码，组件加载的时候，会触发 onMounted 生命周期，我们执行监听 mousemove 事件，从而去更新鼠标位置的 x 和 y 的值；组件卸载的时候，会触发 onUnmounted 生命周期，解除 mousemove 事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;ref, onMounted,onUnmounted&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useMouse</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> x = ref(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">const</span> y = ref(<span class="hljs-number">0</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params">e</span>) </span>&#123;<br>      x.value = e.pageX<br>      y.value = e.pageY<br>    &#125;<br>    onMounted(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, update)<br>    &#125;)<br>  <br>    onUnmounted(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&#x27;mousemove&#x27;</span>, update)<br>    &#125;)<br>    <span class="hljs-keyword">return</span> &#123; x, y &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成了上面的鼠标事件封装这一步之后，我们在组件的入口就可以和普通函数一样使用 useMouse 函数。在下面的代码中，上面的代码返回的 x 和 y 的值可以在模板任意地方使用，也会随着鼠标的移动而改变数值。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br><span class="hljs-keyword">import</span> &#123;useMouse&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../utils/mouse&#x27;</span><br><br><span class="hljs-keyword">let</span> &#123;x,y&#125; = useMouse()<br><br></code></pre></td></tr></table></figure><p>简单来看，<strong>因为 ref 和 computed 等功能都可以从 Vue 中全局引入，所以我们就可以把组件进行任意颗粒度的拆分和组合，这样就大大提高了代码的可维护性和复用性。</strong></p><h3 id="lt-script-setup-gt-好用的功能"><a href="#lt-script-setup-gt-好用的功能" class="headerlink" title="&lt;script setup&gt; 好用的功能"></a><code>&lt;script setup&gt;</code> 好用的功能</h3><p>如果没有 <code>&lt;script setup&gt;</code>，那么我们需要写出下面这样的代码来实现累加器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> &gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> count = ref(<span class="hljs-number">1</span>)</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"></span>) </span>&#123;</span><br>      count.value++<br>    &#125;<br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br>      count,<br>      add<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们要在<code>&lt;script&gt;</code>中导出一个对象。我们在 setup 配置函数中写代码时，和 Options 的写法比，也多了两层嵌套。并且，我们还要在 setup 函数中，返回所有需要在模板中使用的变量和方法。上面的代码中，setup 函数就返回了 count 和 add。</p><blockquote><p>使用 <code>&lt;script setup&gt;</code>可以让代码变得更加精简，这也是现在开发 Vue 3 项目必备的写法。除了我们上面介绍的功能，<code>&lt;script setup&gt;</code> 还有其它一些很好用的功能，比如能够使用顶层的 await 去请求后端的数据等等，我们会在后面的项目中看到这种使用方法。</p></blockquote><h3 id="style-样式的特性"><a href="#style-样式的特性" class="headerlink" title="style 样式的特性"></a>style 样式的特性</h3><p>比如，在 style 标签上，当我们加上 <strong>scoped</strong> 这个属性的时候，我们定义的 CSS 就只会应用到当前组件的元素上，这样就很好地避免了一些样式冲突的问题。</p><p>如果在 scoped 内部，你还想写全局的样式，那么你可以用:global 来标记，这样能确保你可以很灵活地组合你的样式代码（后面项目中用到的话，我还会结合实战进行讲解）。而且我们甚至可以通过 v-bind 函数，直接在 CSS 中使用 JavaScript 中的变量。</p><p>在下面这段代码中, 我在 script 里定义了一个响应式的 color 变量，并且在累加的时候，将变量随机修改为红或者蓝。在 style 内部，我们使用<strong> v-bind</strong> 函数绑定 color 的值，就可以动态地通过 JavaScript 的变量实现 CSS 的样式修改，点击累加器的时候文本颜色会随机切换为红或者蓝。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">count</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span></span><br><span class="xml">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="xml">let count = ref(1)</span><br><span class="xml">let color = ref(&#x27;red&#x27;)</span><br><span class="xml">function add() &#123;</span><br><span class="xml">  count.value++</span><br><span class="xml">  color.value = Math.random()&gt;0.5? &quot;blue&quot;:&quot;red&quot;</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="xml">h1 &#123;</span><br><span class="xml">  color:v-bind(color);</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://time.geekbang.org/column/article/431955">新的代码组织方式：Composition API + script setup 到底好在哪里？</a><br><a href="https://juejin.cn/post/6891640356543627278#heading-2">那个忙了一夜的Vue3动画很好，就是太短了</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript专题之递归</title>
    <link href="/2022/01/24/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0--%E9%80%92%E5%BD%92/"/>
    <url>/2022/01/24/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0--%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<p>定义<br>程序调用自身的编程技巧称为递归(recursion)。</p><hr><h3 id="递归的三大要素"><a href="#递归的三大要素" class="headerlink" title="递归的三大要素"></a>递归的三大要素</h3><h4 id="第一要素：明确你这个函数想要干什么"><a href="#第一要素：明确你这个函数想要干什么" class="headerlink" title="第一要素：明确你这个函数想要干什么"></a>第一要素：明确你这个函数想要干什么</h4><p>对于递归，我觉得很重要的一个事就是，这个函数的功能是什么，他要完成什么样的一件事，而这个，是完全由你自己来定义的。也就是说，我们先不管函数里面的代码什么，而是要先明白，你这个函数是要用来干什么。</p><p>例如，我定义了一个函数</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">// 算 <span class="hljs-built_in">n</span> 的阶乘(假设<span class="hljs-built_in">n</span>不为<span class="hljs-number">0</span>)<br><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数的功能是算 n 的阶乘。好了，我们已经定义了一个函数，并且定义了它的功能是什么，接下来我们看第二要素。</p><h4 id="第二要素：寻找递归结束条件"><a href="#第二要素：寻找递归结束条件" class="headerlink" title="第二要素：寻找递归结束条件"></a>第二要素：寻找递归结束条件</h4><p>所谓递归，就是会在函数内部代码中，调用这个函数本身，所以，我们必须要找出递归的结束条件，不然的话，会一直调用自己，进入无底洞。也就是说，我们需要找出当参数为啥时，递归结束，之后直接把结果返回，请注意，这个时候我们必须能根据这个参数的值，能够直接知道函数的结果是什么。</p><p>例如，上面那个例子，当 n = 1 时，那你应该能够直接知道 f(n) 是啥吧？此时，f(1) = 1。完善我们函数内部的代码，把第二要素加进代码里面，如下</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">// 算 <span class="hljs-built_in">n</span> 的阶乘(假设<span class="hljs-built_in">n</span>不为<span class="hljs-number">0</span>)<br><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)&#123;<br>    <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> == <span class="hljs-number">1</span>)&#123;<br>        return <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有人可能会说，当 n = 2 时，那我们可以直接知道 f(n) 等于多少啊，那我可以把 n = 2 作为递归的结束条件吗？</p><p>当然可以，只要你觉得参数是什么时，你能够直接知道函数的结果，那么你就可以把这个参数作为结束的条件，所以下面这段代码也是可以的。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">// 算 <span class="hljs-built_in">n</span> 的阶乘(假设<span class="hljs-built_in">n</span>&gt;=<span class="hljs-number">2</span>)<br><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)&#123;<br>    <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> == <span class="hljs-number">2</span>)&#123;<br>        return <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意我代码里面写的注释，假设 n &gt;= 2，因为如果 n = 1时，会被漏掉，当 n &lt;= 2时，f(n) = n，所以为了更加<strong>严谨</strong>，我们可以写成这样：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">// 算 <span class="hljs-built_in">n</span> 的阶乘(假设<span class="hljs-built_in">n</span>不为<span class="hljs-number">0</span>)<br><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)&#123;<br>    <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">2</span>)&#123;<br>        return <span class="hljs-built_in">n</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第三要素：找出函数的等价关系式"><a href="#第三要素：找出函数的等价关系式" class="headerlink" title="第三要素：找出函数的等价关系式"></a>第三要素：找出函数的等价关系式</h4><p>第三要素就是，我们要不断缩小参数的范围，缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。</p><p>例如，f(n) 这个范围比较大，我们可以让 f(n) = n * f(n-1)。这样，范围就由 n 变成了 n-1 了，范围变小了，并且为了原函数f(n) 不变，我们需要让 f(n-1) 乘以 n。</p><p>说白了，就是要找到原函数的一个等价关系式，f(n) 的等价关系式为 n * f(n-1)，即</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">f(<span class="hljs-built_in">n</span>) = <span class="hljs-built_in">n</span> * f(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>)。<br></code></pre></td></tr></table></figure><blockquote><p>这个等价关系式的寻找，可以说是最难的一步了,所以需要多加做题联系…</p></blockquote><p>找出了这个等价，继续完善我们的代码，我们把这个等价式写进函数里。如下：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs excel">// 算 <span class="hljs-built_in">n</span> 的阶乘(假设<span class="hljs-built_in">n</span>不为<span class="hljs-number">0</span>)<br><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)&#123;<br>    <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">2</span>)&#123;<br>        return <span class="hljs-built_in">n</span>;<br>    &#125;<br>    // 把 f(<span class="hljs-built_in">n</span>) 的等价操作写进去<br>    return f(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>) * <span class="hljs-built_in">n</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，递归三要素已经都写进代码里了，所以这个 f(n) 功能的内部代码我们已经写好了。</p><p>这就是递归最重要的三要素，每次做递归的时候，你就强迫自己试着去寻找这三个要素。</p><h3 id="案例1：斐波那契数列"><a href="#案例1：斐波那契数列" class="headerlink" title="案例1：斐波那契数列"></a>案例1：斐波那契数列</h3><p>斐波那契数列的是这样一个数列：1、1、2、3、5、8、13、21、34….，即第一项 f(1) = 1,第二项 f(2) = 1…..,第 n 项目为 f(n) = f(n-1) + f(n-2)。求第 n 项的值是多少。</p><h4 id="1、第一递归-函数功能"><a href="#1、第一递归-函数功能" class="headerlink" title="1、第一递归 函数功能"></a>1、第一递归 函数功能</h4><p>假设 f(n) 的功能是求第 n 项的值，代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、找出递归结束的条件"><a href="#2、找出递归结束的条件" class="headerlink" title="2、找出递归结束的条件"></a>2、找出递归结束的条件</h4><p>显然，当 n = 1 或者 n = 2 ,我们可以轻易着知道结果 f(1) =1, f(2) = 1。所以递归结束条件可以为 n &lt;= 2。代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第三要素：找出函数的等价关系式-1"><a href="#第三要素：找出函数的等价关系式-1" class="headerlink" title="第三要素：找出函数的等价关系式"></a>第三要素：找出函数的等价关系式</h4><p>题目已经把等价关系式给我们了，所以我们很容易就能够知道 f(n) = f(n-1) + f(n-2)。我说过，等价关系式是最难找的一个，而这个题目却把关系式给我们了，这也太容易，好吧，我这是为了兼顾几乎零基础的读者。</p><p>所以最终代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">// 1.先写递归结束条件</span><br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>    <span class="hljs-comment">// 2.接着写等价关系式</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(n<span class="hljs-number">-1</span>) + <span class="hljs-built_in">f</span>(n - <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="案例2：小青蛙跳台阶"><a href="#案例2：小青蛙跳台阶" class="headerlink" title="案例2：小青蛙跳台阶"></a>案例2：小青蛙跳台阶</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h4 id="1、第一递归函数功能"><a href="#1、第一递归函数功能" class="headerlink" title="1、第一递归函数功能"></a>1、第一递归函数功能</h4><p>假设 f(n) 的功能是求青蛙跳上一个n级的台阶总共有多少种跳法，代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、找出递归结束的条件-1"><a href="#2、找出递归结束的条件-1" class="headerlink" title="2、找出递归结束的条件"></a>2、找出递归结束的条件</h4><p>我说了，求递归结束的条件，你直接把 n 压缩到很小很小就行了，因为 n 越小，我们就越容易直观着算出 f(n) 的多少，所以当 n = 1时，你知道 f(1) 为多少吧？够直观吧？即 f(1) = 1。代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第三要素：找出函数的等价关系式</p><p>每次跳的时候，小青蛙可以跳一个台阶，也可以跳两个台阶，也就是说，每次跳的时候，小青蛙有两种跳法。</p><p>第一种跳法：第一次我跳了一个台阶，那么还剩下n-1个台阶还没跳，剩下的n-1个台阶的跳法有f(n-1)种。</p><p>第二种跳法：第一次跳了两个台阶，那么还剩下n-2个台阶还没，剩下的n-2个台阶的跳法有f(n-2)种。</p><p>所以，小青蛙的全部跳法就是这两种跳法之和了，即 f(n) = f(n-1) + f(n-2)。至此，等价关系式就求出来了。于是写出代码：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)&#123;<br>    <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> == <span class="hljs-number">1</span>)&#123;<br>        return <span class="hljs-number">1</span>;<br>    &#125;<br>    ruturn f(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>) + f(<span class="hljs-built_in">n</span>-<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>大家觉得上面的代码对不对？</p><p>答是不大对，当 n = 2 时，显然会有 f(2) = f(1) + f(0)。我们知道，f(0) = 0，按道理是递归结束，不用继续往下调用的，但我们上面的代码逻辑中，会继续调用 f(0) = f(-1) + f(-2)。这会导致无限调用，进入<strong>死循环</strong>。</p><p>这也是我要和你们说的，关于<strong>递归结束条件是否够严谨问题</strong>，有很多人在使用递归的时候，由于结束条件不够严谨，导致出现死循环。也就是说，当我们在第二步找出了一个递归结束条件的时候，可以把结束条件写进代码，然后进行第三步，但是请注意，当我们第三步找出等价函数之后，还得再返回去第二步，根据第三步函数的调用关系，会不会出现一些漏掉的结束条件。就像上面，f(n-2)这个函数的调用，有可能出现 f(0) 的情况，导致死循环，所以我们把它补上。代码如下：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)&#123;<br>    //f(<span class="hljs-number">0</span>) = <span class="hljs-number">0</span>,f(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span>，等价于 <span class="hljs-built_in">n</span>&lt;=<span class="hljs-number">1</span>时，f(<span class="hljs-built_in">n</span>) = <span class="hljs-built_in">n</span>。<br>    <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">1</span>)&#123;<br>        return <span class="hljs-number">1</span>;<br>    &#125;<br>    ruturn f(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>) + f(<span class="hljs-built_in">n</span>-<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>有人可能会说，我不知道我的结束条件有没有漏掉怎么办？别怕，多练几道就知道怎么办了。</p><h3 id="递归优化"><a href="#递归优化" class="headerlink" title="递归优化"></a>递归优化</h3><blockquote><p>递归常见的问题：堆栈溢出、重复计算、空间度高(空间复杂度高)</p></blockquote><h4 id="1-考虑是否重复计算"><a href="#1-考虑是否重复计算" class="headerlink" title="1. 考虑是否重复计算"></a>1. 考虑是否重复计算</h4><p>告诉你吧，如果你使用递归的时候不进行优化，是有非常非常非常多的子问题被重复计算的。</p><blockquote><p>啥是子问题？ f(n-1),f(n-2)….就是 f(n) 的子问题了。</p></blockquote><p>例如对于案例2那道题，f(n) = f(n-1) + f(n-2)。递归调用的状态图如下：</p><p><img src="/imageO/leetcode1.jpg" alt="状态图"></p><p>看到没有，递归计算的时候，重复计算了两次 f(5)，五次 f(4)。。。。这是非常恐怖的，n 越大，重复计算的就越多，所以我们必须进行优化。</p><p>如何优化？一般我们可以把我们计算的结果保证起来，例如把 f(4) 的计算结果保证起来，当再次要计算 f(4) 的时候，我们先判断一下，之前是否计算过，如果计算过，直接把 f(4) 的结果取出来就可以了，没有计算过的话，再递归计算。</p><p>用什么保存呢？可以用数组或者 HashMap 保存，我们用数组来保存把，把 n 作为我们的数组下标，f(n) 作为值，例如 arr[n] = f(n)。f(n) 还没有计算过的时候，我们让 arr[n] 等于一个特殊值，例如 arr[n] = -1。</p><p>当我们要判断的时候，如果 arr[n] = -1，则证明 f(n) 没有计算过，否则， f(n) 就已经计算过了，且 f(n) = arr[n]。直接把值取出来就行了。代码如下：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs excel">// 我们实现假定 arr 数组已经初始化好的了。<br><span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)&#123;<br>    <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">1</span>)&#123;<br>        return <span class="hljs-built_in">n</span>;<br>    &#125;<br>    //先判断有没计算过<br>    <span class="hljs-built_in">if</span>(arr[<span class="hljs-built_in">n</span>] != -<span class="hljs-number">1</span>)&#123;<br>        //计算过，直接返回<br>        return arr[<span class="hljs-built_in">n</span>];<br>    &#125;else&#123;<br>        // 没有计算过，递归计算,并且把结果保存到 arr数组里<br>        arr[<span class="hljs-built_in">n</span>] = f(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>) + f(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>);<br>        reutrn arr[<span class="hljs-built_in">n</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，使用递归的时候，必要 须要考虑有没有重复计算，如果重复计算了，一定要把计算过的状态保存起来。</p><h4 id="2-考虑是否可以自底向上"><a href="#2-考虑是否可以自底向上" class="headerlink" title="2. 考虑是否可以自底向上"></a>2. 考虑是否可以自底向上</h4><p>对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回。</p><p>不过，有时候当 n 比较大的时候，例如当 n = 10000 时，那么必须要往下递归10000层直到 n &lt;=1 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用。</p><p>对于这种情况，其实我们是可以考虑自底向上的做法的。例如我知道</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">f</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span>;<br><br><span class="hljs-attribute">f</span>(<span class="hljs-number">2</span>) = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>那么我们就可以推出 f(3) = f(2) + f(1) = 3。从而可以推出f(4),f(5)等直到f(n)。因此，我们可以考虑使用自底向上的方法来取代递归，代码如下：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs excel">public <span class="hljs-built_in">int</span> f(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>) &#123;<br>       <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">2</span>)<br>           return <span class="hljs-built_in">n</span>;<br>       <span class="hljs-built_in">int</span> <span class="hljs-symbol">f1</span> = <span class="hljs-number">1</span>;<br>       <span class="hljs-built_in">int</span> <span class="hljs-symbol">f2</span> = <span class="hljs-number">2</span>;<br>       <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br><br>       for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">3</span>; i &lt;= <span class="hljs-built_in">n</span>; i++) &#123;<br>           <span class="hljs-built_in">sum</span> = <span class="hljs-symbol">f1</span> + <span class="hljs-symbol">f2</span>;<br>           <span class="hljs-symbol">f1</span> = <span class="hljs-symbol">f2</span>;<br>           <span class="hljs-symbol">f2</span> = <span class="hljs-built_in">sum</span>;<br>       &#125;<br>       return <span class="hljs-built_in">sum</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>这种方法，其实也被称之为<strong>递推。</strong></p><blockquote><p>扩展</p></blockquote><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">### 将递归代码改写为非递归代码<br><br>### 尾递归：如何借助尾递归避免递归过深导致的堆栈溢出<br></code></pre></td></tr></table></figure><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6844903839783452680#heading-3">为什么你学不会递归？刷题几个月，告别递归，谈谈我的经验</a></p>]]></content>
    
    
    <categories>
      
      <category>js算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js算法学习</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue面试题总结</title>
    <link href="/2022/01/10/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2022/01/10/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>总结了最近的一些面试题和之前的知识点</p><hr><h3 id="diff算法与虚拟dom"><a href="#diff算法与虚拟dom" class="headerlink" title="diff算法与虚拟dom"></a>diff算法与虚拟dom</h3><p>虚拟DOM实现原理?<br>虚拟DOM本质上是JavaScript对象,是对真实DOM的抽象<br>状态变更时，记录新树和旧树的差异<br>最后把差异更新到真正的dom中<br><a href="https://pengzhenglong.github.io/2022/02/20/Vue--diff%E7%AE%97%E6%B3%95/">博客</a></p><h4 id="虚拟DOM的优劣如何"><a href="#虚拟DOM的优劣如何" class="headerlink" title="虚拟DOM的优劣如何?"></a>虚拟DOM的优劣如何?</h4><p>优点:</p><p>保证性能下限: 虚拟DOM可以经过diff找出最小差异,然后批量进行patch,这种操作虽然比不上手动优化,但是比起粗暴的DOM操作性能要好很多,因此虚拟DOM可以保证性能下限<br>无需手动操作DOM: 虚拟DOM的diff和patch都是在一次更新中自动进行的,我们无需手动操作DOM,极大提高开发效率<br>跨平台: 虚拟DOM本质上是JavaScript对象,而DOM与平台强相关,相比之下虚拟DOM可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等</p><p>缺点:</p><p>无法进行极致优化: 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化,比如VScode采用直接手动操作DOM的方式进行极端的性能优化</p><p><a href="https://juejin.cn/post/6844903903968903175#heading-14">虚拟DOM的优劣如何?</a></p><h3 id="dep-watcher"><a href="#dep-watcher" class="headerlink" title="dep  watcher"></a>dep  watcher</h3><p><a href="https://pengzhenglong.github.io/2022/02/25/Vue--Observer%E3%80%81Dep%E3%80%81Watcher/">博客</a></p><h3 id="开发中有没有遇见过数据修改了页面不刷新的情况"><a href="#开发中有没有遇见过数据修改了页面不刷新的情况" class="headerlink" title="开发中有没有遇见过数据修改了页面不刷新的情况"></a>开发中有没有遇见过数据修改了页面不刷新的情况</h3><p>最近在开发中遇到了这样一些情况，通过点击事件改变了对象里面得数据，但是页面却不刷新，后来发现，是在给对象添加属性时出现的问题。</p><p><strong>当vue的data里边声明或者已经赋值过的对象或者数组(数组里边的值是对象)时，向对象中添加新的属性，如果更新此属性的值，是不会更新视图的。</strong></p><p>当页面初始化时候，vue会遍历data对象所有的属性，并使用object.defineProperty把这些属性全部转化为getter/setter，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。</p><p>官方定义：<br>Vue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。</p><h4 id="方法1-set"><a href="#方法1-set" class="headerlink" title="方法1.$set"></a>方法1.$set</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 上传成功回调函数</span><br>handle<span class="hljs-constructor">AvatarSuccess(<span class="hljs-params">res</span>, <span class="hljs-params">file</span>)</span> &#123;<br>    this.<span class="hljs-constructor">$set(<span class="hljs-params">this</span>.<span class="hljs-params">form</span>,&#x27;<span class="hljs-params">imgUrl</span>&#x27;,<span class="hljs-params">res</span>.<span class="hljs-params">data</span>)</span>;<br>&#125;,<br></code></pre></td></tr></table></figure><h4 id="方法2-forceUpdate"><a href="#方法2-forceUpdate" class="headerlink" title="方法2.$forceUpdate"></a>方法2.$forceUpdate</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">handleAvatarSuccess(res, file) &#123;<br>    <span class="hljs-keyword">this</span>.form.imgUrl = res.<span class="hljs-keyword">data</span>;<br>    <span class="hljs-keyword">this</span>.$forceUpdate();<br>&#125;,<br></code></pre></td></tr></table></figure><p><a href="https://v3.cn.vuejs.org/guide/change-detection.html#%E5%A3%B0%E6%98%8E%E5%93%8D%E5%BA%94%E5%BC%8F-property">官方文档</a></p><h3 id="为什么vue组件中的data是一个函数而不是一个对象？"><a href="#为什么vue组件中的data是一个函数而不是一个对象？" class="headerlink" title="为什么vue组件中的data是一个函数而不是一个对象？"></a>为什么vue组件中的data是一个函数而不是一个对象？</h3><p>如果 data 是一个对象，当复用组件时，因为 data 都会指向同一个引用类型地址，其中一个组件的 data 一旦发生修改，则其他重用的组件中的 data 也会被一并修改。</p><p>如果 data 是一个返回对象的函数，因为每次重用组件时返回的都是一个新对象，引用地址不同，便不会出现如上问题。</p><h3 id="vue和jquery的区别"><a href="#vue和jquery的区别" class="headerlink" title="vue和jquery的区别"></a>vue和jquery的区别</h3><p>vue相对于jquery有什么优点：<br>一. 解除jquery频繁操作dom，转为直接操作数据的思想。<br>二. vue支持双向绑定<br>view的变化，viewmodel感知到变化view变化，通知model发生改变。反之model发生改变，view也改变。<br>三. vue支持组件化<br>提高开发效率。重复功能可单独写到组件中，供其他地方调用。</p><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>一：单向数据流</p><h4 id="单向数据流的意思是指数据的改变只能从一个方向修改"><a href="#单向数据流的意思是指数据的改变只能从一个方向修改" class="headerlink" title="单向数据流的意思是指数据的改变只能从一个方向修改"></a>单向数据流的意思是指数据的改变只能从一个方向修改</h4><p>数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><blockquote><p>注意：在子组件直接用 v-model 绑定父组件传过来的 prop 这样是不规范的写法 开发环境会报警告</p></blockquote><p>如果实在要改变父组件的 prop 值 可以再 data 里面定义一个变量 并用 prop 的值初始化它 之后用$emit 通知父组件去修改</p><p>举个栗子：如一个父组件有两个子组件，分别为1和2。父组件向子组件传递数据，两个组件都接收到了父组件传递过来的数据，在组件1中修改父组件传递过来的数据，子组件2和父组件的值不会发生变化。这就是单向的数据流，子组件不能直接改变父组件的状态。但是如果父组件改变相应的数据，两个子组件的数据也会发生相应的改变。</p><h3 id="MVVM思想-重要"><a href="#MVVM思想-重要" class="headerlink" title="MVVM思想(重要)"></a>MVVM思想(重要)</h3><h4 id="什么是MVVM？"><a href="#什么是MVVM？" class="headerlink" title="什么是MVVM？"></a>什么是MVVM？</h4><p>视图模型双向绑定，是Model-View-ViewModel的缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。以前是操作DOM结构更新视图，现在是数据驱动视图。</p><h4 id="MVVM的优点"><a href="#MVVM的优点" class="headerlink" title="MVVM的优点"></a>MVVM的优点</h4><p>1.低耦合。视图（View）可以独立于Model变化和修改，一个Model可以绑定到不同的View上，当View变化的时候Model可以不变化，当Model变化的时候View也可以不变；<br>2.可重用性。你可以把一些视图逻辑放在一个Model里面，让很多View重用这段视图逻辑。<br>3.独立开发。开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计。<br>4.可测试。</p><h3 id="Vue底层实现原理"><a href="#Vue底层实现原理" class="headerlink" title="Vue底层实现原理"></a>Vue底层实现原理</h3><p>vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调<br>Vue是一个典型的MVVM框架，模型（Model）只是普通的javascript对象，修改它则试图（View）会自动更新。这种设计让状态管理变得非常简单而直观</p><h4 id="Observer（数据监听器）"><a href="#Observer（数据监听器）" class="headerlink" title="Observer（数据监听器）"></a>Observer（数据监听器）</h4><p> Observer的核心是通过Object.defineProprtty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher</p><h4 id="Watcher（订阅者）"><a href="#Watcher（订阅者）" class="headerlink" title="Watcher（订阅者）"></a>Watcher（订阅者）</h4><p>Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是：</p><ol><li>在自身实例化时往属性订阅器(dep)里面添加自己</li><li>自身必须有一个update()方法</li><li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调</li></ol><h4 id="Compile（指令解析器）"><a href="#Compile（指令解析器）" class="headerlink" title="Compile（指令解析器）"></a>Compile（指令解析器）</h4><p> Compile主要做的事情是解析模板指令，将模板中变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加鉴定数据的订阅者，一旦数据有变动，收到通知，更新试图</p><h3 id="vue-双向数据绑定原理？"><a href="#vue-双向数据绑定原理？" class="headerlink" title="vue 双向数据绑定原理？"></a>vue 双向数据绑定原理？</h3><p>使用 Object.defineProperty 将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应属性时，每个属性都拥有自己的 dep 属性，存放他所依赖的 watcher（依赖收集），当属性变化后会通知自己对应的 watcher 去更新(派发更新)。</p><ol><li>vue2是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。vue3中则采用Proxy，它可以监听到数组内的数据变化。<br>相比于vue2.x，使用proxy的优势如下</li></ol><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">defineProperty只能监听某个属性，不能对全对象监听<br>可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）<br>可以监听数组，不用再去单独的对数组做特异性操作 vue<span class="hljs-number">3</span>.<span class="hljs-keyword">x</span>可以检测到数组内部数据的变化<br></code></pre></td></tr></table></figure><ol start="2"><li>默认进行懒观察（lazy observation）。<br>在 2.x 版本里，不管数据多大，都会在一开始就为其创建观察者。当数据很大时，这可能会在页面载入时造成明显的性能压力。3.x 版本，只会对「被用于渲染初始可见部分的数据」创建观察者，而且 3.x 的观察者更高效。</li><li>更精准的变更通知。<br>比例来说：2.x 版本中，使用 Vue.set 来给对象新增一个属性时，这个对象的所有 watcher 都会重新运行；3.x 版本中，只有依赖那个属性的 watcher 才会重新运行。<br>详细资料可以参考：<br><a href="http://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension">《Vue.js 双向绑定的实现原理》</a></li></ol><h3 id="defineProperty-和-Proxy-的区别"><a href="#defineProperty-和-Proxy-的区别" class="headerlink" title="defineProperty 和 Proxy 的区别"></a>defineProperty 和 Proxy 的区别</h3><p>为什么要用 Proxy 代替 defineProperty ？好在哪里？</p><ol><li>Object.defineProperty 是 Es5 的方法，Proxy 是 Es6 的方法</li><li>defineProperty 不能监听到数组下标变化和对象新增属性，Proxy 可以</li><li>defineProperty 是劫持对象属性，Proxy 是代理整个对象</li><li>defineProperty 局限性大，只能针对单属性监听，所以在一开始就要全部递归监听。Proxy 对象嵌套属性运行时递归，用到才代理，也不需要维护特别多的依赖关系，性能提升很大，且首次渲染更快</li><li>defineProperty 会污染原对象，修改时是修改原对象，Proxy 是对原对象进行代理并会返回一个新的代理对象，修改的是代理对象</li><li>defineProperty 不兼容 IE8，Proxy 不兼容 IE11<br><a href="https://pengzhenglong.github.io/2022/03/07/defineproPerty&&proxy/">Object.defineProperty和Proxy，Vue3.0为什么采用Proxy？</a></li></ol><h3 id="计算属性和watch的原理"><a href="#计算属性和watch的原理" class="headerlink" title="计算属性和watch的原理"></a>计算属性和watch的原理</h3><p><a href="https://pengzhenglong.github.io/2022/03/10/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8Ccomputed%E7%9A%84%E5%8E%9F%E7%90%86/">博客：</a></p><h3 id="computed-和-watch-的差异？"><a href="#computed-和-watch-的差异？" class="headerlink" title="computed 和 watch 的差异？"></a>computed 和 watch 的差异？</h3><p>（1）computed 是计算一个新的属性，并将该属性挂载到 Vue 实例上，而 watch 是监听已经存在且已挂载到 Vue 实例上的数据，所以用 watch 同样可以监听 computed 计算属性的变化。<br>（2）computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值。而 watch 则是当数据发生变化便会调用执行函数。<br>（3）从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据。</p><p><a href="https://juejin.im/post/5b98c4da6fb9a05d353c5fd7">《做面试的不倒翁：浅谈 Vue 中 computed 实现原理》</a><br><a href="https://juejin.im/post/5af908ea5188254265399009">《深入理解 Vue 的 watch 实现原理及其实现方式》</a><br><a href="https://pengzhenglong.github.io/2021/04/18/Vue&computed%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/">我的博客</a></p><h3 id="v-if-v-show"><a href="#v-if-v-show" class="headerlink" title="v-if  v-show"></a>v-if  v-show</h3><p>v-show</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">该指令的作用是根据真假切换元素的显示状态<br>原理是修改元素的display，实现显示隐藏<br>指令后面的内容，最终都会解析为布尔值<br>值为<span class="hljs-literal">true</span>元素显示，值为<span class="hljs-literal">false</span>元素隐藏<br>数据改变之后，对应元素的显示状态会同步更新<br></code></pre></td></tr></table></figure><p>v-if</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">该指令的作用是根据表达式的真假来切换元素的显示状态<br>本质是通过操作dom元素来切换显示状态<br>表达式的值为<span class="hljs-keyword">true</span>,元素存在于dom中；为<span class="hljs-keyword">false</span>，从dom树中移除<br>频繁的切换使用v-<span class="hljs-keyword">show</span>,反之使用v-<span class="hljs-keyword">if</span>,前者的切换消耗小<br></code></pre></td></tr></table></figure><h4 id="v-if在条件切换时，会对标签进行适当的创建和销毁，而v-show则仅在初始化时加载一次，因此v-if的开销相对来说会比v-show大"><a href="#v-if在条件切换时，会对标签进行适当的创建和销毁，而v-show则仅在初始化时加载一次，因此v-if的开销相对来说会比v-show大" class="headerlink" title="v-if在条件切换时，会对标签进行适当的创建和销毁，而v-show则仅在初始化时加载一次，因此v-if的开销相对来说会比v-show大"></a>v-if在条件切换时，会对标签进行适当的创建和销毁，而v-show则仅在初始化时加载一次，因此v-if的开销相对来说会比v-show大</h4><blockquote><p>display:none; 会让元素脱离文档流，不占据页面空间。会引起回流和重绘</p></blockquote><p>visibility:hidden; 只是隐藏内容，并没有脱离文档流，会占据页面空间。会引起重绘。</p><h3 id="vue-常用的修饰符？"><a href="#vue-常用的修饰符？" class="headerlink" title="vue 常用的修饰符？"></a>vue 常用的修饰符？</h3><p>.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；.capture: 事件侦听，事件发生的时候会调用</p><h3 id="keep-alive-组件有什么作用？"><a href="#keep-alive-组件有什么作用？" class="headerlink" title="keep-alive 组件有什么作用？"></a>keep-alive 组件有什么作用？</h3><p>如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</p><h4 id="keep-alive的实现"><a href="#keep-alive的实现" class="headerlink" title="keep-alive的实现"></a>keep-alive的实现</h4><p>作用：实现组件缓存，保持这些组件的状态，以避免反复渲染导致的性能问题。 需要缓存组件 频繁切换，不需要重复渲染<br>场景：tabs标签页 后台导航，vue性能优化</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>Vue.js内部将DOM节点抽象成了一个个的<strong>  VNode节点 </strong>，keep-alive组件的缓存也是基于VNode节点的而不是直接存储DOM结构。它将满足条件（pruneCache与pruneCache）的组件在cache对象中缓存起来，在需要重新渲染的时候再将vnode节点从cache对象中取出并渲染。</p><ol><li>使用 LRU 缓存机制进行缓存，max 限制缓存表的最大容量</li><li>根据设定的 include/exclude（如果有）进行条件匹配,决定是否缓存。不匹配,直接返回组件实例</li><li>根据组件 ID 和 tag 生成缓存 Key ,并在缓存对象中查找是否已缓存过该组件实例。如果存在,直接取出缓存值并更新该 key 在 this.keys 中的位置(更新 key 的位置是实现 LRU 置换策略的关键)</li><li>获取节点名称，或者根据节点 cid 等信息拼出当前 组件名称</li><li>获取 keep-alive 包裹着的第一个子组件对象及其组件名<br><a href="https://www.zoo.team/article/lru-keep-alive">参考文章</a></li></ol><h3 id="Vue中的key到底有什么⽤？"><a href="#Vue中的key到底有什么⽤？" class="headerlink" title="Vue中的key到底有什么⽤？"></a>Vue中的key到底有什么⽤？</h3><p>vue 中 key 值的作用可以分为两种情况来考虑。</p><h4 id="第一种情况是-v-if-中使用-key"><a href="#第一种情况是-v-if-中使用-key" class="headerlink" title="第一种情况是 v-if 中使用 key"></a>第一种情况是 v-if 中使用 key</h4><p>由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</p><h4 id="第二种情况是-v-for-中使用-key"><a href="#第二种情况是-v-for-中使用-key" class="headerlink" title="第二种情况是 v-for 中使用 key"></a>第二种情况是 v-for 中使用 key</h4><p>用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</p><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000016344599">《Vue 面试中，经常会被问到的面试题 Vue 知识点整理》</a><br><a href="https://www.zhihu.com/question/61064119">《Vue2.0 v-for 中 :key 到底有什么用？》</a><br><a href="https://www.cnblogs.com/RainyBear/p/8563101.html">《vue 中 key 的作用》</a></p><h3 id="vue-中-mixin-和-mixins-区别？"><a href="#vue-中-mixin-和-mixins-区别？" class="headerlink" title="vue 中 mixin 和 mixins 区别？"></a>vue 中 mixin 和 mixins 区别？</h3><h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><p>mixin 项目变得复杂的时候，多个组件间有重复的逻辑就会用到mixin<br>多个组件有相同的逻辑，抽离出来<br>mixin并不是完美的解决方案，会有一些问题<br>vue3提出的Composition API旨在解决这些问题【追求完美是要消耗一定的成本的，如开发成本】<br>场景：PC端新闻列表和详情页一样的右侧栏目，可以使用mixin进行混合<br>劣势：<br>1.变量来源不明确，不利于阅读<br>2.多mixin可能会造成命名冲突<br> 3.mixin和组件可能出现多对多的关系，使得项目复杂度变高</p><p>mixin 用于全局混入，会影响到每个组件实例。<br>mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并<br>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc731b51882516c56ced6f">《前端面试之道》</a><br><a href="https://cn.vuejs.org/v2/guide/mixins.html">《混入》</a></p><h3 id="React-Vue-项目中-key-的作用"><a href="#React-Vue-项目中-key-的作用" class="headerlink" title="React/Vue 项目中 key 的作用"></a>React/Vue 项目中 key 的作用</h3><ol><li>key的作用是为了在diff算法执行时更快的找到对应的节点，<strong>提高diff速度，更高效的更新虚拟DOM</strong>;vue和react都是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。</li><li>为了在数据变化时强制更新组件，以避免<strong>  “就地复用” </strong>带来的副作用。当 Vue.js 用<strong>v-for </strong> 更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。重复的key会造成渲染错误。</li></ol><h3 id="Vue-的生命周期是什么？"><a href="#Vue-的生命周期是什么？" class="headerlink" title="Vue 的生命周期是什么？"></a>Vue 的生命周期是什么？</h3><p>Vue 的生命周期指的是组件从创建到销毁的一系列的过程，被称为 Vue 的生命周期。通过提供的 Vue 在生命周期各个阶段的钩子函数，我们可以很好的在 Vue 的各个生命阶段实现一些操作。</p><h3 id="Vue-的各个生命阶段是什么？"><a href="#Vue-的各个生命阶段是什么？" class="headerlink" title="Vue 的各个生命阶段是什么？"></a>Vue 的各个生命阶段是什么？</h3><p>Vue 一共有8个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">（<span class="hljs-number">1</span>）<span class="hljs-keyword">beforeCreate </span>钩子函数，在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中我们是获取不到 data 数据的。<br><br>（<span class="hljs-number">2</span>）created 钩子函数，在实例创建完成后触发，此时可以访问 data、methods 等属性。但这个时候组件还没有被挂载到页面中去，所以这个时候访问不到 $el 属性。一般我们可以在这个函数中进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化。<br><br>（<span class="hljs-number">3</span>）<span class="hljs-keyword">beforeMount </span>钩子函数，在组件被挂载到页面之前触发。在 <span class="hljs-keyword">beforeMount </span>之前，会找到对应的 template，并编译成 render 函数。<br><br>（<span class="hljs-number">4</span>）mounted 钩子函数，在组件挂载到页面之后触发。此时可以通过 DOM API 获取到页面中的 DOM 元素。<br><br>（<span class="hljs-number">5</span>）<span class="hljs-keyword">beforeUpdate </span>钩子函数，在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候我们可以对可能会被移除的元素做一些操作，比如移除事件监听器。<br><br>（<span class="hljs-number">6</span>）updated 钩子函数，虚拟 DOM 重新渲染和打补丁之后调用。<br><br>（<span class="hljs-number">7</span>）<span class="hljs-keyword">beforeDestroy </span>钩子函数，在实例销毁之前调用。一般在这一步我们可以销毁定时器、解绑全局事件等。<br><br>（<span class="hljs-number">8</span>）destroyed 钩子函数，在实例销毁之后调用，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<br><br>当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。<br></code></pre></td></tr></table></figure><h3 id="父子组件的生命周期"><a href="#父子组件的生命周期" class="headerlink" title="父子组件的生命周期"></a>父子组件的生命周期</h3><p><a href="https://pengzhenglong.github.io/2022/02/28/Vue%E4%B8%AD%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E9%A1%BA/">博客：</a></p><h3 id="为什么v-for和v-if不建议用在一起"><a href="#为什么v-for和v-if不建议用在一起" class="headerlink" title="为什么v-for和v-if不建议用在一起"></a>为什么v-for和v-if不建议用在一起</h3><p>1.当 v-for 和 v-if 处于同一个节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费<br>2.这种场景建议使用 computed，先对数据进行过滤</p><blockquote><p>注意：3.x 版本中 v-if 总是优先于 v-for 生效。由于语法上存在歧义，建议避免在同一元素上同时使用两者。比起在模板层面管理相关逻辑，更好的办法是通过创建计算属性筛选出列表，并以此创建可见元素。<br>解惑传送门 ☞<a href="https://link.juejin.cn/?target=https://v3.cn.vuejs.org/guide/migration/v-if-v-for.html%23%25E6%25A6%2582%25E8%25A7%2588"># v-if 与 v-for 的优先级对比非兼容</a></p></blockquote><h3 id="路由实现原理是什么"><a href="#路由实现原理是什么" class="headerlink" title="路由实现原理是什么"></a>路由实现原理是什么</h3><p>a.控制地址栏改变；b.根据地址栏的改变来控制组件的切换</p><p>hash通过window.onhashchange监听地址栏的改变；</p><p>history通过window.onpopState监听地址栏的改变</p><p>URL的hash:<br> URL的hash也就是锚点(#), <strong>本质上是改变window.location的href属性；</strong><br> 我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新;</p><p>history接口是HTML5新增的, 它有六种模式改变URL而不刷新页面：<br> replaceState：替换原来的路径；<br> pushState：使用新的路径；<br> popState：路径的回退；<br> go：向前或向后改变路径；<br> forward：向前改变路径；<br> back：向后改变路径；</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="vue-router的push和replace的区别"><a href="#vue-router的push和replace的区别" class="headerlink" title="vue-router的push和replace的区别"></a>vue-router的push和replace的区别</h4><p>1.this.$router.push()</p><p>描述：跳转到不同的url，但这个方法会向history栈<strong>添加一个记录</strong>，点击后退会返回到上一个页面。</p><p>2.this.$router.replace()</p><p>描述：同样是跳转到指定的url，但是这个方法<strong>不会向history里面添加新的记录</strong>，点击返回，会跳转到上上一个页面。上一个记录是不存在的。</p><p>3.this.$router.go(n)</p><p>相对于当前页面向前或向后跳转多少个页面,类似 window.history.go(n)。n可为正数可为负数。正数返回上一个页面</p><p><a href="https://pengzhenglong.github.io/2022/02/17/%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">前端两种路由实现和使用场景–Hash模式&amp;&amp;History模</a></p><h3 id="route-和-router-的区别？"><a href="#route-和-router-的区别？" class="headerlink" title="$route 和 $router 的区别？"></a>$route 和 $router 的区别？</h3><p>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。而 $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</p><h3 id="vue-router-中的导航钩子函数"><a href="#vue-router-中的导航钩子函数" class="headerlink" title="vue-router 中的导航钩子函数"></a>vue-router 中的导航钩子函数</h3><p>（1）全局的钩子函数 beforeEach 和 afterEach</p><p>beforeEach 有三个参数，to 代表要进入的路由对象，from 代表离开的路由对象。next 是一个必须要执行的函数，如果不传参数，那就执行下一个钩子函数，如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错误的监听函数。</p><p>（2）单个路由独享的钩子函数 beforeEnter，它是在路由配置上直接进行定义的。</p><p>（3）组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。它们是直接在路由组<br>件内部直接进行定义的。</p><p>详细资料可以参考： <a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">《导航守卫》</a></p><h3 id="vue组件的通信方式"><a href="#vue组件的通信方式" class="headerlink" title="vue组件的通信方式"></a>vue组件的通信方式</h3><p>props/$emit 父子组件通信父-&gt;子props，子-&gt;父 $on、$emit 获取父子组件实例</p><p>parent、children Ref 获取实例的方式调用组件的属性或者方法</p><p>父-&gt;子孙 Provide、inject 官方不推荐使用，但是写组件库时很常用</p><p>$emit/$on 自定义事件 兄弟组件通信Event Bus 实现跨组件通信 Vue.prototype.$bus = new Vue() 自定义事件</p><p>vuex 跨级组件通信<strong>Vuex、$attrs、$listeners Provide、inject</strong></p><h3 id="为何vue采用异步渲染"><a href="#为何vue采用异步渲染" class="headerlink" title="为何vue采用异步渲染"></a>为何vue采用异步渲染</h3><p>最终一次性更新DOM，避免重复操作DOM，耗费性能。</p><h3 id="nextTick的实现原理是什么？"><a href="#nextTick的实现原理是什么？" class="headerlink" title="nextTick的实现原理是什么？"></a>nextTick的实现原理是什么？</h3><p>在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。 nextTick主要使用了宏任务和微任务。 根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p><h3 id="nextTick的实现"><a href="#nextTick的实现" class="headerlink" title="nextTick的实现"></a>nextTick的实现</h3><ol><li>nextTick是Vue提供的一个全局API,是在下次DOM更新循环结束之后执行延迟回调，在修改数据之后使用$nextTick，则可以在回调中获取更新后的DOM；</li><li>Vue在更新DOM时是异步执行的。只要侦听到数据变化，Vue将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用；</li><li>比如，我在干什么的时候就会使用nextTick，传一个回调函数进去，在里面执行dom操作即可；</li><li>我也有简单了解nextTick实现，它会在callbacks里面加入我们传入的函数，然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。</li></ol><h3 id="使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽"><a href="#使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽" class="headerlink" title="使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽"></a>使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽</h3><p>vue中的插槽是一个非常好用的东西slot说白了就是一个占位的<br>在vue当中插槽包含三种</p><ol><li>一种是默认插槽（匿名）</li><li>一种是具名插槽</li><li>还有一种就是作用域插槽<br>匿名插槽就是没有名字的只要默认的都填到这里具名插槽指的是具有名字的</li></ol><p><a href="https://pengzhenglong.github.io/2021/05/01/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%BA%94)/">博客</a></p><h3 id="Vuex的理解及使用场景"><a href="#Vuex的理解及使用场景" class="headerlink" title="Vuex的理解及使用场景"></a>Vuex的理解及使用场景</h3><ul><li>Vuex 是一个专为 Vue 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。<br>Vuex 的状态存储是响应式的；当 Vue 组件从 store 中读取状态的时候，<br>若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新</li><li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation， 这样使得我们可以方便地跟踪每一个状态的变化 Vuex主要包括以下几个核心模块：</li></ul><ol><li>state：定义了应用的状态数据</li><li>Getter：在 store 中定义“getter”（可以认为是 store 的计算属性），<br>就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来， 且只有当它的依赖值发生了改变才会被重新计算</li><li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数</li><li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作</li><li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中</li></ol><p><img src="/imageO/VueX.jpg" alt="vuex"></p><p><a href="https://pengzhenglong.github.io/2021/05/07/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%B8%83)/">博客</a></p><h3 id="vuex-mutation为什么不可以包含异步回调，action-为什么可以"><a href="#vuex-mutation为什么不可以包含异步回调，action-为什么可以" class="headerlink" title="vuex  mutation为什么不可以包含异步回调，action 为什么可以"></a>vuex  mutation为什么不可以包含异步回调，action 为什么可以</h3><p>官网是这样说的：</p><p>现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p><p>可以看到在Mutation中使用异步和同步最终页面的总和都是正确的，也就是说在Mutation中使用异步不会对数据造成丢失和其他影响。<br>然而我们注意Vue Devtools显示结果，当我们去查看多次Mutation状态时，发现同步的显示Ok，异步的Count显示为0 和我们预期结果不一致，所以会造成状态改变的不可追踪，所以官方说我们Mutation是同步的！</p><blockquote><p>重点事情<br>造成状态改变的不可追踪<br>在actions中就不会出现这种状态改变不可追踪的情况<br><a href="https://www.jianshu.com/p/5bb205f8b8eb">简书</a></p></blockquote><h3 id="Vue动态加载组件的四种方式"><a href="#Vue动态加载组件的四种方式" class="headerlink" title="Vue动态加载组件的四种方式"></a>Vue动态加载组件的四种方式</h3><h4 id="import-require"><a href="#import-require" class="headerlink" title="import /require"></a>import /require</h4><p><a href="https://www.jianshu.com/p/686ce86f4042">Vue动态加载组件的四种方式</a></p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网+HTTP+浏览器+网络安全面试题总结</title>
    <link href="/2022/01/07/%E8%AE%A1%E7%BD%91+%E6%B5%8F%E8%A7%88%E5%99%A8+http+%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/01/07/%E8%AE%A1%E7%BD%91+%E6%B5%8F%E8%A7%88%E5%99%A8+http+%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>总结了最近的一些面试题和之前的知识点</p><hr><h2 id="计网-HTTP"><a href="#计网-HTTP" class="headerlink" title="计网+HTTP"></a>计网+HTTP</h2><h3 id="从输入URL到浏览器显示页面过程中都发生了什么"><a href="#从输入URL到浏览器显示页面过程中都发生了什么" class="headerlink" title="从输入URL到浏览器显示页面过程中都发生了什么"></a>从输入URL到浏览器显示页面过程中都发生了什么</h3><p>  <a href="https://pengzhenglong.github.io/2021/05/27/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%BF%87%E7%A8%8B%E9%9D%A2%E8%AF%95/#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">从输入URL到浏览器显示页面过程中都发生了什么</a></p><h3 id="1-http-和-https-的基本概念"><a href="#1-http-和-https-的基本概念" class="headerlink" title="1.http 和 https 的基本概念"></a>1.http 和 https 的基本概念</h3><p>HTTP 是一种 超文本传输协议(Hypertext Transfer Protocol)，HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范<br><img src="/imageO/Http.jpg" alt="Http"><br>HTTP 主要内容分为三部分，<strong>超文本（Hypertext）、传输（Transfer）、协议（Protocol）</strong>。</p><ol><li>超文本就是不单单只是本文，它还可以传输图片、音频、视频，甚至点击文字或图片能够进行超链接的跳转。</li><li>上面这些概念可以统称为数据，传输就是数据需要经过一系列的物理介质从一个端系统传送到另外一个端系统的过程。通常我们2把传输数据包的一方称为请求方，把接到二进制数据包的一方称为应答方。</li><li>而协议指的就是是网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为协议，只不过是网络协议。<br>说到 HTTP，不得不提的就是 TCP/IP 网络模型，一般是五层模型。如下图所示<br>但是也可以分为四层，就是把链路层和物理层都表示为网络接口层<br><img src="/imageO/WC.jpg" alt="TCP/IP网络模型"><br>还有一种就是 OSI 七层网络模型，它就是在五层协议之上加了表示层和会话层<br><img src="/imageO/QC.jpg" alt="TCP/IP网络模型"></li></ol><h4 id="那么，HTTP-和-HTTPS-的主要区别是什么呢？"><a href="#那么，HTTP-和-HTTPS-的主要区别是什么呢？" class="headerlink" title="那么，HTTP 和 HTTPS 的主要区别是什么呢？"></a>那么，HTTP 和 HTTPS 的主要区别是什么呢？</h4><ol><li>最简单的，HTTP 在地址栏上的协议是以 http:// 开头，而 HTTPS 在地址栏上的协议是以 https:// 开头</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>pengzhenglong.github.io/<br>https:<span class="hljs-regexp">//</span>pengzhenglong.github.io/<br></code></pre></td></tr></table></figure><ol start="2"><li>HTTP 是未经安全加密的协议，它的传输过程容易被攻击者监听、数据容易被窃取、发送方和接收方容易被伪造；而 HTTPS 是安全的协议，它通过<strong> 密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法 </strong>能够解决上面这些问题。</li><li>HTTP 的默认端口是 80，而 HTTPS 的默认端口是 443。</li></ol><h3 id="为什么有了HTTP为什么还要HTTPS？"><a href="#为什么有了HTTP为什么还要HTTPS？" class="headerlink" title="为什么有了HTTP为什么还要HTTPS？"></a>为什么有了HTTP为什么还要HTTPS？</h3><p>https是安全版的http，因为http协议的数据都是明文进行传输的，所以对于一些敏感信息的传输就很不安全，HTTPS就是为了解决HTTP的不安全而生的。</p><h3 id="HTTPS是如何保证安全的？"><a href="#HTTPS是如何保证安全的？" class="headerlink" title="HTTPS是如何保证安全的？"></a>HTTPS是如何保证安全的？</h3><p>过程比较复杂，我们得先理解两个概念</p><p>对称加密：即通信的双方都使用同一个秘钥进行加解密，比如特务接头的暗号，就属于对称加密</p><p>对称加密虽然很简单性能也好，但是无法解决首次把秘钥发给对方的问题，很容易被hacker拦截秘钥。<br>非对称加密：</p><ol><li>私钥 + 公钥= 密钥对</li><li>即用私钥加密的数据,只有对应的公钥才能解密,用公钥加密的数据,只有对应的私钥才能解密</li><li>因为通信双方的手里都有一套自己的密钥对,通信之前双方会先把自己的公钥都先发给对方</li><li>然后对方再拿着这个公钥来加密数据响应给对方,等到到了对方那里,对方再用自己的私钥进行解密</li></ol><p>非对称加密虽然安全性更高，但是带来的问题就是速度很慢，影响性能。<br>解决方案：</p><p>那么结合两种加密方式，将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。</p><p>此时又带来一个问题，中间人问题：</p><p>如果此时在客户端和服务器之间存在一个中间人,这个中间人只需要把原本双方通信互发的公钥,换成自己的公钥,这样中间人就可以轻松解密通信双方所发送的所有数据。</p><p>所以这个时候需要一个安全的第三方颁发证书（CA），证明身份的身份，防止被中间人攻击。</p><p>证书中包括：签发者、证书用途、使用者公钥、使用者私钥、使用者的HASH算法、证书到期时间等</p><p>但是问题来了，如果中间人篡改了证书，那么身份证明是不是就无效了？这个证明就白买了，这个时候需要一个新的技术，数字签名。</p><p>数字签名就是用CA自带的HASH算法对证书的内容进行HASH得到一个摘要，再用CA的私钥加密，最终组成数字签名。</p><p>当别人把他的证书发过来的时候,我再用同样的Hash算法,再次生成消息摘要，然后用CA的公钥对数字签名解密,得到CA创建的消息摘要,两者一比,就知道中间有没有被人篡改了。</p><p>这个时候就能最大程度保证通信的安全了。</p><h3 id="HTTP2相对于HTTP1-x有什么优势和特点？"><a href="#HTTP2相对于HTTP1-x有什么优势和特点？" class="headerlink" title="HTTP2相对于HTTP1.x有什么优势和特点？"></a>HTTP2相对于HTTP1.x有什么优势和特点？</h3><h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4><p>帧：HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。<br>流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID<br>HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。</p><h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。</p><p>服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。</p><h4 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h4><p>HTTP/1.x会在请求和响应中中重复地携带不常改变的、冗长的头部数据，给网络带来额外的负担。</p><ol><li>HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送</li><li>首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</li><li>每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。</li></ol><blockquote><p>你可以理解为只发送差异数据，而不是全部发送，从而减少头部的信息量</p></blockquote><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。<br>HTTP2中：</p><p>同域名下所有通信都在单个连接上完成。<br>单个连接可以承载任意数量的双向数据流。<br>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装</p><h3 id="2-http-和-https-的区别及优缺点？"><a href="#2-http-和-https-的区别及优缺点？" class="headerlink" title="2.http 和 https 的区别及优缺点？"></a>2.http 和 https 的区别及优缺点？</h3><ol><li>http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议安全，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。</li><li>http 协议的默认端口为 80，https 的默认端口为 443。</li><li>http 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li><li>https 缓存不如 http 高效，会增加数据开销。</li><li>Https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。</li><li>SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。</li></ol><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层协议定义了应用进程间的交互和通信规则，不同主机的应用进程间如何相互传递报文，比如传递的报文的类型、格式、  有哪些字段等等。</p><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。<br>HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</p><p>HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP连接三次握手时所花费的时间。</p><p>在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-alive 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。</p><h3 id="HTTP的keep-alive是干什么的？"><a href="#HTTP的keep-alive是干什么的？" class="headerlink" title="HTTP的keep-alive是干什么的？"></a>HTTP的keep-alive是干什么的？</h3><p>在早期的HTTP/1.0中，每次http请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的HTTP/1.0中以及HTTP/1.1中，引入了重用连接的机制，就是在http请求头中加入Connection: keep-alive来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive。</p><h4 id="keep-alive的优点"><a href="#keep-alive的优点" class="headerlink" title="keep-alive的优点"></a>keep-alive的优点</h4><p>较少的CPU和内存的使用（由于同时打开的连接的减少了）<br>允许请求和应答的HTTP管线化<br>降低拥塞控制 （TCP连接减少了）<br>减少了后续请求的延迟（无需再进行握手）<br>报告错误无需关闭TCP连</p><h3 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h3><h4 id="HTTP-报文有两种，一种是请求报文，一种是响应报文"><a href="#HTTP-报文有两种，一种是请求报文，一种是响应报文" class="headerlink" title="HTTP 报文有两种，一种是请求报文，一种是响应报文"></a>HTTP 报文有两种，一种是请求报文，一种是响应报文</h4><p>HTTP 请求报文的格式如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GET</span> / HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span>User-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Macintosh; Intel Mac OS X <span class="hljs-number">10</span>_<span class="hljs-number">10</span>_<span class="hljs-number">5</span>)Accept: */*<br></code></pre></td></tr></table></figure><p>HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这<br>个空行不能省略，它用来划分首部与实体。</p><p>请求行包含三个字段：方法字段、URL 字段和 HTTP 版本字段。</p><p>方法字段可以取几种不同的值，一般有 GET、POST、HEAD、PUT 和 DELETE。<br>一般 GET 方法只被用于向服务器获取数据。<br>POST 方法用于将实体提交到指定的资源，通常会造成服务器资源的修改。<br>HEAD 方法与 GET 方法类似，但是在返回的响应中，不包含请求对象。<br>PUT 方法用于上传文件到服务器，<br>DELETE 方法用于删除服务器上的对象。<br>虽然请求的方法很多，但更多表达的是一种语义上的区别，并不是说 POST 能做的事情，GET 就不能做了，主要看我们如何选择。更多的方法可以参<br>看  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">文档</a>。</p><h3 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a>HTTP 响应报文</h3><p>HTTP 响应报文的格式如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">0</span> <span class="hljs-number">200</span> OKContent-Type: text/plainContent-Length: <span class="hljs-number">137582</span>Expires: Thu, <span class="hljs-number">05</span> Dec <span class="hljs-number">1997</span> <span class="hljs-number">16</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> GMTLast-Modified: Wed, <span class="hljs-number">5</span> August <span class="hljs-number">1996</span> <span class="hljs-number">15</span>:<span class="hljs-number">55</span>:<span class="hljs-number">28</span> GMTServer: Apache <span class="hljs-number">0</span>.<span class="hljs-number">84</span>&lt;html&gt; &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>HTTP 响应报文的第一行叫做状态行，后面的行是首部行，最后是实体主体。<br>状态行包含了三个字段：协议版本字段、状态码和相应的状态信息。<br>实体部分是报文的主要部分，它包含了所请求的对象。<br>常见的状态有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">200-请求成功、202-服务器端已经收到请求消息，但是尚未进行处理<br>301-永久移动、302-临时移动、304-所请求的资源未修改、<br>400-客户端请求的语法错误、404-请求的资源不存在<br>500-服务器内部错误。<br>一般 1XX 代表服务器接收到请求、2XX 代表成功、3XX 代表重定向、4XX 代表客户端错误、5XX 代表服务器端错误。<br></code></pre></td></tr></table></figure><p>更多关于状态码的可以查看：</p><p><a href="https://www.runoob.com/http/http-status-codes.html">《HTTP 状态码》</a></p><h4 id="首部行"><a href="#首部行" class="headerlink" title="首部行"></a>首部行</h4><p>首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设<br>置，区别在于请求首部和响应首部。<br>常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。<br>常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。<br>常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。<br>常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修改时间。<br>更多关于首部的资料可以查看：<br><a href="https://www.cnblogs.com/jycboy/p/http_head.html">《HTTP 首部字段详细介绍》</a><br><a href="https://blog.csdn.net/qq_34289537/article/details/52971516">《图解 HTTP》</a></p><h3 id="3-https-协议的工作原理"><a href="#3-https-协议的工作原理" class="headerlink" title="3.https 协议的工作原理"></a>3.https 协议的工作原理</h3><p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p><ol><li>客户端使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。</li><li>web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），传输给客户端。</li><li>客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。</li><li>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</li><li>web 服务器通过自己的私钥解密出会话密钥。</li><li>web 服务器通过会话密钥加密与客户端之间的通信。<br>传送门 ☞ #<a href="https://juejin.cn/post/6995109407545622542">解读 HTTP1/HTTP2/HTTP3</a></li></ol><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><ol><li>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li><li>第二次握手：服务器收到syn包并确认客户的SYN（ack=j+1），同时也发送一个自己的SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li></ol><blockquote><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p></blockquote><h4 id="目的：-建立可靠的通信通道-，数据的发送和接收（双方正常）"><a href="#目的：-建立可靠的通信通道-，数据的发送和接收（双方正常）" class="headerlink" title="目的： 建立可靠的通信通道 ，数据的发送和接收（双方正常）"></a>目的： 建立可靠的通信通道 ，数据的发送和接收（双方正常）</h4><p>翻译成大白话就是： 客户端：你能接收到我的消息吗？ 服务端：可以的，那你能接收到我的回复吗？ 客户端：可以，那我们开始聊正事吧。</p><h4 id="为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人-为什么不是4次？：3次够了第四次浪费"><a href="#为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人-为什么不是4次？：3次够了第四次浪费" class="headerlink" title="为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人 为什么不是4次？：3次够了第四次浪费"></a>为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人 为什么不是4次？：3次够了第四次浪费</h4><h3 id="TCP-协议四次挥手"><a href="#TCP-协议四次挥手" class="headerlink" title="TCP 协议四次挥手"></a>TCP 协议四次挥手</h3><p>客户端-发送一个FIN,用来关闭客户端到服务器的数据传输<br>服务器-收到这个FIN,它发回一个ACK，确认序号为收到的序号加1.和SYN一样，一个FIN将占用一个序号<br>服务器-关闭与客户端的连接，发送一个FIN给客户端<br>客户端-发回ACK报文确认，并将确认序号设置为收到序号加1</p><h4 id="为什么不是两次？"><a href="#为什么不是两次？" class="headerlink" title="为什么不是两次？"></a>为什么不是两次？</h4><p>两次情况客户端说完结束就立马断开不再接收，无法确认服务端是否接收到断开消息，但且服务端可能还有消息未发送完。</p><h4 id="为什么不是三次？"><a href="#为什么不是三次？" class="headerlink" title="为什么不是三次？"></a>为什么不是三次？</h4><p>3次情况服务端接收到断开消息，向客户端发送确认接受消息，客户端未给最后确认断开的回复。</p><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p><h4 id="TCP作为一种可靠的传输控制协议，其核心思想就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求"><a href="#TCP作为一种可靠的传输控制协议，其核心思想就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求" class="headerlink" title="TCP作为一种可靠的传输控制协议，其核心思想就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求"></a>TCP作为一种可靠的传输控制协议，其核心思想就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求</h4><p><a href="https://pengzhenglong.github.io/2021/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">博客</a></p><h3 id="TCP-IP-如何保证数据包传输的有序可靠？"><a href="#TCP-IP-如何保证数据包传输的有序可靠？" class="headerlink" title="TCP/IP / 如何保证数据包传输的有序可靠？"></a>TCP/IP / 如何保证数据包传输的有序可靠？</h3><p>对字节流分段并进行编号然后通过 ACK 回复和超时重发这两个机制来保证。<br>（1）为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；<br>（2）并为每个已发送的数据包启动一个超时定时器；<br>（3）如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;<br>（4）否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。<br>（5）接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</p><h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><ol><li>TCP是面向链接的，而UDP是面向无连接的。</li><li>TCP仅支持单播传输，UDP 提供了单播，多播，广播的功能。</li><li>TCP的三次握手保证了连接的可靠性; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</li><li>UDP的头部开销比TCP的更小，数据传输速率更高，实时性更好。</li></ol><p>传送门 ☞<a href="https://juejin.cn/post/6992743999756845087"># 深度剖析TCP与UDP的区别</a><br><a href="https://pengzhenglong.github.io/2021/07/09/TCP%E5%8D%8F%E8%AE%AE/">博客</a></p><h3 id="Ajax-是什么-如何创建一个-Ajax？"><a href="#Ajax-是什么-如何创建一个-Ajax？" class="headerlink" title="Ajax 是什么? 如何创建一个 Ajax？"></a>Ajax 是什么? 如何创建一个 Ajax？</h3><p>Gmail开发人员发现IE里面有个XMLHTTPRequest对象来请求数据时，可以实现无刷新数据请求，所以使用这个特性，进行网络数据请求，这就是AJAX的由来。<br>AJAX不是一个单词，他的全称是Asynchronous JavaScript and XML，就是<strong>异步的JavaScript和XML</strong>，它是一套用于创建快速动态网页的技术标准，使用步骤如下：</p><ol><li>创建异步XMLHttpRequest对象</li><li>设置请求参数，包括请求的方法和URL等</li><li>发送请求</li><li>注册事件，事件状态变更会及时响应监听</li><li>在监听里面获取并处理返回数据</li></ol><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-comment">//创建 XMLHttpRequest 对象</span><br><span class="hljs-keyword">var</span> ajax = <span class="hljs-keyword">new</span> XMLHttpRequest();<br><span class="hljs-comment">//规定请求的类型、URL 以及是否异步处理请求。</span><br>ajax.open(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-built_in">url</span>,<span class="hljs-literal">true</span>);<br><span class="hljs-comment">//发送信息至服务器时内容编码类型</span><br>ajax.setRequestHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>); <br><span class="hljs-comment">//发送请求</span><br>ajax.send(<span class="hljs-literal">null</span>);  <br><span class="hljs-comment">//接受服务器响应数据</span><br>ajax.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (obj.readyState == <span class="hljs-number">4</span> &amp;&amp; (obj.status == <span class="hljs-number">200</span> || obj.status == <span class="hljs-number">304</span>)) &#123; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>所以AJAX的核心就是XMLHttpRequest对象，这是一个非常早的实现方法，也是兼容性最好的，已经成为了浏览器标准，虽然我们现在都使用其它的API规范，但对象名字暂时还是用XML命名</p><p><a href="https://pengzhenglong.github.io/2021/05/28/ajax%E9%9D%A2%E8%AF%95/#http%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">博客</a></p><h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>axios是一个基于Promise的HTTP库，可以用在浏览器和node.js中，它底层还是基于XMLHttpRequest对象的，你可以认为它是一个方便的封装库，除了基础请求数据，它还增加了如下功能：</p><ol><li>对PromiseAPI的支持</li><li>支持请求拦截和响应、转换请求数据和响应数据、取消请求</li><li>可以自动转换JSON数据</li><li>支持防御XSRF</li></ol><h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>fetch就<strong>不是XMLHttpRequest对象了，fetch是原生的js对象，也就是说，它不依赖浏览器</strong>，fetch提供了一个理解的请求替换方案，可以提供给其它技术使用。我们主要需要了解下fetch和ajax的本质区别：</p><ol><li>fetch返回的是Promise，所以如果HTTP状态码是404之类的，fetch也是成功返回的，只有在网络连接错误的情况下，才会reject</li><li>fetch不发送cookies</li></ol><p>fetch的请求写法会比AJAX简单许多，但我想，最主要的问题是，<strong>无法区分HTTP状态码了</strong>，这个在编程时还是比较常用的，所以我们目前还是使用axios比较多，而很少使用fetch<br><img src="/imageO/Ajax.jpg" alt="Ajax"></p><h3 id="Cookie、sessionStorage、localStorage-的区别"><a href="#Cookie、sessionStorage、localStorage-的区别" class="headerlink" title="Cookie、sessionStorage、localStorage 的区别"></a>Cookie、sessionStorage、localStorage 的区别</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>存储在客户端</p><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul><li>cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+</li><li>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</li><li>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</li></ul><p>localStorage和SessionStorage</p><ul><li>只能存储字符串对象</li><li>不同浏览器无法共享localStorage与SessionStroage中的信息。相同浏览器的不同页面间（同源页面）可以共享相同的localStorage，但不能共享sessionStorage。</li></ul><h4 id="2-Session"><a href="#2-Session" class="headerlink" title="2. Session"></a>2. Session</h4><p>Session是一种服务端解决方案，通过服务器来保持状态。<br>Session是服务器为了保存用户状态而创建的一个特殊对象。客户端请求服务端，服务端会为这次请示开辟一块内存空间。<br>Session弥补了HTTP的无状态特性。</p><h5 id="Session的创建过程"><a href="#Session的创建过程" class="headerlink" title="Session的创建过程"></a>Session的创建过程</h5><p>当浏览器第一次访问服务器时，服务器会创建一个Session对象(该对象有唯一的ID，即SessionID)。服务器会将SessionID以cookie的方式返回浏览器。<br>当浏览器再次访问服务器时，会将SessionID发送过来，服务器依据sessionID就可以找到对应的session对象。</p><h6 id="Session的缺点"><a href="#Session的缺点" class="headerlink" title="Session的缺点"></a>Session的缺点</h6><p>A 服务器存储了 Session，就是做了负载均衡后，假如一段时间内 A 的访问量激增，会转发到 B 进行访问，但是 B 服务器并没有存储 A 的 Session，会导致 Session 的失效。</p><p><a href="https://pengzhenglong.github.io/2021/06/16/cookie%E3%80%81localStorage%E3%80%81sessionStorage&token/">博客</a><br><a href="https://juejin.cn/post/7012506796489359368">JavaScript的存储–Cookie、Session、localStorage、sessionStorage</a></p><h3 id="什么是浏览器的同源政策？"><a href="#什么是浏览器的同源政策？" class="headerlink" title="什么是浏览器的同源政策？"></a>什么是浏览器的同源政策？</h3><p>我对浏览器的同源政策的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个域的  <strong>协议、域名、端口号</strong>必须相同，否则不属于同一个域。<br>同源政策主要限制了三个方面</p><ol><li>第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</li><li>第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</li><li>第三个是当前域下 ajax 无法发送跨域请求。</li></ol><p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。<br>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是80（默认端口可以省略）。</p><h3 id="跨域怎么实现？jsonp的原理是什么？"><a href="#跨域怎么实现？jsonp的原理是什么？" class="headerlink" title="跨域怎么实现？jsonp的原理是什么？"></a>跨域怎么实现？jsonp的原理是什么？</h3><h4 id="跨域，指的是浏览器不能执行其他网站的脚本。浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行"><a href="#跨域，指的是浏览器不能执行其他网站的脚本。浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行" class="headerlink" title="跨域，指的是浏览器不能执行其他网站的脚本。浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行"></a>跨域，指的是浏览器不能执行其他网站的脚本。浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行</h4><p>解决办法：</p><ol><li>JSONP：注意JSONP只支持GET请求，不支持POST请求。<br>原理：ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。 —   callback</li><li>代理：写后端接口，在后端调用页面拿到返回值返回给html文件。相当于绕过了浏览器，就不会存在跨域问题。例；(nigx反向代理)</li><li>CORS CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin:*&#x27;</span>);<span class="hljs-comment">//允许所有来源访问</span><br><span class="hljs-selector-tag">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Method:POST,GET&#x27;</span>);<span class="hljs-comment">//允许访问的方式</span><br></code></pre></td></tr></table></figure><ol start="4"><li>proxy代理 目前常用方式,通过服务器设置代理</li><li>window.postMessage() 利用h5新特性window.postMessage()</li></ol><h3 id="浏览器会拦截跨域请求，但是只是拦截返回结果，请求还是会被发送到服务器，这样有意义么"><a href="#浏览器会拦截跨域请求，但是只是拦截返回结果，请求还是会被发送到服务器，这样有意义么" class="headerlink" title="浏览器会拦截跨域请求，但是只是拦截返回结果，请求还是会被发送到服务器，这样有意义么"></a>浏览器会拦截跨域请求，但是只是拦截返回结果，请求还是会被发送到服务器，这样有意义么</h3><p>有意义。<br>首先，请求因为跨域被拦截后，会改成OPTIONS请求送达服务器，这样服务器就可以知道有人在请求。<br>至于你说跨域POST也能修改，那因为服务器没对method进行校验，来者不拒，这是你服务器的问题。<br>正常的API数据操作method不包括OPTIONS，OPTIONS只用来确认允许的操作。</p><h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><p>仅记录在 RFC2616 上的 HTTP 状态码就达 40 种，若再加上 WebDAV（RFC4918、5842）和附加 HTTP 状态码 （RFC6585）等扩展，数量就达 60 余种。接下来，我们就介绍一下这些具有代表性的一些状态码。</p><p>1xx: 指示信息——表示请求已接收，继续处理</p><p>2xx: 成功——表示请求已被成功接收</p><p>3xx: 重定向——表示要完成请求必须进行进一步操作</p><p>4xx: 客户端错误——表示请求有语法错误或请求无法实现</p><p>5xx: 服务端错误——表示服务器未能实现合法的请求</p><h4 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h4><p>状态码 描述<br>200 请求成功<br>202-服务器端已经收到请求消息，但是尚未进行处理<br>206 已完成指定范围的请求(带Range头的GET请求),场景如video,audio播放文件较大,文件分片时<br>301 永久重定向<br>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替<br>302 临时重定向<br> 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI<br>304 请求资源未修改，可以使用缓存的资源，不用在服务器取<br>400 请求有语法错误<br>401 没有权限访问<br>403 服务器拒绝执行请求，场景如不允许直接访问，只能通过服务器访问时<br>404 请求资源不存在<br>500 服务器内部错误，无法完成请求<br>503 请求未完成，因服务器过载、宕机或维护等</p><h3 id="长轮询和短轮询"><a href="#长轮询和短轮询" class="headerlink" title="长轮询和短轮询"></a>长轮询和短轮询</h3><h4 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h4><p>客户端发送请求后服务器端不会立即返回数据，服务器端会阻塞请求<strong>连接不会立即断开，直到服务器端有数据更新或者是连接超时才返回，客户端才再次发出请求新建连接、如此反复从而获取最新数据</strong>。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LongAjax</span>(<span class="hljs-params"></span>) </span>&#123;<br>    fetch(url).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>     <span class="hljs-comment">// 数据正确拿到后，</span><br>        LongPolling();<br>    &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>     <span class="hljs-comment">// 出错或者就是超时间</span><br>        LongPolling();<br><br>    &#125;);<br>&#125;<br>LongAjax()<br></code></pre></td></tr></table></figure><p>优点：长轮询与短轮询相比，明显减少了很多不必要的http请求，节约资源。<br>节点：连接挂起也会导致资源的浪费，停留在服务器端。</p><h4 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h4><p>短轮询(Polling)的实现思路就是浏览器端每隔几秒钟向服务器端<strong>发送http请求，服务端在收到请求后，不论是否有数据更新，都直接进行响应。</strong>在服务端响应完成，就会关闭这个Tcp连接。</p><p>优点：就是兼容性比较好，只要支持http协议就可以实现该方式。<br>缺点：很明显消耗资源，因为下一次的建立Tcp是非常消耗资源的，服务器端响应后就会关闭这个Tcp连接。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LongAjax</span>(<span class="hljs-params"></span>) </span>&#123;<br>    fetch(url).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 数据正确拿到后，dosometing</span><br><br>    &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 发现错误，比如返回的数据为空等。</span><br>        console.log(err);<br>    &#125;);<br>&#125;<br>setInterval(LongAjax, <span class="hljs-number">5000</span>);<br></code></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/6864398060702760968#heading-105">长轮询和短轮询</a></p><h3 id="说下进程、线程和协程"><a href="#说下进程、线程和协程" class="headerlink" title="说下进程、线程和协程"></a>说下进程、线程和协程</h3><p> 进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，<strong>是操作系统进行资源分配和调度的一个独立单位</strong>，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义</p><p> 线程是程序执行中一个单一的顺序控制流程，是<strong>程序执行流的最小单元</strong>，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成</p><p> 协程，英文Coroutines，<strong>是一种基于线程之上</strong>，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性</p><p>进程和线程的区别与联系<br>【区别】：</p><h4 id="调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位"><a href="#调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位" class="headerlink" title="调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位"></a>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位</h4><h4 id="并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行"><a href="#并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行" class="headerlink" title="并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行"></a>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行</h4><p>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。</p><p>系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。<br>【联系】：</p><blockquote><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</p></blockquote><blockquote><p>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</p></blockquote><blockquote><p>处理机分给线程，即真正在处理机上运行的是线程；</p></blockquote><p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p><p>传送门 ☞ # <a href="https://juejin.cn/post/7005465381791875109">一文搞懂进程、线程、协程及JS协程的发展 ☞了解更多</a><br>关于浏览器传送门 ☞#<a href="https://juejin.cn/post/6993095345576083486">深入了解现代 Web 浏览器</a><br><a href="https://pengzhenglong.github.io/2021/04/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%A7%A3(%E4%B8%80)/">博客</a></p><h3 id="浏览器的缓存机制-强制缓存-amp-amp-协商缓存"><a href="#浏览器的缓存机制-强制缓存-amp-amp-协商缓存" class="headerlink" title="浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存"></a>浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存</h3><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：<br><img src="/imageO/HC.jpg" alt="如图"><br>由上图我们可以知道：</p><ol><li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中<br>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。</li></ol><h4 id="强制缓存强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程"><a href="#强制缓存强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程" class="headerlink" title="强制缓存强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程"></a>强制缓存强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程</h4><p>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 Expires 和 Cache-Control，其中Cache-Control优先级比Expires高。强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p><ol><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。</li><li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。</li><li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li></ol><h4 id="协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程"><a href="#协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程" class="headerlink" title="协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程"></a>协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</h4><p>同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since 和 Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。协商缓存主要有以下两种情况：</p><ol><li>协商缓存生效，返回304</li><li>协商缓存失效，返回200和请求结果结果<br>传送门 ☞ #<a href="https://juejin.cn/post/6992843117963509791">彻底理解浏览器的缓存机制</a></li></ol><h3 id="介绍下304过程"><a href="#介绍下304过程" class="headerlink" title="介绍下304过程"></a>介绍下304过程</h3><p>a. 浏览器请求资源时首先命中资源的Expires 和 Cache-Control，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过Cache-control: max-age指定最大生命周期，状态仍然返回200，但不会请求数据，在浏览器中能明显看到from cache字样。<br>b. 强缓存失效，进入协商缓存阶段，首先验证ETagETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据客户端上送的If-None-Match值来判断是否命中缓存。<br>c. 协商缓存Last-Modify/If-Modify-Since阶段，客户端第一次请求资源时，服务服返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间。再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。</p><h3 id="粘包问题分析与对策"><a href="#粘包问题分析与对策" class="headerlink" title="粘包问题分析与对策"></a>粘包问题分析与对策</h3><p>TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。<br>粘包出现原因<br>简单得说，在流传输中出现，UDP不会出现粘包，因为它有消息边界</p><h4 id="粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包"><a href="#粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包" class="headerlink" title="粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包"></a>粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包</h4><h4 id="为了避免粘包现象，可采取以下几种措施"><a href="#为了避免粘包现象，可采取以下几种措施" class="headerlink" title="为了避免粘包现象，可采取以下几种措施"></a>为了避免粘包现象，可采取以下几种措施</h4><p>（1）对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；<br>（2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；<br>（3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。分包多发。</p><h4 id="以上提到的三种措施，都有其不足之处"><a href="#以上提到的三种措施，都有其不足之处" class="headerlink" title="以上提到的三种措施，都有其不足之处"></a>以上提到的三种措施，都有其不足之处</h4><p>（1）第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。<br>（2）第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。<br>（3）第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</p><blockquote><p>一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。实验证明这种方法是高效可行的。</p></blockquote><h2 id="网路安全"><a href="#网路安全" class="headerlink" title="网路安全"></a>网路安全</h2><h3 id="什么是-XSS？如何预防？"><a href="#什么是-XSS？如何预防？" class="headerlink" title="什么是 XSS？如何预防？"></a>什么是 XSS？如何预防？</h3><p>XSS 全称是 Cross Site Scripting ,为了与CSS区分开来，故简称 XSS，翻译过来就是“跨站脚本”。<br>XSS是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。<br>最开始的时候，这种攻击是通过跨域来实现的，所以叫“跨域脚本”。发展到现在，往HTML文件中中插入恶意代码方式越来越多，所以是否跨域注入脚本已经不是唯一的注入手段了，但是 XSS 这个名字却一直保留至今。<br>注入恶意脚本可以完成这些事情：</p><ol><li>窃取Cookie</li><li>监听用户行为，比如输入账号密码后之间发给黑客服务器</li><li>在网页中生成浮窗广告</li><li>修改DOM伪造登入表单</li></ol><p>一般的情况下，XSS攻击有三种实现方式</p><p>存储型 XSS 攻击<br>反射型 XSS 攻击<br>基于 DOM 的 XSS 攻击</p><h4 id="存储型-XSS-攻击"><a href="#存储型-XSS-攻击" class="headerlink" title="存储型 XSS 攻击"></a>存储型 XSS 攻击</h4><p>存储型 XSS 攻击大致步骤如下：</p><ol><li>首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；</li><li>然后用户向网站请求包含了恶意 JavaScript 脚本的页面；</li><li>当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。</li></ol><p>比如常见的场景：</p><p>在评论区提交一份脚本代码，假设前后端没有做好转义工作，那内容上传到服务器，在页面渲染的时候就会直接执行，相当于执行一段未知的JS代码。这就是存储型 XSS 攻击。</p><h4 id="反射型-XSS-攻击"><a href="#反射型-XSS-攻击" class="headerlink" title="反射型 XSS 攻击"></a>反射型 XSS 攻击</h4><p>反射型 XSS 攻击指的就是恶意脚本作为<strong>「网络请求的一部分」</strong>，随后网站又把恶意的JavaScript脚本返回给用户，当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。<br>举个例子:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">http://dragon.com?query=<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">alert(<span class="hljs-string">&quot;你受到了XSS攻击&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如上，服务器拿到后解析参数query，最后将内容返回给浏览器，浏览器将这些内容作为HTML的一部分解析，发现是Javascript脚本，直接执行，这样子被XSS攻击了。<br>这也就是反射型名字的由来，将恶意脚本作为参数，通过网络请求，最后经过服务器，在反射到HTML文档中，执行解析。<br>主要注意的就是，<strong>「服务器不会存储这些恶意的脚本，这也算是和存储型XSS攻击的区别吧」。</strong></p><h4 id="基于-DOM-的-XSS-攻击"><a href="#基于-DOM-的-XSS-攻击" class="headerlink" title="基于 DOM 的 XSS 攻击"></a>基于 DOM 的 XSS 攻击</h4><p>基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，在数据传输的时候劫持网络数据包<br>常见的劫持手段有：</p><p>WIFI路由器劫持<br>本地恶意软件</p><h4 id="阻止-XSS-攻击的策略"><a href="#阻止-XSS-攻击的策略" class="headerlink" title="阻止 XSS 攻击的策略"></a>阻止 XSS 攻击的策略</h4><p>以上讲述的XSS攻击原理，都有一个共同点：让恶意脚本直接在浏览器执行。<br>针对三种不同形式的XSS攻击，有以下三种解决办法</p><h5 id="对输入脚本进行过滤或转码"><a href="#对输入脚本进行过滤或转码" class="headerlink" title="对输入脚本进行过滤或转码"></a>对输入脚本进行过滤或转码</h5><p>对用户输入的信息过滤或者是转码<br>举个例子👇<br>转码后👇</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-symbol">&amp;lt;</span>script<span class="hljs-symbol">&amp;gt;</span>alert(<span class="hljs-symbol">&amp;#39;</span>你受到XSS攻击了<span class="hljs-symbol">&amp;#39;</span>)<span class="hljs-symbol">&amp;lt;</span>/script<span class="hljs-symbol">&amp;gt;</span><br></code></pre></td></tr></table></figure><p>这样的代码在 html 解析的过程中是无法执行的。<br>当然了对于<code>&lt;script&gt;、&lt;img&gt;、&lt;a&gt;</code>等关键字标签也是可以过来的，效果如下👇</p><p>最后什么都没有剩下了</p><h5 id="利用-CSP"><a href="#利用-CSP" class="headerlink" title="利用 CSP"></a>利用 CSP</h5><p>该安全策略的实现基于一个称作 Content-Security-Policy的 HTTP 首部。<br>可以移步MDN，有更加规范的解释。我在这里就是梳理一下吧。<br>CSP，即浏览器中的内容安全策略，它的核心思想大概就是服务器决定浏览器加载哪些资源，具体来说有几个功能👇</p><p>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；<br>禁止向第三方域提交数据，这样用户数据也不会外泄；<br>提供上报机制，能帮助我们及时发现 XSS 攻击。<br>禁止执行内联脚本和未授权的脚本；</p><h5 id="利用-HttpOnly"><a href="#利用-HttpOnly" class="headerlink" title="利用 HttpOnly"></a>利用 HttpOnly</h5><p>由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。这样子的话，JavaScript 便无法读取 Cookie 的值。这样也能很好的防范 XSS 攻击。<br>通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的，下面是打开 Google 时，HTTP 响应头中的一段：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set</span>-cookie: NID=<span class="hljs-number">189</span>=M<span class="hljs-number">8</span>l<span class="hljs-number">6</span>-z<span class="hljs-number">41</span>asXtm<span class="hljs-number">2</span>uEwcOC<span class="hljs-number">5</span>oh<span class="hljs-number">9</span>djkffOMhWqQrlnCtOI; expires=Sat, <span class="hljs-number">18</span>-Apr-<span class="hljs-number">2020</span> <span class="hljs-number">06</span>:<span class="hljs-number">52</span>:<span class="hljs-number">22</span> GMT; path=/; domain=.google.com; HttpOnly<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>XSS 攻击是指浏览器中执行恶意脚本, 然后拿到用户的信息进行操作。主要分为存储型、反射型和文档型。防范的措施包括:</p><p>对输入内容过滤或者转码，尤其是类似于<code>&lt;script&gt;、&lt;img&gt;、&lt;a&gt;</code>标签<br>利用CSP<br>利用Cookie的HttpOnly属性</p><p>除了以上策略之外，我们还可以通过添加验证码防止脚本冒充用户提交危险操作。而对于一些不受信任的输入，还可以限制其输入长度，这样可以增大 XSS 攻击的难度。<br><a href="https://juejin.cn/post/6864398060702760968#heading-93">掘金</a></p><h3 id="什么是-CSP？"><a href="#什么是-CSP？" class="headerlink" title="什么是 CSP？"></a>什么是 CSP？</h3><p>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</p><p>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式<code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></p><h3 id="什么是-CSRF-攻击？如何防范-CSRF-攻击？"><a href="#什么是-CSRF-攻击？如何防范-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？如何防范 CSRF 攻击？"></a>什么是 CSRF 攻击？如何防范 CSRF 攻击？</h3><p>CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被<br>攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</p><p>CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</p><p>一般的 CSRF 攻击类型有三种：</p><p>第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提<br>交。</p><p>第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</p><p>第三种是链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</p><p>CSRF 可以用下面几种方法来防护：</p><p>第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。</p><p>第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。</p><p>第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</p><p>第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</p><h3 id="什么是-Samesite-Cookie-属性？"><a href="#什么是-Samesite-Cookie-属性？" class="headerlink" title="什么是 Samesite Cookie 属性？"></a>什么是 Samesite Cookie 属性？</h3><p>Samesite Cookie 表示同站 cookie，避免 cookie 被第三方所利用。</p><p>将 Samesite 设为 strict ，这种称为严格模式，表示这个 cookie 在任何情况下都不可能作为第三方 cookie。</p><p>将 Samesite 设为 Lax ，这种模式称为宽松模式，如果这个请求是个 GET 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie。</p><p>使用这种方法的缺点是，因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都回重新登录。还有一个问题就是它的兼容性不够好。</p><h3 id="什么是点击劫持？如何防范点击劫持？"><a href="#什么是点击劫持？如何防范点击劫持？" class="headerlink" title="什么是点击劫持？如何防范点击劫持？"></a>什么是点击劫持？如何防范点击劫持？</h3><p>点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。</p><p>我们可以在 http 相应头中设置 X-FRAME-OPTIONS 来防御用 iframe 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特定的一些情况才能作为 iframe 来使用。</p><h3 id="SQL-注入攻击？"><a href="#SQL-注入攻击？" class="headerlink" title="SQL 注入攻击？"></a>SQL 注入攻击？</h3><p>SQL 注入攻击指的是攻击者在 HTTP 请求中注入恶意的 SQL 代码，服务器使用参数构建数据库 SQL 命令时，恶意 SQL 被一起构造，破坏原有 SQL 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。</p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS+ES6面试题总结</title>
    <link href="/2022/01/05/JS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/01/05/JS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>总结了最近的一些面试题和之前的知识点</p><hr><h3 id="js种8种数据类型"><a href="#js种8种数据类型" class="headerlink" title="js种8种数据类型"></a>js种8种数据类型</h3><h4 id="六种基本数据类型：undefined-null-number-bollean-string"><a href="#六种基本数据类型：undefined-null-number-bollean-string" class="headerlink" title="六种基本数据类型：undefined,null,number,bollean, string"></a>六种基本数据类型：undefined,null,number,bollean, string</h4><p>还有在 ES6 中新增的 Symbol 和 ES10 中新增的 BigInt 类型。</p><blockquote><p>Symbol 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。<br>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</p></blockquote><h4 id="另一种是复杂数据类型：Object"><a href="#另一种是复杂数据类型：Object" class="headerlink" title="另一种是复杂数据类型：Object"></a>另一种是复杂数据类型：Object</h4><p>js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。<br>复杂数据类型指的是 Object 类型，所有其他的如 Array、Date 等数据类型都可以理解为 Object 类型的子类。</p><h4 id="两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值"><a href="#两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值" class="headerlink" title="两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值"></a>两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值</h4><h3 id="ES6-Object新增的Api"><a href="#ES6-Object新增的Api" class="headerlink" title="ES6 Object新增的Api"></a>ES6 Object新增的Api</h3><p><a href="https://pengzhenglong.github.io/2021/04/13/ES6(%E5%9B%9B)/">博客</a></p><h3 id="js判断类型"><a href="#js判断类型" class="headerlink" title="js判断类型"></a>js判断类型</h3><p>判断方法：typeof()，instanceof，Object.prototype.toString.call()等</p><ol><li>typeof<br>返回数据类型，包含这7种： number、boolean、symbol、string、object、undefined、function。<br>typeof null   返回类型错误，返回object<br>引用类型，除了function返回function类型外，其他均返回object。<br>其中，null 有属于自己的数据类型 Null</li><li>toString 这个是最完美的<br>toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。<br>对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。<strong>而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</strong></li></ol><blockquote><p>原理：<br>在toString方法被调用时,会执行下面的操作步骤:</p></blockquote><ol><li><p>获取this对象的[[Class]]属性的值.</p></li><li><p>计算出三个字符串”[object “, 第一步的操作结果Result(1), 以及 “]”连接后的新字符串.</p></li><li><p>返回第二步的操作结果Result(2).</p></li></ol><p>判断类型举例：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;&#x27;</span>) ;   // [<span class="hljs-keyword">object</span> String]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-number">1</span>) ;    // [<span class="hljs-keyword">object</span> Number]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">true</span>) ; // [<span class="hljs-keyword">object</span> <span class="hljs-type">Boolean</span>]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(Symbol()); //[<span class="hljs-keyword">object</span> Symbol]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(undefined) ; // [<span class="hljs-keyword">object</span> Undefined]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">null</span>) ; // [<span class="hljs-keyword">object</span> <span class="hljs-keyword">Null</span>]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> <span class="hljs-keyword">Function</span>()) ; // [<span class="hljs-keyword">object</span> <span class="hljs-keyword">Function</span>]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>()) ; // [<span class="hljs-keyword">object</span> <span class="hljs-type">Date</span>]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>([]) ; // [<span class="hljs-keyword">object</span> <span class="hljs-keyword">Array</span>]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> RegExp()) ; // [<span class="hljs-keyword">object</span> RegExp]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> Error()) ; // [<span class="hljs-keyword">object</span> Error]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(document) ; // [<span class="hljs-keyword">object</span> HTMLDocument]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">window</span>) ; //[<span class="hljs-keyword">object</span> <span class="hljs-keyword">global</span>] <span class="hljs-keyword">window</span> 是全局对象 <span class="hljs-keyword">global</span> 的引用<br></code></pre></td></tr></table></figure><ol><li>constructor<br>constructor是原型prototype的一个属性，当函数被定义时候，js引擎会为函数添加原型prototype，并且这个prototype中constructor属性指向函数引用， 因此重写prototype会丢失原来的constructor。<br>不过这种方法有问题：<br>1：null 和 undefined 无constructor，这种方法判断不了。<br>2：还有，如果自定义对象，开发者重写prototype之后，原有的constructor会丢失，因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改。</li><li>instanceof<br>instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型，<br><img src="/imageO/instance.jpg" alt="instance"><br> 由上图可以看出[]的原型指向Array.prototype，间接指向Object.prototype, 因此 [] instanceof Array 返回true， [] instanceof Object 也返回true。<br>instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</li></ol><h3 id="如何判断一个对象是数组还是对象"><a href="#如何判断一个对象是数组还是对象" class="headerlink" title="如何判断一个对象是数组还是对象"></a>如何判断一个对象是数组还是对象</h3><p>一、typeof判断数据类型（判断数组跟对象都返回object）<br>二、instanceof判断对象的原型链是否是指向构造函数的prototype</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">　　<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>];<br>　　<span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>三、对象的constructor属性</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">　　<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>];<br>　　console.log(arr.<span class="hljs-keyword">constructor</span> === <span class="hljs-keyword">Array</span>)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>四、Object.prototype.toString.call(arr)<br>　　利用对象的toString可以准确判断是什么类型，call()改变this指向，这里是借用Object的方法，然后有人可能会问为什么不直接用arr.toString而要借用Object的方法，</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(&quot;jerry&quot;));//[<span class="hljs-keyword">object</span> String]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-number">12</span>));//[<span class="hljs-keyword">object</span> Number]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">true</span>));//[<span class="hljs-keyword">object</span> <span class="hljs-type">Boolean</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(undefined));//[<span class="hljs-keyword">object</span> Undefined]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">null</span>));//[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Null</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(&#123;<span class="hljs-type">name</span>: &quot;jerry&quot;&#125;));//[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Object</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">function</span>()&#123;&#125;));//[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Function</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>([]));//[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Array</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>));//[<span class="hljs-keyword">object</span> <span class="hljs-type">Date</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(/\d/));//[<span class="hljs-keyword">object</span> RegExp]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> Person));//[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Object</span>]<br></code></pre></td></tr></table></figure><p>直接用tostring()</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">console.log(<span class="hljs-string">&quot;jerry&quot;</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//jerry</span><br>console.log((<span class="hljs-number">1</span>).<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//1</span><br>console.log(<span class="hljs-literal">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//1,2</span><br>console.log(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//Wed Dec 21 2016 20:35:48 GMT+0800 (中国标准时间)</span><br>console.log(<span class="hljs-keyword">function</span><span class="hljs-literal">()</span>&#123;&#125;.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//function ()&#123;&#125;</span><br>console.log(null.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//error</span><br>console.log(undefined.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure><h4 id="因为toString为Object原型上的方法，而Array、Function都是Object的实例，实例重新改写了原型上的toString方法，不同的对象调用toString方法，调用的是改写之后的方法"><a href="#因为toString为Object原型上的方法，而Array、Function都是Object的实例，实例重新改写了原型上的toString方法，不同的对象调用toString方法，调用的是改写之后的方法" class="headerlink" title="因为toString为Object原型上的方法，而Array、Function都是Object的实例，实例重新改写了原型上的toString方法，不同的对象调用toString方法，调用的是改写之后的方法"></a>因为toString为Object原型上的方法，而Array、Function都是Object的实例，实例重新改写了原型上的toString方法，不同的对象调用toString方法，调用的是改写之后的方法</h4><p>（转成各种类型的字符串），而不会调用Object原型上的toString()方法，因此直接调用不能判断对象类型</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var arr=<span class="hljs-literal">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]</span>;<br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>prototype.has<span class="hljs-constructor">OwnProperty(<span class="hljs-string">&quot;toString&quot;</span>)</span>);<span class="hljs-comment">//true</span><br>console.log(arr.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//1,2,3</span><br>delete <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>prototype.toString;<span class="hljs-comment">//delete操作符可以删除实例属性</span><br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>prototype.has<span class="hljs-constructor">OwnProperty(<span class="hljs-string">&quot;toString&quot;</span>)</span>);<span class="hljs-comment">//false</span><br>console.log(arr.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//&quot;[object Array]&quot;</span><br></code></pre></td></tr></table></figure><p>　我们可以看到，删除实例上的toString方法后调用的是Object原型上的toString()方法，返回对象类型</p><p>五、es6的方法——Array.isArray()</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">　　<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array([])</span> <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>六、看好多博客说用length判断，这个其实不准确</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> obj=&#123;<span class="hljs-selector-tag">a</span>:<span class="hljs-number">1</span>&#125;<br><span class="hljs-selector-tag">var</span> arr = <span class="hljs-selector-attr">[]</span><br>console<span class="hljs-selector-class">.log</span>(obj.length)<span class="hljs-comment">//undefined</span><br>console<span class="hljs-selector-class">.log</span>(arr.length)<span class="hljs-comment">//0</span><br><br>obj<span class="hljs-selector-class">.length</span> = <span class="hljs-number">1</span><br>console<span class="hljs-selector-class">.log</span>(obj.length)<span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><p>对象可以直接添加length这个属性，就无法区分了</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>事件会从最内层的元素开始发生，一直向上传播，直到document对象。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;<br>    &lt;p <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;Click <span class="hljs-keyword">me</span>!&lt;/p&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">div</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">body</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">html</span> -&gt;</span> document<br></code></pre></td></tr></table></figure><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。<br>上面的例子在事件捕获的概念下发生click事件的顺序应该是</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">document</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">html</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">body</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">div</span> -&gt;</span> p<br></code></pre></td></tr></table></figure><h3 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h3><p>addEventListener方法用来为一个特定的元素绑定一个事件处理函数，是JavaScript中的常用方法。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">element.add<span class="hljs-constructor">EventListener(<span class="hljs-params">event</span>, <span class="hljs-params">function</span>, <span class="hljs-params">useCapture</span>)</span><br></code></pre></td></tr></table></figure><p>重点来看看第三个参数useCapture</p><p>true - 事件句柄在捕获阶段执行（即在事件捕获阶段调用处理函数）<br>false- false- 默认。事件句柄在冒泡阶段执行（即表示在事件冒泡的阶段调用事件处理函数）</p><p>所以我们通常来说，默认第三个参数不写的话，是按照事件句柄在冒泡执行的。</p><h4 id="attachEvent"><a href="#attachEvent" class="headerlink" title="attachEvent"></a>attachEvent</h4><p>兼容IE的写法，默认是事件冒泡阶段调用处理函数，写事件名时候要加上”on”前缀（”onload”、”onclick”等）。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">object</span>.attach<span class="hljs-constructor">Event(<span class="hljs-params">event</span>, <span class="hljs-params">function</span>)</span><br></code></pre></td></tr></table></figure><h4 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h4><p>利用事件流的特性，我们可以使用一种叫做事件代理的方法，其实利用的就是事件冒泡的机制。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span>下面的内容是子元素1<br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>li内容&gt;&gt;&gt; <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> 这是span内容123<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        下面的内容是子元素2<br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>li内容&gt;&gt;&gt; <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> 这是span内容123<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        下面的内容是子元素3<br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>li内容&gt;&gt;&gt; <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> 这是span内容123<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>js代码</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stan">xxx.addEventListener(&#x27;click&#x27;, function (<span class="hljs-built_in">e</span>) &#123;<br>            console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">e</span>,<span class="hljs-built_in">e</span>.<span class="hljs-built_in">target</span>)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">e</span>.<span class="hljs-built_in">target</span>.tagName.toLowerCase() === &#x27;li&#x27;) &#123;<br>                console.<span class="hljs-built_in">log</span>(&#x27;打印&#x27;)<br>            &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>更加规范的写法👇</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delegate</span><span class="hljs-params">(element, eventType, selector, fn)</span> &#123;</span><br>          element.addEventListener(eventType, <span class="hljs-keyword">e</span> =&gt; &#123;<br>              <span class="hljs-keyword">let</span> <span class="hljs-keyword">el</span> = <span class="hljs-keyword">e</span>.target<br>              <span class="hljs-keyword">while</span> (!el.matches(selector)) &#123;<br>                  <span class="hljs-keyword">if</span> (element === <span class="hljs-keyword">el</span>) &#123;<br>                      <span class="hljs-keyword">el</span> = null<br>                      <span class="hljs-keyword">break</span><br>                  &#125;<br>                  <span class="hljs-keyword">el</span> = <span class="hljs-keyword">el</span>.parentNode<br>              &#125;<br>              <span class="hljs-keyword">el</span> &amp;&amp; fn.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">el</span>, <span class="hljs-keyword">e</span>, <span class="hljs-keyword">el</span>)<br>          &#125;,true)<br>          <span class="hljs-keyword">return</span> element<br>      &#125;<br></code></pre></td></tr></table></figure><p>阻止事件冒泡和默认事件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">event.preventDefault()   <span class="hljs-regexp">//</span> 阻止默认事件<br>event.stopPropagation() <span class="hljs-regexp">//</span>阻止冒泡<br></code></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/6864398060702760968#heading-19">天天文章</a></p><h3 id="事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3><p>1.事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。<br>2.事件处理机制：IE 支持事件冒泡、Firefox 同时支持两种事件模型，也就是：事件冒泡和事件捕获。<br>3.event.stopPropagation() 或者 ie 下的方法 event.cancelBubble = true;</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/lvdabao/p/3265870.html">《Javascript 事件模型系列（一）事件及事件的三种模型》</a><br><a href="https://blog.csdn.net/wuseyukui/article/details/13771493">《Javascript 事件模型：事件捕获和事件冒泡》</a></p><h3 id="●-数组去重"><a href="#●-数组去重" class="headerlink" title="● 数组去重"></a>● 数组去重</h3><p>法一：indexOf循环去重<br>法二：ES6 Set去重；Array.from(new Set(array))<br>法三：Object 键值对去重；把数组的值存成 Object 的 key 值，比如 Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的。<br><a href="https://juejin.cn/post/6844904121380667399#heading-65">掘金</a></p><h3 id="●-去除字符串首尾空格"><a href="#●-去除字符串首尾空格" class="headerlink" title="● 去除字符串首尾空格"></a>● 去除字符串首尾空格</h3><ol><li>使用正则(^\s*)|(\s*$)即可</li><li>使用jquery</li></ol><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">$.<span class="hljs-keyword">trim</span>(str) <br></code></pre></td></tr></table></figure><h3 id="●-暂停死区"><a href="#●-暂停死区" class="headerlink" title="● 暂停死区"></a>● 暂停死区</h3><p>在代码块内，使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”</p><h3 id="●-数组常用方法-一般方法"><a href="#●-数组常用方法-一般方法" class="headerlink" title="● 数组常用方法(一般方法)"></a>● 数组常用方法(一般方法)</h3><p>push()，pop()，shift()，unshift()，splice()，sort()，reverse()，map()等</p><ol><li>indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。如果没有找到匹配的字符串则返回 -1。</li><li>slice() 截取Array的一部分，返回一个新数组，类似于String中的substring  [)</li><li>push:  压入到尾部        pop:  弹出尾部的一个元素</li><li>unshift  压入到头部           shift    弹出头部的一个元素</li><li>sort() 方法用于对数组的元素进行排序。 排序顺序可以是字母或数字，并按升序或降序。默认排序顺序为按字母升序。</li><li>reverse() 方法用于颠倒数组中元素的顺序。</li><li>concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</li><li>splice() 方法用于添加或删除数组中的元素。注意：这种方法会改变原始数组。</li></ol><h3 id="数组和对象方法（进阶）"><a href="#数组和对象方法（进阶）" class="headerlink" title="数组和对象方法（进阶）"></a>数组和对象方法（进阶）</h3><p>8.数组常用的方法  find  filter(返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组。)  every  some</p><p>9.判断一个数组中有符合我需求的元素用哪个比较合适–indexof    find(返回数组中满足条件的第一个元素的值，如果没有，返回undefined)</p><blockquote><p>如果要返回一个布尔值—   includes  some every<br><a href="https://pengzhenglong.github.io/2022/02/28/Js%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/#JS%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%80%BC">博客</a></p></blockquote><h4 id="遍历一个对象-for-of-Object-key-Object-value-Object-entries"><a href="#遍历一个对象-for-of-Object-key-Object-value-Object-entries" class="headerlink" title="遍历一个对象  for  of   Object.key  Object.value  Object.entries"></a>遍历一个对象  for  of   Object.key  Object.value  Object.entries</h4><p>工作中遍历对象都用for  in 嘛，遍历用的比较多的方法是(有用过forEach嘛)</p><h3 id="for-in和for-of-区别"><a href="#for-in和for-of-区别" class="headerlink" title="for in和for of 区别"></a>for in和for of 区别</h3><h4 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h4><p>我们直接从一段代码来看</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.method=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.length);<br>&#125;<br><span class="hljs-keyword">var</span> myArray=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>myArray.name=<span class="hljs-string">&quot;数组&quot;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> index <span class="hljs-keyword">in</span> myArray) &#123;<br>  <span class="hljs-built_in">console</span>.log(myArray[index]);<br>&#125;<br></code></pre></td></tr></table></figure><p>有哪些缺陷呢👇<br>index获取的是索引<br>遍历的顺序可能不是按照顺序进行的<br>使用for in 会遍历数组所有可枚举属性，包括原型。例如上面的method和name都会遍历</p><blockquote><p>for in 更适合遍历对象，不要使用for in去遍历数组</p></blockquote><h4 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.method=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.length);<br>&#125;<br><span class="hljs-keyword">var</span> myArray=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>myArray.name=<span class="hljs-string">&quot;数组&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> value <span class="hljs-keyword">of</span> myArray) &#123;<br>  <span class="hljs-built_in">console</span>.log(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>for of语法遍历的是数组元素的值<br>for in 遍历的是索引</p><blockquote><p>for of遍历的只是数组内的元素(value)，而不包括数组的原型属性method和索引name</p></blockquote><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li><p>for in 可以遍历一个普通的对象，这样也是它的本质工作，for in<strong>会遍历原型以及可枚举属性</strong>，最好的情况下，使用hasOwnProperty判断是不是实例属性。</p></li><li><p>for..of<strong>适用遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合，不能遍历对象</strong>，因为没有迭代对象，与forEach()不同的是，它可以正确响应break、continue和return语句。</p></li></ol><h4 id="如何使用for-of-循环遍历对象-给对象添加迭代器"><a href="#如何使用for-of-循环遍历对象-给对象添加迭代器" class="headerlink" title="如何使用for of 循环遍历对象(给对象添加迭代器)"></a>如何使用for of 循环遍历对象(给对象添加迭代器)</h4><ol><li>类数组对象<br>如果对象是一个类数组对象，那好办，用Array.from转成数组即可。</li><li>非类数组对象<br>如果不是类数组对象，也有办法，添加一个[Symbol.iterator]属性，并指向一个迭代器即可。<br>Object.keys/Object.values/Object.entries</li></ol><h4 id="forEach（数组方法）首先forEach是不能使用任何手段跳出循环的"><a href="#forEach（数组方法）首先forEach是不能使用任何手段跳出循环的" class="headerlink" title="forEach（数组方法）首先forEach是不能使用任何手段跳出循环的"></a>forEach（数组方法）首先forEach是不能使用任何手段跳出循环的</h4><p>特性：</p><p>便利的时候更加简洁，效率和for循环相同，不用关心集合下标的问题，减少了出错的概率。<br>没有返回值<br>不能使用break中断循环，不能使用return返回到外层函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">实例：<br><span class="hljs-keyword">let</span> newarr=arr.forEach(<span class="hljs-function"><span class="hljs-params">i</span>=&gt;</span>&#123;<br> i+=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">console</span>.log(i);<span class="hljs-comment">//2,4,5</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(arr)<span class="hljs-comment">//[1,3,4]</span><br><span class="hljs-built_in">console</span>.log(newarr)<span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure><p>注意：</p><ol><li>forEach() 对于空数组是不会执行回调函数的。</li><li>for可以用continue跳过循环中的一个迭代，forEach用continue会报错。</li><li>forEach() 需要用 return 跳过循环中的一个迭代，跳过之后会执行下一个迭代。</li></ol><h4 id="任何数据结构只要部署-Iterator-接口，就可以完成遍历操作，即依次处理该数据结构的所有成员"><a href="#任何数据结构只要部署-Iterator-接口，就可以完成遍历操作，即依次处理该数据结构的所有成员" class="headerlink" title="任何数据结构只要部署 Iterator 接口，就可以完成遍历操作，即依次处理该数据结构的所有成员"></a>任何数据结构只要部署 Iterator 接口，就可以完成遍历操作，即依次处理该数据结构的所有成员</h4><p>迭代器本质<br>迭代器对象本质上，就是一个指针对象。通过指针对象的next()，用来移动指针。</p><p>【迭代器协议】对象必须提供一个next()，执行该方法要么返回迭代中的下一项，要么就引起一个Stopiteration异常，以终止迭代。</p><p>next()返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性，value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next()。对于遍历器对象来说，done: false和value: undefined属性都是可以省略的。</p><p>ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性上。</p><p>实现Iterator接口的原生对象<br>原生具备 Iterator 接口的数据结构如下。</p><p>Array<br>Map<br>Set<br>String<br>TypedArray<br>函数的 arguments 对象<br>NodeList 对象</p><h5 id="如何判断一个类型是不是可迭代对象"><a href="#如何判断一个类型是不是可迭代对象" class="headerlink" title="如何判断一个类型是不是可迭代对象"></a>如何判断一个类型是不是可迭代对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> someString = <span class="hljs-string">&quot;hi&quot;</span>;<br><span class="hljs-keyword">typeof</span> someString[<span class="hljs-built_in">Symbol</span>.iterator];          <span class="hljs-comment">// &quot;function&quot;</span><br></code></pre></td></tr></table></figure><p>结论</p><p>常见的可迭代对象，有Array，Map, Set, String,TypeArray, arguments<br>可以通过判断Symbol.iterator判断当前变量是否是可迭代对象</p><h3 id="JS判断数组中是否包含某个值-amp-amp-JS如何实现数组扁平化？"><a href="#JS判断数组中是否包含某个值-amp-amp-JS如何实现数组扁平化？" class="headerlink" title="JS判断数组中是否包含某个值&amp;&amp;JS如何实现数组扁平化？"></a>JS判断数组中是否包含某个值&amp;&amp;JS如何实现数组扁平化？</h3><p><a href="https://pengzhenglong.github.io/2022/02/28/Js%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/">博客地址</a></p><h3 id="比较运算符！！！重要"><a href="#比较运算符！！！重要" class="headerlink" title="比较运算符！！！重要"></a>比较运算符！！！重要</h3><p>=    赋值<br>==   等于(类型不一样，值一样，也会判断为true)<br>===   绝对等于 (类型一样，值一样，结果为true)</p><h4 id="Object-is-使用过吗？跟-和-区别"><a href="#Object-is-使用过吗？跟-和-区别" class="headerlink" title="Object.is()使用过吗？跟 === 和 == 区别"></a>Object.is()使用过吗？跟 === 和 == 区别</h4><p>两等号判等，会在比较时进行类型转换。<br>三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回false）<br>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。</p><h3 id="get-和-post-请求在缓存方面的区别"><a href="#get-和-post-请求在缓存方面的区别" class="headerlink" title="get 和 post 请求在缓存方面的区别"></a>get 和 post 请求在缓存方面的区别</h3><p>相关知识点：<br>get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。<br>post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 get 请求适合于请求缓存。</p><p>回答：<br>缓存一般只适用于那些不会更新服务端数据的请求。一般 get 请求都是查找请求，不会对服务器资源数据造成修改</p><h4 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h4><p>GET请求的数据会附加在URL之后，用问号分割，多个参数用&amp;进行连接。<br>GET请求的数据会暴露在地址栏中。<br>GET请求URL的编码格式采用的是ASCII编码，而不是Unicode编码。<br>GET请求传输大小有限制，大小在2KB。<br>GET相对安全性较差，会被浏览器主动缓存。<br>GET产生一个TCP数据包，head和data一起发送。<br>GET浏览器回退无害。</p><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>POST请求会把数据放置在HTTP请求包的包体中，不会直接暴露给用户。<br>POST请求，理论上大小是不会限制的，但是实际上各个服务器会规定POST提交数据大小。<br>POST相对Get更安全，因为参数不会保存浏览器立式或者是web服务器日志中。<br>POST产生两个TCP数据包，header先发送，服务器响应100ms然后继续，发送data，服务器200然后返回数据。<br>POST浏览器回退重新请求。<br>其他http方法</p><h3 id="什么是-DOM-和-BOM？"><a href="#什么是-DOM-和-BOM？" class="headerlink" title="什么是 DOM 和 BOM？"></a>什么是 DOM 和 BOM？</h3><p>DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</p><p>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。<br>BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。<br><a href="https://pengzhenglong.github.io/2021/04/06/Javascript%E5%85%A5%E9%97%A8(%E4%BA%94)/#%E6%93%8D%E4%BD%9CBOM%E5%AF%B9%E8%B1%A1-%E9%87%8D%E7%82%B9">博客：</a></p><h3 id="操作符的作用？"><a href="#操作符的作用？" class="headerlink" title="~ 操作符的作用？"></a>~ 操作符的作用？</h3><p>~ 返回 2 的补码，并且 ~ 会将数字转换为 32 位整数，因此我们可以使用 ~ 来进行取整操作。</p><p>~x 大致等同于 -(x+1)。</p><h3 id="和-的-valueOf-和-toString-的结果是什么？"><a href="#和-的-valueOf-和-toString-的结果是什么？" class="headerlink" title="{} 和 [] 的 valueOf 和 toString 的结果是什么？"></a>{} 和 [] 的 valueOf 和 toString 的结果是什么？</h3><p>{} 的 valueOf 结果为 {} ，toString 的结果为 “[object Object]”</p><p>[] 的 valueOf 结果为 [] ，toString 的结果为 “”</p><h3 id="mouseover和mouseenter的区别"><a href="#mouseover和mouseenter的区别" class="headerlink" title="mouseover和mouseenter的区别"></a>mouseover和mouseenter的区别</h3><p>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout<br>mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave</p><h3 id="图片的懒加载和预加载"><a href="#图片的懒加载和预加载" class="headerlink" title="图片的懒加载和预加载"></a>图片的懒加载和预加载</h3><p>懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。<br>原理<br><strong>将页面中的img标签src指向一张小图片或者字符串，然后定义data-src（这个属性可以自定义命名，我才用data-src）属性指向真实的图片。src指向一张默认的图片，否则当src为空时也会向服务器发送一次请求。可以指向loading的地址。</strong></p><p>预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。<br>实现预加载的几种办法(使用HTML标签:display:none,使用Image对象)</p><p>这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p><h3 id="防止表单重复提交的解决方案-amp-amp-实现图片懒加载-amp-amp-预加载"><a href="#防止表单重复提交的解决方案-amp-amp-实现图片懒加载-amp-amp-预加载" class="headerlink" title="防止表单重复提交的解决方案&amp;&amp;实现图片懒加载&amp;&amp;预加载"></a>防止表单重复提交的解决方案&amp;&amp;实现图片懒加载&amp;&amp;预加载</h3><p><a href="https://pengzhenglong.github.io/2022/02/26/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/">博客地址</a></p><h3 id="防抖-amp-amp-节流"><a href="#防抖-amp-amp-节流" class="headerlink" title="防抖&amp;&amp;节流"></a>防抖&amp;&amp;节流</h3><h4 id="介绍节流防抖原理、区别以及应用"><a href="#介绍节流防抖原理、区别以及应用" class="headerlink" title="介绍节流防抖原理、区别以及应用"></a>介绍节流防抖原理、区别以及应用</h4><h5 id="防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如-1-秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待-1-秒，直到能最终执行"><a href="#防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如-1-秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待-1-秒，直到能最终执行" class="headerlink" title="防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行"></a>防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行</h5><h5 id="节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次"><a href="#节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次" class="headerlink" title="节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次"></a>节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次</h5><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>防抖：搜索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染。<br>节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……<br><a href="https://pengzhenglong.github.io/2021/05/16/JS&%E9%98%B2%E6%8A%96&%E8%8A%82%E6%B5%81/">函数的防抖与节流 _</a></p><h3 id="如何解决异步回调地狱-异步编程的实现方式？"><a href="#如何解决异步回调地狱-异步编程的实现方式？" class="headerlink" title="如何解决异步回调地狱||  异步编程的实现方式？"></a>如何解决异步回调地狱||  异步编程的实现方式？</h3><p>promise、generator、async/await</p><p>回答：<br>js 中的异步机制可以分为以下几种：</p><ol><li><p>第一种最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</p></li><li><p>第二种是 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</p></li><li><p>第三种是使用 generator 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来。当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。因此我们在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</p></li><li><p>第四种是使用 async 函数的形式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候， <strong>如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行</strong>。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。<br><a href="https://pengzhenglong.github.io/2021/05/11/Es6async&await/">博客：</a></p></li></ol><h3 id="promise-generotor-await-await后面接收的是什么"><a href="#promise-generotor-await-await后面接收的是什么" class="headerlink" title="promise  /generotor /await  (await后面接收的是什么)"></a>promise  /generotor /await  (await后面接收的是什么)</h3><p>正常情况下，async中的await命令是一个Promise对象，返回该对象的结果。<br>但如果不是Promise对象的话，就会直接返回对应的值，相当于Promise.resolve()<br>如果在async函数中抛出了错误，则终止错误结果，不会继续向下执行。</p><h4 id="then方法为什么可以链式调用"><a href="#then方法为什么可以链式调用" class="headerlink" title="then方法为什么可以链式调用"></a>then方法为什么可以链式调用</h4><p>Promise可以链式调用，不过promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用, 它并不像一般我们任务的链式调用一样return this。</p><h3 id="Promise、Promise-all、Promise-race-分别怎么用？"><a href="#Promise、Promise-all、Promise-race-分别怎么用？" class="headerlink" title="Promise、Promise.all、Promise.race 分别怎么用？"></a>Promise、Promise.all、Promise.race 分别怎么用？</h3><p>Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。<br>Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。<br>语法：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim">new <span class="hljs-type">Promise</span>( function(resolve, reject) <span class="hljs-meta">&#123;...&#125;</span>);<br></code></pre></td></tr></table></figure><p>状态的缺点<br>无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。</p><p>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</p><p>当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><h4 id="then-方法"><a href="#then-方法" class="headerlink" title="then 方法"></a>then 方法</h4><p>then 方法接收两个函数作为参数，第一个参数是 Promise 执行成功时的回调，第二个参数是 Promise 执行失败时的回调，两个函数只会有一个被调用。</p><h5 id="then-方法的特点"><a href="#then-方法的特点" class="headerlink" title="then 方法的特点"></a>then 方法的特点</h5><p>在 JavaScript 事件队列的当前运行完成之前，回调函数永远不会被调用。</p><p>then 方法将返回一个 resolved 或 rejected 状态的 Promise 对象用于链式调用，且 Promise 对象的值就是这个返回值。</p><h4 id="then-方法的特点-1"><a href="#then-方法的特点-1" class="headerlink" title="then 方法的特点"></a>then 方法的特点</h4><p>在 JavaScript 事件队列的当前运行完成之前，回调函数永远不会被调用。</p><h5 id="then-方法注意点"><a href="#then-方法注意点" class="headerlink" title="then 方法注意点"></a>then 方法注意点</h5><p>简便的 Promise 链式编程最好保持扁平化，不要嵌套 Promise。</p><p>注意总是返回或终止 Promise 链。</p><h4 id="Promise-all方法"><a href="#Promise-all方法" class="headerlink" title="Promise.all方法"></a>Promise.all方法</h4><p>简而言之：Promise.all( ).then( )适用于处理多个异步任务，且所有的异步任务都得到结果时的情况。</p><blockquote><p>promise1和promise2都成功才会调用success1<br>比如：用户点击按钮，会弹出一个弹出对话框，对话框中有两部分数据呈现，这两部分数据分别是不同的后端接口获取的数据。<br>弹框弹出后的初始情况下，就让这个弹出框处于数据加载中的状态，当这两部分数据都从接口获取到的时候，才让这个数据加载中状态消失。让用户看到这两部分的数据。</p></blockquote><h4 id="Promise-race方法"><a href="#Promise-race方法" class="headerlink" title="Promise.race方法"></a>Promise.race方法</h4><p>Promise.race赛跑机制，只认第一名</p><blockquote><p>promise1和promise2只要有一个成功就会调用success1<br>Promise.race其实使用的并不多，如果真要使用。我们可以提出这样一个需求：<br><strong>比如：点击按钮发请求，当后端的接口超过一定时间，假设超过三秒，没有返回结果，我们就提示用户请求超时</strong></p></blockquote><h4 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h4><p>Promise.allSettled(promises) 允许您并行执行互相独立的promise, 并每一个promise执行之后的状态（已完成或拒绝）存放在数组中。</p><p>当您需要执行并行和独立的异步操作并获取到异步操作的所有结果时，Promise.allSettled(…) 非常有用，即使某些异步操作可能会失败。</p><p><a href="https://pengzhenglong.github.io/2021/04/17/ES6(promise)/#Promise-all">博客</a><br><a href="https://juejin.cn/post/6998891444312211492#heading-4">博客</a></p><h3 id="js-延迟加载的方式有哪些？"><a href="#js-延迟加载的方式有哪些？" class="headerlink" title="js 延迟加载的方式有哪些？"></a>js 延迟加载的方式有哪些？</h3><p>相关知识点：</p><h5 id="js-延迟加载，也就是等页面加载完成之后再加载-JavaScript-文件。-js-延迟加载有助于提高页面加载速度"><a href="#js-延迟加载，也就是等页面加载完成之后再加载-JavaScript-文件。-js-延迟加载有助于提高页面加载速度" class="headerlink" title="js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度"></a>js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度</h5><p>一般有以下几种方式：<br>defer 属性<br>async 属性<br>动态创建 DOM 方式<br>使用 setTimeout 延迟方法<br>让 JS 最后加载</p><p>js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。<br>我了解到的几种方式是：</p><ol><li><p>第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</p></li><li><p>第二种方式是给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</p></li><li><p>第三种方式是给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</p></li><li><p>第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</p></li></ol><h3 id="JavaScript-原型，原型链？-有什么特点？"><a href="#JavaScript-原型，原型链？-有什么特点？" class="headerlink" title="JavaScript 原型，原型链？ 有什么特点？"></a>JavaScript 原型，原型链？ 有什么特点？</h3><p>在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。</p><p>当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。</p><p>一般来说我们是不应该能够获取到这个值的，但是现在浏览器中都实现了<code>__proto__</code>属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对象的原型。</p><p>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是我们新建的对象为什么能够使用 toString() 等方法的原因。</p><p>特点：<br>JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。<br><img src="/imageO/YX.jpg" alt="原型链"></p><h3 id="js-获取原型的方法？"><a href="#js-获取原型的方法？" class="headerlink" title="js 获取原型的方法？"></a>js 获取原型的方法？</h3><p>p.<code>__proto__</code><br>p.constructor.prototype<br>Object.getPrototypeOf(p)</p><h3 id="闭包是什么？有什么优点和缺点？"><a href="#闭包是什么？有什么优点和缺点？" class="headerlink" title="闭包是什么？有什么优点和缺点？"></a>闭包是什么？有什么优点和缺点？</h3><p> 解答：闭包是指有权访问另一个函数作用域中的变量的函数。<br>  优点：① 能够读取函数内部的变量；②让这些变量一直存在于内存中，不会在调用结束后被垃圾回收机制回收；<br>  缺点：由于闭包会使用函数中的变量存在在内存中，内存消耗很大，所以不能滥用闭包；解决的办法是退出函数之前，将不使用的局部变量删除；<br><a href="https://pengzhenglong.github.io/2021/04/26/JS%E9%97%AD%E5%8C%85%E7%90%86%E8%A7%A3/">博客：</a></p><h3 id="This"><a href="#This" class="headerlink" title="This"></a>This</h3><p>谈一谈你对this的理解，以及在各种环境下的this<br>在浏览器里，在全局范围内this指向window对象<br>在函数中，this永远指向最后调用他的那个对象(箭头函数除外)。<br>在构造函数中，this指向new出来的新对象。<br>call、apply、bind中的this被强绑定在指定的那个对象上。<br>箭头函数this为父作用域的this，不是调用时的this。<br><a href="https://pengzhenglong.github.io/2021/05/12/JS&this%E6%8C%87%E5%90%91/">博客：</a></p><h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><p>本篇我们重点比较一下箭头函数与普通函数。<br>主要区别包括：</p><h4 id="没有-this"><a href="#没有-this" class="headerlink" title="没有 this"></a>没有 this</h4><p>箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。<br>这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this。</p><h4 id="1-箭头函数this为父作用域的this，不是调用时的this"><a href="#1-箭头函数this为父作用域的this，不是调用时的this" class="headerlink" title="1.箭头函数this为父作用域的this，不是调用时的this"></a>1.箭头函数this为父作用域的this，不是调用时的this</h4><p><img src="/imageO/JTHS.jpg" alt="this"><br>箭头函数的this永远指向其父作用域，任何方法都改变不了，包括call，apply，bind。</p><p>普通函数的this指向调用它的那个对象。</p><blockquote><p>上例中，init为箭头函数，其内部的this为全局window，onclick的this也就是init函数的this，也是window，得到的this.name就为undefined。</p></blockquote><h4 id="没有-arguments"><a href="#没有-arguments" class="headerlink" title="没有 arguments"></a>没有 arguments</h4><p>箭头函数没有自己的 arguments 对象，这不一定是件坏事，因为箭头函数可以访问外围函数的 arguments 对象：<br>那如果我们就是要访问箭头函数的参数呢？<br>你可以通过命名参数或者 rest 参数的形式访问参数:<br>let nums = (…nums) =&gt; nums;</p><h4 id="不能通过-new-关键字调用"><a href="#不能通过-new-关键字调用" class="headerlink" title="不能通过 new 关键字调用"></a>不能通过 new 关键字调用</h4><p>JavaScript 函数有两个内部方法：[[Call]] 和 [[Construct]]。</p><p>当通过 new 调用函数时，执行 [[Construct]] 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。</p><p>当直接调用的时候，执行 [[Call]] 方法，直接执行函数体。</p><p>箭头函数并没有 [[Construct]] 方法，不能被用作构造函数，如果通过 new 的方式调用，会报错。</p><p>var Foo = () =&gt; {};<br>var foo = new Foo(); // TypeError: Foo is not a constructor</p><h4 id="没有-new-target"><a href="#没有-new-target" class="headerlink" title="没有 new.target"></a>没有 new.target</h4><p>因为不能使用 new 调用，所以也没有 new.target 值。</p><p>关于 new.target，可以参考 <a href="https://es6.ruanyifeng.com/#docs/class#new-target-%E5%B1%9E%E6%80%A7">es6</a></p><h4 id="没有原型"><a href="#没有原型" class="headerlink" title="没有原型"></a>没有原型</h4><p>由于不能使用 new 调用箭头函数，所以也没有构建原型的需求，于是箭头函数也不存在 prototype 这个属性。</p><p>var Foo = () =&gt; {};<br>console.log(Foo.prototype); // undefined</p><h4 id="没有-super"><a href="#没有-super" class="headerlink" title="没有 super"></a>没有 super</h4><p>连原型都没有，自然也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的，不过跟 this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。</p><h4 id="箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或-new-target。这些函数表达式最适合用于非方法函数-non-method-functions-，并且它们不能用作构造函数"><a href="#箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或-new-target。这些函数表达式最适合用于非方法函数-non-method-functions-，并且它们不能用作构造函数" class="headerlink" title="箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数(non-method functions)，并且它们不能用作构造函数"></a>箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数(non-method functions)，并且它们不能用作构造函数</h4><p><a href="https://juejin.cn/post/6844903616231260174#heading-4">参考文章</a></p><h3 id="call-和-apply-的区别？"><a href="#call-和-apply-的区别？" class="headerlink" title="call() 和 .apply() 的区别？"></a>call() 和 .apply() 的区别？</h3><ol><li>它们的作用一模一样，区别仅在于传入参数的形式的不同。</li><li>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li></ol><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Function.call(obj,<span class="hljs-comment">[param1<span class="hljs-comment">[,param2<span class="hljs-comment">[,…<span class="hljs-comment">[,paramN]</span>]</span>]</span>]</span>)<br></code></pre></td></tr></table></figure><ol start="3"><li><p>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</p></li><li><p>bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。</p></li></ol><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl">function add (a, b) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br>function <span class="hljs-function"><span class="hljs-keyword">sub</span> (<span class="hljs-title">a</span>, <span class="hljs-title">b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a - b;<br>&#125;<br>add.bind(<span class="hljs-function"><span class="hljs-keyword">sub</span>, 5, 3)</span>; // 这时，并不会返回 <span class="hljs-number">8</span><br>add.bind(<span class="hljs-function"><span class="hljs-keyword">sub</span>, 5, 3)</span>(); // 调用后，返回 <span class="hljs-number">8</span><br><br></code></pre></td></tr></table></figure><p><a href="https://pengzhenglong.github.io/2021/05/14/Js&call&apply&bind/">博客：</a></p><h3 id="typeof-NaN-的结果是什么？"><a href="#typeof-NaN-的结果是什么？" class="headerlink" title="typeof NaN 的结果是什么？"></a>typeof NaN 的结果是什么？</h3><p>NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出<br>数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">typeof NaN; <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;number&quot;</span><br></code></pre></td></tr></table></figure><p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN<br>为 true。</p><h3 id="null是对象吗？为什么？"><a href="#null是对象吗？为什么？" class="headerlink" title="null是对象吗？为什么？"></a>null是对象吗？为什么？</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">typeof 运算符对基本数据类型的运算：<br>typeof <span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;string&#x27;</span><br>typeof NaN <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;number&#x27;</span><br>typeof <span class="hljs-number">1</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;number&#x27;</span><br>typeof true <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;boolean&#x27;</span><br>typeof undefined <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;undefined&#x27;</span><br>typeof Symbol() <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;symbol&#x27;</span><br>typeof null <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;object&#x27;</span><br></code></pre></td></tr></table></figure><p>结论: null不是对象。</p><p>解释: 虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。<br>在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存</p><h3 id="null和undefined的区别"><a href="#null和undefined的区别" class="headerlink" title="null和undefined的区别"></a>null和undefined的区别</h3><p><a href="https://juejin.cn/post/6912298148098473998#comment">null和undefined的区别（简单易懂）</a><br>null==undefined结果为true<br>null===undefined结果为false</p><h3 id="JavaScript-有几种类型的值？你能画一下他们的内存图吗？"><a href="#JavaScript-有几种类型的值？你能画一下他们的内存图吗？" class="headerlink" title="JavaScript 有几种类型的值？你能画一下他们的内存图吗？"></a>JavaScript 有几种类型的值？你能画一下他们的内存图吗？</h3><p>js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。</p><p>基本数据类型….（参考1）</p><p>复杂数据类型指的是   Object   类型，所有其他的如 Array、Date 等数据类型都可以理解为 Object 类型的子类。</p><p>两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中<br>保存对应的指针来获取堆中的值。</p><h3 id="0-1-0-2为什么不等于0-3？"><a href="#0-1-0-2为什么不等于0-3？" class="headerlink" title="0.1+0.2为什么不等于0.3？"></a>0.1+0.2为什么不等于0.3？</h3><p>当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。</p><p>对于这样的情况，<strong>我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数</strong>，以这种方式来解决这个问题。<br>(toPrecision vs toFixed  –toPrecision 是处理精度，精度是从左至右第一个不为0的数开始数起。<br>–toFixed 是小数点后指定位数取整，从小数点开始数起。)</p><p>我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以<br>使用 es6 的 Number.EPSILON</p><h3 id="setTimeout输出值的时候，如何实现i按序输出？"><a href="#setTimeout输出值的时候，如何实现i按序输出？" class="headerlink" title="setTimeout输出值的时候，如何实现i按序输出？"></a>setTimeout输出值的时候，如何实现i按序输出？</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br>//<span class="hljs-number">55555</span><br></code></pre></td></tr></table></figure><p>这道题挺经典的，输出结果是什么呢？结果是1000毫秒之后，输出5个5（隔一秒输出在1000上乘个i就行）<br><strong>原因是，for循环在主线程内，setTimeout是异步方法，在任务队列里面，只有主线程执行完后，任务队列才执行，此时i的值已经是5，所以得到结果是5个5</strong></p><p>那么怎么解决呢？其实思路很容易，只要每次循环把当前的i值传入setTimeout内即可</p><h4 id="方法1：使用let"><a href="#方法1：使用let" class="headerlink" title="方法1：使用let"></a>方法1：使用let</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br>//<span class="hljs-number">01234</span><br></code></pre></td></tr></table></figure><p>使用let 相当于每次循环的时候都新建了1个i并为其赋值</p><p>这是因为第一个代码块中setTimeout 的 console.log(i); 的i是 var 定义的，所以是函数级的作用域，不属于 for 循环体，属于 全局变量。等到 for 循环结束，i 已经等于 5 了，这个时候再执行 setTimeout 的五个回调函数（参考上面对事件机制的阐述），里面的 console.log(i); 的 i 去向上找作用域，只能找到 全局作用下 的 i，即 5。所以输出都是 5。</p><p>而let是代码块的作用域，即是局部变量，所以每一次 for 循环，console.log(i); 都引用到 for 代码块作用域下的i，因为这样被引用，所以 for 循环结束后，这些作用域在 setTimeout 未执行前都不会被释放。</p><h4 id="方法2：定义函数并传值"><a href="#方法2：定义函数并传值" class="headerlink" title="方法2：定义函数并传值"></a>方法2：定义函数并传值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params">i</span>) </span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(i)<br>        &#125;, <span class="hljs-number">1000</span>);        <br>    &#125;<br>    a(i)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法3：IIFE（立即执行函数）"><a href="#方法3：IIFE（立即执行函数）" class="headerlink" title="方法3：IIFE（立即执行函数）"></a>方法3：IIFE（立即执行函数）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    ~<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) </span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(i)<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;(i)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>MDN<br>IIFE（立即调用函数表达式）<br>IIFE（ 立即调用函数表达式）是一个在定义时就会立即执行的  JavaScript 函数。</p></blockquote><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name">function</span> () &#123;<br>    statements<br>&#125;)()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这是一个被称为 自执行匿名函数 的设计模式，主要包含两部分。第一部分是包围在 圆括号运算符 () 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。</p><p>第二部分再一次使用 () 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。</p><h4 id="方法4：使用闭包"><a href="#方法4：使用闭包" class="headerlink" title="方法4：使用闭包"></a>方法4：使用闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<br>        (<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span><br>            () =&gt; <span class="hljs-built_in">console</span>.log(i)<br>        )(i), <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法5：setTimeout第三个参数传入i-是的，你没看错，setTimeout还有第三个参数"><a href="#方法5：setTimeout第三个参数传入i-是的，你没看错，setTimeout还有第三个参数" class="headerlink" title="方法5：setTimeout第三个参数传入i(是的，你没看错，setTimeout还有第三个参数)"></a>方法5：setTimeout第三个参数传入i(是的，你没看错，setTimeout还有第三个参数)</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">for</span> (var i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">(i)</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(i),<span class="hljs-number">1000</span>,i);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><h4 id="匿名函数的作用"><a href="#匿名函数的作用" class="headerlink" title="匿名函数的作用"></a>匿名函数的作用</h4><p>1、通过匿名函数可以实现闭包（必须掌握的知识点）</p><p>2、模拟块级作用域，减少全局变量。执行完匿名函数，存储在内存中相对应的变量会被销毁，使用块级作用域，会大大降低命名冲突的问题，不必担心搞乱全局作用域了。</p><h4 id="正确定义的匿名函数"><a href="#正确定义的匿名函数" class="headerlink" title="正确定义的匿名函数"></a>正确定义的匿名函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 由于没有执行该匿名函数，所以不会执行匿名函数体内的语句。</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;zxx&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="小括号的作用"><a href="#小括号的作用" class="headerlink" title="小括号的作用"></a>小括号的作用</h4><p>小括号能把我们的表达式组合分块，并且每一块，也就是每一对小括号，都有一个返回值。这个返回值实际上也就是小括号中表达式的返回值。所以，当我们用一对小括号把匿名函数括起来的时候，实际上小括号返回的就是一个匿名函数的Function对象。因此，小括号对加上匿名函数就如同有名字的函数般被我们取得它的引用位置了。所以如果在这个引用变量后面再加上参数列表，就会实现普通函数的调用形式。 通俗点讲就是，加入小括号后就实现了和具名函数一样的形式</p><p><a href="https://juejin.cn/post/6844903962257129485">详解JavaScript的匿名函数（面试重点）</a></p><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>相关资料：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 浅拷贝的实现;</span><br><br><span class="hljs-keyword">function</span> shallow<span class="hljs-constructor">Copy(<span class="hljs-params">object</span>)</span> &#123;<br> <span class="hljs-comment">// 只拷贝对象</span><br> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">object</span><span class="hljs-operator"> || </span>typeof <span class="hljs-keyword">object</span> !== <span class="hljs-string">&quot;object&quot;</span>) return;<br><br> <span class="hljs-comment">// 根据 object 的类型判断是新建一个数组还是对象</span><br> <span class="hljs-keyword">let</span> newObject = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">object</span>)</span> ? <span class="hljs-literal">[]</span> : &#123;&#125;;<br><br> <span class="hljs-comment">// 遍历 object，并且判断是 object 的属性才拷贝</span><br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">object</span>) &#123;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">object</span>.has<span class="hljs-constructor">OwnProperty(<span class="hljs-params">key</span>)</span>) &#123;<br>      newObject<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> = <span class="hljs-keyword">object</span><span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span>;<br>    &#125;<br>  &#125;<br><br> return newObject;<br>&#125;<br><br><span class="hljs-comment">// 深拷贝的实现;</span><br><br><span class="hljs-keyword">function</span> deep<span class="hljs-constructor">Copy(<span class="hljs-params">object</span>)</span> &#123;<br> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">object</span><span class="hljs-operator"> || </span>typeof <span class="hljs-keyword">object</span> !== <span class="hljs-string">&quot;object&quot;</span>) return <span class="hljs-keyword">object</span>;<br><br> <span class="hljs-keyword">let</span> newObject = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">object</span>)</span> ? <span class="hljs-literal">[]</span> : &#123;&#125;;<br><br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">object</span>) &#123;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">object</span>.has<span class="hljs-constructor">OwnProperty(<span class="hljs-params">key</span>)</span>) &#123;<br>      newObject<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> = deep<span class="hljs-constructor">Copy(<span class="hljs-params">object</span>[<span class="hljs-params">key</span>])</span>;<br>    &#125;<br>  &#125;<br><br> return newObject;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>JS的基本类型不存在浅拷贝还是深拷贝的问题,深拷贝与浅拷贝的概念只存在于引用类型。</li><li>对于仅仅是复制了引用（地址），换句话说，复制了之后，原来的变量和新的变量指向同一个东西，彼此之间的操作会互相影响，为 浅拷贝。而如果是在堆中重新分配内存，拥有不同的地址，但是值是一样的，复制后的对象与原来的对象是完全隔离，互不影响，为 深拷贝。</li><li>深浅拷贝 的主要区别就是：复制的是引用(地址)还是复制的是实例。</li></ol><p>浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用 Object.assign 和展开运算符来实现。</p><p>深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。<br><a href="https://pengzhenglong.github.io/2021/04/17/javascript%20%E5%85%B3%E4%BA%8E%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/#%E4%BE%8B">博客：</a></p><h3 id="slice-和-concat"><a href="#slice-和-concat" class="headerlink" title="slice 和 concat"></a>slice 和 concat</h3><p>Array 的 slice 和 concat 方法 和 jQuery 中的 extend 复制方法，他们都会复制第一层的值，对于 第一层 的值都是 深拷贝，而到 第二层 的时候 Array 的 slice 和 concat 方法就是 复制引用 ，jQuery 中的 extend 复制方法 则 取决于 你的 第一个参数， 也就是是否进行递归复制。所谓第一层 就是 key 所对应的 value 值是基本数据类型，也就像上面栗子中的name、age，而对于 value 值是引用类型 则为第二层，也就像上面栗子中的 company。</p><h3 id="new-操作符具体干了什么呢？如何实现？"><a href="#new-操作符具体干了什么呢？如何实现？" class="headerlink" title="new 操作符具体干了什么呢？如何实现？"></a>new 操作符具体干了什么呢？如何实现？</h3><p>// （1）首先创建了一个新的空对象<br>// （2）设置原型，将对象的原型设置为函数的 prototype 对象。<br>// （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）<br>// （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p><p>new共经历了四个过程。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><br><span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; &#125;;<br><span class="hljs-keyword">var</span> fnObj = <span class="hljs-keyword">new</span> fn();<br><br><span class="hljs-number">1</span>、创建了一个空对象<br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br><br><span class="hljs-number">2</span>、设置原型链<br>obj._proto_ = fn.prototype;<br><br><span class="hljs-number">3</span>、让fn的<span class="hljs-built_in">this</span>指向obj，并执行fn的函数体<br><br><span class="hljs-keyword">var</span> result = fn.call(obj);<br><br><span class="hljs-number">4</span>、判断fn的返回值类型，如果是值类型，返回obj。如果是引用类型，就返回这个引用类型的对象。<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(result) == <span class="hljs-string">&quot;object&quot;</span>)&#123;      fnObj = result;  &#125; <span class="hljs-keyword">else</span> &#123;      fnObj = obj;&#125;  <br><br><span class="hljs-comment">// 实现:</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFactory</span>(<span class="hljs-params"></span>) </span>&#123;<br> <span class="hljs-keyword">let</span> newObject = <span class="hljs-literal">null</span>,<br>    <span class="hljs-title">constructor</span> = <span class="hljs-title">Array</span>.<span class="hljs-title">prototype</span>.<span class="hljs-title">shift</span>.<span class="hljs-title">call</span>(<span class="hljs-params"><span class="hljs-built_in">arguments</span></span>),<br>    <span class="hljs-title">result</span> = <span class="hljs-title">null</span>;<br><br> <span class="hljs-comment">// 参数判断</span><br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title">constructor</span> !== &quot;<span class="hljs-title">function</span>&quot;) &#123;<br> <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;type error&quot;</span>);<br> <span class="hljs-keyword">return</span>;<br>  &#125;<br><br> <span class="hljs-comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br>  newObject = <span class="hljs-built_in">Object</span>.create(<span class="hljs-title">constructor</span>.<span class="hljs-title">prototype</span>);<br><br> <span class="hljs-comment">// 将 this 指向新建对象，并执行函数</span><br>  result = <span class="hljs-title">constructor</span>.<span class="hljs-title">apply</span>(<span class="hljs-params">newObject, <span class="hljs-built_in">arguments</span></span>);<br><br> <span class="hljs-comment">// 判断返回对象</span><br> <span class="hljs-keyword">let</span> flag =<br>    result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;function&quot;</span>);<br><br> <span class="hljs-comment">// 判断返回结果</span><br> <span class="hljs-keyword">return</span> flag ? result : newObject;<br>&#125;<br><br><span class="hljs-comment">// 使用方法</span><br><span class="hljs-comment">// objectFactory(构造函数, 初始化参数);</span><br><br></code></pre></td></tr></table></figure><p><a href="https://pengzhenglong.github.io/2021/07/02/JS%20new%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/">博客</a></p><h3 id="JS垃圾回收机制"><a href="#JS垃圾回收机制" class="headerlink" title="JS垃圾回收机制"></a>JS垃圾回收机制</h3><ol><li>项目中，如果存在大量不被释放的内存（堆/栈/上下文），页面性能会变得很慢。当某些代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存。</li><li>浏览器垃圾回收机制/内存回收机制:浏览器的<strong>Javascript</strong>具有自动垃圾回收机制(GC:Garbage Collecation)，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。标记清除:在js中，最常用的垃圾回收机制是标记清除：当变量进入执行环境时，被标记为“进入环境”，当变量离开执行环境时，会被标记为“离开环境”。垃圾回收器会销毁那些带标记的值并回收它们所占用的内存空间。谷歌浏览器：“查找引用”，浏览器不定时去查找当前内存的引用，如果没有被占用了，浏览器会回收它；如果被占用，就不能回收。IE浏览器：“引用计数法”，当前内存被占用一次，计数累加1次，移除占用就减1，减到0时，浏览器就回收它。</li><li>优化手段：内存优化 ; 手动释放：取消内存的占用即可。（1）堆内存：fn = null 【null：空指针对象】（2）栈内存：把上下文中，被外部占用的堆的占用取消即可。</li><li>内存泄漏在 JS 中，常见的内存泄露主要有 4 种,全局变量、闭包、DOM 元素的引用、定时器</li></ol><h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>创建函数的时候，已经声明了当前函数的作用域==&gt;当前创建函数所处的上下文。如果是在全局下创建的函数就是[[scope]]:EC(G)，函数执行的时候，形成一个全新的私有上下文EC(FN)，供字符串代码执行(进栈执行)<br>定义：简单来说作用域就是变量与函数的可访问范围，由当前环境与上层环境的一系列变量对象组成<br>1.全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。</p><p>2.函数作用域：在固定的代码片段才能被访问</p><p>作用：作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。<br>作用域链参考链接一般情况下，变量到 创建该变量 的函数的作用域中取值。但是如果在当前作用域中没有查到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。<br><a href="https://juejin.cn/post/7016593221815910408#heading-43">掘金</a></p><h3 id="EventLoop-事件循环"><a href="#EventLoop-事件循环" class="headerlink" title="EventLoop 事件循环"></a>EventLoop 事件循环</h3><p>JS是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。微任务队列的代表就是，<strong>Promise.then，MutationObserver</strong>，宏任务的话就是 <strong>setImmediate setTimeout setInterval</strong></p><p>JS运行的环境。一般为浏览器或者Node。 在浏览器环境中，有JS 引擎线程和渲染线程，且两个线程互斥。 Node环境中，只有JS 线程。 不同环境执行机制有差异，不同任务进入不同Event Queue队列。 当主程结束，先执行准备好微任务，然后再执行准备好的宏任务，一个轮询结束。</p><h3 id="浏览器中的事件环（Event-Loop"><a href="#浏览器中的事件环（Event-Loop" class="headerlink" title="浏览器中的事件环（Event Loop)"></a>浏览器中的事件环（Event Loop)</h3><p>事件环的运行机制是，先会执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后在取宏任务清微任务这样不停的循环。</p><ul><li>eventLoop 是由JS的宿主环境（浏览器）来实现的；</li><li>事件循环可以简单的描述为以下四个步骤:</li></ul><ol><li>函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空；</li><li>此期间WebAPIs完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）</li><li>执行栈为空时，Event Loop把微任务队列执行清空；</li><li>微任务队列清空后，进入宏任务队列，取队列的第一项任务放入Stack(栈）中执行，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列。重复4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所有的任务。</li></ol><ul><li>浏览器中的任务源(task):<ol><li>宏任务(macrotask)：宿主环境提供的，比如浏览器ajax、setTimeout、setInterval、setTmmediate(只兼容ie)、script、2. 2.requestAnimationFrame、messageChannel、UI渲染、一些浏览器api</li></ol></li></ul><ol start="2"><li>微任务(microtask)：语言本身提供的，比如promise.thenthen、queueMicrotask(基于then)、mutationObserver(浏览器提供)、messageChannel 、mutationObersve<br><a href="https://pengzhenglong.github.io/2021/07/03/Js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/">博客：这一次，彻底弄懂 JavaScript 执行机制</a><br><a href="https://juejin.cn/post/7001881781125251086">传送门 ☞ # 宏任务和微任务</a></li></ol><h3 id="Node-环境中的事件环（Event-Loop"><a href="#Node-环境中的事件环（Event-Loop" class="headerlink" title="Node 环境中的事件环（Event Loop)"></a>Node 环境中的事件环（Event Loop)</h3><p>Node是基于V8引擎的运行在服务端的JavaScript运行环境，在处理高并发、I/O密集(文件操作、网络操作、数据库操作等)场景有明显的优势。虽然用到也是V8引擎，但由于服务目的和环境不同，导致了它的API与原生JS有些区别，其Event Loop还要处理一些I/O，比如新的网络连接等，所以Node的Event Loop(事件环机制)与浏览器的是不太一样。<br> 执行顺序如下：</p><p><img src="/imageO/Node.jpg" alt="Node"></p><p>timers: 计时器，执行setTimeout和setInterval的回调<br>pending callbacks: 执行延迟到下一个循环迭代的 I/O 回调<br>idle, prepare: 队列的移动，仅系统内部使用<br>poll轮询: 检索新的 I/O 事件;执行与 I/O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。<br>check: 执行setImmediate回调，setImmediate在这里执行<br>close callbacks: 执行close事件的callback，一些关闭的回调函数，如：socket.on(‘close’, …)</p><h3 id="哪些操作会造成内存泄漏？"><a href="#哪些操作会造成内存泄漏？" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h3><p>相关知识点：</p><p>1.意外的全局变量<br>2.被遗忘的计时器或回调函数<br>3.脱离 DOM 的引用<br>4.闭包</p><p>第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</p><p>第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留<br>在内存中，而无法被回收。</p><p>第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回<br>收。</p><p>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="ES6-语法知道哪些，分别怎么用？"><a href="#ES6-语法知道哪些，分别怎么用？" class="headerlink" title="ES6 语法知道哪些，分别怎么用？"></a>ES6 语法知道哪些，分别怎么用？</h3><p>let const 块级作用域 箭头函数 词法this Class 解构，剩余运算符，Promise等，往这些方面展开。<br>                     不定参数…rest</p><h4 id="let与var对比-做项目中习惯用let声明变量"><a href="#let与var对比-做项目中习惯用let声明变量" class="headerlink" title="let与var对比(做项目中习惯用let声明变量)"></a>let与var对比(做项目中习惯用let声明变量)</h4><p>var声明的变量往往会越狱 (let 是在代码块内有效，var 是在全局范围内有效:)<br>let声明的变量有严格局部作用域<br>var可以声明多次<br>let只能声明一次<br>let 不存在变量提升var 会变量提升</p><h4 id="const声明变量-只读变量"><a href="#const声明变量-只读变量" class="headerlink" title="const声明变量 (只读变量)"></a>const声明变量 (只读变量)</h4><p>声明之后不允许改变<br>一旦声明必须初始化，否者会报错<br>const 如何做到变量在声明初始化之后不允许改变的？其实 const 其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动</p><h3 id="Set-Map-Reduce"><a href="#Set-Map-Reduce" class="headerlink" title="Set  Map  Reduce"></a>Set  Map  Reduce</h3><blockquote><p>Set类似于数组，但是它里面每一项的值是唯一的，没有重复的值，Set是一个构造函数，用来生成set的数据结构<br>Set中两个对象永远是不相等的，即使键和值都是一样的</p></blockquote><blockquote><p>Map类似于对象，也是键值对的集合，但是“键”的范围不限制于字符串，各种类型的值（包含对象）都可以当作键。Map 也可以接受一个数组作为参数，数组的成员是一个个表示键值对的数组。<br>map() 接受一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回</p></blockquote><blockquote><p>reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。<br><a href="https://pengzhenglong.github.io/2021/04/14/Map&&Set&&Weakmap&&Weakset/">博客：</a></p></blockquote><h3 id="对象新增的API"><a href="#对象新增的API" class="headerlink" title="对象新增的API"></a>对象新增的API</h3><p>ES6给Object扩展了许多新的方法，如：<br>-keys(obj)，获取对象的所有key形成的数组<br>-values(obj),获取对象的所有value形成的数组<br>-entries(obj)，获取对象的所有key和value形成的二维数组</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>const person = &#123;<br>   <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>   age: <span class="hljs-number">21</span>,<br>   <span class="hljs-keyword">language</span>: [<span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;js&#x27;</span>, <span class="hljs-string">&#x27;css&#x27;</span>],<br> &#125;;<br> console.log(<span class="hljs-keyword">Object</span>.keys(person)); //<span class="hljs-number">0</span>: &quot;name&quot;<span class="hljs-number">1</span>: &quot;age&quot;<span class="hljs-number">2</span>: &quot;language&quot;<br> console.log(<span class="hljs-keyword">Object</span>.<span class="hljs-keyword">values</span>(person)); //<span class="hljs-number">0</span>: &quot;jack&quot;<span class="hljs-number">1</span>: <span class="hljs-number">212</span>: (<span class="hljs-number">3</span>) [&quot;java&quot;, &quot;js&quot;, &quot;css&quot;]<br> console.log(<span class="hljs-keyword">Object</span>.entries(person)); // [<span class="hljs-keyword">Array</span>(<span class="hljs-number">2</span>), <span class="hljs-keyword">Array</span>(<span class="hljs-number">2</span>), <span class="hljs-keyword">Array</span>(<span class="hljs-number">2</span>)]//<span class="hljs-number">0</span>: (<span class="hljs-number">2</span>) [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;jack&#x27;</span>]<span class="hljs-number">1</span>: (<span class="hljs-number">2</span>) [<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">21</span>]<span class="hljs-number">2</span>: (<span class="hljs-number">2</span>) [<span class="hljs-string">&#x27;language&#x27;</span>, <span class="hljs-keyword">Array</span>(<span class="hljs-number">3</span>)]length: <span class="hljs-number">3</span>[[Prototype]]: <span class="hljs-keyword">Array</span>(<span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure><p>对象的新方法<br>Object.assign(dest, ···src) ,将多个src对象的值拷贝到dest中(第一层为深拷贝，第二层为浅拷贝)<br>用于将源对象的所有可枚举属性复制到目标对象中。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">target</span> = &#123; a: 1 &#125;;<br><span class="hljs-keyword">const</span> source1 = &#123; b: 2 &#125;;<br><span class="hljs-keyword">const</span> source2 = &#123; c: 3 &#125;;<br><span class="hljs-comment">// Object.assign方法的第一个参数是目标对象，后面的参数都是源对象</span><br>Object.assign(<span class="hljs-keyword">target</span>, source1, source2);<br>console.log(<span class="hljs-keyword">target</span>); <span class="hljs-comment">//&#123;a: 1, b: 2, c: 3&#125;</span><br><br></code></pre></td></tr></table></figure><h3 id="对象拓展运算符"><a href="#对象拓展运算符" class="headerlink" title="对象拓展运算符"></a>对象拓展运算符</h3><ol><li>拷贝对象（深拷贝）</li></ol><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><br><span class="hljs-keyword">let</span> p1 = &#123; name: <span class="hljs-string">&#x27;Amy&#x27;</span>, age: <span class="hljs-number">15</span> &#125;;<br><span class="hljs-keyword">let</span> someone = &#123; <span class="hljs-params">...</span>p1 &#125;;<br>console.<span class="hljs-keyword">log</span>(someone); <span class="hljs-comment">//age: 15 name: &quot;Amy&quot;</span><br><br></code></pre></td></tr></table></figure><ol start="2"><li>合并对象</li></ol><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><br><span class="hljs-keyword">let</span> age1 = &#123; age: <span class="hljs-number">15</span> &#125;;<br><span class="hljs-keyword">let</span> name1 = &#123; name: <span class="hljs-string">&#x27;Amy&#x27;</span> &#125;;<br><span class="hljs-comment">//假设之前已经有一个值，但是打印时最后的值还是会覆盖原来的值</span><br><span class="hljs-keyword">let</span> p2 = &#123; name: <span class="hljs-string">&#x27;zhangsan&#x27;</span> &#125;;<br>p2 = &#123; <span class="hljs-params">...</span>age1, <span class="hljs-params">...</span>name1 &#125;;<br>console.<span class="hljs-keyword">log</span>(p2); <span class="hljs-comment">//age: 15 name: &quot;Amy&quot;</span><br><br></code></pre></td></tr></table></figure><p><a href="https://pengzhenglong.github.io/2021/04/13/ES6(%E5%9B%9B)/">博客：</a></p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>模块化就是把代码进行拆分，方便重复利用，类似java中的导包，需要使用一个包，必须先导包，而js中没有包的概念，换来的是模块<br>ES6 的模块化分为导出（export） @与导入（import）两个模块。</p><h4 id="模块化优点"><a href="#模块化优点" class="headerlink" title="模块化优点"></a>模块化优点</h4><p>避免命名冲突（减少命名空间污染）<br>更好的分类，按需加载<br>更高的复用性<br>高可维护性</p><h3 id="CommomJS-node应用由模块组成"><a href="#CommomJS-node应用由模块组成" class="headerlink" title="CommomJS(node应用由模块组成)"></a>CommomJS(node应用由模块组成)</h3><p>CommonJS定义了两个主要概念：<br>require函数，用于导入模块<br>module.exports变量，用于导出模块<br>require<br>导入，代码很简单，let {count,addCount}=require(“./utils”)就可以了。<br>require的第一步是解析路径获取到模块内容：</p><p>如果是核心模块，比如fs，就直接返回模块<br>如果是带有路径的如/,./等等，则拼接出一个绝对路径，然后先读取缓存require.cache再读取文件。如果没有加后缀，则自动加后缀然后一一识别。</p><p>.js 解析为JavaScript 文本文件<br>.json解析JSON对象<br>.node解析为二进制插件模块</p><p>首次加载后的模块会缓存在require.cache之中，所以多次加载require，得到的对象是同一个。<br>在执行模块代码的时候，会将模块包装成如下模式，以便于作用域在模块范围之内。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><br><span class="hljs-keyword">module</span><br><span class="hljs-keyword">let</span><span class="hljs-built_in"> count</span>=<span class="hljs-number">0</span><br><span class="hljs-keyword">function</span> addCount()&#123;<br>   <span class="hljs-built_in"> count</span>++<br>&#125;<br><span class="hljs-keyword">module</span>.exports=<span class="hljs-built_in">&#123;count</span>,addCount&#125;<br><br></code></pre></td></tr></table></figure><p>然后根据require执行代码时需要加上的，那么实际上我们的代码长成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span>, <span class="hljs-built_in">module</span>, __filename,__dirname</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> count=<span class="hljs-number">0</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCount</span>(<span class="hljs-params"></span>)</span>&#123;<br>        count++<br>    &#125;<br>    <span class="hljs-built_in">module</span>.exports=&#123;count,addCount&#125;<br>&#125;);<br><br></code></pre></td></tr></table></figure><h3 id="ES6模块与CommonJS的区别"><a href="#ES6模块与CommonJS的区别" class="headerlink" title="ES6模块与CommonJS的区别"></a>ES6模块与CommonJS的区别</h3><h4 id="CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用"><a href="#CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用" class="headerlink" title="CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用"></a>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</h4><ol><li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li><li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li></ol><h4 id="CommonJS-模块是运行时加载，ES6-模块是编译时输出接口"><a href="#CommonJS-模块是运行时加载，ES6-模块是编译时输出接口" class="headerlink" title="CommonJS 模块是运行时加载，ES6 模块是编译时输出接口"></a>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</h4><ol><li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li><li>编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li></ol><h4 id="CommonJs导出有有缓存，而ES6没有"><a href="#CommonJs导出有有缓存，而ES6没有" class="headerlink" title="CommonJs导出有有缓存，而ES6没有"></a>CommonJs导出有有缓存，而ES6没有</h4><p><a href="https://pengzhenglong.github.io/2022/03/01/CommonJS%E5%92%8CES6%E6%A8%A1%E5%9D%97/">博客</a></p><p><a href="https://pengzhenglong.github.io/2021/04/17/ES6%E6%A8%A1%E5%9D%97%E5%8C%96/">博客：</a></p><h3 id="ECMAScript6-怎么写-class，为什么会出现-class-这种东西"><a href="#ECMAScript6-怎么写-class，为什么会出现-class-这种东西" class="headerlink" title="ECMAScript6 怎么写 class，为什么会出现 class 这种东西?"></a>ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</h3><p>在我看来 ES6 新添加的 class 只是为了补充 js 中缺少的一些面向对象语言的特性，但本质上来说它只是一种语法糖，不是一个新的东西，其背后还是原型继承的思想。通过加入 class 可以有利于我们更好的组织代码。在 class 中添加的方法，其实是添加在类的原型上的。</p><h2 id="进阶–面试题"><a href="#进阶–面试题" class="headerlink" title="进阶–面试题"></a>进阶–面试题</h2><h3 id="js如何将json字符串转换为json对象"><a href="#js如何将json字符串转换为json对象" class="headerlink" title="js如何将json字符串转换为json对象"></a>js如何将json字符串转换为json对象</h3><p>JSON字符串:<br>var str1 = ‘{ “name”: “cxh”, “sex”: “man” }’;<br>JSON对象:<br>var str2 = { “name”: “cxh”, “sex”: “man” };</p><h4 id="一、JSON字符串转换为JSON对象-（eval-函数-amp-amp-parseJSON-amp-amp-parse）"><a href="#一、JSON字符串转换为JSON对象-（eval-函数-amp-amp-parseJSON-amp-amp-parse）" class="headerlink" title="一、JSON字符串转换为JSON对象 （eval(()函数 &amp;&amp;parseJSON &amp;&amp; parse）"></a>一、JSON字符串转换为JSON对象 （eval(()函数 &amp;&amp;parseJSON &amp;&amp; parse）</h4><p>要使用上面的str1，必须使用下面的方法先转化为JSON对象：</p><p>//由JSON字符串转换为JSON对象<br>var obj = eval(‘(‘ + str + ‘)’);<br>或者</p><p>var obj = str.parseJSON(); //由JSON字符串转换为JSON对象<br>或者</p><p>var obj = JSON.parse(str); //由JSON字符串转换为JSON对象<br>然后，就可以这样读取：</p><p>Alert(obj.name);<br>Alert(obj.sex);<br>特别注意：如果obj本来就是一个JSON对象，那么使用eval（）函数转换后（哪怕是多次转换）还是JSON对象，但是使用parseJSON（）函数处理后会有问题（抛出语法异常）。</p><h5 id="二、可以使用toJSONString-或者全局方法JSON-stringify-将JSON对象转化为JSON字符串"><a href="#二、可以使用toJSONString-或者全局方法JSON-stringify-将JSON对象转化为JSON字符串" class="headerlink" title="二、可以使用toJSONString()或者全局方法JSON.stringify()将JSON对象转化为JSON字符串"></a>二、可以使用toJSONString()或者全局方法JSON.stringify()将JSON对象转化为JSON字符串</h5><p>例如：</p><p>var last=obj.toJSONString(); //将JSON对象转化为JSON字符<br>或者</p><p>var last=JSON.stringify(obj); //将JSON对象转化为JSON字符</p><p><a href="https://zhuanlan.zhihu.com/p/138712665">js如何将json字符串转换为json对象</a></p><h3 id="如何中断已经发出去的请求-amp-amp-大文件上传处理"><a href="#如何中断已经发出去的请求-amp-amp-大文件上传处理" class="headerlink" title="如何中断已经发出去的请求&amp;&amp;大文件上传处理"></a>如何中断已经发出去的请求&amp;&amp;大文件上传处理</h3><p><a href="https://pengzhenglong.github.io/2022/03/08/%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%B9%B6%E5%8F%91/">博客</a></p><h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><h3 id="number与string的转换-面试题"><a href="#number与string的转换-面试题" class="headerlink" title="number与string的转换(面试题)"></a>number与string的转换(面试题)</h3><h4 id="number-gt-string"><a href="#number-gt-string" class="headerlink" title="number -&gt; string"></a>number -&gt; string</h4><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-comment">// toString()</span><br>/*<br><span class="hljs-built_in">var</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">var</span> res = num.toString();<br>alert(typeof (num));<br>alert(typeof (res));<br>*/<br><br><span class="hljs-comment">// 加一个空格</span><br>/*<br><span class="hljs-built_in">var</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">var</span> res = num + <span class="hljs-string">&quot;&quot;</span><br>alert(num + <span class="hljs-string">&quot;, &quot;</span> + typeof (num));<br>alert(res + <span class="hljs-string">&quot;, &quot;</span> + typeof (res));<br>*/<br><br><span class="hljs-comment">// 使用String(数字)函数</span><br>/*<br><span class="hljs-built_in">var</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">var</span> res = String(num);<br>alert(num + <span class="hljs-string">&quot;, &quot;</span> + typeof (num));<br>alert(res + <span class="hljs-string">&quot;, &quot;</span> + typeof (res));<br>*/<br><br><span class="hljs-comment">// 没有固定精度的表示</span><br>/*<br><span class="hljs-built_in">var</span> n = <span class="hljs-number">1234.56789</span>;<br><span class="hljs-built_in">var</span> s4 = n.toFixed(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">var</span> s5 = n.toExponential(<span class="hljs-number">2</span>); <span class="hljs-comment">// 指数表示</span><br><span class="hljs-built_in">var</span> s6 = n.toPrecision(<span class="hljs-number">2</span>); <span class="hljs-comment">// 有效位数</span><br><br>alert(s4 + <span class="hljs-string">&quot;, &quot;</span> + typeof(s4));<br>alert(s5 + <span class="hljs-string">&quot;, &quot;</span> + typeof(s5));<br>alert(s6 + <span class="hljs-string">&quot;, &quot;</span> + typeof(s6));<br>*/<br></code></pre></td></tr></table></figure><h4 id="string-gt-number"><a href="#string-gt-number" class="headerlink" title="string -&gt; number"></a>string -&gt; number</h4><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-comment">// 做除了加法以外的数字运算</span><br>/*<br><span class="hljs-built_in">var</span> s = <span class="hljs-string">&quot;12345&quot;</span>;<br><span class="hljs-built_in">var</span> r = s / <span class="hljs-number">1</span>; <span class="hljs-comment">// s - 0;</span><br>alert(s + <span class="hljs-string">&quot;, &quot;</span> + typeof s);<br>alert(r + <span class="hljs-string">&quot;, &quot;</span> + typeof r);<br>*/<br><br><span class="hljs-comment">// 使用parse系方法</span><br><span class="hljs-comment">// parseInt() parseFloat()</span><br>/*<br><span class="hljs-built_in">var</span> s = <span class="hljs-string">&quot;08&quot;</span>;<br><span class="hljs-built_in">var</span> r = parseInt(s);<br>alert(s + <span class="hljs-string">&quot;, &quot;</span> + typeof s);<br>alert(r + <span class="hljs-string">&quot;, &quot;</span> + typeof r);<br>*/<br><span class="hljs-comment">// parse系方法，只识别一个字符串中开始的数字，如果识别不了就返回NaN</span><br>alert(parseInt(<span class="hljs-string">&quot;a123abc&quot;</span>) + <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 使用Number()函数</span><br></code></pre></td></tr></table></figure><h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p><a href="https://pengzhenglong.github.io/2022/03/11/Js%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/">博客</a></p><h3 id="Ts"><a href="#Ts" class="headerlink" title="Ts"></a>Ts</h3><h4 id="typescript-中-interface-和-type-的区别"><a href="#typescript-中-interface-和-type-的区别" class="headerlink" title="typescript 中 interface 和 type 的区别"></a>typescript 中 interface 和 type 的区别</h4><p>相同点 (都可以描述一个对象或者函数&amp;&amp;都允许拓展（extends）)<br>不同点 (type 可以声明基本类型别名，联合类型，元组等类型,type 语句中还可以使用 typeof 获取实例的 类型进行赋值 ,interface 能够声明合并)<br><a href="https://pengzhenglong.github.io/2022/03/11/Ts%E9%9D%A2%E8%AF%95%E9%A2%98/">博客</a></p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javaScript之Math常用方法</title>
    <link href="/2022/01/04/javaScript%E4%B9%8BMath%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2022/01/04/javaScript%E4%B9%8BMath%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Math是 JavaScript 的原生对象，提供各种数学功能。Math对象是目前javaScript原生对象里唯一一个不是构造函数，不用实例化，所有的属性和方法都是直接在Math对象上调用。下面是本次分享的Math主要方法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">【一】<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs<span class="hljs-literal">()</span> 返回绝对值<br>【二】<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>ceil<span class="hljs-literal">()</span>,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>floor<span class="hljs-literal">()</span> 向上取整和向下取整<br>【三】<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max<span class="hljs-literal">()</span>,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min<span class="hljs-literal">()</span> 最大值和最小值<br>【四】<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>round<span class="hljs-literal">()</span> 四舍五入<br>【五】<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>random<span class="hljs-literal">()</span> 随机数<br>【六】<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>pow<span class="hljs-literal">()</span> 指数运算<br>【七】<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>sqrt<span class="hljs-literal">()</span> 平方根<br>【八】<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>log<span class="hljs-literal">()</span> 自然对数<br>【九】<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>exp<span class="hljs-literal">()</span> e的指数<br>【十】Math属性<br>【十一】Math三角函数<br></code></pre></td></tr></table></figure><hr><h3 id="1-Math-abs-绝对值"><a href="#1-Math-abs-绝对值" class="headerlink" title="1.Math.abs() 绝对值"></a>1.Math.abs() 绝对值</h3><p>Math.abs()方法，接收一个参数，返回这个参数的绝对值，通俗的讲就是把任何一个有效数字返回一个正数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">abs</span>(<span class="hljs-number">10</span>))   <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 输出 <span class="hljs-number">10</span><br>console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">abs</span>(<span class="hljs-number">-10</span>))  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 输出 <span class="hljs-number">10</span><br><br></code></pre></td></tr></table></figure><h3 id="2-Math-ceil-Math-floor-向上取整和向下取整"><a href="#2-Math-ceil-Math-floor-向上取整和向下取整" class="headerlink" title="2.Math.ceil(),Math.floor() 向上取整和向下取整"></a>2.Math.ceil(),Math.floor() 向上取整和向下取整</h3><p>Math.ceil(),Math.floor()方法是获取整数的方法，接收一个参数，把小数点后面的数向上或者向下取一个整数。Math.ceil()是向上，Math.floor()是向下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">ceil</span>(<span class="hljs-number">10.01</span>))   <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 输出 <span class="hljs-number">11</span><br>console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">floor</span>(<span class="hljs-number">10.01</span>))  <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 输出 <span class="hljs-number">10</span><br><br></code></pre></td></tr></table></figure><h3 id="3-Math-max-Math-min-最大值和最小值"><a href="#3-Math-max-Math-min-最大值和最小值" class="headerlink" title="3.Math.max(),Math.min() 最大值和最小值"></a>3.Math.max(),Math.min() 最大值和最小值</h3><p>Math.max(),Math.min()方法接收多个参数，并返回参数里数值最大或者最小的那个数，Math.max()是获取最大，Math.min()是获取最小：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">console</span>.log(Math.max(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>))   // 输出 <span class="hljs-number">9</span><br><span class="hljs-attribute">console</span>.log(Math.min(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>))  // 输出 <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><p>Math.max(),Math.min()也可以用来获取数组里的最大数值和最小数值：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> arr = [<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>];<br>// 先看用循环实现方法,采用循环方式的核心思想就是假设法。<br><span class="hljs-built_in">var</span> <span class="hljs-built_in">max</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">min</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">var</span> <span class="hljs-built_in">num</span> of arr) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span> &lt; <span class="hljs-built_in">num</span>) &#123;<br>  <span class="hljs-built_in">max</span> = <span class="hljs-built_in">num</span><br> &#125;<br> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">min</span> &gt; <span class="hljs-built_in">num</span>) &#123;<br>  <span class="hljs-built_in">min</span> = <span class="hljs-built_in">num</span>;<br> &#125;<br>&#125;   // 输出 <span class="hljs-number">9</span>, <span class="hljs-number">1</span>;<br>// 下面是采用<span class="hljs-built_in">apply</span>改变this指向的方式直接获取最大值和最小值<br>console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">max</span>.<span class="hljs-built_in">apply</span>(null, arr))   // 输出 <span class="hljs-number">9</span><br>console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">min</span>.<span class="hljs-built_in">apply</span>(null, arr))  // 输出 <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h3 id="4-Math-round-四舍五入"><a href="#4-Math-round-四舍五入" class="headerlink" title="4.Math.round() 四舍五入"></a>4.Math.round() 四舍五入</h3><p>Math.round()方法接收一个数字参数，对数字小数点后一位的数进行四舍五入处理</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">console</span>.log(Math.round(<span class="hljs-number">3</span>.<span class="hljs-number">87</span>))   // 输出 <span class="hljs-number">4</span><br><span class="hljs-attribute">console</span>.log(Math.round(<span class="hljs-number">3</span>.<span class="hljs-number">39</span>))  // 输出 <span class="hljs-number">3</span><br><br></code></pre></td></tr></table></figure><h3 id="5-Math-random-随机数"><a href="#5-Math-random-随机数" class="headerlink" title="5.Math.random() 随机数"></a>5.Math.random() 随机数</h3><p>Math.random()方法返回一个0到1之间的随机数；</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">random</span>())   <span class="hljs-comment">// 输出 0到1之间的随机数</span><br><br></code></pre></td></tr></table></figure><p>Math.random()是一个应用非常广泛的方法，下面看一个限定范围内的随机数：<br>`<br>function getRandom (min, max) {<br> return Math.round(Math.random()*(max - min))<br>}<br>console.log(getRandom(0, 100)); // 输出0到100的随机整数</p><p><code>基于这个思想，可以做很多事情，比如随机取字符串里的值，随机取数组里的某个当前项等等。</code><br>var ary = [‘red’, ‘orange’, ‘yellow’, ‘blue’, ‘green’]<br>function getRandom (min, max) {<br>   return ary[Math.round(Math.random()*(max - min))]<br> }<br>console.log(getRandom(0, ary.length-1)); // 输出数组里随机的一个当前项</p><p>`</p><h3 id="6-Math-pow-指数运算"><a href="#6-Math-pow-指数运算" class="headerlink" title="6.Math.pow() 指数运算"></a>6.Math.pow() 指数运算</h3><p>Math.pow()方法返回以第一个参数为底数、第二个参数为幂的指数值。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出4</span><br><span class="hljs-comment">// 等同于 2 **2</span><br>console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出8</span><br><span class="hljs-comment">// 等同于 2** 3</span><br><br></code></pre></td></tr></table></figure><h3 id="7-Math-sqrt-平方根"><a href="#7-Math-sqrt-平方根" class="headerlink" title="7.Math.sqrt() 平方根"></a>7.Math.sqrt() 平方根</h3><p>Math.sqrt()方法返回参数值的平方根。如果参数是一个负值，则返回NaN。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">9</span>)); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 输出<span class="hljs-number">3</span><br>console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-9</span>)); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 输出NaN<br></code></pre></td></tr></table></figure><p>`</p><h3 id="8-Math-log"><a href="#8-Math-log" class="headerlink" title="8.Math.log()"></a>8.Math.log()</h3><p>Math.log方法返回以e为底的自然对数值。<br>`<br>console.log(Math.log(10)); // 输出 2.302585092994046</p><p>`</p><h3 id="9-Math-exp"><a href="#9-Math-exp" class="headerlink" title="9.Math.exp()"></a>9.Math.exp()</h3><p>Math.exp()方法返回常数e的参数次方。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">exp</span>(<span class="hljs-number">1</span>)); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 输出 <span class="hljs-number">2.7182818284590455</span><br>console.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">exp</span>(<span class="hljs-number">2</span>)); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> 输出 <span class="hljs-number">7.38905609893065</span><br><br></code></pre></td></tr></table></figure><p>Math属性</p><p>Math.E：常数e。<br>Math.LN2：2 的自然对数。<br>Math.LN10：10 的自然对数。<br>Math.LOG2E：以 2 为底的e的对数。<br>Math.LOG10E：以 10 为底的e的对数。<br>Math.PI：常数π。<br>Math.SQRT1_2：0.5 的平方根。<br>Math.SQRT2：2 的平方根</p><p>`<br>Math.E // 2.718281828459045<br>Math.LN2 // 0.6931471805599453<br>Math.LN10 // 2.302585092994046<br>Math.LOG2E // 1.4426950408889634<br>Math.LOG10E // 0.4342944819032518<br>Math.PI // 3.141592653589793<br>Math.SQRT1_2 // 0.7071067811865476<br>Math.SQRT2 // 1.4142135623730951</p><p>`<br>注意Math的这些属性都是只读，不可以修改的。</p><p>Math三角函数</p><p>Math.sin()：返回参数的正弦（参数为弧度值）<br>Math.cos()：返回参数的余弦（参数为弧度值）<br>Math.tan()：返回参数的正切（参数为弧度值）<br>Math.asin()：返回参数的反正弦（返回值为弧度值）<br>Math.acos()：返回参数的反余弦（返回值为弧度值）<br>Math.atan()：返回参数的反正切（返回值为弧度值）</p><p>`<br>Math.sin(0) // 0<br>Math.cos(0) // 1<br>Math.tan(0) // 0<br>Math.sin(Math.PI / 2) // 1<br>Math.asin(1) // 1.5707963267948966<br>Math.acos(1) // 0<br>Math.atan(1) // 0.7853981633974483</p><p>`</p><p>结语</p><p>Math对象本身是对js里的数字做数学处理的，里面有不少方法。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844903687932870670">javaScript之Math常用方法</a></p>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 奇怪又实用的姿势又增加了六个</title>
    <link href="/2022/01/03/JavaScript%20%E5%A5%87%E6%80%AA%E5%8F%88%E5%AE%9E%E7%94%A8%E7%9A%84%E5%A7%BF%E5%8A%BF%E5%8F%88%E5%A2%9E%E5%8A%A0%E4%BA%86%E5%85%AD%E4%B8%AA/"/>
    <url>/2022/01/03/JavaScript%20%E5%A5%87%E6%80%AA%E5%8F%88%E5%AE%9E%E7%94%A8%E7%9A%84%E5%A7%BF%E5%8A%BF%E5%8F%88%E5%A2%9E%E5%8A%A0%E4%BA%86%E5%85%AD%E4%B8%AA/</url>
    
    <content type="html"><![CDATA[<p>该文章引用于零一</p><hr><h3 id="一、解构小技巧"><a href="#一、解构小技巧" class="headerlink" title="一、解构小技巧"></a>一、解构小技巧</h3><p>平常我们需要用到一个嵌套多层的对象中某些属性，会将其解构出来使用</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sqf">let obj = &#123;<br>  part1: &#123;<br>    <span class="hljs-built_in">name</span>: <span class="hljs-string">&#x27;零一&#x27;</span>,<br>    age: <span class="hljs-number">23</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 解构</span><br>const &#123; part1: &#123; <span class="hljs-built_in">name</span>, age &#125; &#125; = obj<br><span class="hljs-comment">// 使用</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">name</span>, age)  <span class="hljs-comment">// 零一  23</span><br></code></pre></td></tr></table></figure><p>这种情况下，你把 name 和 age 从 part1 里解构出来了以后，你就无法使用变量 obj 中的 part1 属性了，如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// .... 省略</span><br><br><span class="hljs-keyword">const</span> &#123; part1: &#123; name, age &#125; &#125; = obj<br>console.<span class="hljs-built_in">log</span>(part1)   <span class="hljs-comment">// Uncaught ReferenceError: part1 is not defined</span><br></code></pre></td></tr></table></figure><p>其实你可以多次解构，如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> .... 省略<br><br>const &#123; part1: &#123; name, age &#125;, part1 &#125; = obj<br>console.log(part1)   <span class="hljs-regexp">//</span> &#123;name: <span class="hljs-string">&quot;零一&quot;</span>, age: <span class="hljs-number">23</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、数字分隔符"><a href="#二、数字分隔符" class="headerlink" title="二、数字分隔符"></a>二、数字分隔符</h3><p>有时你会在文件中定义一个数字常量</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> myMoney = <span class="hljs-number">1000000000000</span><br></code></pre></td></tr></table></figure><p>这么多个 0 ，1、2 … 6、7 … 数晕了都，怎么办？</p><p>数字分隔符整起来！</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">const</span> myMoney = <span class="hljs-number">1</span>_<span class="hljs-number">000</span>_<span class="hljs-number">000</span>_<span class="hljs-number">000</span>_<span class="hljs-number">000</span><br><br><span class="hljs-attribute">console</span>.log(myMoney)  // <span class="hljs-number">1000000000000</span><br></code></pre></td></tr></table></figure><p>这样写是没问题的，而且数字分割开后也更直观！！</p><h3 id="三、try…catch…finally-谁厉害？"><a href="#三、try…catch…finally-谁厉害？" class="headerlink" title="三、try…catch…finally 谁厉害？"></a>三、try…catch…finally 谁厉害？</h3><p>普通函数调用中，return 一般会提前结束函数的执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">demo</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我是零一&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(demo())   <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>而在  try…catch…finally 中，return 就不会提前结束执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">demo</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-built_in">console</span>.log(err)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(demo())   <span class="hljs-comment">// 返回什么？？</span><br></code></pre></td></tr></table></figure><p>这个程序会返回什么呢？思考一下</p><p>Tow hours Later~</p><p>答案是：3</p><p>最后得出结论，还是 finally 比较厉害</p><p>那么我们可以搞一些骚操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">demo</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-built_in">console</span>.log(err)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">4</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(demo())  <span class="hljs-comment">// 返回 4</span><br></code></pre></td></tr></table></figure><h3 id="四、获取当前调用栈"><a href="#四、获取当前调用栈" class="headerlink" title="四、获取当前调用栈"></a>四、获取当前调用栈</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> first<span class="hljs-constructor">Function()</span> &#123; second<span class="hljs-constructor">Function()</span>; &#125; <br><span class="hljs-keyword">function</span> second<span class="hljs-constructor">Function()</span> &#123; thrid<span class="hljs-constructor">Function()</span>; &#125; <br><span class="hljs-keyword">function</span> thrid<span class="hljs-constructor">Function()</span> &#123; console.log(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Error()</span>.stack); &#125; <br><br>first<span class="hljs-constructor">Function()</span>;<br><br><span class="hljs-comment">//=&gt; Error </span><br><span class="hljs-comment">//  at thridFunction (&lt;anonymous&gt;:2:17) </span><br><span class="hljs-comment">//  at secondFunction (&lt;anonymous&gt;:5:5) </span><br><span class="hljs-comment">//  at firstFunction (&lt;anonymous&gt;:8:5) </span><br><span class="hljs-comment">//  at &lt;anonymous&gt;:10:1</span><br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Error()</span>.stack 这样就能随时获取到当前代码执行的调用栈信息，也不失一种调试代码的办法<br></code></pre></td></tr></table></figure><h3 id="五、一行代码生成随机字符串"><a href="#五、一行代码生成随机字符串" class="headerlink" title="五、一行代码生成随机字符串"></a>五、一行代码生成随机字符串</h3><p>我最初学js时，想自己实现一个随机生成字符串的函数，是这么搞的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hash</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-keyword">const</span> strs = [<br>    <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <br>    <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <br>    <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <br>    <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <br>    <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>,<br>    <span class="hljs-string">&#x27;9&#x27;</span>,<br>  ]<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    s += strs[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * strs.length)]<br>  &#125;<br>  <span class="hljs-keyword">return</span> s<br>&#125;<br><br>hash()  <span class="hljs-comment">// &#x27;www7v2if9r&#x27;</span><br></code></pre></td></tr></table></figure><p>真麻烦啊！我光写26个字母和10个数字就写了半天（当然也可以用ASCII码来实现，会更方便点）</p><p>接下来介绍一个方法，只需 一行超短代码 即可实现 “随机生成字符串” 的功能</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">const</span> <span class="hljs-built_in">str</span> = Math.<span class="hljs-built_in">random</span>().toString(<span class="hljs-number">36</span>).substr(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>);<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span>);   <span class="hljs-comment">// &#x27;w5jetivt7e&#x27;</span><br></code></pre></td></tr></table></figure><p>我们同样获得了一个10位数的随机字符串，这太酷了😎，跟我写的那个比起来，简直不要太爽</p><p>先是 Math.random() 生成 [0, 1) 的数，也就是 0.123312、0.982931之类的，然后调用 number 的 toString方法将其转换成36进制的，按照MDN的说法，36进制的转换应该是包含了字母 a<del>z 和 数字0</del>9的，因为这样生成的是 0.89kjna21sa 类似这样的，所以要截取一下小数部分，即从索引 2 开始截取10个字符就是我们想要的随机字符串了</p><p>很多开源库都使用此方式为DOM元素创建随机ID。</p><h3 id="六、最快获取dom的方法"><a href="#六、最快获取dom的方法" class="headerlink" title="六、最快获取dom的方法"></a>六、最快获取dom的方法</h3><p>HTML中带有 id 属性的元素，都会被全局的 ID 同名变量所引用</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;zero2one&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>原本获取 dom 是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;zero2one&#x27;</span>)  <br><span class="hljs-built_in">console</span>.log(el)   <span class="hljs-comment">// &lt;div id=&quot;zero2one&quot;&gt;&lt;/div&gt;</span><br></code></pre></td></tr></table></figure><p>现在可以这样</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">console.log(zero2one)   // <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;zero2one&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>是不是很方便 ^-^</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://mp.weixin.qq.com/s/qvTppljF8BL-qzsUzOgB7Q">JavaScript 奇怪又实用的姿势又增加了六个</a></p>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS Grid 网格布局教程(二)</title>
    <link href="/2021/12/27/CSSGrid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B(2)/"/>
    <url>/2021/12/27/CSSGrid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B(2)/</url>
    
    <content type="html"><![CDATA[<hr><h4 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h4><p>grid-row-gap 属性，<br>grid-column-gap 属性，<br>grid-gap 属性<br>grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  grid-row-gap: <span class="hljs-number">20px</span>;<br>  grid-<span class="hljs-attribute">column-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，grid-row-gap用于设置行间距，grid-column-gap用于设置列间距。</p><p><img src="/imageO/gird11.jpg" alt="效果"></p><p>grid-gap属性是grid-column-gap和grid-row-gap的合并简写形式，语法如下。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">grid</span>-gap: &lt;<span class="hljs-built_in">grid</span>-<span class="hljs-built_in">row</span>-gap&gt; &lt;<span class="hljs-built_in">grid</span>-column-gap&gt;;<br></code></pre></td></tr></table></figure><p>因此，上面一段 CSS 代码等同于下面的代码。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel">.<span class="hljs-keyword">container</span> &#123;<br>  <span class="hljs-keyword">grid</span>-gap: <span class="hljs-number">20</span>px <span class="hljs-number">20</span>px;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果grid-gap省略了第二个值，浏览器认为第二个值等于第一个值。</p><h5 id="注"><a href="#注" class="headerlink" title="注"></a>注</h5><ul><li>根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。</li></ul><h4 id="3-4-grid-template-areas-属性"><a href="#3-4-grid-template-areas-属性" class="headerlink" title="3.4 grid-template-areas 属性"></a>3.4 grid-template-areas 属性</h4><p>网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>  grid-template-rows: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>  grid-template-areas: <span class="hljs-string">&#x27;a b c&#x27;</span><br>                       <span class="hljs-string">&#x27;d e f&#x27;</span><br>                       <span class="hljs-string">&#x27;g h i&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。</p><p>多个单元格合并成一个区域的写法如下。</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sml">grid-template-areas: <span class="hljs-symbol">&#x27;a</span> a a&#x27;<br>                     <span class="hljs-symbol">&#x27;b</span> b b&#x27;<br>                     <span class="hljs-symbol">&#x27;c</span> c c&#x27;;<br></code></pre></td></tr></table></figure><p>上面代码将9个单元格分成a、b、c三个区域。</p><p>下面是一个布局实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">grid-<span class="hljs-keyword">template</span>-areas: <span class="hljs-string">&quot;header header header&quot;</span><br>                     <span class="hljs-string">&quot;main main sidebar&quot;</span><br>                     <span class="hljs-string">&quot;footer footer footer&quot;</span>;<br></code></pre></td></tr></table></figure><p>上面代码中，顶部是页眉区域header，底部是页脚区域footer，中间部分则为main和sidebar。</p><p>如果某些区域不需要利用，则使用”点”（.）表示。</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sml">grid-template-areas: <span class="hljs-symbol">&#x27;a</span> . c&#x27;<br>                     <span class="hljs-symbol">&#x27;d</span> . f&#x27;<br>                     <span class="hljs-symbol">&#x27;g</span> . i&#x27;;<br></code></pre></td></tr></table></figure><p>上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。</p><ul><li>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。</li></ul><p>比如，区域名为header，则起始位置的水平网格线和垂直网格线叫做header-start，终止位置的水平网格线和垂直网格线叫做header-end。</p><h4 id="3-5-grid-auto-flow-属性"><a href="#3-5-grid-auto-flow-属性" class="headerlink" title="3.5 grid-auto-flow 属性"></a>3.5 grid-auto-flow 属性</h4><p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。<br><img src="/imageO/gird12.jpg" alt="效果"><br>这个顺序由grid-auto-flow属性决定，默认值是row，即”先行后列”。也可以将它设成column，变成”先列后行”。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">grid-<span class="hljs-attribute">auto</span>-flow: column;<br></code></pre></td></tr></table></figure><p>上面代码设置了column以后，放置顺序就变成了下图。<br><img src="/imageO/gird13.jpg" alt="效果"></p><p>grid-auto-flow属性除了设置成row和column，还可以设成row dense和column dense。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。</p><p>下面的例子让1号项目和2号项目各占据两个单元格，然后在默认的grid-auto-flow: row情况下，会产生下面这样的布局。<br><img src="/imageO/gird14.jpg" alt="效果"></p><p>上图中，1号项目后面的位置是空的，这是因为3号项目默认跟着2号项目，所以会排在2号项目后面。</p><p>现在修改设置，设为row dense，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">grid-<span class="hljs-attribute">auto</span>-flow: row dense;`<br></code></pre></td></tr></table></figure><p>上面代码的效果如下。<br><img src="/imageO/gird15.jpg" alt="效果"><br>上图会先填满第一行，再填满第二行，所以3号项目就会紧跟在1号项目的后面。8号项目和9号项目就会排到第四行。</p><p>如果将设置改为column dense，表示”先列后行”，并且尽量填满空格。</p><p>grid-auto-flow: column dense;<br>上面代码的效果如下。<br><img src="/imageO/gird16.jpg" alt="效果"><br>上图会先填满第一列，再填满第2列，所以3号项目在第一列，4号项目在第二列。8号项目和9号项目被挤到了第四列。</p><h4 id="3-6"><a href="#3-6" class="headerlink" title="3.6"></a>3.6</h4><p>justify-items 属性，<br>align-items 属性，<br>place-items 属性<br>justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coq">.container &#123;<br>  justify-items: start | <span class="hljs-type">end</span> | <span class="hljs-type">center</span> | <span class="hljs-type">stretch</span>;<br>  align-items: start | <span class="hljs-type">end</span> | <span class="hljs-type">center</span> | <span class="hljs-type">stretch</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个属性的写法完全相同，都可以取下面这些值。</p><p>start：对齐单元格的起始边缘。<br>end：对齐单元格的结束边缘。<br>center：单元格内部居中。<br>stretch：拉伸，占满单元格的整个宽度（默认值）。</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs puppet">.<span class="hljs-keyword">container</span> &#123;<br>  justify-items: <span class="hljs-literal">start</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码表示，单元格的内容左对齐，效果如下图。<br><img src="/imageO/gird17.jpg" alt="效果"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">align-items</span>: start;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码表示，单元格的内容头部对齐，效果如下图。<br><img src="/imageO/gird18.jpg" alt="效果"><br>place-items属性是align-items属性和justify-items属性的合并简写形式。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">place-<span class="hljs-built_in">items</span>: &lt;align-<span class="hljs-built_in">items</span>&gt; &lt;justify-<span class="hljs-built_in">items</span>&gt;;<br></code></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">place-items: <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span>;<br></code></pre></td></tr></table></figure><p>如果省略第二个值，则浏览器认为与第一个值相等。</p><h4 id="3-7-这里的属性和flex盒子模型中相似"><a href="#3-7-这里的属性和flex盒子模型中相似" class="headerlink" title="3.7   这里的属性和flex盒子模型中相似"></a>3.7   这里的属性和flex盒子模型中相似</h4><p>justify-content 属性，<br>align-content 属性，<br>place-content 属性<br>justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">.container &#123;<br>  justify-content: start | <span class="hljs-keyword">end</span> | center | stretch | <span class="hljs-literal">space</span>-<span class="hljs-keyword">around</span> | <span class="hljs-literal">space</span>-<span class="hljs-keyword">between</span> | <span class="hljs-literal">space</span>-evenly;<br>  align-content: start | <span class="hljs-keyword">end</span> | center | stretch | <span class="hljs-literal">space</span>-<span class="hljs-keyword">around</span> | <span class="hljs-literal">space</span>-<span class="hljs-keyword">between</span> | <span class="hljs-literal">space</span>-evenly;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以justify-content属性为例，align-content属性的图完全一样，只是将水平方向改成垂直方向。）</p><p>start - 对齐容器的起始边框。</p><p>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。<br><img src="/imageO/gird19.jpg" alt="效果"></p><p>place-content属性是align-content属性和justify-content属性的合并简写形式。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">place-<span class="hljs-built_in">content</span>: &lt;align-<span class="hljs-built_in">content</span>&gt; &lt;justify-<span class="hljs-built_in">content</span>&gt;<br></code></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">place-content: <span class="hljs-literal">space</span>-<span class="hljs-keyword">around</span> <span class="hljs-literal">space</span>-evenly;<br></code></pre></td></tr></table></figure><p>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p><h4 id="3-8"><a href="#3-8" class="headerlink" title="3.8"></a>3.8</h4><p>grid-auto-columns 属性，<br>grid-auto-rows 属性<br>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。</p><p>grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p><p>下面的例子里面，划分好的网格是3行 x 3列，但是，8号项目指定在第4行，9号项目指定在第5行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>  grid-template-rows: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>  grid-<span class="hljs-attribute">auto</span>-rows: <span class="hljs-number">50px</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码指定新增的行高统一为50px（原始的行高为100px）。<br><img src="/imageO/gird20.jpg" alt="效果"></p><h4 id="3-9"><a href="#3-9" class="headerlink" title="3.9"></a>3.9</h4><p>grid-template 属性，<br>grid 属性<br>grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。</p><p>grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。</p><p>从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。</p><h3 id="四、项目属性"><a href="#四、项目属性" class="headerlink" title="四、项目属性"></a>四、项目属性</h3><p>下面这些属性定义在项目上面。</p><h4 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h4><p>grid-column-start 属性，<br>grid-column-end 属性，<br>grid-row-start 属性，<br>grid-row-end 属性<br>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>属性：左边框所在的垂直网格线<br>grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>属性：右边框所在的垂直网格线<br>grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>属性：上边框所在的水平网格线<br>grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>属性：下边框所在的水平网格线<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.item<span class="hljs-number">-1</span> &#123;<br>  grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">2</span>;<br>  grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码指定，1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。<br><img src="/imageO/gird21.jpg" alt="效果"><br>上图中，只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。</p><p>除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的grid-auto-flow属性决定，这个属性的默认值是row，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成column、row dense和column dense，看看其他项目的位置发生了怎样的变化。</p><p>下面的例子是指定四个边框位置的效果。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.item<span class="hljs-number">-1</span> &#123;<br>  grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;<br>  grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">3</span>;<br>  grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">2</span>;<br>  grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/imageO/gird22.jpg" alt="效果"></p><p>上面代码中，左边框和右边框的位置，都指定为网格线的名字。</p><p>这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.item<span class="hljs-number">-1</span> &#123;<br>  grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: span <span class="hljs-number">2</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面代码表示，1号项目的左边框距离右边框跨越2个网格。<br><img src="/imageO/gird23.jpg" alt="效果"><br>这与下面的代码效果完全一样。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">.<span class="hljs-built_in">item</span><span class="hljs-number">-1</span> &#123;<br>  grid-column-<span class="hljs-keyword">end</span>: span <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序。</p><h4 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h4><p>grid-column 属性，<br>grid-row 属性<br>grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.item &#123;<br>  grid-<span class="hljs-keyword">column</span>: &lt;<span class="hljs-keyword">start</span>-<span class="hljs-type">line</span>&gt; / &lt;<span class="hljs-keyword">end</span>-<span class="hljs-type">line</span>&gt;;<br>  grid-<span class="hljs-keyword">row</span>: &lt;<span class="hljs-keyword">start</span>-<span class="hljs-type">line</span>&gt; / &lt;<span class="hljs-keyword">end</span>-<span class="hljs-type">line</span>&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.item<span class="hljs-number">-1</span> &#123;<br>  grid-<span class="hljs-keyword">column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>  grid-<span class="hljs-keyword">row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">/* 等同于 */</span><br>.item<span class="hljs-number">-1</span> &#123;<br>  grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;<br>  grid-<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">3</span>;<br>  grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>: <span class="hljs-number">1</span>;<br>  grid-<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>: <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，项目item-1占据第一行，从第一根列线到第三根列线。</p><p>这两个属性之中，也可以使用span关键字，表示跨越多少个网格。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#b03532</span>;<br>  grid-column: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>  grid-row: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-comment">/* 等同于 */</span><br><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#b03532</span>;<br>  grid-column: <span class="hljs-number">1</span> / span <span class="hljs-number">2</span>;<br>  grid-row: <span class="hljs-number">1</span> / span <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，项目item-1占据的区域，包括第一行 + 第二行、第一列 + 第二列。<br><img src="/imageO/gird24.jpg" alt="效果"></p><p>斜杠以及后面的部分可以省略，默认跨越一个网格。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">.item-<span class="hljs-number">1</span> &#123;<br>  <span class="hljs-built_in">grid</span>-column: <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">grid</span>-<span class="hljs-built_in">row</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，项目item-1占据左上角第一个网格。</p><h4 id="4-3-grid-area-属性"><a href="#4-3-grid-area-属性" class="headerlink" title="4.3 grid-area 属性"></a>4.3 grid-area 属性</h4><p>grid-area属性指定项目放在哪一个区域。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">.<span class="hljs-built_in">item</span><span class="hljs-number">-1</span> &#123;<br>  grid-area: e;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，1号项目位于e区域，效果如下图。<br><img src="/imageO/gird25.jpg" alt="效果"><br>grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.item &#123;<br>  grid-area: &lt;<span class="hljs-keyword">row</span>-<span class="hljs-keyword">start</span>&gt; / &lt;<span class="hljs-keyword">column</span>-<span class="hljs-keyword">start</span>&gt; / &lt;<span class="hljs-keyword">row</span>-<span class="hljs-keyword">end</span>&gt; / &lt;<span class="hljs-keyword">column</span>-<span class="hljs-keyword">end</span>&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">.item-1 &#123;<br>  grid-area:<span class="hljs-number"> 1 </span>/<span class="hljs-number"> 1 </span>/<span class="hljs-number"> 3 </span>/ 3;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4"><a href="#4-4" class="headerlink" title="4.4"></a>4.4</h4><p>justify-self 属性，<br>align-self 属性，<br>place-self 属性<br>justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。</p><p>align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coq">.item &#123;<br>  justify-self: start | <span class="hljs-type">end</span> | <span class="hljs-type">center</span> | <span class="hljs-type">stretch</span>;<br>  align-self: start | <span class="hljs-type">end</span> | <span class="hljs-type">center</span> | <span class="hljs-type">stretch</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个属性都可以取下面四个值。</p><p>start：对齐单元格的起始边缘。<br>end：对齐单元格的结束边缘。<br>center：单元格内部居中。<br>stretch：拉伸，占满单元格的整个宽度（默认值）。<br>下面是justify-self: start的例子。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.item-1</span>  &#123;<br>  justify-self: start;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>place-self属性是align-self属性和justify-self属性的合并简写形式。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">place-<span class="hljs-literal">self</span>: &lt;align-<span class="hljs-literal">self</span>&gt; &lt;justify-<span class="hljs-literal">self</span>&gt;;<br></code></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">place-self: <span class="hljs-built_in">center</span> <span class="hljs-built_in">center</span>;<br></code></pre></td></tr></table></figure><p>如果省略第二个值，place-self属性会认为这两个值相等。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">阮一峰—CSS Grid 网格布局教程</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS Grid 网格布局教程(一)</title>
    <link href="/2021/12/27/CSSGrid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B(1)/"/>
    <url>/2021/12/27/CSSGrid%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E6%95%99%E7%A8%8B(1)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>网格布局（Grid）是最强大的 CSS 布局方案。</p><p>它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。<br><img src="/imageO/gird1.jpg" alt="效果"></p><p>上图这样的布局，就是 Grid 布局的拿手好戏。</p><p>Grid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。</p><p>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。</p><h3 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h3><p>学习 Grid 布局之前，需要了解一些基本概念。</p><h4 id="2-1-容器和项目"><a href="#2-1-容器和项目" class="headerlink" title="2.1 容器和项目"></a>2.1 容器和项目</h4><p>采用网格布局的区域，称为”容器”（container）。容器内部采用网格定位的子元素，称为”项目”（item）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面代码中，最外层的<code>&lt;div&gt;</code>元素就是容器，内层的三个<code>&lt;div&gt;</code>元素就是项目。</p><p>注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的<code>&lt;p&gt;</code>元素就不是项目。Grid 布局只对项目生效。</p><h4 id="2-2-行和列"><a href="#2-2-行和列" class="headerlink" title="2.2 行和列"></a>2.2 行和列</h4><p>容器里面的水平区域称为”行”（row），垂直区域称为”列”（column）。<br><img src="/imageO/gird2.jpg" alt="效果"></p><p>上图中，水平的深色区域就是”行”，垂直的深色区域就是”列”。</p><h4 id="2-3-单元格"><a href="#2-3-单元格" class="headerlink" title="2.3 单元格"></a>2.3 单元格</h4><p>行和列的交叉区域，称为”单元格”（cell）。</p><p>正常情况下，n行和m列会产生n x m个单元格。比如，3行3列会产生9个单元格。</p><h4 id="2-4-网格线"><a href="#2-4-网格线" class="headerlink" title="2.4 网格线"></a>2.4 网格线</h4><p>划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。</p><p>正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线，比如三行就有四根水平网格线。<br><img src="/imageO/gird3.jpg" alt="效果"></p><p>上图是一个 4 x 4 的网格，共有5根水平网格线和5根垂直网格线。</p><h3 id="三、容器属性"><a href="#三、容器属性" class="headerlink" title="三、容器属性"></a>三、容器属性</h3><p>Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。</p><h4 id="3-1-display-属性"><a href="#3-1-display-属性" class="headerlink" title="3.1 display 属性"></a>3.1 display 属性</h4><p>display: grid指定一个容器采用网格布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/imageO/gird4.jpg" alt="网格"></p><p>上图是display: grid的效果。</p><p>默认情况下，容器元素都是块级元素，但也可以设成行内元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-grid;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码指定div是一个行内元素，该元素内部采用网格布局。</p><p><img src="/imageO/gird5.jpg" alt="行内"><br>上图是display: inline-grid的效果。</p><ul><li>注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</li></ul><h4 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h4><ol><li>grid-template-columns 属性，</li><li>grid-template-rows 属性<br>容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs applescript">  &lt;span&gt;foo&lt;/span&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item item-1&quot;</span>&gt;<span class="hljs-number">1</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item item-2&quot;</span>&gt;<span class="hljs-number">2</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item item-3&quot;</span>&gt;<span class="hljs-number">3</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item item-4&quot;</span>&gt;<span class="hljs-number">4</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item item-5&quot;</span>&gt;<span class="hljs-number">5</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item item-6&quot;</span>&gt;<span class="hljs-number">6</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item item-7&quot;</span>&gt;<span class="hljs-number">7</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item item-8&quot;</span>&gt;<span class="hljs-number">8</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item item-9&quot;</span>&gt;<span class="hljs-number">9</span>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;span&gt;bar&lt;/span&gt;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;  <span class="hljs-comment">//列</span><br>  grid-template-rows: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;  <span class="hljs-comment">//行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码指定了一个三行三列的网格，列宽和行高都是100px。</p><p><img src="/imageO/gird6.jpg" alt="行内"></p><p>除了使用绝对单位，也可以使用百分比。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mel">.<span class="hljs-keyword">container</span> &#123;<br>  display: <span class="hljs-keyword">grid</span>;<br>  <span class="hljs-keyword">grid</span>-template-columns: <span class="hljs-number">33.33</span>% <span class="hljs-number">33.33</span>% <span class="hljs-number">33.33</span>%;<br>  <span class="hljs-keyword">grid</span>-template-rows: <span class="hljs-number">33.33</span>% <span class="hljs-number">33.33</span>% <span class="hljs-number">33.33</span>%;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（1）repeat"><a href="#（1）repeat" class="headerlink" title="（1）repeat()"></a>（1）repeat()</h4><p>有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用repeat()函数，简化重复的值。上面的代码用repeat()改写如下。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">33.33%</span>);<br>  grid-template-rows: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">33.33%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>repeat()接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。</p></li><li><p>repeat()重复某种模式也是可以的。</p></li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">grid</span>-template-columns: repeat(<span class="hljs-number">2</span>, <span class="hljs-number">100</span>px <span class="hljs-number">20</span>px <span class="hljs-number">80</span>px);<br></code></pre></td></tr></table></figure><p>上面代码定义了6列，第一列和第四列的宽度为100px，第二列和第五列为20px，第三列和第六列为80px。<br><img src="/imageO/gird7.jpg" alt="repeat"></p><h4 id="（2）auto-fill-关键字"><a href="#（2）auto-fill-关键字" class="headerlink" title="（2）auto-fill 关键字"></a>（2）auto-fill 关键字</h4><p>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-number">100px</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面代码表示每列宽度100px，然后自动填充，直到容器不能放置更多的列。</p><p><img src="/imageO/gird8.jpg" alt="fill"></p><h4 id="（3）fr-关键字"><a href="#（3）fr-关键字" class="headerlink" title="（3）fr 关键字"></a>（3）fr 关键字</h4><p>为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码表示两个相同宽度的列。</p><p><img src="/imageO/gird9.jpg" alt="fr"></p><p>fr可以与绝对长度的单位结合使用，这时会非常方便。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-number">150px</span> <span class="hljs-number">1</span>fr <span class="hljs-number">2</span>fr;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面代码表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。</p><p><img src="/imageO/gird10.jpg" alt="fr"></p><h4 id="（4）minmax"><a href="#（4）minmax" class="headerlink" title="（4）minmax()"></a>（4）minmax()</h4><p>minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">grid</span>-template-columns: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr minmax(<span class="hljs-number">100</span>px, <span class="hljs-number">1</span>fr);<br></code></pre></td></tr></table></figure><p>上面代码中，minmax(100px, 1fr)表示列宽不小于100px，不大于1fr。</p><h4 id="（5）auto-关键字"><a href="#（5）auto-关键字" class="headerlink" title="（5）auto 关键字"></a>（5）auto 关键字</h4><p>auto关键字表示由浏览器自己决定长度。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">grid</span>-template-columns: <span class="hljs-number">100</span>px auto <span class="hljs-number">100</span>px;<br></code></pre></td></tr></table></figure><p>上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度。</p><h4 id="（6）网格线的名称"><a href="#（6）网格线的名称" class="headerlink" title="（6）网格线的名称"></a>（6）网格线的名称</h4><p>grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">.<span class="hljs-keyword">container</span> &#123;<br>  display: grid;<br>  grid-template-columns: <span class="hljs-comment">[c1]</span> 100px <span class="hljs-comment">[c2]</span> 100px <span class="hljs-comment">[c3]</span> auto <span class="hljs-comment">[c4]</span>;<br>  grid-template-rows: <span class="hljs-comment">[r1]</span> 100px <span class="hljs-comment">[r2]</span> 100px <span class="hljs-comment">[r3]</span> auto <span class="hljs-comment">[r4]</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。</p><p>网格布局允许同一根线有多个名字，比如[fifth-line row-5]。</p><h4 id="（7）布局实例"><a href="#（7）布局实例" class="headerlink" title="（7）布局实例"></a>（7）布局实例</h4><p>grid-template-columns属性对于网页布局非常有用。两栏式布局只需要一行代码。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.<span class="hljs-keyword">wrapper</span> &#123;<br>  display: grid;<br>  grid-<span class="hljs-keyword">template</span>-<span class="hljs-keyword">columns</span>: <span class="hljs-number">70</span>% <span class="hljs-number">30</span>%;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码将左边栏设为70%，右边栏设为30%。</p><p>传统的十二网格布局，写起来也很容易。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">grid-template-<span class="hljs-attribute">columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">12</span>, <span class="hljs-number">1</span>fr);<br></code></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">阮一峰—CSS Grid 网格布局教程</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三数之和&amp;&amp;最接近的三数之和&amp;&amp;四数之和(排序+头尾双指针)</title>
    <link href="/2021/12/05/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0(3)/"/>
    <url>/2021/12/05/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0(3)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p>三数之和：<br>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。<br>注意：答案中不可以包含重复的三元组。<br>示例 1：<br>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]</p><p>示例 2：<br>输入：nums = []<br>输出：[]</p><p>示例 3：<br>输入：nums = [0]<br>输出：[]</p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><h5 id="1-方法1-暴力求解，对于三个数字，循环3次，分别计算和，时间复杂度O-n-3"><a href="#1-方法1-暴力求解，对于三个数字，循环3次，分别计算和，时间复杂度O-n-3" class="headerlink" title="1. 方法1.暴力求解，对于三个数字，循环3次，分别计算和，时间复杂度O(n^3)"></a>1. 方法1.暴力求解，对于三个数字，循环3次，分别计算和，时间复杂度O(n^3)</h5><h5 id="2-方法2-c-a-b-确定了a和b，那就可以想两数之和一样，在map中寻找-a-b-，减少一层循环，时间复杂度O-n-2-，空间复杂度O-n"><a href="#2-方法2-c-a-b-确定了a和b，那就可以想两数之和一样，在map中寻找-a-b-，减少一层循环，时间复杂度O-n-2-，空间复杂度O-n" class="headerlink" title="2. 方法2.c=-(a+b): 确定了a和b，那就可以想两数之和一样，在map中寻找-(a+b)，减少一层循环，时间复杂度O(n^2)，空间复杂度O(n)"></a>2. 方法2.c=-(a+b): 确定了a和b，那就可以想两数之和一样，在map中寻找-(a+b)，减少一层循环，时间复杂度O(n^2)，空间复杂度O(n)</h5><h5 id="3-方法3-排序然后查找"><a href="#3-方法3-排序然后查找" class="headerlink" title="3. 方法3.排序然后查找"></a>3. 方法3.排序然后查找</h5><p>思路：先排序数组，数组长度必须大于3，循环数组，假如当前循环到了i索引，则定义两个指针L = i+1，和R = nums.length-1,如果和sum=nums[i] + nums[L] + nums[R]小于0，则向右移动左指针，如果sum大于0，则左移右指针，如果sum等于0，则正好找到了这3个数，然后在尝试L++,R–，继续寻找中间是否有三个数之和等于0，注意在循环的过程中遇见相同的三个数需要去重。</p><p>注：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 去重（当前数字等于前一个数字则跳出循环）<br><span class="hljs-regexp">//</span> <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span> || nums[i] !== nums[i - <span class="hljs-number">1</span>]) <br><span class="hljs-regexp">//</span> 如果不加这个判断则输出为：有重复的数组<br><span class="hljs-regexp">//</span> Finished<br><span class="hljs-regexp">//</span> Your Input<br><span class="hljs-regexp">//</span> [-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">4</span>]<br><span class="hljs-regexp">//</span> Output (<span class="hljs-number">64</span> ms)<br><span class="hljs-regexp">//</span> [[-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<br><span class="hljs-regexp">//</span> Expected Answer<br><span class="hljs-regexp">//</span> [[-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">var threeSum = <span class="hljs-keyword">function</span> (nums) &#123;<br>  const result = [];<br>  // 对数组进行升序排序<br>  nums.sort(<span class="hljs-keyword">function</span> (a, b) &#123;<br>    <span class="hljs-keyword">return</span> a - b;<br>  &#125;)<br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>    // 去重（当前数字等于前一个数字则跳出循环）<br>    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span> || nums[i] !== nums[i - <span class="hljs-number">1</span>]) &#123;<br>      let start = i + <span class="hljs-number">1</span>; end = nums.length - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">start</span> &lt; <span class="hljs-keyword">end</span>) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] + nums[<span class="hljs-keyword">start</span>] + nums[<span class="hljs-keyword">end</span>] === <span class="hljs-number">0</span>) &#123;<br>          // push到数组中<br>          result.push([nums[i], nums[<span class="hljs-keyword">start</span>], nums[<span class="hljs-keyword">end</span>]]);<br>          <span class="hljs-keyword">start</span>++;<br>          <span class="hljs-keyword">end</span><span class="hljs-comment">--;</span><br>          // 去重<br>          <span class="hljs-keyword">while</span> (<span class="hljs-keyword">start</span> &lt; <span class="hljs-keyword">end</span> &amp;&amp; nums[<span class="hljs-keyword">start</span>] === nums[<span class="hljs-keyword">start</span> - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">start</span>++;<br>          &#125;<br>          <span class="hljs-keyword">while</span> (<span class="hljs-keyword">start</span> &lt; <span class="hljs-keyword">end</span> &amp;&amp; nums[<span class="hljs-keyword">end</span>] === nums[<span class="hljs-keyword">end</span> + <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">end</span>++;<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[<span class="hljs-keyword">start</span>] + nums[<span class="hljs-keyword">end</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">start</span>++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">end</span><span class="hljs-comment">--;</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>复杂度分析：时间复杂度O(n^2)，n为数组的长度。空间复杂度O(logn)，即排序所需要的空间</p></blockquote><h3 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a>最接近的三数之和</h3><p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。<br>返回这三个数的和。<br>假定每组输入只存在恰好一个解。<br>示例 1：<br>输入：nums = [-1,2,1,-4], target = 1<br>输出：2<br>解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</p><p>示例 2：<br>输入：nums = [0,0,0], target = 1<br>输出：0</p><h4 id="解法：固定一个数，再双指针-与三数之和解法相似"><a href="#解法：固定一个数，再双指针-与三数之和解法相似" class="headerlink" title="解法：固定一个数，再双指针(与三数之和解法相似)"></a>解法：固定一个数，再双指针(与三数之和解法相似)</h4><p> 思路</p><ol><li>先将数组从小到大排序，便于微调 sum 的大小。</li><li>从左到右遍历，先固定一个数，剩下的部分，用头尾双指针扫描</li><li>如果 sum 大于目标值，就右指针左移，使 sum 变小，否则左指针右移，sum 变大。</li><li>再看 abs(sum - target) 是否比之前更小了，如果是，将当前 sum 更新给 res<br>遍历结束，就有了最接近目标值的 sum</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">var</span> threeSumClosest = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;<br>nums.sort(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>a-b)<br><span class="hljs-keyword">let</span> res  =nums[<span class="hljs-number">0</span>]+nums[<span class="hljs-number">1</span>]+nums[nums.length-<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span>  i=<span class="hljs-number">0</span>;i&lt;nums.length-<span class="hljs-number">2</span>;i++)&#123;<br>  <span class="hljs-keyword">const</span>   n1=nums[i];<br>  <span class="hljs-keyword">let</span>  l=i+<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> r  =nums.length-<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>    <span class="hljs-keyword">const</span>  n2  = nums[l]<br>    <span class="hljs-keyword">const</span>   n3  = nums[r]<br>    <span class="hljs-keyword">const</span>   sum  = n1+n2+n3;<br>    <span class="hljs-keyword">if</span>(sum  &gt;target)&#123;<br>      r--<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      l++<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Math</span>.abs(sum-target)&lt;<span class="hljs-built_in">Math</span>.abs(res-target))&#123;<br>      res=sum;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">return</span>   res;<br>&#125;;<br><br></code></pre></td></tr></table></figure><blockquote><p>Math.abs(x) 函数返回指定数字 “x“ 的绝对值。传入一个非数字形式的字符串或者 undefined/empty 变量，将返回 NaN。传入 null 将返回 0。</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(&#x27;-<span class="hljs-number">1</span>&#x27;);     <span class="hljs-comment">// 1</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs<span class="hljs-number">(-2)</span>;       <span class="hljs-comment">// 2</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(null);     <span class="hljs-comment">// 0</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(<span class="hljs-string">&quot;string&quot;</span>); <span class="hljs-comment">// NaN</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs<span class="hljs-literal">()</span>;         <span class="hljs-comment">// NaN</span><br><br></code></pre></td></tr></table></figure><blockquote><p>复杂度分析：时间复杂度O(n^2)，n为数组的长度。空间复杂度O(logn)，即排序所需要的空间</p></blockquote><h3 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h3><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p><p>0 &lt;= a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] == target<br>你可以按 任意顺序 返回答案 。<br>示例 1：<br>输入：nums = [1,0,-1,0,-2,2], target = 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</p><p>示例 2：<br>输入：nums = [2,2,2,2,2], target = 8<br>输出：[[2,2,2,2]]</p><h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><p>思路同三数之和，注意是双重循环，注意如何去重</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> fourSum = function(nums, target) &#123;<br>    nums.<span class="hljs-built_in">sort</span>((a,b)=&gt;a-b);<br>    const  res=[];<br>    // 双层循环，外层循环一次，里面循环执行全部<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">let</span>  i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">length</span>-<span class="hljs-number">3</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">let</span>  j=i+<span class="hljs-number">1</span>;j&lt;nums.<span class="hljs-built_in">length</span>-<span class="hljs-number">2</span>;j++)&#123;<br>            <span class="hljs-built_in">let</span>  low  =j+<span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">let</span>  <span class="hljs-built_in">height</span>=nums.<span class="hljs-built_in">length</span>-<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(low&lt;<span class="hljs-built_in">height</span>)&#123;<br>                    const  <span class="hljs-built_in">sum</span>=nums[i]+nums[j]+nums[low]+nums[<span class="hljs-built_in">height</span>];<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span>===target)&#123;<br>                        res.<span class="hljs-built_in">push</span>([nums[i],nums[j],nums[low],nums[<span class="hljs-built_in">height</span>]])<br>                        <span class="hljs-keyword">while</span>(nums[low]===nums[low+<span class="hljs-number">1</span>]  )  low++;<br>                        <span class="hljs-keyword">while</span>(nums[<span class="hljs-built_in">height</span>]===nums[<span class="hljs-built_in">height</span>-<span class="hljs-number">1</span>])  <span class="hljs-built_in">height</span>--;<br>                        low++;<br>                        <span class="hljs-built_in">height</span>--;<br>                    &#125;<span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span>&lt;target)&#123;<br>                        low++<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-built_in">height</span>--;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">while</span>(nums[j]  ===nums[j+<span class="hljs-number">1</span>] )  j++;<br>        &#125;   <br>        <span class="hljs-keyword">while</span>(nums[i]===nums[i+<span class="hljs-number">1</span>])   i++;<br>    &#125;<br>    <span class="hljs-built_in">return</span>   res;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://leetcode-cn.com/problems/3sum/solution/15-san-shu-zhi-he-by-chen-wei-f-9odz/">LeetCode-Solution–三数之和</a></p>]]></content>
    
    
    <categories>
      
      <category>js算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js算法学习</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寻找两个正序数组的中位数-4(hard)</title>
    <link href="/2021/12/02/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0(2)/"/>
    <url>/2021/12/02/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0(2)/</url>
    
    <content type="html"><![CDATA[<p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。<br>算法的时间复杂度应该为 O(log (m+n)) 。<br>示例 1：<br>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2<br>示例 2：<br>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5<br>示例 3：<br>输入：nums1 = [0,0], nums2 = [0,0]<br>输出：0.00000<br>示例 4：<br>输入：nums1 = [], nums2 = [1]<br>输出：1.00000<br>示例 5：<br>输入：nums1 = [2], nums2 = []<br>输出：2.00000</p><hr><h3 id="方法一：暴力解法"><a href="#方法一：暴力解法" class="headerlink" title="方法一：暴力解法"></a>方法一：暴力解法</h3><p>简单粗暴，先将两个数组合并，两个有序数组的合并也是归并排序中的一部分。然后根据奇数，还是偶数，返回中位数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> findMedianSortedArrays = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums1, nums2</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> p1 = nums1;<br>  <span class="hljs-keyword">let</span> p2 = nums2;<br>  <span class="hljs-keyword">let</span> p3 = [...p1, ...p2]; <span class="hljs-comment">//ES6新语法很好用，p3得出来的是拼接后的数组</span><br>  <span class="hljs-keyword">let</span> p4 = p3.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b); <span class="hljs-comment">//进行从小到大排序</span><br>  n = p4.length;<br>  <span class="hljs-keyword">if</span> (!p4) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//若长度不能被2整除则为奇数，去获取他的中位数</span><br>      <span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(n / <span class="hljs-number">2</span>)<br>      <span class="hljs-keyword">return</span> p4[i]<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//若长度为偶数，寻找中间两个数字除2就为答案啦</span><br>      <span class="hljs-keyword">let</span> j = <span class="hljs-built_in">Math</span>.floor(n / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">return</span> ((p4[j] + p4[j + <span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>)<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>时间复杂度：遍历全部数组 (m+n)(m+n),   空间复杂度：开辟了一个数组，保存合并后的两个数组 O(m+n)O(m+n)</p></blockquote><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/">LeetCode-Solution</a></p>]]></content>
    
    
    <categories>
      
      <category>js算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js算法学习</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数之和--暴力解法&amp;&amp;哈希解法</title>
    <link href="/2021/12/01/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0(1)/"/>
    <url>/2021/12/01/js%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0(1)/</url>
    
    <content type="html"><![CDATA[<p>题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案。<br>示例 1：<br>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<br>示例 2：<br>输入：nums = [3,2,4], target = 6<br>输出：[1,2]<br>示例 3：<br>输入：nums = [3,3], target = 6<br>输出：[0,1]</p><hr><h3 id="方法一：暴力枚举"><a href="#方法一：暴力枚举" class="headerlink" title="方法一：暴力枚举"></a>方法一：暴力枚举</h3><p>最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。</p><p>当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。</p><p>我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> twoSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br>      <span class="hljs-keyword">if</span> (nums[i] === target - nums[j]) &#123;<br>        <span class="hljs-keyword">return</span> [i, j]<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> []<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>两次for循环进行遍历，时间复杂度：O（N^2）,空间复杂度:O(1)</p></blockquote><h3 id="方法二：哈希表-map中的has和set-get方法使用"><a href="#方法二：哈希表-map中的has和set-get方法使用" class="headerlink" title="方法二：哈希表(map中的has和set,get方法使用)"></a>方法二：哈希表(map中的has和set,get方法使用)</h3><p>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)O(1)。</p><p>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p><ol><li>Set类似于数组，但是它里面每一项的值是唯一的，没有重复的值，Set是一个构造函数，用来生成set的数据结构</li><li>Map类似于对象，也是键值对的集合，但是“键”的范围不限制于字符串，各种类型的值（包含对象）都可以当作键。Map 也可以接受一个数组作为参数，数组的成员是一个个表示键值对的数组。注意Map里面也不可以放重复的项。let map = new Map([[‘js’,’react’]]);</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">var</span> twoSum = <span class="hljs-keyword">function</span> (nums, target) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">map</span>.has(target - nums[i])) &#123;<br>      <span class="hljs-keyword">return</span> [<span class="hljs-keyword">map</span>.get(target - nums[i]), i]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">map</span>.set(nums[i], i)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> []<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>时间复杂度：O（N），空间复杂度O（N）</p></blockquote><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/">LeetCode-Solution</a></p>]]></content>
    
    
    <categories>
      
      <category>js算法学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js算法学习</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>源码学习---一行代码统一规范团队包管理器的神器(only-allow)</title>
    <link href="/2021/11/30/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0--only-allow(1)/"/>
    <url>/2021/11/30/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0--only-allow(1)/</url>
    
    <content type="html"><![CDATA[<p>场景：团队开发项目时，常常需要安装依赖，虽然一般使用文档可以说明。但不是比较强制的约束。(之前遇到一个项目在同事电脑安装依赖能运行，而我电脑安装依赖却跑不起来。后面发现是由于我node和npm的版本引起的安装依赖和运行项目失败了<a href="https://www.cnblogs.com/wangtong111/p/11861055.html">参考解决链接</a>)。假如规定是用的npm,团队中的某个同学使用其他包管理工具进行依赖的安装，且提交了。那么很大可能会直接影响到同时在该分支工作的其他同学，带来不必要的精力损耗。这时候我们可以借助工具(代码)来强制约束。</p><p>其中 Vue3 源码用了 npm 的 preinstall 钩子 约束，只能使用 pnpm 安装依赖。我们接着来看其实现：</p><hr><h3 id="Vue3-源码-amp-amp-npm-命令钩子"><a href="#Vue3-源码-amp-amp-npm-命令钩子" class="headerlink" title="Vue3 源码 &amp;&amp; npm 命令钩子"></a>Vue3 源码 &amp;&amp; npm 命令钩子</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// vue-next/package.json</span><br>&#123;<br>  <span class="hljs-attr">&quot;private&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;3.2.22&quot;</span>,<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;preinstall&quot;</span>: <span class="hljs-string">&quot;node ./scripts/preinstall.js&quot;</span>,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vala">依次执行<br><span class="hljs-meta"># install 之前执行这个脚本</span><br>preinstall<br><span class="hljs-meta"># 执行 install 脚本</span><br>install<br><span class="hljs-meta"># install 之后执行这个脚本</span><br>postinstall<br></code></pre></td></tr></table></figure><p>当然也支持自定义的命令。更多可以查看<a href="https://docs.npmjs.com/cli/v6/using-npm/scripts#pre--post-scripts">官方文档钩子</a></p><ul><li>接着我们来看 <a href="https://github1s.com/vuejs/vue-next/blob/HEAD/scripts/preinstall.js">preinstall</a> 源码。</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> vue-<span class="hljs-keyword">next</span><span class="hljs-regexp">/scripts/</span>preinstall.js<br><br><span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/pnpm/</span>.test(process.env.npm_execpath || <span class="hljs-string">&#x27;&#x27;</span>)) &#123;<br>  console.warn(<br>    `\u001b[<span class="hljs-number">33</span>mThis repository requires using pnpm as the package manager ` +<br>      ` <span class="hljs-keyword">for</span> scripts to work properly.\u001b[<span class="hljs-number">39</span>m\n`<br>  )<br>  process.<span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码也相对简单，校验如果不是 <code>pnpm</code>执行脚本则报错，退出进程。</p><p>关于 process 对象可以查看 阮一峰老师 <a href="http://javascript.ruanyifeng.com/nodejs/process.html">process 对象</a></p><blockquote><p>process.argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是 node，第二个成员是脚本文件名，其余成员是脚本文件的参数。</p></blockquote><p><img src="/imageO/29.png" alt="参考若川文章"></p><h3 id="环境准备：克隆代码"><a href="#环境准备：克隆代码" class="headerlink" title="环境准备：克隆代码"></a>环境准备：克隆代码</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 或者克隆官方仓库</span><br>git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/pnpm/</span>only-allow.git<br>cd only-allow<br><span class="hljs-comment"># npm i -g pnpm    (这行命令也要输入)</span><br>pnpm i<br></code></pre></td></tr></table></figure><p>Tips:开源项目一般先看<a href="https://github.com/pnpm/only-allow">README.md</a>。<br>readme</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs llvm">only-allow<br>Force a specific package manager <span class="hljs-keyword">to</span> be used on a project<br>强制在项目中使用特定的包管理器<br><br>Usage<br>Add a preinstall script <span class="hljs-keyword">to</span> your project&#x27;s package.json.<br><br>If you want <span class="hljs-keyword">to</span> force npm<span class="hljs-punctuation">,</span> <span class="hljs-keyword">add</span>:<br><br>&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;preinstall&quot;</span>: <span class="hljs-string">&quot;npx only-allow npm&quot;</span><br>  &#125;<br>&#125;<br>If you want <span class="hljs-keyword">to</span> force pnpm<span class="hljs-punctuation">,</span> <span class="hljs-keyword">add</span>:<br><br>&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;preinstall&quot;</span>: <span class="hljs-string">&quot;npx only-allow pnpm&quot;</span><br>  &#125;<br>&#125;<br>If you want <span class="hljs-keyword">to</span> force yarn<span class="hljs-punctuation">,</span> <span class="hljs-keyword">add</span>:<br><br>&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;preinstall&quot;</span>: <span class="hljs-string">&quot;npx only-allow yarn&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>目录结构：</p><p><img src="/imageO/28.png" alt="项目目录结构"></p><h3 id="调试源码"><a href="#调试源码" class="headerlink" title="调试源码"></a>调试源码</h3><p>查看 package.json 文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// only-allow/package.json</span><br>&#123;<br>  <span class="hljs-attr">&quot;bin&quot;</span>: <span class="hljs-string">&quot;bin.js&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>确定主入口文件为 only-allow/bin.js。</p><p>在最新版的 VSCode 中，auto attach 功能，默认支持智能调试，如果发现不支持，可以通过快捷键 ctrl + shift + p 查看是否启用。</p><p>于是我们在 only-allow/package.json 文件中，添加如下命令。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// only-allow/package.json</span><br>&#123;<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;preinstall&quot;</span>: <span class="hljs-string">&quot;node bin.js pnpm&quot;</span><br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>可以提前在 only-allow/bin.js 文件打上断点 const usedPM = whichPMRuns()</p><p><img src="/imageO/30.png" alt="打断点"></p><p>然后：<br>输入如下 yarn add release-it -D  (或者  npm  i) 命令，即可调试 only-allow/bin.js。</p><p>安装yarn可直接进入此电脑cmd输入安装命令:(npm install -g yarn)</p><p>查看版本：yarn –version<br><img src="/imageO/31.png" alt="输入命令"></p><h3 id="only-allow-源码"><a href="#only-allow-源码" class="headerlink" title="only-allow 源码"></a>only-allow 源码</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// only-allow/bin.js</span><br>#!/usr/bin/env node<br>const whichPMRuns = require(<span class="hljs-symbol">&#x27;which</span>-pm-runs&#x27;)<br>const boxen = require(<span class="hljs-symbol">&#x27;boxe</span>n&#x27;)<br><br>const argv = process.argv.slice(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">if</span> (argv.length === <span class="hljs-number">0</span>) &#123;<br>  console.log(<span class="hljs-symbol">&#x27;Please</span> specify the wanted <span class="hljs-keyword">package</span> manager: only-allow &lt;npm|pnpm|yarn&gt;&#x27;)<br>  process.exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-comment">// 第一个参数则是 用户传入的希望使用的包管理器</span><br><span class="hljs-comment">// 比如 npx only-allow pnpm </span><br><span class="hljs-comment">// 这里调试是 node bin.js pnpm</span><br>const wantedPM = argv[<span class="hljs-number">0</span>]<br><span class="hljs-comment">// npm pnpm yarn 都不是，则报错</span><br><span class="hljs-keyword">if</span> (wantedPM !== <span class="hljs-symbol">&#x27;np</span>m&#x27; &amp;&amp; wantedPM !== <span class="hljs-symbol">&#x27;pnp</span>m&#x27; &amp;&amp; wantedPM !== <span class="hljs-symbol">&#x27;yar</span>n&#x27;) &#123;<br>  console.log(`<span class="hljs-string">&quot;$&#123;wantedPM&#125;&quot;</span> is not a valid <span class="hljs-keyword">package</span> manager. <span class="hljs-type">Available</span> <span class="hljs-keyword">package</span> managers are: npm, pnpm, or yarn.`)<br>  process.exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-comment">// 使用的包管理器</span><br>const usedPM = whichPMRuns()<br><span class="hljs-comment">// 希望使用的包管理器 不相等，则报错。</span><br><span class="hljs-comment">// - npm  提示使用 npm install</span><br><span class="hljs-comment">// - pnpm 提示使用 pnpm install</span><br><span class="hljs-comment">// - yarn 提示使用 yarn install</span><br><span class="hljs-comment">// 最后退出进程</span><br><span class="hljs-keyword">if</span> (usedPM &amp;&amp; usedPM.name !== wantedPM) &#123;<br>  const boxenOpts = &#123; borderColor: <span class="hljs-symbol">&#x27;re</span>d&#x27;, borderStyle: <span class="hljs-symbol">&#x27;doubl</span>e&#x27;, padding: <span class="hljs-number">1</span> &#125;<br>  switch (wantedPM) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-symbol">&#x27;np</span>m&#x27;:<br>      console.log(boxen(<span class="hljs-symbol">&#x27;Use</span> <span class="hljs-string">&quot;npm install&quot;</span> <span class="hljs-keyword">for</span> installation in <span class="hljs-keyword">this</span> project&#x27;, boxenOpts))<br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-symbol">&#x27;pnp</span>m&#x27;:<br>      console.log(boxen(`<span class="hljs-type">Use</span> <span class="hljs-string">&quot;pnpm install&quot;</span> <span class="hljs-keyword">for</span> installation in <span class="hljs-keyword">this</span> project.<br><br><span class="hljs-type">If</span> you don<span class="hljs-symbol">&#x27;t</span> have pnpm, install it via <span class="hljs-string">&quot;npm i -g pnpm&quot;</span>.<br><span class="hljs-type">For</span> more details, go to https:<span class="hljs-comment">//pnpm.js.org/`, boxenOpts))</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-symbol">&#x27;yar</span>n&#x27;:<br>      console.log(boxen(`<span class="hljs-type">Use</span> <span class="hljs-string">&quot;yarn&quot;</span> <span class="hljs-keyword">for</span> installation in <span class="hljs-keyword">this</span> project.<br><br><span class="hljs-type">If</span> you don<span class="hljs-symbol">&#x27;t</span> have <span class="hljs-type">Yarn</span>, install it via <span class="hljs-string">&quot;npm i -g yarn&quot;</span>.<br><span class="hljs-type">For</span> more details, go to https:<span class="hljs-comment">//yarnpkg.com/`, boxenOpts))</span><br>      <span class="hljs-keyword">break</span><br>  &#125;<br>  process.exit(<span class="hljs-number">1</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过本文，我们了解了 npm 的脚本钩子和 process 的简单应用。only-allow 通过获取系统环境运行时的信息，和预设好的参数信息进行对比，来限制预期外包管理器的使用。</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/7033560885050212389?share_token=999a177b-d1e2-4e96-8c8e-c9f5ff186f7c#heading-6">从 vue3 和 vite 源码中，我学到了一行代码统一规范团队包管理器的神器</a></p>]]></content>
    
    
    <categories>
      
      <category>源码学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端进阶</tag>
      
      <tag>源码学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>玩转 Vue 3 全家桶--初始Vue3(1)</title>
    <link href="/2021/11/17/Vue3Study(1)/"/>
    <url>/2021/11/17/Vue3Study(1)/</url>
    
    <content type="html"><![CDATA[<p>2021 年的前端范畴已经今非昔比，从最早的做页面，到现在的工程化、监控、跨端，薪资水涨船高的同时，也对从业者提出了更高的要求：不能只会做页面，而是要全面地拥抱计算机知识体系，比如算法、设计模式、编译原理等计算机专业知识，这也是现在各大厂面试的主要考察点。对于这些考察点，只有一小部分面试者有过系统的学习，大部分面试者都只是零散地学习过其中的某些内容，也就是说前端这个岗位的断层其实非常严重。由于大学计算机专业不教系统性的前端开发课程，所以大部分前端工程师都跟我一样，是由兴趣和爱好驱动</p><p>以下是基于Vue全家桶的学习记录</p><hr><h3 id="现在很多前端工程师进阶困难的痛点就是，没有体系化的学"><a href="#现在很多前端工程师进阶困难的痛点就是，没有体系化的学" class="headerlink" title="现在很多前端工程师进阶困难的痛点就是，没有体系化的学"></a>现在很多前端工程师进阶困难的痛点就是，没有体系化的学</h3><p><strong>为了防止你的顿悟仅仅相当于别人的基础水平</strong>，我们需要体系化和系统化地探索前端开发这座冰山。这就意味着，我们学习的不仅仅是表面的增删改查，而是底层的工程化、框架，还有海底的计算机知识体系。</p><h3 id="为什么要学-Vue-3"><a href="#为什么要学-Vue-3" class="headerlink" title="为什么要学 Vue 3"></a>为什么要学 Vue 3</h3><p>在目前的前端开发中，流行的框架相信你并不陌生。它们的目标都是为了帮助开发者高效地开发 Web 应用，只不过走的路线略显不同，比如 <code>React 注重数据不可变、虚拟 DOM 和运行时；而 Svelte 运行时都非常轻量级，侧重在于编译时的优化；Angular 则在抽象这个维度又走向一个极致，生来就是为了复杂项目。</code></p><p>每个流行框架的内部，都有一大堆的最佳实践。而相比之下，Vue 就简单多了，简单到大部分前端开发者都能学得会。Vue 在每个维度之间，做了非常好的权衡和取舍，算是一个非常中庸且优雅的框架，兼顾响应式、虚拟 DOM、运行时和编译优化。</p><p>而且 Vue 3 作为 Vue 框架最新的版本，有很多优秀的设计相信你会非常喜欢，例如 Composition 组合 API、基于 Proxy 的响应式系统、自定义渲染器等。</p><p>这些设计可以让我们以很轻松的方式，从最熟悉的框架逐渐深入底层。学习 Vue 3 的同时，我们就可以去回顾 Vue 1 和 Vue 2，直观地感受 Vue 框架发展的过程。在此基础上，<strong>我们再去横向对比 Angular、React、Svelte 等框架，最终是可以把学到的知识点串成一个网络的。这不仅是加强记忆那么简单，还能大大开阔你的前端视野。</strong></p><p><img src="/image/vue3.1.png" alt="Vue和React的知识"></p><h3 id="学习Vue3"><a href="#学习Vue3" class="headerlink" title="学习Vue3"></a>学习Vue3</h3><p>全家桶实战篇–我们将主要学习 Vue 3 的⽣态，包括 Vue-cli、Vite、Vuex、Vue-router、Devtools 等生态库，以及实战开发中需要的库，比如 Vue 3 中集成 JSX、单元测试、服务端渲染 SSR。这⼀模块学完，我们就能全副武装，应对复杂的项⽬开发也就不成问题了。<br><img src="/image/vue3.2.png" alt="学习 Vue 3"></p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://time.geekbang.org/column/article/427605">开篇词 | 如何借助Vue 3建构你的前端知识体系？</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript 学习二</title>
    <link href="/2021/08/04/TS%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
    <url>/2021/08/04/TS%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="四、TypeScript-函数"><a href="#四、TypeScript-函数" class="headerlink" title="四、TypeScript 函数"></a>四、TypeScript 函数</h3><ol><li>TypeScript 函数与 JavaScript 函数的区别</li></ol><p><img src="/imageO/26.png" alt="如图"></p><ol start="2"><li>箭头函数</li></ol><p>1.常见语法</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">myBooks.forEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;reading&#x27;</span>));<br><br>myBooks.forEach(title =&gt; <span class="hljs-built_in">console</span>.log(title));<br><br>myBooks.forEach(<span class="hljs-function"><span class="hljs-params">(title, idx, arr)</span> =&gt;</span><br>  <span class="hljs-built_in">console</span>.log(idx + <span class="hljs-string">&#x27;-&#x27;</span> + title);<br>);<br><br>myBooks.forEach(<span class="hljs-function"><span class="hljs-params">(title, idx, arr)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(idx + <span class="hljs-string">&#x27;-&#x27;</span> + title);<br>&#125;);<br></code></pre></td></tr></table></figure><p>2.使用示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 未使用箭头函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Book</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> self = <span class="hljs-built_in">this</span>;<br>  self.publishDate = <span class="hljs-number">2016</span>;<br>  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(self.publishDate);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-comment">// 使用箭头函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Book</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.publishDate = <span class="hljs-number">2016</span>;<br>  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.publishDate);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>参数类型和返回类型</li></ol><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">function</span> createUserId<span class="hljs-built_in">(name</span>:<span class="hljs-built_in"> string</span>,<span class="hljs-built_in"> id</span>:<span class="hljs-built_in"> number</span>):<span class="hljs-built_in"> string</span> &#123;<br>  <span class="hljs-keyword">return</span><span class="hljs-built_in"> name</span> +<span class="hljs-built_in"> id</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>函数类型</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> IdGenerator:<span class="hljs-function"> (<span class="hljs-params">chars</span>: <span class="hljs-params">string</span>, <span class="hljs-params">nums</span>: <span class="hljs-params">number</span>) =&gt;</span> <span class="hljs-built_in">string</span>;<br><br><span class="hljs-keyword">function</span> create<span class="hljs-constructor">UserId(<span class="hljs-params">name</span>: <span class="hljs-params">string</span>, <span class="hljs-params">id</span>: <span class="hljs-params">number</span>)</span>: <span class="hljs-built_in">string</span> &#123;<br>  return name + id;<br>&#125;<br><br>IdGenerator = createUserId;<br></code></pre></td></tr></table></figure><ol start="5"><li>可选参数及默认参数</li></ol><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xquery">// 可选参数<br><span class="hljs-keyword">function</span> createUserId<span class="hljs-built_in">(name</span>:<span class="hljs-built_in"> string</span>,<span class="hljs-built_in"> id</span>:<span class="hljs-built_in"> number</span>, age?:<span class="hljs-built_in"> number</span>):<span class="hljs-built_in"> string</span> &#123;<br>  <span class="hljs-keyword">return</span><span class="hljs-built_in"> name</span> +<span class="hljs-built_in"> id</span>;<br>&#125;<br><br>// 默认参数<br><span class="hljs-keyword">function</span> createUserId(<br> <span class="hljs-built_in"> name</span>:<span class="hljs-built_in"> string</span> = <span class="hljs-string">&quot;Semlinker&quot;</span>,<br> <span class="hljs-built_in"> id</span>:<span class="hljs-built_in"> number</span>,<br>  age?:<span class="hljs-built_in"> number</span><br>):<span class="hljs-built_in"> string</span> &#123;<br>  <span class="hljs-keyword">return</span><span class="hljs-built_in"> name</span> +<span class="hljs-built_in"> id</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在声明函数时，可以通过 ? 号来定义可选参数，比如 age?: number 这种形式。在实际使用时，需要注意的是可选参数要放在普通参数的后面，不然会导致编译错误。</p><ol start="6"><li>剩余参数</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span><span class="hljs-params">(array, <span class="hljs-rest_arg">...items</span>)</span> </span>&#123;<br>  items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(item)</span> </span>&#123;<br>    array.push(item);<br>  &#125;);<br>&#125;<br><br>let a = [];<br>push(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><ol start="7"><li>函数重载</li></ol><p>函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。要解决前面遇到的问题，方法就是为同一个函数提供多个函数类型定义来进行函数重载，编译器会根据这个列表去处理函数的调用。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">add</span>(<span class="hljs-attribute">a</span>: number, <span class="hljs-attribute">b</span>: number): <span class="hljs-selector-tag">number</span>;<br><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">add</span>(<span class="hljs-attribute">a</span>: string, <span class="hljs-attribute">b</span>: string): <span class="hljs-selector-tag">string</span>;<br><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">add</span>(<span class="hljs-attribute">a</span>: string, <span class="hljs-attribute">b</span>: number): <span class="hljs-selector-tag">string</span>;<br><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">add</span>(<span class="hljs-attribute">a</span>: number, <span class="hljs-attribute">b</span>: string): <span class="hljs-selector-tag">string</span>;<br><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">add</span>(<span class="hljs-attribute">a</span>: Combinable, <span class="hljs-attribute">b</span>: Combinable) &#123;<br>  <span class="hljs-selector-tag">if</span> (typeof a === <span class="hljs-string">&quot;string&quot;</span> || typeof b === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.toString</span>() + <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.toString</span>();<br>  &#125;<br>  <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在以上代码中，我们为 add 函数提供了多个函数类型定义，从而实现函数的重载。之后，可恶的错误消息又消失了，因为这时 result 变量的类型是 string 类型。在 TypeScript 中除了可以重载普通函数之外，我们还可以重载类中的成员方法。</p><p>方法重载是指在同一个类中方法同名，参数不同（参数类型不同、参数个数不同或参数个数相同时参数的先后顺序不同），调用时根据实参的形式，选择与它匹配的方法执行操作的一种技术。所以类中成员方法满足重载的条件是：在同一个类中，方法名相同且参数列表不同。下面我们来举一个成员方法重载的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> </span>&#123;<br>  add(a: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;<br>  add(a: <span class="hljs-built_in">string</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;<br>  add(a: <span class="hljs-built_in">string</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>;<br>  add(a: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;<br>  <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">a: Combinable, b: Combinable</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">&quot;string&quot;</span> || <span class="hljs-keyword">typeof</span> b === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>      <span class="hljs-keyword">return</span> a.toString() + b.toString();<br>    &#125;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> calculator = <span class="hljs-keyword">new</span> Calculator();<br><span class="hljs-keyword">const</span> result = calculator.add(<span class="hljs-string">&quot;Semlinker&quot;</span>, <span class="hljs-string">&quot; Kakuqo&quot;</span>);<br></code></pre></td></tr></table></figure><p>这里需要注意的是，当 TypeScript 编译器处理函数重载时，它会查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。另外在 Calculator 类中，add(a: Combinable, b: Combinable){ } 并不是重载列表的一部分，因此对于 add 成员方法来说，我们只定义了四个重载方法。</p><ol start="8"><li>ypeScript 数组</li></ol><p>8.1 数组解构</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">number</span>; <span class="hljs-keyword">let</span> y: <span class="hljs-built_in">number</span>; <span class="hljs-keyword">let</span> z: <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">let</span> five_array = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br>[x,y,z] = five_array;<br></code></pre></td></tr></table></figure><p>8.2 数组展开运算符</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">two_array</span> = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-attr">five_array</span> = [...two_array, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br></code></pre></td></tr></table></figure><p>8.3 数组遍历</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> colors: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> i of colors) &#123;<br>  console.<span class="hljs-built_in">log</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="9"><li>TypeScript 对象</li></ol><p>9.1 对象解构</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">let</span> person = &#123;<br> <span class="hljs-built_in"> name</span>: <span class="hljs-string">&quot;Semlinker&quot;</span>,<br>  gender: <span class="hljs-string">&quot;Male&quot;</span>,<br>&#125;;<br><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-built_in"> name</span>, gender &#125; = person;<br></code></pre></td></tr></table></figure><p>9.2 对象展开运算符</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">let</span> person = &#123;<br>  name: <span class="hljs-string">&quot;Semlinker&quot;</span>,<br>  gender: <span class="hljs-string">&quot;Male&quot;</span>,<br>  address: <span class="hljs-string">&quot;Xiamen&quot;</span>,<br>&#125;;<br><br><span class="hljs-comment">// 组装对象</span><br><span class="hljs-keyword">let</span> personWithAge = &#123; <span class="hljs-params">...</span>person, age: <span class="hljs-number">33</span> &#125;;<br><br><span class="hljs-comment">// 获取除了某些项外的其它项</span><br><span class="hljs-keyword">let</span> &#123; name, <span class="hljs-params">...</span>rest &#125; = person;<br></code></pre></td></tr></table></figure><h3 id="五、TypeScript-接口"><a href="#五、TypeScript-接口" class="headerlink" title="五、TypeScript 接口"></a>五、TypeScript 接口</h3><p>在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。</p><p>TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。</p><p>10.1 对象的形状</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts">interface <span class="hljs-class">Person </span>&#123;<br><span class="hljs-symbol">  name:</span> string;<br><span class="hljs-symbol">  age:</span> number;<br>&#125;<br><br>let Semlinker: Person = &#123;<br><span class="hljs-symbol">  name:</span> <span class="hljs-string">&quot;Semlinker&quot;</span>,<br><span class="hljs-symbol">  age:</span> <span class="hljs-number">33</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>10.2 可选 | 只读属性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Person &#123;<br>  <span class="hljs-keyword">readonly</span> name: <span class="hljs-built_in">string</span>;<br>  age?: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScript 还提供了 ReadonlyArray<T> 类型，它与 Array<T> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">let a: number[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>let ro: ReadonlyArray&lt;number&gt; = a;<br>ro[<span class="hljs-number">0</span>] = <span class="hljs-number">12</span>; <span class="hljs-regexp">//</span> error!<br>ro.push(<span class="hljs-number">5</span>); <span class="hljs-regexp">//</span> error!<br>ro.length = <span class="hljs-number">100</span>; <span class="hljs-regexp">//</span> error!<br>a = ro; <span class="hljs-regexp">//</span> error!<br><br></code></pre></td></tr></table></figure><h3 id="六、TypeScript-类"><a href="#六、TypeScript-类" class="headerlink" title="六、TypeScript 类"></a>六、TypeScript 类</h3><p>11.1 类的属性与方法<br>在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。</p><p>在 TypeScript 中，我们可以通过 Class 关键字来定义一个类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeter</span> </span>&#123;<br>  <span class="hljs-comment">// 静态属性</span><br>  <span class="hljs-keyword">static</span> cname: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;Greeter&quot;</span>;<br>  <span class="hljs-comment">// 成员属性</span><br>  greeting: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-comment">// 构造函数 - 执行初始化操作</span><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.greeting = message;<br>  &#125;<br><br>  <span class="hljs-comment">// 静态方法</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getClassName</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Class name is Greeter&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 成员方法</span><br>  <span class="hljs-function"><span class="hljs-title">greet</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-built_in">this</span>.greeting;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> greeter = <span class="hljs-keyword">new</span> Greeter(<span class="hljs-string">&quot;world&quot;</span>);<br></code></pre></td></tr></table></figure><p>那么成员属性与静态属性，成员方法与静态方法有什么区别呢？这里无需过多解释，我们直接看一下以下编译生成的 ES5 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">var</span> Greeter = <span class="hljs-comment">/** <span class="hljs-doctag">@class </span>*/</span> (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 构造函数 - 执行初始化操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeter</span>(<span class="hljs-params">message</span>) </span>&#123;<br>        <span class="hljs-built_in">this</span>.greeting = message;<br>    &#125;<br>    <span class="hljs-comment">// 静态方法</span><br>    Greeter.getClassName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Class name is Greeter&quot;</span>;<br>    &#125;;<br>    <span class="hljs-comment">// 成员方法</span><br>    Greeter.prototype.greet = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-built_in">this</span>.greeting;<br>    &#125;;<br>    <span class="hljs-comment">// 静态属性</span><br>    Greeter.cname = <span class="hljs-string">&quot;Greeter&quot;</span>;<br>    <span class="hljs-keyword">return</span> Greeter;<br>&#125;());<br><span class="hljs-keyword">var</span> greeter = <span class="hljs-keyword">new</span> Greeter(<span class="hljs-string">&quot;world&quot;</span>);<br></code></pre></td></tr></table></figure><p>11.2 访问器<br>在 TypeScript 中，我们可以通过 getter 和 setter 方法来实现数据的封装和有效性校验，防止出现异常数据。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> passcode = <span class="hljs-string">&quot;Hello TypeScript&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> _fullName: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">fullName</span>(): <span class="hljs-title">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._fullName;<br>  &#125;<br><br>  <span class="hljs-keyword">set</span> <span class="hljs-title">fullName</span>(<span class="hljs-params">newName: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (passcode &amp;&amp; passcode == <span class="hljs-string">&quot;Hello TypeScript&quot;</span>) &#123;<br>      <span class="hljs-built_in">this</span>._fullName = newName;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Error: Unauthorized update of employee!&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> employee = <span class="hljs-keyword">new</span> Employee();<br>employee.fullName = <span class="hljs-string">&quot;Semlinker&quot;</span>;<br><span class="hljs-keyword">if</span> (employee.fullName) &#123;<br>  <span class="hljs-built_in">console</span>.log(employee.fullName);<br>&#125;<br></code></pre></td></tr></table></figure><p>11.3 类的继承<br>继承 (Inheritance) 是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。</p><p>继承是一种 is-a 关系：</p><p>在 TypeScript 中，我们可以通过 extends 关键字来实现继承：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  <br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = theName;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-title">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Snake</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name);<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-title">move</span>(<span class="hljs-params">distanceInMeters = <span class="hljs-number">5</span></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Slithering...&quot;</span>);<br>    <span class="hljs-built_in">super</span>.move(distanceInMeters);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> sam = <span class="hljs-keyword">new</span> Snake(<span class="hljs-string">&quot;Sammy the Python&quot;</span>);<br>sam.move();<br></code></pre></td></tr></table></figure><p>11.4 ECMAScript 私有字段<br>在 TypeScript 3.8 版本就开始支持ECMAScript 私有字段，使用方式如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  #name: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.#name = name;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">greet</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.#name&#125;</span>!`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> semlinker = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Semlinker&quot;</span>);<br><br>semlinker.#name;<br><span class="hljs-comment">//     ~~~~~</span><br><span class="hljs-comment">// Property &#x27;#name&#x27; is not accessible outside class &#x27;Person&#x27;</span><br><span class="hljs-comment">// because it has a private identifier.</span><br></code></pre></td></tr></table></figure><p>与常规属性（甚至使用 private 修饰符声明的属性）不同，私有字段要牢记以下规则：</p><ul><li>私有字段以 # 字符开头，有时我们称之为私有名称；</li><li>每个私有字段名称都唯一地限定于其包含的类；</li><li>不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）；</li><li>私有字段不能在包含的类之外访问，甚至不能被检测到。</li></ul><h3 id="七、TypeScript-泛型"><a href="#七、TypeScript-泛型" class="headerlink" title="七、TypeScript 泛型"></a>七、TypeScript 泛型</h3><p>软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p><blockquote><p>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p></blockquote><p>设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。</p><p>泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。</p><p>12.1 泛型接口</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span> <span class="hljs-symbol">GenericIdentityFn</span>&lt;<span class="hljs-symbol">T</span>&gt; &#123;<br>  (arg: T): T;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>12.2 泛型类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericNumber</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  zeroValue: T;<br>  add: <span class="hljs-function">(<span class="hljs-params">x: T, y: T</span>) =&gt;</span> T;<br>&#125;<br><br><span class="hljs-keyword">let</span> myGenericNumber = <span class="hljs-keyword">new</span> GenericNumber&lt;<span class="hljs-built_in">number</span>&gt;();<br>myGenericNumber.zeroValue = <span class="hljs-number">0</span>;<br>myGenericNumber.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br></code></pre></td></tr></table></figure><p>12.3 泛型变量</p><p>对刚接触 TypeScript 泛型的小伙伴来说，看到 T 和 E，还有 K 和 V 这些泛型变量时，估计会一脸懵逼。其实这些大写字母并没有什么本质的区别，只不过是一个约定好的规范而已。也就是说使用大写字母 A-Z 定义的类型变量都属于泛型，把 T 换成 A，也是一样的。下面我们介绍一下一些常见泛型变量代表的意思：</p><ul><li>在T（Type）：表示一个 TypeScript 类型</li><li>K（Key）：表示对象中的键类型</li><li>V（Value）：表示对象中的值类型</li><li>E（Element）：表示元素类型</li></ul><p>12.4 泛型工具类型<br>为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。出于篇幅考虑，这里我们只简单介绍 Partial 工具类型。不过在具体介绍之前，我们得先介绍一些相关的基础知识，方便读者自行学习其它的工具类型。</p><p>1.typeof</p><p>在 TypeScript 中，typeof 操作符可以用来获取一个变量声明或对象的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Person &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  age: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> sem: Person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;semlinker&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;;<br><span class="hljs-keyword">type</span> Sem= <span class="hljs-keyword">typeof</span> sem; <span class="hljs-comment">// -&gt; Person</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toArray</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">Array</span>&lt;<span class="hljs-title">number</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">return</span> [x];<br>&#125;<br><br><span class="hljs-keyword">type</span> Func = <span class="hljs-keyword">typeof</span> toArray; <span class="hljs-comment">// -&gt; (x: number) =&gt; number[]</span><br></code></pre></td></tr></table></figure><p>2.keyof</p><p>keyof 操作符可以用来一个对象中的所有 key 值：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">interface Person &#123;<br>    name: <span class="hljs-keyword">string</span>;<br>    age: <span class="hljs-keyword">number</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> K1 = keyof Person; // <span class="hljs-string">&quot;name&quot;</span> | <span class="hljs-string">&quot;age&quot;</span><br><span class="hljs-keyword">type</span> K2 = keyof Person[]; // <span class="hljs-string">&quot;length&quot;</span> | <span class="hljs-string">&quot;toString&quot;</span> | <span class="hljs-string">&quot;pop&quot;</span> | <span class="hljs-string">&quot;push&quot;</span> | <span class="hljs-string">&quot;concat&quot;</span> | <span class="hljs-string">&quot;join&quot;</span><br><span class="hljs-keyword">type</span> K3 = keyof &#123; [x: <span class="hljs-keyword">string</span>]: Person &#125;;  // <span class="hljs-keyword">string</span> | <span class="hljs-keyword">number</span><br></code></pre></td></tr></table></figure><p>3.in</p><p>in 用来遍历枚举类型：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">type</span> <span class="hljs-type">Keys</span> = <span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> | <span class="hljs-string">&quot;c&quot;</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-type">Obj</span> =  &#123;<br>  [p <span class="hljs-keyword">in</span> <span class="hljs-type">Keys</span>]: <span class="hljs-built_in">any</span><br>&#125; // -&gt; &#123; a: <span class="hljs-built_in">any</span>, b: <span class="hljs-built_in">any</span>, c: <span class="hljs-built_in">any</span> &#125;<br></code></pre></td></tr></table></figure><p>4.infer</p><p>在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">type</span> ReturnType&lt;T&gt; = T <span class="hljs-keyword">extends</span> (<br>  ...args: <span class="hljs-built_in">any</span>[]<br>) =&gt; infer R ? R : <span class="hljs-built_in">any</span>;<br></code></pre></td></tr></table></figure><p>以上代码中 infer R 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。</p><p>5.extends</p><p>有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">interface</span> ILengthwise &#123;<br>  length: <span class="hljs-keyword">number</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span></span> loggingIdentity&lt;T <span class="hljs-keyword">extends</span> ILengthwise&gt;(arg: T): T &#123;<br>  console.<span class="hljs-built_in">log</span>(arg.length);<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">loggingIdentity</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// Error, number doesn&#x27;t have a .length property</span><br></code></pre></td></tr></table></figure><p>这时我们需要传入符合约束类型的值，必须包含必须的属性：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">logging<span class="hljs-constructor">Identity(&#123;<span class="hljs-params">length</span>: 10, <span class="hljs-params">value</span>: 3&#125;)</span>;<br></code></pre></td></tr></table></figure><p>6.Partial</p><p>Partial<T> 的作用就是将某个类型里的属性全部变为可选项 ?。</p><p>定义：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs elm">/**<br><br>* node_modules/typescript/lib/lib.es5.d.ts<br>* <span class="hljs-type">Make</span> all properties <span class="hljs-keyword">in</span> <span class="hljs-type">T</span> optional<br> */<br><span class="hljs-keyword">type</span> <span class="hljs-type">Partial</span>&lt;<span class="hljs-type">T</span>&gt; = &#123;<br>  [<span class="hljs-type">P</span> in keyof <span class="hljs-type">T</span>]?: <span class="hljs-type">T</span>[<span class="hljs-type">P</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>在以上代码中，首先通过 keyof T 拿到 T 的所有属性名，然后使用 in 进行遍历，将值赋给 P，最后通过 T[P] 取得相应的属性值。中间的 ? 号，用于将所有属性变为可选。</p><p>示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> Todo &#123;<br>  title: <span class="hljs-built_in">string</span>;<br>  description: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateTodo</span>(<span class="hljs-params">todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123; ...todo, ...fieldsToUpdate &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> todo1 = &#123;<br>  title: <span class="hljs-string">&quot;organize desk&quot;</span>,<br>  description: <span class="hljs-string">&quot;clear clutter&quot;</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> todo2 = updateTodo(todo1, &#123;<br>  description: <span class="hljs-string">&quot;throw out trash&quot;</span>,<br>&#125;);<br><br>在上面的 updateTodo 方法中，我们利用 Partial&lt;T&gt; 工具类型，定义 fieldsToUpdate 的类型为 Partial&lt;Todo&gt;，即：<br><br>&#123;<br>   title?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;<br>   description?: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="八、TypeScript-装饰器"><a href="#八、TypeScript-装饰器" class="headerlink" title="八、TypeScript 装饰器"></a>八、TypeScript 装饰器</h3><p>13.1 装饰器是什么</p><ul><li>它是一个表达式</li><li>该表达式被执行后，返回一个函数</li><li>函数的入参分别为 target、name 和 descriptor</li><li>执行该函数后，可能返回 descriptor 对象，用于配置 target 对象</li></ul><p>13.2 装饰器的分类</p><ul><li>类装饰器（Class decorators）</li><li>属性装饰器（Property decorators）</li><li>方法装饰器（Method decorators）</li><li>参数装饰器（Parameter decorators）</li></ul><p>13.3 类装饰器<br>类装饰器声明：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">declare</span> type ClassDecorator = &lt;TFunction <span class="hljs-keyword">extends</span> <span class="hljs-function"><span class="hljs-keyword">Function</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  target: TFunction</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) =&gt;</span> TFunction | <span class="hljs-keyword">void</span>;<br></code></pre></td></tr></table></figure><p>类装饰器顾名思义，就是用来装饰类的。它接收一个参数：</p><ul><li>target: TFunction - 被装饰的类<br>看完第一眼后，是不是感觉都不好了。没事，我们马上来个例子：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeter</span>(<span class="hljs-params">target: <span class="hljs-built_in">Function</span></span>): <span class="hljs-title">void</span> </span>&#123;<br>  target.prototype.greet = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello Semlinker!&quot;</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-meta">@Greeter</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeting</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 内部实现</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> myGreeting = <span class="hljs-keyword">new</span> Greeting();<br>myGreeting.greet(); <span class="hljs-comment">// console output: &#x27;Hello Semlinker!&#x27;;</span><br></code></pre></td></tr></table></figure><p>上面的例子中，我们定义了 Greeter 类装饰器，同时我们使用了 @Greeter 语法糖，来使用装饰器。</p><blockquote><p>友情提示：读者可以直接复制上面的代码，在 TypeScript Playground 中运行查看结果。</p></blockquote><p>有的读者可能想问，例子中总是输出 Hello Semlinker! ，能自定义输出的问候语么 ？这个问题很好，答案是可以的。</p><p>具体实现如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeter</span>(<span class="hljs-params">greeting: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target: <span class="hljs-built_in">Function</span></span>) </span>&#123;<br>    target.prototype.greet = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(greeting);<br>    &#125;;<br>  &#125;;<br>&#125;<br><br><span class="hljs-meta">@Greeter</span>(<span class="hljs-string">&quot;Hello TS!&quot;</span>)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeting</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 内部实现</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> myGreeting = <span class="hljs-keyword">new</span> Greeting();<br>myGreeting.greet(); <span class="hljs-comment">// console output: &#x27;Hello TS!&#x27;;</span><br></code></pre></td></tr></table></figure><p>13.4 属性装饰器<br>属性装饰器声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">type</span> PropertyDecorator = (target:<span class="hljs-built_in">Object</span>,<br>  propertyKey: <span class="hljs-built_in">string</span> | symbol ) =&gt; <span class="hljs-built_in">void</span>;<br></code></pre></td></tr></table></figure><p>属性装饰器顾名思义，用来装饰类的属性。它接收两个参数：</p><p>target: Object - 被装饰的类<br>propertyKey: string | symbol - 被装饰类的属性名<br>趁热打铁，马上来个例子热热身：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logProperty</span>(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, key: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">delete</span> target[key];<br><br>  <span class="hljs-keyword">const</span> backingField = <span class="hljs-string">&quot;_&quot;</span> + key;<br><br>  <span class="hljs-built_in">Object</span>.defineProperty(target, backingField, &#123;<br>    writable: <span class="hljs-literal">true</span>,<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span><br>  &#125;);<br><br>  <span class="hljs-comment">// property getter</span><br>  <span class="hljs-keyword">const</span> getter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">this</span>: <span class="hljs-built_in">any</span></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> currVal = <span class="hljs-built_in">this</span>[backingField];<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Get: <span class="hljs-subst">$&#123;key&#125;</span> =&gt; <span class="hljs-subst">$&#123;currVal&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> currVal;<br>  &#125;;<br><br>  <span class="hljs-comment">// property setter</span><br>  <span class="hljs-keyword">const</span> setter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">this</span>: <span class="hljs-built_in">any</span>, newVal: <span class="hljs-built_in">any</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Set: <span class="hljs-subst">$&#123;key&#125;</span> =&gt; <span class="hljs-subst">$&#123;newVal&#125;</span>`</span>);<br>    <span class="hljs-built_in">this</span>[backingField] = newVal;<br>  &#125;;<br><br>  <span class="hljs-comment">// Create new property with getter and setter</span><br>  <span class="hljs-built_in">Object</span>.defineProperty(target, key, &#123;<br>    get: getter,<br>    set: setter,<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span><br>  &#125;);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-meta">@logProperty</span><br>  <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name : <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;semlinker&quot;</span>);<br>p1.name = <span class="hljs-string">&quot;kakuqo&quot;</span>;<br></code></pre></td></tr></table></figure><p>以上代码我们定义了一个 logProperty 函数，来跟踪用户对属性的操作，当代码成功运行后，在控制台会输出以下结果：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Set: <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> semlinker<br>Set: <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> kakuqo<br></code></pre></td></tr></table></figure><p>13.5 方法装饰器<br>方法装饰器声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">type</span> MethodDecorator = &lt;T&gt;(target:<span class="hljs-built_in">Object</span>, <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span> | symbol,<br>  descriptor: TypePropertyDescript&lt;T&gt;) =&gt; TypedPropertyDescriptor&lt;T&gt; | <span class="hljs-built_in">void</span>;<br></code></pre></td></tr></table></figure><p>方法装饰器顾名思义，用来装饰类的方法。它接收三个参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs typescript">target: <span class="hljs-built_in">Object</span> - 被装饰的类<br>propertyKey: <span class="hljs-built_in">string</span> | symbol - 方法名<br>descriptor: TypePropertyDescript - 属性描述符<br>废话不多说，直接上例子：<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LogOutput</span>(<span class="hljs-params">tarage: <span class="hljs-built_in">Function</span>, key: <span class="hljs-built_in">string</span>, descriptor: <span class="hljs-built_in">any</span></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> originalMethod = descriptor.value;<br>  <span class="hljs-keyword">let</span> newMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args: <span class="hljs-built_in">any</span>[]</span>): <span class="hljs-title">any</span> </span>&#123;<br>    <span class="hljs-keyword">let</span> result: <span class="hljs-built_in">any</span> = originalMethod.apply(<span class="hljs-built_in">this</span>, args);<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.loggedOutput) &#123;<br>      <span class="hljs-built_in">this</span>.loggedOutput = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;();<br>    &#125;<br>    <span class="hljs-built_in">this</span>.loggedOutput.push(&#123;<br>      method: key,<br>      parameters: args,<br>      output: result,<br>      timestamp: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>    &#125;);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br>  descriptor.value = newMethod;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> </span>&#123;<br>  <span class="hljs-meta">@LogOutput</span><br>  double (num: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> num * <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> calc = <span class="hljs-keyword">new</span> Calculator();<br>calc.double(<span class="hljs-number">11</span>);<br><span class="hljs-comment">// console ouput: [&#123;method: &quot;double&quot;, output: 22, ...&#125;]</span><br><span class="hljs-built_in">console</span>.log(calc.loggedOutput);<br><br>下面我们来介绍一下参数装饰器。<br></code></pre></td></tr></table></figure><p>13.6 参数装饰器<br>参数装饰器声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">type</span> ParameterDecorator = (target: <span class="hljs-built_in">Object</span>, <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span> | symbol,<br>  parameterIndex: <span class="hljs-built_in">number</span> ) =&gt; <span class="hljs-built_in">void</span><br></code></pre></td></tr></table></figure><p>参数装饰器顾名思义，是用来装饰函数参数，它接收三个参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript">target: <span class="hljs-built_in">Object</span> - 被装饰的类<br>propertyKey: <span class="hljs-built_in">string</span> | symbol - 方法名<br>parameterIndex: <span class="hljs-built_in">number</span> - 方法中参数的索引值<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Log</span>(<span class="hljs-params">target: <span class="hljs-built_in">Function</span>, key: <span class="hljs-built_in">string</span>, parameterIndex: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> functionLogged = key || target.prototype.constructor.name;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`The parameter in position <span class="hljs-subst">$&#123;parameterIndex&#125;</span> at <span class="hljs-subst">$&#123;functionLogged&#125;</span> has</span><br><span class="hljs-string"> been decorated`</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeter</span> </span>&#123;<br>  greeting: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-meta">@Log</span> phrase: <span class="hljs-built_in">string</span></span>)</span> &#123;<br> <span class="hljs-built_in">this</span>.greeting = phrase;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// console output: The parameter in position 0</span><br><span class="hljs-comment">// at Greeter has been decorated</span><br></code></pre></td></tr></table></figure><p>介绍完 TypeScript 入门相关的基础知识，猜测很多刚入门的小伙伴已有 “从入门到放弃” 的想法，最后我们来简单介绍一下编译上下文。</p><h3 id="九、编译上下文"><a href="#九、编译上下文" class="headerlink" title="九、编译上下文"></a>九、编译上下文</h3><p>14.1 tsconfig.json 的作用</p><ul><li>用于标识 TypeScript 项目的根路径；</li><li>用于配置 TypeScript 编译器；</li><li>用于指定编译的文件。</li></ul><p>14.2 tsconfig.json 重要字段</p><ul><li>files - 设置要编译的文件的名称；</li><li>include - 设置需要进行编译的文件，支持路径模式匹配；</li><li>exclude - 设置无需进行编译的文件，支持路径模式匹配；</li><li>compilerOptions - 设置与编译流程相关的选项。</li></ul><p>14.3 compilerOptions 选项</p><p>compilerOptions 支持很多选项，常见的有 baseUrl、 target、baseUrl、 moduleResolution 和 lib 等。</p><p>compilerOptions 每个选项的详细说明如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span>: &#123;<br><br>    <span class="hljs-comment">/* 基本选项 */</span><br>    <span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;es5&quot;</span>,                       <span class="hljs-comment">// 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES6&#x27;/&#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span><br>    <span class="hljs-attr">&quot;module&quot;</span>: <span class="hljs-string">&quot;commonjs&quot;</span>,                  <span class="hljs-comment">// 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span><br>    <span class="hljs-attr">&quot;lib&quot;</span>: [],                             <span class="hljs-comment">// 指定要包含在编译中的库文件</span><br>    <span class="hljs-attr">&quot;allowJs&quot;</span>: <span class="hljs-literal">true</span>,                       <span class="hljs-comment">// 允许编译 javascript 文件</span><br>    <span class="hljs-attr">&quot;checkJs&quot;</span>: <span class="hljs-literal">true</span>,                       <span class="hljs-comment">// 报告 javascript 文件中的错误</span><br>    <span class="hljs-attr">&quot;jsx&quot;</span>: <span class="hljs-string">&quot;preserve&quot;</span>,                     <span class="hljs-comment">// 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span><br>    <span class="hljs-attr">&quot;declaration&quot;</span>: <span class="hljs-literal">true</span>,                   <span class="hljs-comment">// 生成相应的 &#x27;.d.ts&#x27; 文件</span><br>    <span class="hljs-attr">&quot;sourceMap&quot;</span>: <span class="hljs-literal">true</span>,                     <span class="hljs-comment">// 生成相应的 &#x27;.map&#x27; 文件</span><br>    <span class="hljs-attr">&quot;outFile&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 将输出文件合并为一个文件</span><br>    <span class="hljs-attr">&quot;outDir&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                        <span class="hljs-comment">// 指定输出目录</span><br>    <span class="hljs-attr">&quot;rootDir&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 用来控制输出目录结构 --outDir.</span><br>    <span class="hljs-attr">&quot;removeComments&quot;</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 删除编译后的所有的注释</span><br>    <span class="hljs-attr">&quot;noEmit&quot;</span>: <span class="hljs-literal">true</span>,                        <span class="hljs-comment">// 不生成输出文件</span><br>    <span class="hljs-attr">&quot;importHelpers&quot;</span>: <span class="hljs-literal">true</span>,                 <span class="hljs-comment">// 从 tslib 导入辅助工具函数</span><br>    <span class="hljs-attr">&quot;isolatedModules&quot;</span>: <span class="hljs-literal">true</span>,               <span class="hljs-comment">// 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span><br><br>    <span class="hljs-comment">/* 严格的类型检查选项 */</span><br>    <span class="hljs-attr">&quot;strict&quot;</span>: <span class="hljs-literal">true</span>,                        <span class="hljs-comment">// 启用所有严格类型检查选项</span><br>    <span class="hljs-attr">&quot;noImplicitAny&quot;</span>: <span class="hljs-literal">true</span>,                 <span class="hljs-comment">// 在表达式和声明上有隐含的 any类型时报错</span><br>    <span class="hljs-attr">&quot;strictNullChecks&quot;</span>: <span class="hljs-literal">true</span>,              <span class="hljs-comment">// 启用严格的 null 检查</span><br>    <span class="hljs-attr">&quot;noImplicitThis&quot;</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 当 this 表达式值为 any 类型的时候，生成一个错误</span><br>    <span class="hljs-attr">&quot;alwaysStrict&quot;</span>: <span class="hljs-literal">true</span>,                  <span class="hljs-comment">// 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span><br><br>    <span class="hljs-comment">/* 额外的检查 */</span><br>    <span class="hljs-attr">&quot;noUnusedLocals&quot;</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 有未使用的变量时，抛出错误</span><br>    <span class="hljs-attr">&quot;noUnusedParameters&quot;</span>: <span class="hljs-literal">true</span>,            <span class="hljs-comment">// 有未使用的参数时，抛出错误</span><br>    <span class="hljs-attr">&quot;noImplicitReturns&quot;</span>: <span class="hljs-literal">true</span>,             <span class="hljs-comment">// 并不是所有函数里的代码都有返回值时，抛出错误</span><br>    <span class="hljs-attr">&quot;noFallthroughCasesInSwitch&quot;</span>: <span class="hljs-literal">true</span>,    <span class="hljs-comment">// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span><br><br>    <span class="hljs-comment">/* 模块解析选项 */</span><br>    <span class="hljs-attr">&quot;moduleResolution&quot;</span>: <span class="hljs-string">&quot;node&quot;</span>,            <span class="hljs-comment">// 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span><br>    <span class="hljs-attr">&quot;baseUrl&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 用于解析非相对模块名称的基目录</span><br>    <span class="hljs-attr">&quot;paths&quot;</span>: &#123;&#125;,                           <span class="hljs-comment">// 模块名到基于 baseUrl 的路径映射的列表</span><br>    <span class="hljs-attr">&quot;rootDirs&quot;</span>: [],                        <span class="hljs-comment">// 根文件夹列表，其组合内容表示项目运行时的结构内容</span><br>    <span class="hljs-attr">&quot;typeRoots&quot;</span>: [],                       <span class="hljs-comment">// 包含类型声明的文件列表</span><br>    <span class="hljs-attr">&quot;types&quot;</span>: [],                           <span class="hljs-comment">// 需要包含的类型声明文件名列表</span><br>    <span class="hljs-attr">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 允许从没有设置默认导出的模块中默认导入。</span><br><br>    <span class="hljs-comment">/* Source Map Options */</span><br>    <span class="hljs-attr">&quot;sourceRoot&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                    <span class="hljs-comment">// 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span><br>    <span class="hljs-attr">&quot;mapRoot&quot;</span>: <span class="hljs-string">&quot;./&quot;</span>,                       <span class="hljs-comment">// 指定调试器应该找到映射文件而不是生成文件的位置</span><br>    <span class="hljs-attr">&quot;inlineSourceMap&quot;</span>: <span class="hljs-literal">true</span>,               <span class="hljs-comment">// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span><br>    <span class="hljs-attr">&quot;inlineSources&quot;</span>: <span class="hljs-literal">true</span>,                 <span class="hljs-comment">// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span><br><br>    <span class="hljs-comment">/* 其他选项 */</span><br>    <span class="hljs-attr">&quot;experimentalDecorators&quot;</span>: <span class="hljs-literal">true</span>,        <span class="hljs-comment">// 启用装饰器</span><br>    <span class="hljs-attr">&quot;emitDecoratorMetadata&quot;</span>: <span class="hljs-literal">true</span>          <span class="hljs-comment">// 为装饰器提供元数据的支持</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h4><p><a href="https://juejin.cn/post/6844904182843965453#heading-28">1.2W字 | 了不起的 TypeScript 入门教程</a></p>]]></content>
    
    
    <categories>
      
      <category>TS学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>TS学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript 入门</title>
    <link href="/2021/08/03/TS%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/08/03/TS%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>ts的优缺点</p><p>1、优点<br>代码的可读性和可维护性：举个🌰看后端某个接口返回值，一般需要去network看or去看接口文档，才知道返回数据结构，而正确用了ts后，编辑器会提醒接口返回值的类型，这点相当实用。</p><p>在编译阶段就发现大部分错误，避免了很多线上bug</p><p>增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等</p><p>2、缺点<br>有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念</p><p>会增加一些开发成本，当然这是前期的，后期维护更简单了</p><p>一些JavaScript库需要兼容，提供声明文件，像vue2，底层对ts的兼容就不是很好。</p><p>ts编译是需要时间的，这就意味着项目大了以后，开发环境启动和生产环境打包的速度就成了考验<br>可以看看<a href="https://www.infoq.cn/article/u72qtztgazttfazzihbz">Deno 内部代码将停用 TypeScript，并公布五项具体理由</a></p><hr><h3 id="Typescript-是什么？"><a href="#Typescript-是什么？" class="headerlink" title="Typescript 是什么？"></a>Typescript 是什么？</h3><p><img src="/imageO/23.png" alt="如图"></p><ul><li>Typescript 是 JavaScript 的超集，两者是所属关系。</li><li>Typescript 是 JavaScript 的增强，包含 JavaScript 的最新特性，非常适合创建大型项目</li><li>Typescript 是静态语言与动态语言 JavaScript 不同，TS 是和 JS 都是弱类型语言</li><li>Typescript 也是前端的趋势，各大著名的前端框架都使用了 TS 重构，如 Vue, React 等</li></ul><h3 id="下载安装及使用"><a href="#下载安装及使用" class="headerlink" title="下载安装及使用"></a>下载安装及使用</h3><ul><li>本地环境需要先下载 node vscode，随后打开 vscode 终端，使用 npm install -g typescript 即可</li><li>tsc -v 查看版本号，这份教程是最新的 typescript 4.0</li><li>建议安装 TSlint 插件规范代码</li><li>编写 TS 文件代码，使用 tsc xx.ts 命令运行 ts 文件，运行 ts 文件后会生成相应的 js 文件，这个 js 文件时 tsc 将 xx.ts 代码编译成 xx.js的代码</li><li>tsc  –watch  xx.ts 自动监测编译代码</li></ul><h3 id="动态语言和静态语言的差别"><a href="#动态语言和静态语言的差别" class="headerlink" title="动态语言和静态语言的差别"></a>动态语言和静态语言的差别</h3><ul><li>静态语言在编写代码的时候就能发现潜在的错误.</li><li>静态语言更容易读懂代码，像上面的data参数静态语言能直接读出里面的属性 x, y，但是动态语言参数 data 显然不能直接读出里面包含什么属性。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// TS</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tsFunc</span> (<span class="hljs-params">data: &#123;x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>&#125;</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;demo ts&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.sqrt(data.x ** <span class="hljs-number">2</span> + data.y ** <span class="hljs-number">2</span>)<br>&#125;<br><br><span class="hljs-comment">// tsFunc()  // 没有传入参数，这里的代码 vscode 会提示错误,这就是静态语言在编写代码的时候就可以知道有错误。</span><br>tsFunc(&#123;<span class="hljs-attr">x</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">4</span>&#125;)  <span class="hljs-comment">//需要将参数代码一起写入。</span><br><br><span class="hljs-comment">// 再比如传入参数的个数，ts 能直接检测，但是生成的 js 文件不能检测</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">param</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> param<br>&#125;<br><br>get(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><br>get(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// error: 应有 1 个参数，但获得 2 个</span><br></code></pre></td></tr></table></figure><p>编写代码时静态语言能识别到可能使用到的属性等,但动态语言不一定能提示的正确。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 静态类型和动态类型的差别，静态类型在编写代码时就可以发现错误像C++,Java等，动态类型的语言则需要代码运行时才可以知道错误，像JavaScript，python。<br><span class="hljs-regexp">//</span> js-code<br><br><span class="hljs-keyword">function</span> jsFunc (data) &#123;<br>    return Math.sqrt(x ** <span class="hljs-number">2</span> + y ** <span class="hljs-number">2</span>)<br>&#125;<br><br>jsFunc()  <span class="hljs-regexp">//</span> 没有传入参数，但这里的代码 vscode不会提示错误，但实际运行会发生报错。<br><br></code></pre></td></tr></table></figure><h3 id="二-静态类型"><a href="#二-静态类型" class="headerlink" title="二. 静态类型"></a>二. 静态类型</h3><h4 id="静态类型"><a href="#静态类型" class="headerlink" title="静态类型"></a>静态类型</h4><h6 id="就像前面看到的那样静态类型可以是基础类型-number-string-null-undefined-symbol-boolean-void-enum-还可以是对象类型-Object，Array-class-function，还可以是自定义类型-interface-或任何类型-any-等详情-typescript官网"><a href="#就像前面看到的那样静态类型可以是基础类型-number-string-null-undefined-symbol-boolean-void-enum-还可以是对象类型-Object，Array-class-function，还可以是自定义类型-interface-或任何类型-any-等详情-typescript官网" class="headerlink" title="就像前面看到的那样静态类型可以是基础类型 number string null undefined symbol boolean void enum 还可以是对象类型 Object，Array, class, function，还可以是自定义类型 interface 或任何类型 any 等详情 typescript官网"></a>就像前面看到的那样静态类型可以是基础类型 number string null undefined symbol boolean void enum 还可以是对象类型 Object，Array, class, function，还可以是自定义类型 interface 或任何类型 any 等详情 typescript官网</h6><ul><li>定义为相应类型后可以直接使用对应类型的方法或属性如 number,vscode 直接提示</li></ul><p><img src="/imageO/24.png" alt="如图"></p><p>类型属性提示</p><p>. 基础类型 number string null undefined symbol boolean any void never。。。</p><ul><li>number 类型</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">const</span> num: <span class="hljs-built_in">number</span> = <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><ul><li>string 类型</li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">const</span> <span class="hljs-keyword">Name</span>: <span class="hljs-keyword">string</span> = <span class="hljs-string">&#x27;LinYY&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>boolean 类型</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">const</span> <span class="hljs-keyword">boolean</span>: <span class="hljs-keyword">Boolean</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ul><li>null 类型 。null 类型不可以赋值给 undefined 类型和 联合类型（后面介绍）</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> n: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><ul><li>undefined 类型</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> u: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><p>undefined 类型。可以作用到可选类型，因为可选的类型默认会有一个undefined 类型</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">interface</span> <span class="hljs-string">E</span> &#123;<br>    <span class="hljs-attr">b:</span> <span class="hljs-string">number</span><br>    <span class="hljs-string">c?:</span> <span class="hljs-string">number</span><br>&#125;<br><br><span class="hljs-attr">let e:</span> <span class="hljs-string">E</span> <span class="hljs-string">=</span> &#123;<span class="hljs-attr">b:</span> <span class="hljs-number">12</span>, <span class="hljs-attr">c:</span> <span class="hljs-number">12</span>&#125;<br><br><span class="hljs-string">e</span> <span class="hljs-string">=</span> &#123;<span class="hljs-attr">b:</span> <span class="hljs-number">23</span>, <span class="hljs-attr">c:</span> <span class="hljs-string">undefined</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>any 类型。已经定义变量的类型不能再修改，否则报错。<br>注意 any 类型，any 类型定义后可以修改为其他的类型</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// any 类型可以修改成其他任何类型，TS 不对 any 类型作类型检测</span><br><span class="hljs-keyword">let</span> not: <span class="hljs-built_in">any</span><br>not = <span class="hljs-number">2</span><br>not = <span class="hljs-string">&#x27;2&#x27;</span><br>not = <span class="hljs-literal">true</span><br><br><span class="hljs-comment">// 处理不确定的数组类型 any 比较合适。</span><br><span class="hljs-keyword">let</span> listArr: <span class="hljs-built_in">any</span>[] = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>]<br></code></pre></td></tr></table></figure><ul><li>void 类型 和 any 类型相反，表示没有任何类型</li></ul><blockquote><p>void 类型 通常作用在函数中代表没有返回值，虽然也可以作为其他变量的类型，但只能赋值成 undefined。换一个方向想函数总是有返回值的，如果不是一个确定的值那么就是 undefined 值，所以 void 其实是属于 undefined 的，所以一个变量类型是 void 时，值只能 undefined 值。但是 不能将类型“void”分配给类型“undefined”详情看例子</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// void 空类型，一般用于函数，</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noReturn</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;no value return&#x27;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;<br>    <span class="hljs-comment">// Error</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>  &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn5</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;<br>&#125;<br><span class="hljs-keyword">let</span> un: <span class="hljs-literal">undefined</span> = fn5(); <span class="hljs-comment">// Error 不能将类型“void”分配给类型“undefined”</span><br><br><span class="hljs-keyword">let</span> voidValue: <span class="hljs-keyword">void</span> = <span class="hljs-literal">undefined</span><br><span class="hljs-keyword">let</span> voidValue2: <span class="hljs-keyword">void</span> = <span class="hljs-literal">null</span>   <span class="hljs-comment">// 不能将类型“null”分配给类型“void”</span><br></code></pre></td></tr></table></figure><ul><li>never 一个特殊类型。简单的说如果函数是一个永远不会执行完的函数，返回值就是 never 类型，像函数 errorFunc，abs。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// never 类型，不会执行结束的函数类型</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">errorFunc</span>(<span class="hljs-params"></span>): <span class="hljs-title">never</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>()<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;never&#x27;</span>)    <span class="hljs-comment">// 抛出错误后 这段代码不打印。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">abs</span>(<span class="hljs-params"></span>): <span class="hljs-title">never</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;never&#x27;</span>)    <span class="hljs-comment">// 上面的代码永远是true 这段代码不打印。</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对象类型 object type。object {}，array [], class {}， function</li></ul><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">let</span> person: &#123;<br>   <span class="hljs-built_in"> name</span>:<span class="hljs-built_in"> string</span>,<br>    age:<span class="hljs-built_in"> number</span><br>&#125; = &#123;<br>   <span class="hljs-built_in"> name</span>: <span class="hljs-string">&#x27;LinYY&#x27;</span>,<br>    age: <span class="hljs-number">12</span><br>&#125;<br><br>// 或 (不推荐写法)<br><span class="hljs-keyword">let</span> personB:<span class="hljs-built_in">&#123;name</span>:<span class="hljs-built_in"> string</span>&#125; &amp; &#123;age:<span class="hljs-built_in"> number</span>&#125; = &#123;<br>   <span class="hljs-built_in"> name</span>: <span class="hljs-string">&#x27;LinYY&#x27;</span>,<br>    age: <span class="hljs-number">12</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>数组类型 也是对象类型，下面声明number型数组只能写入数字来初始化，写入字符串将会报错。</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">const</span> list: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">12</span>, <span class="hljs-number">23</span>, <span class="hljs-number">34</span>]<br><br>//等同于，下面的数组泛型，泛型是什么之后会讲，先留一个印象。<br><span class="hljs-keyword">const</span> listA: Array&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br>// <span class="hljs-keyword">const</span> listB: <span class="hljs-built_in">number</span>[] = [<span class="hljs-string">&#x27;12&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-number">34</span>]<br></code></pre></td></tr></table></figure><ul><li>class类 类型</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;&#125;<br>const LinYY: <span class="hljs-type">Person  </span>= <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>()<br></code></pre></td></tr></table></figure><ul><li>function 函数类型, 下面的函数类型要求返回值是 number 数字类型，写成其他类型如 string 会报错。</li></ul><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">const <span class="hljs-name">getNumber</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> number = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    // <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;LinYY&#x27;</span>   报错<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">123</span><br>&#125;<br><br>// 要求返回值是<span class="hljs-built_in">string</span> 字符类型<br>const <span class="hljs-name">getString</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">string</span> = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;LinYY&#x27;</span><br>    // <span class="hljs-keyword">return</span> <span class="hljs-number">123</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>interface 自定义类型，也就是接口</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts">interface <span class="hljs-class">Point </span>&#123;<br><span class="hljs-symbol">    x:</span> number,<br><span class="hljs-symbol">    y:</span> number<br>&#125;<br><br>const point: Point = &#123;<br><span class="hljs-symbol">    x:</span> <span class="hljs-number">2</span>,<br><span class="hljs-symbol">    y:</span> <span class="hljs-number">4</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>多类型。变量的类型可以有多个，比如可以是 number 或 string类型</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">// 变量的类型可以有多个，比如可以是<span class="hljs-keyword">number</span>或<span class="hljs-keyword">string</span>类型。<br>let temp: <span class="hljs-keyword">number</span> | <span class="hljs-keyword">string</span> = <span class="hljs-number">23</span><br>temp = &#x27;<span class="hljs-number">23</span>&#x27;<br><br><span class="hljs-keyword">type</span> alias 类型别名，类型别名不是 TS 的基本数据类型，类型别名常用于提取公共类型，下面 interface 接口会详细介绍<br><span class="hljs-keyword">type</span> <span class="hljs-keyword">User</span> <span class="hljs-title">= &#123; name</span>: <span class="hljs-keyword">string</span>, age: <span class="hljs-keyword">number</span> &#125;<br>let male: <span class="hljs-keyword">User</span> <span class="hljs-title">= &#123;name</span>: &#x27;LinYY&#x27;, age: <span class="hljs-number">18</span>&#125;<br>let famale: <span class="hljs-keyword">User</span> <span class="hljs-title">= &#123;name</span>: &#x27;nana&#x27;, age: <span class="hljs-number">18</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="小-tip"><a href="#小-tip" class="headerlink" title="小 tip"></a>小 tip</h4><p>注释小技巧tip: 使用 /** */ 可以给类型添加更友好的提示</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// 注释</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* this is good Per</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-symbol">Per</span> &#123;<br>    name: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">const</span> p: Per =&#123;<br>    name: <span class="hljs-string">&#x27;LinYY&#x27;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>在 typescript 里面 name 是一个预留关键字，不能直接当变量来用</p></blockquote><h3 id="三-类型注解和类型推断"><a href="#三-类型注解和类型推断" class="headerlink" title="三.类型注解和类型推断"></a>三.类型注解和类型推断</h3><h4 id="type-annotation-类型注解"><a href="#type-annotation-类型注解" class="headerlink" title="type annotation 类型注解"></a>type annotation 类型注解</h4><ul><li>直接声明的类型，告诉TS变量是什么类型。比如这里的 count 是 number 类型</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">// <span class="hljs-built_in">type</span> annotation 类型注解。<br><span class="hljs-keyword">let</span> coun<span class="hljs-variable">t:</span> <span class="hljs-keyword">number</span><br><span class="hljs-built_in">count</span> = <span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><h4 id="type-inference-类型推断"><a href="#type-inference-类型推断" class="headerlink" title="type inference 类型推断"></a>type inference 类型推断</h4><p>没有直接声明类型，TS 会尝试去分析变量类型，如这里的 countB，推断是 number 类型。（此处加图说明）<br><img src="/imageO/25.png" alt="如图"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">countB</span> = <span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><ul><li>但是声明的变量没有直接在一行赋值 TS 将默认变量为 any 类型，如这里的变量 countC，鼠标箭头移动到 countC 上方就可以看到类型。正确写法是加上类型注解。</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">let countC <span class="hljs-regexp">//</span> any 类型<br>countC = <span class="hljs-number">233</span><br></code></pre></td></tr></table></figure><h4 id="TS-并不能所有的类型都能推断出来，那么什么时候使用类型注解呢？具体情况需要具体分析"><a href="#TS-并不能所有的类型都能推断出来，那么什么时候使用类型注解呢？具体情况需要具体分析" class="headerlink" title="TS 并不能所有的类型都能推断出来，那么什么时候使用类型注解呢？具体情况需要具体分析"></a>TS 并不能所有的类型都能推断出来，那么什么时候使用类型注解呢？具体情况需要具体分析</h4><ul><li>一般简单的变量声明可以不写类型注解。如这里的 num1 num2 sum。TS 能直接判断。</li><li>一般函数的参数需要类型注解，返回值可以不用写类型注解，TS 能自动判断</li><li>已经有未确定的 any 类型，需要加类型注解，如 total 显示为 any,原因是类型 a b 不确定。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> num2 = <span class="hljs-number">2</span><br><span class="hljs-keyword">let</span> sum = num1 + num2 <span class="hljs-comment">// TS 推断出 sum 是 number 类型</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    name: <span class="hljs-string">&#x27;LinYY&#x27;</span>,<br>    age: <span class="hljs-number">18</span><br>&#125;<br><br><span class="hljs-comment">// obj.name = 23 // TS 推断出来的类型 同样不能再修改</span><br><br><span class="hljs-comment">// 需要类型注解</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSum</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-keyword">const</span> total = getSum(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h4 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h4><p><a href="https://juejin.cn/post/6927452747218288654#heading-7">【林一一】2021一份热乎的万字 TypeScript 教程(含4.0)</a></p>]]></content>
    
    
    <categories>
      
      <category>TS学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>TS学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器的回流与重绘</title>
    <link href="/2021/07/24/%E9%87%8D%E7%BB%98%E5%9B%9E%E6%B5%81/"/>
    <url>/2021/07/24/%E9%87%8D%E7%BB%98%E5%9B%9E%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="什么是回流？"><a href="#什么是回流？" class="headerlink" title="什么是回流？"></a>什么是回流？</h3><p>当一个元素自身的宽高，布局，显示或隐藏，或元素内部的文字结构发生变化，导致需要重新构建页面的时候，就产生了回流</p><h3 id="什么是重绘？"><a href="#什么是重绘？" class="headerlink" title="什么是重绘？"></a>什么是重绘？</h3><p>当一个元素自身的宽高，布局，及显示或隐藏没有改变，而只是改变了元素的外观风格的时候，就产生了重绘</p><h3 id="注意：回流一定会触发重绘，而重绘不一定会回流"><a href="#注意：回流一定会触发重绘，而重绘不一定会回流" class="headerlink" title="注意：回流一定会触发重绘，而重绘不一定会回流"></a>注意：回流一定会触发重绘，而重绘不一定会回流</h3><h3 id="什么时候会进行回流？"><a href="#什么时候会进行回流？" class="headerlink" title="什么时候会进行回流？"></a>什么时候会进行回流？</h3><ol><li><p>添加或者删除可见的DOM元素的时候</p></li><li><p>元素的位置发生改变</p></li><li><p>元素的尺寸发生改变</p></li><li><p>内容改变</p></li><li><p>页面第一次渲染的时候</p></li></ol><p>列举一些相关的CSS样式：width、height、line-height、padding、margin、diaplay、border、top、position、float、font-size、overflow等</p><h3 id="什么时候会进行重绘？"><a href="#什么时候会进行重绘？" class="headerlink" title="什么时候会进行重绘？"></a>什么时候会进行重绘？</h3><p>列举一些相关的CSS样式：color、background、background-size、visibility、box-shadow</p><h3 id="如何进行性能优化？"><a href="#如何进行性能优化？" class="headerlink" title="如何进行性能优化？"></a>如何进行性能优化？</h3><ol><li><p>用transform 代替 top，left ，margin-top， margin-left… 这些位移属性</p></li><li><p>不要使用 js 代码对dom 元素设置多条样式，选择用一个 className 代替之</p></li><li><p>不要在循环内获取dom 的样式例如：offsetWidth, offsetHeight, clientWidth, clientHeight等。浏览器有一个回流的缓冲机制，获取这些属性时会产生回流</p></li><li><p>避免设置多层内联样式，写个外部类这样只回流一次</p></li><li><p>让多次回流的元素脱离文档流比如动画，使用 position 属性的 fixed 值或 absolute 值</p></li><li><p>一起变化（同时修改所有需要变化的属性）</p></li></ol><h3 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h3><p>CSS</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><br>避免使用table布局。<br>尽可能在DOM树的最末端改变<span class="hljs-keyword">class</span>。<br>避免设置多层内联样式。<br>将动画效果应用到<span class="hljs-symbol">position</span>属性为<span class="hljs-symbol">absolute</span>或<span class="hljs-symbol">fixed</span>的元素上。<br>避免使用<span class="hljs-symbol">CSS</span>表达式（例如：<span class="hljs-symbol">calc</span>()）。<br></code></pre></td></tr></table></figure><p>JavaScript</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为<span class="hljs-keyword">class</span>并一次性更改<span class="hljs-symbol">class</span>属性。<br>避免频繁操作<span class="hljs-symbol">DOM</span>，创建一个<span class="hljs-symbol">documentFragment</span>，在它上面应用所有<span class="hljs-symbol">DOM</span>操作，最后再把它添加到文档中。<br>也可以先为元素设置<span class="hljs-symbol">display: <span class="hljs-symbol">none</span></span>，操作结束后再把它显示出来。因为在<span class="hljs-symbol">display</span>属性为<span class="hljs-symbol">none</span>的元素上进行的<span class="hljs-symbol">DOM</span>操作不会引发回流和重绘。<br>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。<br>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。<br></code></pre></td></tr></table></figure><h5 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h5><p><a href="https://juejin.cn/post/6844903569087266823#heading-2">掘金</a><br><a href="https://www.zhihu.com/search?type=content&q=%E9%87%8D%E7%BB%98%E5%9B%9E%E6%B5%81">知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP协议</title>
    <link href="/2021/07/09/TCP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2021/07/09/TCP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>引言<br>网络协议是每个前端工程师都必须要掌握的知识，TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP，本文将介绍下这两者以及它们之间的区别。</p><hr><h3 id="一、TCP-IP网络模型"><a href="#一、TCP-IP网络模型" class="headerlink" title="一、TCP/IP网络模型"></a>一、TCP/IP网络模型</h3><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。<br>TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。<br>TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p><p>链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。<br>网络层：负责路由以及把分组报文发送给目标网络或主机。<br>传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。<br>应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。<br><img src="/imageO/XY.jpg" alt="TCP/IP"></p><p>在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。接下去介绍TCP/IP 中有两个具有代表性的传输层协议—-TCP 和 UDP。</p><h3 id="二、UDP"><a href="#二、UDP" class="headerlink" title="二、UDP"></a>二、UDP</h3><p>UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。<br>它有以下几个特点：</p><h4 id="1-面向无连接"><a href="#1-面向无连接" class="headerlink" title="1. 面向无连接"></a>1. 面向无连接</h4><p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。<br>具体来说就是：</p><ol><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ol><h4 id="2-有单播，多播，广播的功能"><a href="#2-有单播，多播，广播的功能" class="headerlink" title="2. 有单播，多播，广播的功能"></a>2. 有单播，多播，广播的功能</h4><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p><h4 id="3-UDP是面向报文的"><a href="#3-UDP是面向报文的" class="headerlink" title="3. UDP是面向报文的"></a>3. UDP是面向报文的</h4><p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p><h4 id="4-不可靠性"><a href="#4-不可靠性" class="headerlink" title="4. 不可靠性"></a>4. 不可靠性</h4><p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。<br>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。<br>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p><h4 id="5-头部开销小，传输数据报文时是很高效的"><a href="#5-头部开销小，传输数据报文时是很高效的" class="headerlink" title="5. 头部开销小，传输数据报文时是很高效的"></a>5. 头部开销小，传输数据报文时是很高效的</h4><p>UDP 头部包含了以下几个数据：</p><ol><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li></ol><p>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</p><h3 id="三、TCP"><a href="#三、TCP" class="headerlink" title="三、TCP"></a>三、TCP</h3><p>当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。<br>TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。</p><h4 id="1-TCP连接过程"><a href="#1-TCP连接过程" class="headerlink" title="1. TCP连接过程"></a>1. TCP连接过程</h4><h4 id="2-三次握手-四次挥手"><a href="#2-三次握手-四次挥手" class="headerlink" title="2.三次握手-四次挥手"></a>2.三次握手-四次挥手</h4><h5 id="3-TCP协议的特点"><a href="#3-TCP协议的特点" class="headerlink" title="3. TCP协议的特点"></a>3. TCP协议的特点</h5><ol><li><p>面向连接<br>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p></li><li><p>仅支持单播传输</p></li></ol><p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p><ol start="3"><li>面向字节流</li></ol><p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p><ol start="4"><li><p>可靠传输<br>对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p></li><li><p>提供拥塞控制</p></li></ol><p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p><ol start="6"><li>TCP提供全双工通信</li></ol><p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p><h3 id="四、TCP和UDP的比较"><a href="#四、TCP和UDP的比较" class="headerlink" title="四、TCP和UDP的比较"></a>四、TCP和UDP的比较</h3><ol><li>对比</li></ol><p><img src="/imageO/TCPUDP.jpg" alt="TCP/UDP"></p><h4 id="五、TCP-和-UDP-应用场景"><a href="#五、TCP-和-UDP-应用场景" class="headerlink" title="五、TCP 和 UDP 应用场景"></a>五、TCP 和 UDP 应用场景</h4><ol><li><p>UDP的应用场景：即时通信。面向数据报方式；网络数据大多为短消息；拥有大量客户端；对数据安全性无特殊要求；网络负担重但对响应速度要求高的场景。eg: IP电话、实时视频会议等。</p></li><li><p>TCP的应用场景：对数据准确性要求高，速度可以相对较慢的。eg: 文件传输、邮件的发送与接收等。</p></li></ol><h4 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h4><p>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。<br>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为<br>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</p><h4 id="转载文章"><a href="#转载文章" class="headerlink" title="转载文章"></a>转载文章</h4><p><a href="https://juejin.cn/post/6992743999756845087#heading-2">深度剖析TCP与UDP的区别</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何获取页面出现次数最多的 HTML 标签</title>
    <link href="/2021/07/08/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%20HTML%20%E6%A0%87%E7%AD%BE/"/>
    <url>/2021/07/08/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%20HTML%20%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<p>相同点：</p><p>递归和迭代都是循环的一种。</p><p>不同点：</p><p>1、程序结构不同</p><p>递归是重复调用函数自身实现循环。迭代是函数内某段代码实现循环。 其中，迭代与普通循环的区别是：迭代时，循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。</p><p>2、算法结束方式不同</p><p>递归循环中，遇到满足终止条件的情况时逐层返回来结束。迭代则使用计数器结束循环。 当然很多情况都是多种循环混合采用，这要根据具体需求。</p><p>3、效率不同</p><p>在循环的次数较大的时候，迭代的效率明显高于递归</p><hr><p>这是一道前端基础与编程功底具备的面试题：</p><p>如果你前端基础强会了解 document.querySelector(*) 能够列出页面内所有标签<br>如果你编程能力强能够用递归/正则快速实现同等的效果<br>有三种 API 可以列出页面所有标签：</p><ol><li>document.querySelector(‘*’)，标准规范实现</li><li>$$(‘*’)，devtools 实现</li><li>document.all，非标准规范实现</li></ol><blockquote><p>document.querySelectorAll(‘*’)</p></blockquote><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&lt; NodeList(<span class="hljs-number">593</span>) <span class="hljs-meta">[</span>html, head, meta, meta, meta, meta, meta, meta, meta, title, <span class="hljs-keyword">link</span>#favicon, <span class="hljs-keyword">link</span>, <span class="hljs-keyword">link</span>#MainCss, <span class="hljs-keyword">link</span>#mobile<span class="hljs-params">-style</span>, <span class="hljs-keyword">link</span>, <span class="hljs-keyword">link</span>, <span class="hljs-keyword">link</span>, script, script, script, script, script, script, script, <span class="hljs-keyword">link</span>, script, <span class="hljs-keyword">link</span>, <span class="hljs-keyword">link</span>, script, input#_w_brink, body, a, div#home, div#header, div#blogTitle, a#lnkBlogLogo, img#blogLogo, h1, a#Header1_HeaderTitle.headermaintitle.HeaderMainTitle, h2, div#navigator, ul#navList, li, a#blog_nav_sitehome.menu, li, a#blog_nav_myhome.menu, li, a#blog_nav_newpost.menu, li, a#blog_nav_contact.menu, li, a#blog_nav_rss.menu, li, a#blog_nav_admin.menu, div.blogStats, span#stats_post_count, span#stats_article_count, span#stats<span class="hljs-params">-comment_count</span>, div#main, div#mainContent, div.forFlow, div#post_detail, div#topics, div.post, h1.postTitle, a#cb_post_title_url.postTitle2.vertical<span class="hljs-params">-middle</span>, span, div.clear, div.postBody, div#cnblogs_post_body.blogpost<span class="hljs-params">-body</span>, p, p, strong, p, p, p, strong, div.cnblogs_code, pre, span, span, span, span, span, p, span, strong, pre, strong, span, strong, br, br, br, div.cnblogs_code, pre, span, span, p, p, …<span class="hljs-meta">]</span><br><span class="hljs-meta">[</span><span class="hljs-number">0</span> … <span class="hljs-number">99</span><span class="hljs-meta">]</span><br><span class="hljs-meta">[</span><span class="hljs-number">100</span> … <span class="hljs-number">199</span><span class="hljs-meta">]</span><br><span class="hljs-meta">[</span><span class="hljs-number">200</span> … <span class="hljs-number">299</span><span class="hljs-meta">]</span><br><span class="hljs-meta">[</span><span class="hljs-number">300</span> … <span class="hljs-number">399</span><span class="hljs-meta">]</span><br><span class="hljs-meta">[</span><span class="hljs-number">400</span> … <span class="hljs-number">499</span><span class="hljs-meta">]</span><br><span class="hljs-meta">[</span><span class="hljs-number">500</span> … <span class="hljs-number">592</span><span class="hljs-meta">]</span><br>__proto__: NodeList<br></code></pre></td></tr></table></figure><p>使用 document.querySelectorAll 实现如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 实现一个 maxBy 方便找出出现次数最多的 HTML 标签</span><br><span class="hljs-keyword">const</span> maxBy = <span class="hljs-function">(<span class="hljs-params">list, keyBy</span>) =&gt;</span> list.reduce(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> keyBy(x) &gt; keyBy(y) ? x : y)<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFrequentTag</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> tags = [...document.querySelectorAll(<span class="hljs-string">&#x27;*&#x27;</span>)].map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.tagName).reduce(<span class="hljs-function">(<span class="hljs-params">o, tag</span>) =&gt;</span> &#123;<br>    o[tag] = o[tag] ? o[tag] + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> o<br>  &#125;, &#123;&#125;)<br>  <span class="hljs-keyword">return</span> maxBy(<span class="hljs-built_in">Object</span>.entries(tags), <span class="hljs-function"><span class="hljs-params">tag</span> =&gt;</span> tag[<span class="hljs-number">1</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 element.children 递归迭代如下 (最终结果多一个 document)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAllTags</span>(<span class="hljs-params">el = <span class="hljs-built_in">document</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> children = <span class="hljs-built_in">Array</span>.from(el.children).reduce(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> [...x, ...getAllTags(y)], [])<br>  <span class="hljs-keyword">return</span> children<br>&#125;<br><br><span class="hljs-comment">// 或者通过 flatMap 实现</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAllTags</span>(<span class="hljs-params">el = <span class="hljs-built_in">document</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> children = <span class="hljs-built_in">Array</span>.prototype.flatMap.call(el.children, <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> getAllTags(x))<br>  <span class="hljs-keyword">return</span> [el, ...children]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://q.shanyue.tech/fe/js/418.html">如何获取页面出现次数最多的 HTML 标签</a></p>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 组件传参的八种方式总结</title>
    <link href="/2021/07/08/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <url>/2021/07/08/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="一、props-传参"><a href="#一、props-传参" class="headerlink" title="一、props 传参"></a>一、props 传参</h3><p>子组件定义 props 有三种方式:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// 第一种数组方式</span><br><span class="hljs-symbol">props:</span> [xxx, xxx, xxx]<br><br><span class="hljs-comment">// 第二种对象方式</span><br><span class="hljs-symbol">props:</span> &#123; xxx: Number, xxx: String&#125;<br><br><span class="hljs-comment">// 第三种对象嵌套对象方式</span><br><span class="hljs-symbol">props:</span> &#123;<br><span class="hljs-symbol">    xxx:</span> &#123;<br>        <span class="hljs-comment">//类型不匹配会警告</span><br><span class="hljs-symbol">        type:</span> Number,<br><span class="hljs-symbol">        default:</span> <span class="hljs-number">0</span>,<br><span class="hljs-symbol">        required:</span> true,<br>        <span class="hljs-comment">// 返回值不是 true,会警告</span><br>        validator(val) &#123; return val === <span class="hljs-number">10</span>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第三种对象默认支持 4 种属性，并且都是非必填的。可以随意使用</p><h4 id="父组件传参的俩种方式"><a href="#父组件传参的俩种方式" class="headerlink" title="父组件传参的俩种方式"></a>父组件传参的俩种方式</h4><h5 id="第一种静态属性传参"><a href="#第一种静态属性传参" class="headerlink" title="第一种静态属性传参"></a>第一种静态属性传参</h5><p>注意：</p><p>在不定义 props 类型的情况下 props 接受到的均为 String。<br>当 props 属性指定为 Boolean时，并且只有属性 key 没有值 value 时接受到的是 true</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--props 接受到的均为 String --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">children</span> <span class="hljs-attr">xxx</span>=<span class="hljs-string">&quot;123&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">children</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 有只有属性没有值, 这种情况 props 指定类型是 Boolean 则接收到的是 true --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">children</span> <span class="hljs-attr">xxx</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">children</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="第二种动态属性传参"><a href="#第二种动态属性传参" class="headerlink" title="第二种动态属性传参"></a>第二种动态属性传参</h5><p>注意：</p><p>需要区分非简写形式传入的值是对象，则会对应 props 中多个值<br>会保留传入值的类型<br>如果是表达式则获取到的是表达式的计算结果</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!-- prop 接收到 Number 类型的 123--&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">children</span> <span class="hljs-attr">:xxx</span>=<span class="hljs-string">&quot;123&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">children</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-comment">&lt;!-- prop 接收到 Array 类型的 [1, 2, 3]--&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">children</span> <span class="hljs-attr">v-bind:xxx</span>=<span class="hljs-string">&quot;[1, 2, 3]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">children</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-comment">&lt;!-- prop 会接收到 xxx1 和 xxx2 俩个参数。这种不支持简写形式--&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">children</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;xxx1: 1, xxx2: 2&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">children</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="二、attrs-和listeners"><a href="#二、attrs-和listeners" class="headerlink" title="二、attrs 和listeners"></a>二、attrs 和listeners</h3><p>$attrs</p><p>$attrs 会获取到 props 中未定义的属性（class 和 style 属性除外）,支持响应式。常用的场景有俩种：</p><ol><li>组件嵌套组件时可以使用 $attrs 来支持过多的属性支持。比如 elementUI 的 table 组件。支持的属性十几个，而平常封装的时候用的最多的也就一俩个。</li><li>属性默认是添加在父组件上的，有时候想把多余的属性添加在子组件上（可以结合 inheritAttrs: false 属性，让父属性不接受多余的属性）</li></ol><p>$listeners 定义的事件都在子组件的根元素上，有时候想加到其他元素上。就可以使用 $listerners。它包含了父组件中的事件监听器(除了带有 .native 修饰符的监听器)</p><h3 id="三、-emit-通知"><a href="#三、-emit-通知" class="headerlink" title="三、$emit 通知"></a>三、$emit 通知</h3><p>Vue 默认有 $on $emit $once $off 几种方法来实现发布订阅模式，这也应用在了组件传参上。在组件上添加的特殊方法 @abc=”methods” 就相当于使用了 $on 来监听这个方法。因此组件内可以使用 $emit 来进行通知。</p><p>这里有一道考题: for 循环的时候如何拿到子组件的传值和 for 中循环的值</p><p>答案有俩种，一是 $event, 二是 闭包。只是需要注意 $event 只能获取到第一个值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in [1, 2, 3]&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">children</span> @<span class="hljs-attr">abc</span>=<span class="hljs-string">&quot;((val, val2) =&gt; getValue(val, item))&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">children</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="四、v-model"><a href="#四、v-model" class="headerlink" title="四、v-model"></a>四、v-model</h3><p>这个其实是一种通过 emit，on 的组合方式。优点再于同步值方便,写法优雅。下面三种写法其实是一个意思</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 写法 1</span><br>&lt;children v-model=<span class="hljs-string">&quot;a&quot;</span>&gt;&lt;/children&gt;<br>&#123;<br>    model: &#123;<br>        prop: <span class="hljs-string">&#x27;value&#x27;</span>,<br>        event: <span class="hljs-string">&#x27;update:a&#x27;</span>,<br>    &#125;,<br>    methods: &#123;<br>        <span class="hljs-function"><span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;update:a&#x27;</span>, <span class="hljs-number">1</span>)&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 写法 2</span><br>&lt;children :a=<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-meta">@update</span>:a=<span class="hljs-string">&quot;a = $event&quot;</span>&gt;&lt;/children&gt;<br>&#123;<br>    props: [<span class="hljs-string">&#x27;a&#x27;</span>]<br>    methods: &#123;<br>        <span class="hljs-function"><span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;update:a&#x27;</span>, <span class="hljs-number">1</span>)&#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 写法 3</span><br><span class="hljs-comment">// 1. 事件名必须是 update: + 属性名</span><br><span class="hljs-comment">// 2. 参数不能是表达式，最好是 data 里面的属性</span><br>&lt;children :a.sync=<span class="hljs-string">&quot;a&quot;</span>&gt;&lt;/children&gt;<br>&#123;<br>    props: [<span class="hljs-string">&#x27;a&#x27;</span>]<br>    methods: &#123;<br>        <span class="hljs-function"><span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;update:a&#x27;</span>, <span class="hljs-number">1</span>)&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="五、插槽"><a href="#五、插槽" class="headerlink" title="五、插槽"></a>五、插槽</h3><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!--默认插槽--&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!--另一种默认插槽的写法--&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;default&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!--具名插槽--&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!--传参插槽--&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">v-bind:user</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-comment">&lt;!--使用--&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">children</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!--跑到默认插槽中去--&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!--另一种默认插槽的写法--&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!--跑到具名插槽 footer 中去--&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!--缩写形式--&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!--获取子组件的值--&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>=<span class="hljs-string">&quot;slot&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">slot.user</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!--结构插槽值--&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>=<span class="hljs-string">&quot;&#123;user: person&#125;&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">person</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!--老式写法，可以写到具体的标签上面--&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;footer&quot;</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;scope&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">children</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="六、-refs-root-parent-children"><a href="#六、-refs-root-parent-children" class="headerlink" title="六、$refs, $root, $parent, $children"></a>六、$refs, $root, $parent, $children</h3><p>$root 获取根组件<br>$parent 获取父组件<br>$children 获取子组件(所有的子组件，不保证顺序)<br>$refs 组件获取组件实例，元素获取元素<br>七、project / inject<br>注意：注入的值是非响应的</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!--父组件 提供--&gt;</span></span><br><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    project() &#123;</span><br><span class="hljs-template-variable">        return &#123;</span><br><span class="hljs-template-variable">            parent: this</span><br><span class="hljs-template-variable">        &#125;</span><br><span class="xml">    &#125;</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-comment">&lt;!--子组件 注入--&gt;</span></span><br><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    // 写法一</span><br><span class="hljs-template-variable">    inject: [&#x27;parent&#x27;]</span><br><span class="hljs-template-variable">    // 写法二</span><br><span class="hljs-template-variable">    inject: &#123; parent: &#x27;parent&#x27; &#125;</span><br><span class="xml">    // 写法三</span><br><span class="xml">    inject: </span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">        parent: &#123;</span><br><span class="hljs-template-variable">            from: &#x27;parent&#x27;,</span><br><span class="hljs-template-variable">            <span class="hljs-keyword">default</span>: 222</span><br><span class="hljs-template-variable">        &#125;</span><br><span class="xml">    &#125;</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="八、Vuex"><a href="#八、Vuex" class="headerlink" title="八、Vuex"></a>八、Vuex</h3><p>介绍</p><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态， 并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension， 提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p><p>优缺点</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>解决了多层组件之间繁琐的事件传播。<br>解决了多组件依赖统同一状态的问题。<br>单向数据流<br>为Vue量身定做，学习成本不高</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>不能做数据持久化，刷新页面就要重制，要做数据持久化可以考虑使用localstorage。<br>增加额外的代码体积，简单的业务场景不建议使用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。</p><ol><li>props / $emit 适用 父子组件通信</li></ol><p>这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。</p><ol start="2"><li>ref 与 $parent / $children 适用 父子组件通信</li></ol><p>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例<br>$parent / $children：访问父 / 子实例<br>3. EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信</p><p>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</p><ol start="4"><li>$attrs/$listeners 适用于 隔代组件通信</li></ol><p>$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=”$attrs” 传入内部组件。通常配合 inheritAttrs 选项一起使用。<br>$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件<br>5. provide / inject 适用于 隔代组件通信</p><p>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p><ol start="6"><li>Vuex 适用于 父子、隔代、兄弟组件通信</li></ol><h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p><p>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p><p>（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p><p>主要包括以下几个模块：</p><p>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。<br>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。<br>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。<br>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。<br>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844904080540712967#heading-2">Vue 组件传参的八种方式总结</a><br><a href="https://juejin.cn/post/6844903736356126734#heading-1">几种常见的Vue组件间的传参方式</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css实现两栏固定中间自适应</title>
    <link href="/2021/07/06/Css%E5%B8%83%E5%B1%80/"/>
    <url>/2021/07/06/Css%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="css实现两栏固定中间自适应"><a href="#css实现两栏固定中间自适应" class="headerlink" title="css实现两栏固定中间自适应"></a>css实现两栏固定中间自适应</h3><h4 id="1、利用绝对定位和margin"><a href="#1、利用绝对定位和margin" class="headerlink" title="1、利用绝对定位和margin"></a>1、利用绝对定位和margin</h4><blockquote><p>此方法的原理说将左右两侧进行定位，让其脱离文档流。 中心区域自然流动到它们下面，再为其设置margin值</p></blockquote><p>此方法页面元素结构可以顺序可以随意变动， 注意top值需要进行处理，不然可能会出现对不齐现象</p><p>HTML</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">&lt;<span class="hljs-keyword">div</span> id=<span class="hljs-string">&#x27;container&#x27;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&#x27;left&#x27;</span>&gt;左侧&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&#x27;center&#x27;</span>&gt;中间&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&#x27;right&#x27;</span>&gt;右侧&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>CSS</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.left</span>, <span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.center</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span> <span class="hljs-number">210px</span>;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、利用浮动和margin"><a href="#2、利用浮动和margin" class="headerlink" title="2、利用浮动和margin"></a>2、利用浮动和margin</h3><p>此方法的原理说将左右两侧进行float 浮动让其脱离文档流，中心部分处于正常文档流，再为其设置margin值</p><blockquote><p>此方法一定要将center中间部分放到最后，当窗口特别小时右侧会被挤下来</p></blockquote><p>HTML</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">&lt;<span class="hljs-keyword">div</span> id=<span class="hljs-string">&#x27;container&#x27;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&#x27;left&#x27;</span>&gt;左侧&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&#x27;right&#x27;</span>&gt;右侧&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&#x27;center&#x27;</span>&gt;中间&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>CSS</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.left</span>, <span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">float</span>: right;<br>&#125;<br><span class="hljs-selector-class">.center</span> &#123;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span> <span class="hljs-number">210px</span>;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、CSS3-flex"><a href="#3、CSS3-flex" class="headerlink" title="3、CSS3 flex"></a>3、CSS3 flex</h3><p>HTML</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">&lt;<span class="hljs-keyword">div</span> id=<span class="hljs-string">&#x27;container&#x27;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&#x27;left&#x27;</span>&gt;左侧&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&#x27;center&#x27;</span>&gt;中间&lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&#x27;right&#x27;</span>&gt;右侧&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>CSS</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><span class="hljs-selector-class">.left</span>, <span class="hljs-selector-class">.right</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">500px</span>;<br>&#125;<br><span class="hljs-selector-class">.center</span> &#123;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/imageO/21.png" alt="效果"></p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844903727204139022#heading-0">css实现两栏固定中间自适应</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP报文&amp;HTTP的优缺点</title>
    <link href="/2021/07/05/Http%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/07/05/Http%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="HTTP-报文结构是怎样的？"><a href="#HTTP-报文结构是怎样的？" class="headerlink" title="HTTP 报文结构是怎样的？"></a>HTTP 报文结构是怎样的？</h3><p>对于 TCP 而言，在传输的时候分为两个部分:TCP头和数据部分。</p><p>而 HTTP 类似，也是header + body的结构，具体而言:</p><blockquote><p>起始行 + 头部 + 空行 + 实体</p></blockquote><p>由于 http 请求报文和响应报文是有一定区别，因此我们分开介绍。</p><p>起始行<br>对于请求报文来说，起始行类似下面这样:</p><blockquote><p>GET /home HTTP/1.1</p></blockquote><p>也就是方法 + 路径 + http版本。</p><p>对于响应报文来说，起始行一般张这个样:</p><blockquote><p>HTTP/1.1 200 OK</p></blockquote><p>响应报文的起始行也叫做状态行。由http版本、状态码和原因三部分组成。</p><p>值得注意的是，在起始行中，每两个部分之间用空格隔开，最后一个部分后面应该接一个换行，严格遵循ABNF语法规范。</p><h4 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h4><p>展示一下请求头和响应头在报文中的位置:</p><p>不管是请求头还是响应头，其中的字段是相当多的，而且牵扯到http非常多的特性，这里就不一一列举的，重点看看这些头部字段的格式：</p><p>字段名不区分大小写<br>字段名不允许出现空格，不可以出现下划线_<br>字段名后面必须紧接着:</p><h4 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h4><p>很重要，用来区分开头部和实体。</p><p>问: 如果说在头部中间故意加一个空行会怎么样？</p><p>那么空行后的内容全部被视为实体。</p><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><p>就是具体的数据了，也就是body部分。请求报文对应请求体, 响应报文对应响应体。</p><h3 id="如何理解-URI？"><a href="#如何理解-URI？" class="headerlink" title="如何理解 URI？"></a>如何理解 URI？</h3><p><strong>URI</strong>, 全称为(Uniform Resource Identifier), 也就是<strong>统一资源标识符</strong>，它的作用很简单，就是区分互联网上不同的资源。</p><blockquote><p>但是，它并不是我们常说的网址, 网址指的是URL, 实际上URI包含了URN和URL两个部分，由于 URL 过于普及，就默认将 URI 视为 URL 了。</p></blockquote><p>URI 的结构<br>URI 真正最完整的结构是这样的。</p><p>可能你会有疑问，好像跟平时见到的不太一样啊！先别急，我们来一一拆解。</p><p><strong>scheme</strong> 表示协议名，比如http, https, file等等。后面必须和://连在一起。</p><p><strong>user:passwd@</strong> 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。</p><p><strong>host:port</strong>表示主机名和端口。</p><p><strong>path</strong>表示请求路径，标记资源所在位置。</p><p><strong>query</strong>表示查询参数，为key=val这种形式，多个键值对之间用&amp;隔开。</p><p><strong>fragment</strong>表示 URI 所定位的资源内的一个锚点，浏览器可以根据这个锚点跳转到对应的位置。</p><p>举个例子:</p><p><code>&lt;https://www.baidu.com/s?wd=HTTP&amp;rsv_spt=1&gt;</code><br>复制代码<br>这个 URI 中，https即scheme部分，<code>www.baidu.com</code>为host:port部分（注意，http 和 https 的默认端口分别为80、443），/s为path部分，而wd=HTTP&amp;rsv_spt=1就是query部分。</p><h3 id="如何理解-HTTP-状态码？"><a href="#如何理解-HTTP-状态码？" class="headerlink" title="如何理解 HTTP 状态码？"></a>如何理解 HTTP 状态码？</h3><p>RFC 规定 HTTP 的状态码为三位数，被分为五类:</p><p>1xx: 表示目前是协议处理的中间状态，还需要后续操作。<br>2xx: 表示成功状态。<br>3xx: 重定向状态，资源位置发生变动，需要重新请求。<br>4xx: 请求报文有误。<br>5xx: 服务器端发生错误。</p><h3 id="简要概括一下-HTTP-的特点？HTTP-有哪些缺点？"><a href="#简要概括一下-HTTP-的特点？HTTP-有哪些缺点？" class="headerlink" title="简要概括一下 HTTP 的特点？HTTP 有哪些缺点？"></a>简要概括一下 HTTP 的特点？HTTP 有哪些缺点？</h3><h4 id="HTTP-特点"><a href="#HTTP-特点" class="headerlink" title="HTTP 特点"></a>HTTP 特点</h4><p>HTTP 的特点概括如下:</p><ol><li><p>灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</p></li><li><p>可靠传输。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。</p></li></ol><p>请求-应答。也就是一发一收、有来有回， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。</p><ol start="3"><li>无状态。这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。</li></ol><h4 id="TTP-缺点"><a href="#TTP-缺点" class="headerlink" title="TTP 缺点"></a>TTP 缺点</h4><h5 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h5><p>所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的无状态。</p><p>在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。</p><p>但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。</p><h4 id="明文传输"><a href="#明文传输" class="headerlink" title="明文传输"></a>明文传输</h4><p>即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。</p><p>这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。WIFI陷阱就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。</p><h4 id="队头阻塞问题"><a href="#队头阻塞问题" class="headerlink" title="队头阻塞问题"></a>队头阻塞问题</h4><p>当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的队头阻塞问题。接下来会有一小节讨论这个问题。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844904100035821575#heading-15">（建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue router钩子函数</title>
    <link href="/2021/07/05/Vue%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90/"/>
    <url>/2021/07/05/Vue%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="路由钩子函数就是在发生路由跳转时，在每个时机调用的函数"><a href="#路由钩子函数就是在发生路由跳转时，在每个时机调用的函数" class="headerlink" title="路由钩子函数就是在发生路由跳转时，在每个时机调用的函数"></a>路由钩子函数就是在发生路由跳转时，在每个时机调用的函数</h2><h3 id="路由的钩子函数总结有6个"><a href="#路由的钩子函数总结有6个" class="headerlink" title="路由的钩子函数总结有6个"></a>路由的钩子函数总结有6个</h3><p>全局的路由钩子函数：beforeEach、afterEach</p><p>单个的路由钩子函数：beforeEnter</p><p>组件内的路由钩子函数：beforeRouteEnter、beforeRouteLeave、beforeRouteUpdate</p><h3 id="模块一：全局导航钩子函数"><a href="#模块一：全局导航钩子函数" class="headerlink" title="模块一：全局导航钩子函数"></a>模块一：全局导航钩子函数</h3><h4 id="1、vue-router-beforeEach（全局前置守卫）"><a href="#1、vue-router-beforeEach（全局前置守卫）" class="headerlink" title="1、vue router.beforeEach（全局前置守卫）"></a>1、vue router.beforeEach（全局前置守卫）</h4><p>beforeEach的钩子函数，它是一个全局的before 钩子函数，</p><p>（beforeEach）意思是在 每次每一个路由改变的时候都得执行一遍。</p><p>它的三个参数：</p><p>to: (Route路由对象) 即将要进入的目标 路由对象 to对象下面的属性： path params query hash fullPath matched name meta（在matched下，但是本例可以直接用）</p><p>from: (Route路由对象) 当前导航正要离开的路由</p><p>next: (Function函数) 一定要调用该方法来 resolve 这个钩子。 调用方法：next(参数或者空) ***必须调用</p><p>next(无参数的时候): 进行管道中的下一个钩子，如果走到最后一个钩子函数，那么 导航的状态就是 confirmed （确认的）</p><p>next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。</p><p>应用场景：可进行一些页面跳转前处理，例如判断需要登录的页面进行拦截，做登录跳转！！</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">router.beforeEach((to, from, <span class="hljs-keyword">next</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (to.meta.requireAuth) &#123;<br>        <span class="hljs-regexp">//</span>判断该路由是否需要登录权限<br>        <span class="hljs-keyword">if</span> (cookies(<span class="hljs-string">&#x27;token&#x27;</span>)) &#123;<br>            <span class="hljs-regexp">//</span>通过封装好的cookies读取token，如果存在，name接下一步如果不存在，那跳转回登录页<br>            <span class="hljs-keyword">next</span>()<span class="hljs-regexp">//</span>不要在<span class="hljs-keyword">next</span>里面加<span class="hljs-string">&quot;path:/&quot;</span>,会陷入死循环<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">next</span>(&#123;<br>                path: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>                query: &#123;redirect: to.fullPath&#125;<span class="hljs-regexp">//</span>将跳转的路由path作为参数，登录成功后跳转到该路由<br>            &#125;)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">next</span>()<br>    &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>应用场景，进入页面登录判断、管理员权限判断、浏览器判断</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>使用钩子函数对路由进行权限跳转<br>router.beforeEach((to, from, <span class="hljs-keyword">next</span>) =&gt; &#123;<br>    const role = localStorage.getItem(<span class="hljs-string">&#x27;ms_username&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(!role &amp;&amp; to.path !== <span class="hljs-string">&#x27;/login&#x27;</span>)&#123;<br>        <span class="hljs-keyword">next</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(to.meta.permission)&#123;<br>        <span class="hljs-regexp">//</span> 如果是管理员权限则可进入，这里只是简单的模拟管理员权限而已<br>        role === <span class="hljs-string">&#x27;admin&#x27;</span> ? <span class="hljs-keyword">next</span>() : <span class="hljs-keyword">next</span>(<span class="hljs-string">&#x27;/403&#x27;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-regexp">//</span> 简单的判断IE10及以下不进入富文本编辑器，该组件不兼容<br>        <span class="hljs-keyword">if</span>(navigator.userAgent.indexOf(<span class="hljs-string">&#x27;MSIE&#x27;</span>) &gt; -<span class="hljs-number">1</span> &amp;&amp; to.path === <span class="hljs-string">&#x27;/editor&#x27;</span>)&#123;<br>            Vue.prototype.<span class="hljs-variable">$alert</span>(<span class="hljs-string">&#x27;vue-quill-editor组件不兼容IE10及以下浏览器，请使用更高版本的浏览器查看&#x27;</span>, <span class="hljs-string">&#x27;浏览器不兼容通知&#x27;</span>, &#123;<br>                confirmButtonText: <span class="hljs-string">&#x27;确定&#x27;</span><br>            &#125;);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">next</span>();<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="2、vue-router-afterEach（全局后置守卫）"><a href="#2、vue-router-afterEach（全局后置守卫）" class="headerlink" title="2、vue router.afterEach（全局后置守卫）"></a>2、vue router.afterEach（全局后置守卫）</h4><p>router.beforeEach 是页面加载之前，相反router.afterEach是页面加载之后</p><h3 id="模块二：路由独享的守卫-路由内钩子"><a href="#模块二：路由独享的守卫-路由内钩子" class="headerlink" title="模块二：路由独享的守卫(路由内钩子)"></a>模块二：路由独享的守卫(路由内钩子)</h3><p>你可以在路由配置上直接定义 beforeEnter 守卫：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  routes: [<br>    &#123;<br>      path: <span class="hljs-string">&#x27;/foo&#x27;</span>,<br>      component: Foo,<br>      beforeEnter: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>      &#125;<br>    &#125;<br>  ]<br><br></code></pre></td></tr></table></figure><p>这些守卫与全局前置守卫的方法参数是一样的。</p><h3 id="模块三：组件内的守卫-组件内钩子"><a href="#模块三：组件内的守卫-组件内钩子" class="headerlink" title="模块三：组件内的守卫(组件内钩子)"></a>模块三：组件内的守卫(组件内钩子)</h3><p>1、beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">const Foo = &#123;<br>  template: `...`,<br>  beforeRouteEnter (to, from, <span class="hljs-keyword">next</span>) &#123;<br>    <span class="hljs-regexp">//</span> 在渲染该组件的对应路由被 confirm 前调用<br>    <span class="hljs-regexp">//</span> 不！能！获取组件实例 `this`<br>    <span class="hljs-regexp">//</span> 因为当钩子执行前，组件实例还没被创建<br>  &#125;,<br>  beforeRouteUpdate (to, from, <span class="hljs-keyword">next</span>) &#123;<br>    <span class="hljs-regexp">//</span> 在当前路由改变，但是该组件被复用时调用<br>    <span class="hljs-regexp">//</span> 举例来说，对于一个带有动态参数的路径 <span class="hljs-regexp">/foo/</span>:id，在 <span class="hljs-regexp">/foo/</span><span class="hljs-number">1</span> 和 <span class="hljs-regexp">/foo/</span><span class="hljs-number">2</span> 之间跳转的时候，<br>    <span class="hljs-regexp">//</span> 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。<br>    <span class="hljs-regexp">//</span> 可以访问组件实例 `this`<br>  &#125;,<br>  beforeRouteLeave (to, from, <span class="hljs-keyword">next</span>) &#123;<br>    <span class="hljs-regexp">//</span> 导航离开该组件的对应路由时调用<br>    <span class="hljs-regexp">//</span> 可以访问组件实例 `this`<br><br>  &#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>路由钩子在实际开发中的应用场景<br>(一) 清除当前组件中的定时器</li></ol><p>当一个组件中有一个定时器时, 在路由进行切换的时候, 可使用beforeRouteLeave将定时器进行清楚, 以免占用内存:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta">beforeRouteLeave (to, <span class="hljs-keyword">from</span>, <span class="hljs-keyword">next</span>) &#123;  <br> window.clearInterval(<span class="hljs-keyword">this</span>.timer) <span class="hljs-comment">//清楚定时器   </span><br> <span class="hljs-keyword">next</span>()<br> &#125;<br></code></pre></td></tr></table></figure><p>(二) 当页面中有未关闭的窗口, 或未保存的内容时, 阻止页面跳转</p><p>如果页面内有重要的信息需要用户保存后才能进行跳转, 或者有弹出框的情况. 应该阻止用户跳转，结合vuex状态管理（dialogVisibility是否有保存）</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs axapta">beforeRouteLeave (to, <span class="hljs-keyword">from</span>, <span class="hljs-keyword">next</span>) &#123;<br> <span class="hljs-comment">//判断是否弹出框的状态和保存信息与否</span><br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.dialogVisibility === <span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">this</span>.dialogVisibility = <span class="hljs-literal">false</span> <span class="hljs-comment">//关闭弹出框</span><br>    <span class="hljs-keyword">next</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">//回到当前页面, 阻止页面跳转</span><br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.saveMessage === <span class="hljs-literal">false</span>) &#123;<br>    alert(<span class="hljs-string">&#x27;请保存信息后退出!&#x27;</span>) <span class="hljs-comment">//弹出警告</span><br>    <span class="hljs-keyword">next</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">//回到当前页面, 阻止页面跳转</span><br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">next</span>() <span class="hljs-comment">//否则允许跳转</span><br>  &#125;<br><br></code></pre></td></tr></table></figure><p>(三) 保存相关内容到Vuex中或Session中</p><p>当用户需要关闭页面时, 可以将公用的信息保存到session或Vuex中</p><p> beforeRouteLeave (to, from, next) {<br>    localStorage.setItem(name, content); //保存到localStorage中<br>    next()<br>}</p><h4 id="全局路由钩子函数"><a href="#全局路由钩子函数" class="headerlink" title="全局路由钩子函数"></a>全局路由钩子函数</h4><p>每次路由跳转，都会执行beforeEach和afterEach，一般写在main.js可以做权限控制</p><p>例如：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">router.beforeEach(<span class="hljs-function"><span class="hljs-params">(to, <span class="hljs-keyword">from</span>, <span class="hljs-built_in">next</span>)</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (to.matched.length === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">from</span>.name ? <span class="hljs-built_in">next</span>(&#123; name : <span class="hljs-keyword">from</span>.name &#125;) : <span class="hljs-built_in">next</span>(<span class="hljs-string">&#x27;/&#x27;</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">next</span>()<br>  &#125;<br>&#125;)<br>router.afterEach(<span class="hljs-function"><span class="hljs-params">(to,<span class="hljs-keyword">from</span>)</span> =&gt;</span> &#123;<br>  console.log(to);//到达的路由<br>  console.log(<span class="hljs-keyword">from</span>);//离开的路由<br>&#125;)<br> <br>单个路由钩子函数<br><br>beforeEnter有三个参数：to/<span class="hljs-keyword">from</span>/<span class="hljs-built_in">next</span><br><br>  <span class="hljs-name">routes</span>: [<br>    &#123;<br>      <span class="hljs-name">path</span>: <span class="hljs-string">&#x27;/foo&#x27;</span>,<br>      <span class="hljs-name">component</span>: Foo,<br>      <span class="hljs-name">beforeEnter</span>: <span class="hljs-function"><span class="hljs-params">(to, <span class="hljs-keyword">from</span>, <span class="hljs-built_in">next</span>)</span> =&gt;</span> &#123;<br>        // ...<br>      &#125;<br>    &#125;<br>  ]<br></code></pre></td></tr></table></figure><p>组件内路由钩子函数</p><p>三个参数：to/from/next</p><p>beforeRouteEnter：进入这个组建路由之前</p><p>beforeRouteLeave：离开这个组建路由</p><p>beforeRouteUpdate：再本路由的下级路由切换才会触发beforeRouteUpdate</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk">beforeRouteEnter (to, from, <span class="hljs-keyword">next</span>) &#123;<br>  console.log(<span class="hljs-string">&#x27;1111&#x27;</span>)<br>  <span class="hljs-keyword">next</span>()<br>  <span class="hljs-regexp">//</span> 在渲染该组件的对应路由被 confirm 前调用<br>  <span class="hljs-regexp">//</span> 不！能！获取组件实例 `this`<br>  <span class="hljs-regexp">//</span> 因为当钩子执行前，组件实例还没被创建<br>&#125;,<br>beforeRouteUpdate (to, from, <span class="hljs-keyword">next</span>) &#123;<br>   console.log(<span class="hljs-string">&#x27;222&#x27;</span>)<br>  <span class="hljs-regexp">//</span> 在当前路由改变，但是该组件被复用时调用<br>  <span class="hljs-regexp">//</span> 举例来说，对于一个带有动态参数的路径 <span class="hljs-regexp">/foo/</span>:id，在 <span class="hljs-regexp">/foo/</span><span class="hljs-number">1</span> 和 <span class="hljs-regexp">/foo/</span><span class="hljs-number">2</span> 之间跳转的时候，<br>  <span class="hljs-regexp">//</span> 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。<br>  <span class="hljs-regexp">//</span> 可以访问组件实例 `this`<br>&#125;,<br>beforeRouteLeave (to, from, <span class="hljs-keyword">next</span>) &#123;<br>  <span class="hljs-regexp">//</span> 导航离开该组件的对应路由时调用<br>  <span class="hljs-regexp">//</span> 可以访问组件实例 `this`<br>  alert(<span class="hljs-string">&quot;3sdsss&quot;</span>)<br>  <span class="hljs-keyword">next</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.zhihu.com/search?type=content&q=ue%20router%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0">知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 响应式原理</title>
    <link href="/2021/07/04/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <url>/2021/07/04/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="Vue-初始化"><a href="#Vue-初始化" class="headerlink" title="Vue 初始化"></a>Vue 初始化</h3><p>先从最简单的一段 Vue 代码开始：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">message</span> &#125;&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">new Vue(&#123;</span><br><span class="xml">  data() &#123;</span><br><span class="xml">    return &#123;</span><br><span class="xml">      message: &quot;hello world&quot;,</span><br><span class="xml">    &#125;;</span><br><span class="xml">  &#125;,</span><br><span class="xml">&#125;);</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这段代码很简单，最终会在页面上打印一个 hello world，它是如何实现的呢？</p><p>我们从源头：new Vue 的地方开始分析。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 执行 new Vue 时会依次执行以下方法</span><br><span class="hljs-comment">// 1. Vue.prototype._init(option)</span><br><span class="hljs-comment">// 2. initState(vm)</span><br><span class="hljs-comment">// 3. observe(vm._data)</span><br><span class="hljs-comment">// 4. new Observer(data)</span><br><br><span class="hljs-comment">// 5. 调用 walk 方法，遍历 data 中的每一个属性，监听数据的变化。</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">walk</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(obj);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) &#123;<br>    defineReactive(obj, keys[i]);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 6. 执行 defineProperty 监听数据读取和设置。</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">obj, key, val</span>) </span>&#123;<br>  <span class="hljs-comment">// 为每个属性创建 Dep（依赖搜集的容器，后文会讲）</span><br>  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep();<br>  <span class="hljs-comment">// 绑定 get、set</span><br>  <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;<br>    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">const</span> value = val;<br>      <span class="hljs-comment">// 如果有 target 标识，则进行依赖搜集</span><br>      <span class="hljs-keyword">if</span> (Dep.target) &#123;<br>        dep.depend();<br>      &#125;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newVal</span>)</span> &#123;<br>      val = newVal;<br>      <span class="hljs-comment">// 修改数据时，通知页面重新渲染</span><br>      dep.notify();<br>    &#125;,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>…</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>从 new Vue 开始，首先通过 get、set 监听 Data 中的数据变化，同时创建 Dep 用来搜集使用该 Data 的 Watcher。</p></li><li><p>编译模板，创建 Watcher，并将 Dep.target 标识为当前 Watcher。</p></li><li><p>编译模板时，如果使用到了 Data 中的数据，就会触发 Data 的 get 方法，然后调用 Dep.addSub 将 Watcher 搜集起来。</p></li><li><p>数据更新时，会触发 Data 的 set 方法，然后调用 Dep.notify 通知所有使用到该 Data 的 Watcher 去更新 DOM。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 中的 router 实现原理如何&amp;SPA页面优缺点</title>
    <link href="/2021/07/04/Vue-Router%E5%8E%9F%E7%90%86/"/>
    <url>/2021/07/04/Vue-Router%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="后端路由简介"><a href="#后端路由简介" class="headerlink" title="后端路由简介"></a>后端路由简介</h3><p>路由这个概念最先是后端出现的。在以前用模板引擎开发页面时，经常会看到这样</p><p><code>&lt;http://www.xxx.com/login&gt;</code></p><p>大致流程可以看成这样：</p><p>浏览器发出请求</p><p>服务器监听到80端口（或443）有请求过来，并解析url路径</p><p>根据服务器的路由配置，返回相应信息（可以是 html 字串，也可以是 json 数据，图片等）</p><p>浏览器根据数据包的 Content-Type 来决定如何解析数据</p><p>简单来说路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能。</p><h4 id="说说你对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#说说你对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="说说你对 SPA 单页面的理解，它的优缺点分别是什么？"></a>说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h4><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li><li>基于上面一点，SPA 相对对服务器压力小；</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ol><h3 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h3><h3 id="1-hash-模式"><a href="#1-hash-模式" class="headerlink" title="1. hash 模式"></a>1. hash 模式</h3><p>随着 ajax 的流行，异步数据请求交互运行在不刷新浏览器的情况下进行。而异步交互体验的更高级版本就是 SPA —— 单页应用。单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。 类似于服务端路由，前端路由实现起来其实也很简单，就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容。但是这样存在一个问题，就是 url 每次变化的时候，都会造成页面的刷新。那解决问题的思路便是在改变 url 的情况下，保证页面的不刷新。在 2014 年之前，大家是通过 hash 来实现路由，url hash 就是类似于：</p><p><code>&lt;http://www.xxx.com/#/login&gt;</code><br>复制代码<br>这种 #。后面 hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外每次 hash 值的变化，还会触发hashchange 这个事件，通过这个事件我们就可以知道 hash 值发生了哪些变化。然后我们便可以监听hashchange来实现更新页面部分内容的操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchAndUpdate</span> (<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-comment">// todo 匹配 hash 做 dom 更新操作</span><br>&#125;<br><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;hashchange&#x27;</span>, matchAndUpdate)<br></code></pre></td></tr></table></figure><h3 id="2-history-模式"><a href="#2-history-模式" class="headerlink" title="2. history 模式"></a>2. history 模式</h3><p>14年后，因为HTML5标准发布。多了两个 API，pushState 和 replaceState，通过这两个 API 可以改变 url 地址且不会发送请求。同时还有popstate 事件。通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。用了 HTML5 的实现，单页路由的 url 就不会多出一个#，变得更加美观。但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">matchAndUpdate</span> (<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-comment">// todo 匹配路径 做 dom 更新操作</span><br>&#125;<br><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;popstate&#x27;</span>, matchAndUpdate)<br></code></pre></td></tr></table></figure><h3 id="前端路由实现的本质是监听url变化，实现方式有两种：Hash模式和History模式无需刷新页面就能重新加载相应的页面"><a href="#前端路由实现的本质是监听url变化，实现方式有两种：Hash模式和History模式无需刷新页面就能重新加载相应的页面" class="headerlink" title="前端路由实现的本质是监听url变化，实现方式有两种：Hash模式和History模式无需刷新页面就能重新加载相应的页面"></a>前端路由实现的本质是监听url变化，实现方式有两种：Hash模式和History模式无需刷新页面就能重新加载相应的页面</h3><p>Hash url的格式为<code>www.a.com/#/</code>，当#后的哈希值发生变化时，通过hashchange事件监听，然后页面跳转。 History url通过history.pushState和history.replaceState改变url。 两种模式的区别：</p><ol><li>hash只能改变#后的值，而history模式可以随意设置同源url；</li><li>hash只能添加字符串类的数据，而history可以通过API添加多种类型的数据；</li><li>hash的历史记录只显示之前的<code>www.a.com</code>而不会显示hash值，而history的每条记录都会进入到历史记录；</li><li>hash无需后端配置且兼容性好，而history需要配置index.html用于匹配不到资源的情况。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这一次，彻底弄懂 JavaScript 执行机制</title>
    <link href="/2021/07/03/Js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/07/03/Js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>因为javascript是一门单线程语言，javascript是按照语句出现的顺序执行的</p><hr><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>正因为js是一行一行执行的，所以我们以为js都是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;1&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(a);<br><br><span class="hljs-keyword">let</span> b = <span class="hljs-string">&#x27;2&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(b);<br><br></code></pre></td></tr></table></figure><p>然而实际上js是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;定时器开始啦&#x27;</span>)<br>&#125;);<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;马上执行for循环啦&#x27;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;<br>        i == <span class="hljs-number">99</span> &amp;&amp; resolve();<br>    &#125;<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;执行then函数啦&#x27;</span>)<br>&#125;);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;代码执行结束&#x27;</span>);<br></code></pre></td></tr></table></figure><p>依照js是按照语句出现的顺序执行这个理念，自信的写下输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-string">&quot;定时器开始啦&quot;</span><br><span class="hljs-regexp">//</span><span class="hljs-string">&quot;马上执行for循环啦&quot;</span><br><span class="hljs-regexp">//</span><span class="hljs-string">&quot;执行then函数啦&quot;</span><br><span class="hljs-regexp">//</span><span class="hljs-string">&quot;代码执行结束&quot;</span><br></code></pre></td></tr></table></figure><p>去chrome上验证下，结果完全不对，瞬间懵了，说好的一行一行执行的呢？</p><p>我们真的要彻底弄明白javascript的执行机制了。</p><h3 id="关于javascript"><a href="#关于javascript" class="headerlink" title="关于javascript"></a>关于javascript</h3><p>javascript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。所以一切javascript版的”多线程”都是用单线程模拟出来的，一切javascript多线程都是纸老虎！</p><h3 id="javascript事件循环"><a href="#javascript事件循环" class="headerlink" title="javascript事件循环"></a>javascript事件循环</h3><p>既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？因此聪明的程序员将任务分为两类：</p><blockquote><p>同步任务<br>异步任务<br>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。</p></blockquote><p><img src="/imageO/19.png" alt="如图"></p><p>导图要表达的内容用文字来表述的话：</p><ul><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ul><p>我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p><p>说了这么多文字，不如直接一段代码更直白：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">let data = [];<br>$.ajax(&#123;<br>    url:www.javascript.com,<br>    data:data,<br>    success:<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;发送成功!&#x27;</span>);<br>    &#125;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;代码执行结束&#x27;</span>);<br></code></pre></td></tr></table></figure><p>上面是一段简易的ajax请求代码：</p><ul><li>ajax进入Event Table，注册回调函数success。</li><li>执行console.log(‘代码执行结束’)。</li><li>ajax事件完成，回调函数success进入Event Queue。</li><li>主线程从Event Queue读取回调函数success并执行。</li></ul><h3 id="事件循环Event-Loop是js实现异步的一种方法，也是js的执行机制"><a href="#事件循环Event-Loop是js实现异步的一种方法，也是js的执行机制" class="headerlink" title="事件循环Event Loop是js实现异步的一种方法，也是js的执行机制"></a>事件循环Event Loop是js实现异步的一种方法，也是js的执行机制</h3><p>首先要知道，JS分为同步任务和异步任务<br>同步任务都在主线程(这里的主线程就是JS引擎线程)上执行，会形成一个执行栈<br>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放一个事件回调<br>一旦执行栈中的所有同步任务执行完毕(也就是JS引擎线程空闲了)，系统就会读取任务队列，将可运行的异步任务(任务队列中的事件回调，只要任务队列中有事件回调，就说明可以执行)添加到执行栈中，开始执行</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>javascript是一门单线程语言<br>Event Loop是javascript的执行机制</p><h3 id="宏任务-macrotask-amp-微任务-microtask"><a href="#宏任务-macrotask-amp-微任务-microtask" class="headerlink" title="宏任务(macrotask) &amp; 微任务(microtask)"></a>宏任务(macrotask) &amp; 微任务(microtask)</h3><h4 id="宏任务-macrotask"><a href="#宏任务-macrotask" class="headerlink" title="宏任务(macrotask)"></a>宏任务(macrotask)</h4><p>在ECMAScript中，macrotask也被称为task</p><p>我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)， 每一个宏任务会从头到尾执行完毕，不会执行其他</p><p>由于JS引擎线程和GUI渲染线程是互斥的关系，浏览器为了能够使宏任务和DOM任务有序的进行，会在一个宏任务执行结果后，在下一个宏任务执行前，GUI渲染线程开始工作，对页面进行渲染</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">宏任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...<br></code></pre></td></tr></table></figure><p>常见的宏任务</p><p>主代码块</p><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate ()-Node</li><li>requestAnimationFrame ()-浏览器</li></ul><p>微任务(microtask)<br>ES6新引入了Promise标准，同时浏览器实现上多了一个microtask微任务概念，在ECMAScript中，microtask也被称为jobs</p><p>我们已经知道宏任务结束后，会执行渲染，然后执行下一个宏任务， 而微任务可以理解成在当前宏任务执行后立即执行的任务</p><p>当一个宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">宏任务 -&gt; 微任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...<br></code></pre></td></tr></table></figure><p>常见微任务</p><ul><li>process.nextTick ()-Node</li><li>Promise.then()</li><li>catch</li><li>finally</li><li>Object.observe</li><li>MutationObserver</li></ul><h3 id="微任务宏任务注意点"><a href="#微任务宏任务注意点" class="headerlink" title="微任务宏任务注意点"></a>微任务宏任务注意点</h3><ul><li><p>浏览器会先执行一个宏任务，紧接着执行当前执行栈产生的微任务，再进行渲染，然后再执行下一个宏任务</p></li><li><p>微任务和宏任务不在一个任务队列，不在一个任务队列</p></li></ul><ol><li>例如setTimeout是一个宏任务，它的事件回调在宏任务队列，Promise.then()是一个微任务，它的事件回调在微任务队列，二者并不是一个任务队列</li><li>以Chrome 为例，有关渲染的都是在渲染进程中执行，渲染进程中的任务（DOM树构建，js解析…等等）需要主线程执行的任务都会在主线程中执行，而浏览器维护了一套事件循环机制，主线程上的任务都会放到消息队列中执行，主线程会循环消息队列，并从头部取出任务进行执行，如果执行过程中产生其他任务需要主线程执行的，渲染进程中的其他线程会把该任务塞入到消息队列的尾部，消息队列中的任务都是宏任务</li><li>微任务是如何产生的呢？当执行到script脚本的时候，js引擎会为全局创建一个执行上下文，在该执行上下文中维护了一个微任务队列，当遇到微任务，就会把微任务回调放在微队列中，当所有的js代码执行完毕，在退出全局上下文之前引擎会去检查该队列，有回调就执行，没有就退出执行上下文，这也就是为什么微任务要早于宏任务，也是大家常说的，每个宏任务都有一个微任务队列（由于定时器是浏览器的API，所以定时器是宏任务，在js中遇到定时器会也是放入到浏览器的队列中）</li></ol><h4 id="图解宏任务和微任务"><a href="#图解宏任务和微任务" class="headerlink" title="图解宏任务和微任务"></a>图解宏任务和微任务</h4><p><img src="/imageO/Hong.jpg" alt="如图"><br>首先执行一个宏任务，执行结束后判断是否存在微任务</p><p>有微任务先执行所有的微任务，再渲染，没有微任务则直接渲染</p><p>然后再接着执行下一个宏任务</p><h3 id="图解完整的Event-Loop"><a href="#图解完整的Event-Loop" class="headerlink" title="图解完整的Event Loop"></a>图解完整的Event Loop</h3><p><img src="/imageO/20.png" alt="如图"><br>首先，整体的script(作为第一个宏任务)开始执行的时候，会把所有代码分为同步任务、异步任务两部分</p><p>同步任务会直接进入主线程依次执行</p><p>异步任务会再分为宏任务和微任务</p><p>宏任务进入到Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中</p><p>微任务也会进入到另一个Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中</p><p>当主线程内的任务执行完毕，主线程为空时，会检查微任务的Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务</p><p>上述过程会不断重复，这就是Event Loop，比较完整的事件循环</p><h3 id="关于Promise"><a href="#关于Promise" class="headerlink" title="关于Promise"></a>关于Promise</h3><p>new Promise(() =&gt; {}).then() ，我们来看这样一个Promise代码<br>前面的<strong>new Promise() 这一部分是一个构造函数，这是一个同步任务<br>后面的 .then() 才是一个异步微任务</strong> ，这一点是非常重要的</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve)</span> =&gt;</span> &#123;<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>  resolve()<br>&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>上面代码输出<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="关于-async-await-函数"><a href="#关于-async-await-函数" class="headerlink" title="关于 async/await 函数"></a>关于 async/await 函数</h3><p>async/await本质上还是基于Promise的一些封装，而Promise是属于微任务的一种<br>所以在使用await关键字与Promise.then效果类似</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>))<br><br><span class="hljs-keyword">async</span> function test() &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve()<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>&#125;<br>test()<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>上述代码输出1 2 3 4<br>可以理解为，await 以前的代码，相当于与 new Promise 的同步代码，await 以后的代码相当于 Promise.then的异步</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844904050543034376#heading-1">「硬核JS」一次搞懂JS运行机制</a></p><p><a href="https://juejin.cn/post/6844904072240201736#heading-1">JavaScript运行机制</a></p><p><a href="https://juejin.cn/post/6844903512845860872#heading-2">这一次，彻底弄懂 JavaScript 执行机制</a></p>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈一谈你对 nextTick 的理解？</title>
    <link href="/2021/07/03/Vue&amp;$nextTick%E7%90%86%E8%A7%A3/"/>
    <url>/2021/07/03/Vue&amp;$nextTick%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="什么是nextTick呢？"><a href="#什么是nextTick呢？" class="headerlink" title="什么是nextTick呢？"></a>什么是nextTick呢？</h3><p>vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。</p><p>官方文档：</p><blockquote><p>在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。</p></blockquote><p>nextTick，我可以理解为next是下一个的意思，在事件循环中，每进行一次循环操作称为 tick</p><p>就是下一个事件循环操作，也就是下一个宏任务</p><h3 id="nextTick实现原理"><a href="#nextTick实现原理" class="headerlink" title="nextTick实现原理"></a>nextTick实现原理</h3><h4 id="异步更新"><a href="#异步更新" class="headerlink" title="异步更新"></a>异步更新</h4><p>  我们发现上述两个问题的发生，不管子组件还是父组件，都是在给data中赋值后立马去查看数据导致的。由于“查看数据”这个动作是同步操作的，而且都是在赋值之后；因此我们猜测一下，给数据赋值操作是一个异步操作，并没有马上执行，Vue官网对数据操作是这么描述的：</p><blockquote><p>可能你还没有注意到，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。</p></blockquote><p>  也就是说我们在设置this.msg = ‘xiaoming’的时候，Vue并没有马上去更新DOM数据，而是将这个操作放进一个队列中；如果我们重复执行的话，队列还会进行去重操作；等待同一事件循环中的所有数据变化完成之后，会将队列中的事件拿出来处理。<br>  这样做主要是为了提升性能，因为如果在主线程中更新DOM，循环100次就要更新100次DOM；但是如果等事件循环完成之后更新DOM，只需要更新1次。</p><p>直接上代码看效果</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;views__home&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;xiaoming&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">message</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">export default &#123;</span><br><span class="xml">    data() &#123;</span><br><span class="xml">        return &#123;</span><br><span class="xml">            message: &#x27;test&#x27;</span><br><span class="xml">        &#125;;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    mounted() &#123;</span><br><span class="xml">        this.message = &#x27;xiaoming&#x27;;</span><br><br><span class="xml">        console.log(&#x27;first&#x27;, this.$refs.xiaoming.innerHTML);</span><br><br><span class="xml">        this.$nextTick(() =&gt; &#123;</span><br><span class="xml">            console.log(&#x27;second&#x27;, this.$refs.xiaoming.innerHTML);</span><br><span class="xml">        &#125;);</span><br><span class="xml">    &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/imageO/18.png" alt="如图"></p><h4 id="为什么会这样呢？"><a href="#为什么会这样呢？" class="headerlink" title="为什么会这样呢？"></a>为什么会这样呢？</h4><p>当你执行this.message = ‘xiaoming’的时候，只是把xiaoming赋值给了一个变量，dom实际上还没有更新呢</p><h3 id="那么为什么在this-nextTick里面却可以拿到dom更新后的值呢？"><a href="#那么为什么在this-nextTick里面却可以拿到dom更新后的值呢？" class="headerlink" title="那么为什么在this.$nextTick里面却可以拿到dom更新后的值呢？"></a>那么为什么在this.$nextTick里面却可以拿到dom更新后的值呢？</h3><p>一般来说nextTick，就是在dom渲染完了之后才会执行</p><h3 id="我们要知道vue里面有一个虚拟dom，页面上所有的操作都是先改变虚拟dom，最后再把虚拟dom更新到实际的页面dom上，这个时候就会涉及到到一个问题，什么时候才是最后？"><a href="#我们要知道vue里面有一个虚拟dom，页面上所有的操作都是先改变虚拟dom，最后再把虚拟dom更新到实际的页面dom上，这个时候就会涉及到到一个问题，什么时候才是最后？" class="headerlink" title="我们要知道vue里面有一个虚拟dom，页面上所有的操作都是先改变虚拟dom，最后再把虚拟dom更新到实际的页面dom上，这个时候就会涉及到到一个问题，什么时候才是最后？"></a>我们要知道vue里面有一个虚拟dom，页面上所有的操作都是先改变虚拟dom，最后再把虚拟dom更新到实际的页面dom上，这个时候就会涉及到到一个问题，什么时候才是最后？</h3><p>这个时候就会涉及到JS事件执行机制中的宏任务和微任务</p><p>1、执行完当前宏任务script，立即执行微任务</p><p>2、微任务执行完毕后进行页面渲染</p><p>3、页面渲染完毕，开始执行$nextTick</p><h3 id="为什么用Vue-nextTick"><a href="#为什么用Vue-nextTick" class="headerlink" title="为什么用Vue.nextTick()"></a>为什么用Vue.nextTick()</h3><p>首先来了解一下JS的运行机制。</p><p>JS运行机制（Event Loop）</p><p>JS执行是单线程的，它是基于事件循环的。</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈。</li><li>主线程之外，会存在一个任务队列，只要异步任务有了结果，就在任务队列中放置一个事件。</li><li>当执行栈中的所有同步任务执行完后，就会读取任务队列。那些对应的异步任务，会结束等待状态，进入执行栈。<br>主线程不断重复第三步。</li><li>这里主线程的执行过程就是一个tick，而所有的异步结果都是通过任务队列来调度。Event Loop 分为宏任务和微任务，无论是执行宏任务还是微任务，完成后都会进入到一下tick，并在两个tick之间进行UI渲染。</li></ol><blockquote><p>由于Vue DOM更新是异步执行的，即修改数据时，视图不会立即更新，而是会监听数据变化，并缓存在同一事件循环中，等同一数据循环中的所有数据变化完成之后，再统一进行视图更新。为了确保得到更新后的DOM，所以设置了 Vue.nextTick()方法。</p></blockquote><h3 id="Vue-使用了-nextTick-进行统一更新"><a href="#Vue-使用了-nextTick-进行统一更新" class="headerlink" title="Vue 使用了 nextTick 进行统一更新"></a>Vue 使用了 nextTick 进行统一更新</h3><p>你应该知道，即使在 Vue 中多么频繁地修改数据，最后 Vue 页面只会更新一次</p><p>这是 Vue 和 nextTick 合作产生的结果，但又并不只是 nextTick 起作用</p><p>根据响应式原理，你我都知道</p><p>响应式原理</p><p>比如</p><p>数据 name 被 页面引用，name 会收集到 页面的 watcher</p><p>name 被修改时，会通知所有收集到的 watcher 进行更新（watcher.update）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">this.name</span> = <span class="hljs-number">2</span><br><br><span class="hljs-attr">this.name</span> = <span class="hljs-number">3</span><br><br><span class="hljs-attr">this.name</span> = <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>如果</p><p>name 一时间被修改三次时，按道理应该会通知三次 watcher 更新，那么页面会更新三次</p><p>但是最后只会更新一次</p><p>就是因为他们的合作</p><p>设置 nextTick 回调 + 过滤 watcher</p><p>当数据变化后，把 watcher.update  函数存放进 nextTick 的 回调数组中，并且会做过滤。</p><p>通过 watcher.id 来判断 回调数组 中是否已经存在这个 watcher 的更新函数</p><p>不存在，才 push</p><p>之后 nextTick 遍历回调数组，便会执行了更新</p><p>所以</p><p>当三次修改数据的时候，会准备 push进 回调数组 三个 watcher.update，但是只有第一次是 push 成功的，其他的会被过滤掉</p><p>所以，不管你修改多少次数据，nextTick 的回调数组中只存在唯一一个 watcher.update，从而页面只会更新一次</p><h3 id="nextTick源码分析"><a href="#nextTick源码分析" class="headerlink" title="nextTick源码分析"></a>nextTick源码分析</h3><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p>  Vue把nextTick的源码单独抽到一个文件中，/src/core/util/next-tick.js，删掉注释也就大概六七十行的样子，让我们逐段来分析。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> callbacks = []<br><span class="hljs-keyword">let</span> pending = <span class="hljs-literal">false</span><br><span class="hljs-keyword">let</span> timerFunc<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextTick</span> (<span class="hljs-params">cb?: <span class="hljs-built_in">Function</span>, ctx?: <span class="hljs-built_in">Object</span></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> _resolve<br>  callbacks.push(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (cb) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        cb.call(ctx)<br>      &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        handleError(e, ctx, <span class="hljs-string">&#x27;nextTick&#x27;</span>)<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_resolve) &#123;<br>      _resolve(ctx)<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">if</span> (!pending) &#123;<br>    pending = <span class="hljs-literal">true</span><br>    timerFunc()<br>  &#125;<br>  <span class="hljs-comment">// $flow-disable-line</span><br>  <span class="hljs-keyword">if</span> (!cb &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>      _resolve = resolve<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 我们首先找到nextTick这个函数定义的地方，看看它具体做了什么操作；看到它在外层定义了三个变量，有一个变量看名字就很熟悉：callbacks，就是我们上面说的队列；在nextTick的外层定义变量就形成了一个闭包，所以我们每次调用$nextTick的过程其实就是在向callbacks新增回调函数的过程。<br>  callbacks新增回调函数后又执行了timerFunc函数，pending用来标识同一个时间只能执行一次。那么这个timerFunc函数是做什么用的呢，我们继续来看代码：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">export</span> let isUsingMicroTask = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="hljs-built_in">Promise</span>)) &#123;<br>  <span class="hljs-regexp">//</span>判断<span class="hljs-number">1</span>：是否原生支持<span class="hljs-built_in">Promise</span><br>  const p = <span class="hljs-built_in">Promise</span>.resolve()<br><span class="hljs-function">  <span class="hljs-title">timerFunc</span> = <span class="hljs-params">()</span> =&gt;</span> &#123;<br>    p.<span class="hljs-keyword">then</span>(flushCallbacks)<br>    <span class="hljs-keyword">if</span> (isIOS) <span class="hljs-built_in">setTimeout</span>(noop)<br>  &#125;<br>  isUsingMicroTask = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isIE &amp;&amp; <span class="hljs-keyword">typeof</span> MutationObserver !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; (<br>  isNative(MutationObserver) ||<br>  MutationObserver.toString() === <span class="hljs-string">&#x27;[object MutationObserverConstructor]&#x27;</span><br>)) &#123;<br>  <span class="hljs-regexp">//</span>判断<span class="hljs-number">2</span>：是否原生支持MutationObserver<br>  let counter = <span class="hljs-number">1</span><br>  const observer = <span class="hljs-keyword">new</span> MutationObserver(flushCallbacks)<br>  const textNode = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-built_in">String</span>(counter))<br>  observer.observe(textNode, &#123;<br>    characterData: <span class="hljs-literal">true</span><br>  &#125;)<br><span class="hljs-function">  <span class="hljs-title">timerFunc</span> = <span class="hljs-params">()</span> =&gt;</span> &#123;<br>    counter = (counter + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span><br>    textNode.data = <span class="hljs-built_in">String</span>(counter)<br>  &#125;<br>  isUsingMicroTask = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setImmediate !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;<br>  <span class="hljs-regexp">//</span>判断<span class="hljs-number">3</span>：是否原生支持setImmediate<br><span class="hljs-function">  <span class="hljs-title">timerFunc</span> = <span class="hljs-params">()</span> =&gt;</span> &#123;<br>    setImmediate(flushCallbacks)<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-regexp">//</span>判断<span class="hljs-number">4</span>：上面都不行，直接用<span class="hljs-built_in">setTimeout</span><br><span class="hljs-function">  <span class="hljs-title">timerFunc</span> = <span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(flushCallbacks, <span class="hljs-number">0</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里出现了好几个isNative函数，这是用来判断所传参数是否在当前环境原生就支持；例如某些浏览器不支持Promise，虽然我们使用了垫片(polify)，但是isNative(Promise)还是会返回false。<br>  可以看出这边代码其实是做了四个判断，对当前环境进行不断的降级处理，尝试使用原生的Promise.then、MutationObserver和setImmediate，上述三个都不支持最后使用setTimeout；降级处理的目的都是将flushCallbacks函数放入微任务(判断1和判断2)或者宏任务(判断3和判断4)，等待下一次事件循环时来执行。MutationObserver是Html5的一个新特性，用来监听目标DOM结构是否改变，也就是代码中新建的textNode；如果改变了就执行MutationObserver构造函数中的回调函数，不过是它是在微任务中执行的。<br>  那么最终我们顺藤摸瓜找到了最终的大boss：flushCallbacks；nextTick不顾一切的要把它放入微任务或者宏任务中去执行，它究竟是何方神圣呢？让我们来一睹它的真容：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix">  <span class="hljs-attr">pending</span> = <span class="hljs-literal">false</span><br>  const <span class="hljs-attr">copies</span> = callbacks.slice(<span class="hljs-number">0</span>)<br>  callbacks.<span class="hljs-attr">length</span> = <span class="hljs-number">0</span><br>  for (<span class="hljs-keyword">let</span> <span class="hljs-attr">i</span> = <span class="hljs-number">0</span>; i &lt; copies.length; i++) &#123;<br>    copies[i]()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  本来以为有多复杂的flushCallbacks，居然不过短短的8行。它所做的事情也非常的简单，把callbacks数组复制一份，然后把callbacks置为空，最后把复制出来的数组中的每个函数依次执行一遍；所以它的作用仅仅是用来执行callbacks中的回调函数。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  到这里，整体nextTick的代码都分析完毕了，总结一下它的流程就是：</p><ol><li>把回调函数放入callbacks等待执行</li><li>将执行函数放到微任务或者宏任务中</li><li>事件循环到了微任务或者宏任务，执行函数依次执行callbacks中的回调</li></ol><p>  再回到我们开头说的setTimeout，可以看出来nextTick是对setTimeout进行了多种兼容性的处理，宽泛的也可以理解为将回调函数放入setTimeout中执行；不过nextTick优先放入微任务执行，而setTimeout是宏任务，因此nextTick一般情况下总是先于setTimeout执行，我们可以在浏览器中尝试一下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)<br>&#125;)<br><span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)<br>&#125;)<br><span class="hljs-regexp">//</span>运行结果 <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p> 最后验证猜想，当前宏任务执行完成后，优先执行两个微任务，最后再执行宏任务。</p><h5 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://www.zhihu.com/search?type=content&q=$nexttick%E8%A7%A3%E9%87%8A">知乎</a><br><a href="https://juejin.cn/post/6844904147804749832">Vue中$nextTick源码解析</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript new 操作符具体干了什么呢？如何实现？</title>
    <link href="/2021/07/02/JS%20new%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/"/>
    <url>/2021/07/02/JS%20new%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>JavaScript new 操作符具体干了什么呢？如何实现？</p><hr><h3 id="new-操作符具体干了什么？"><a href="#new-操作符具体干了什么？" class="headerlink" title="new 操作符具体干了什么？"></a>new 操作符具体干了什么？</h3><p>// （1）首先创建了一个新的空对象<br>// （2）设置原型，将对象的原型设置为函数的 prototype 对象。<br>// （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）<br>// （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p><p>new共经历了四个过程。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">var</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> = <span class="hljs-title">function</span> (<span class="hljs-params"></span>) </span>&#123; &#125;;<br><span class="hljs-keyword">var</span> fnObj = <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">fn</span>(<span class="hljs-params"></span>)</span>;<br><br></code></pre></td></tr></table></figure><p>1、创建了一个空对象</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br></code></pre></td></tr></table></figure><p>2、设置原型链</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">obj._proto_</span> = fn.prototype<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>3、让fn的this指向obj，并执行fn的函数体</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">var</span> <span class="hljs-literal">result</span> = fn.call(obj);<br></code></pre></td></tr></table></figure><p>4、判断fn的返回值类型，如果是值类型，返回obj。如果是引用类型，就返回这个引用类型的对象。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-function"><span class="hljs-title">typeof</span>(<span class="hljs-variable"><span class="hljs-class">result</span></span>) == <span class="hljs-string">&quot;object&quot;</span>)&#123;  </span><br><span class="hljs-function">    <span class="hljs-variable">fnObj</span> = <span class="hljs-variable"><span class="hljs-class">result</span></span>;  </span><br><span class="hljs-function">&#125; <span class="hljs-variable"><span class="hljs-keyword">else</span></span> &#123;  </span><br><span class="hljs-function">    <span class="hljs-variable">fnObj</span> = <span class="hljs-variable">obj</span>;</span><br><span class="hljs-function">&#125;  </span><br></code></pre></td></tr></table></figure><p>// 实现:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFactory</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-literal">null</span>,<br>    <span class="hljs-title">constructor</span> = <span class="hljs-title">Array</span>.<span class="hljs-title">prototype</span>.<span class="hljs-title">shift</span>.<span class="hljs-title">call</span>(<span class="hljs-params"><span class="hljs-built_in">arguments</span></span>),<br>    <span class="hljs-title">result</span> = <span class="hljs-title">null</span>;<br><br>  <span class="hljs-comment">// 参数判断</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title">constructor</span> !== &quot;<span class="hljs-title">function</span>&quot;) &#123;<br>    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;type error&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br>  newObject = <span class="hljs-built_in">Object</span>.create(<span class="hljs-title">constructor</span>.<span class="hljs-title">prototype</span>);<br><br>  <span class="hljs-comment">// 将 this 指向新建对象，并执行函数</span><br>  result = <span class="hljs-title">constructor</span>.<span class="hljs-title">apply</span>(<span class="hljs-params">newObject, <span class="hljs-built_in">arguments</span></span>);<br><br>  <span class="hljs-comment">// 判断返回对象</span><br>  <span class="hljs-keyword">let</span> flag =<br>    result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;function&quot;</span>);<br><br>  <span class="hljs-comment">// 判断返回结果</span><br>  <span class="hljs-keyword">return</span> flag ? result : newObject;<br>&#125;<br><br><span class="hljs-comment">// 使用方法</span><br><span class="hljs-comment">// objectFactory(构造函数, 初始化参数);</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 原型，原型链？ 有什么特点？js 获取原型的方法？</title>
    <link href="/2021/07/02/JavaScript%20%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F%20%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F&amp;%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2021/07/02/JavaScript%20%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F%20%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F&amp;%E8%8E%B7%E5%8F%96%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>JavaScript 原型，原型链？ 有什么特点？js 获取原型的方法？</p><hr><h3 id="JavaScript-原型，原型链？-有什么特点？"><a href="#JavaScript-原型，原型链？-有什么特点？" class="headerlink" title="JavaScript 原型，原型链？ 有什么特点？"></a>JavaScript 原型，原型链？ 有什么特点？</h3><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><ul><li><p>在js中，我们通常会使用构造函数来创建一个对象，每一个构造函数的内部都有一个prototype属性，这个属性对应的值是一个对象，这个对象它包含了可以由该构造函数的所有实例都共享的属性和方法，我们把它称为原型。</p></li><li><p>原型分为显示原型和隐式原型，一般称prototype为显示原型，__proto__称为隐式原型。<br>一般而言，__proto__这个指针我们应该获取这个值，但是浏览器中都实现了<code>__proto__</code>属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。<br>ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对象的原型。</p></li></ul><p>举个例子:</p><ul><li>为什么我们新建的对象可以使用toString()方法，这是因为我们访问一个对象的属性时，首先会在这个对象身上找，如果没有的话，我们会通过这个对象的__proto__找到该对象的原型，然后在这个原型对象中找，这个原型对象又没有的话，就这样子通过一直找下去，这也就是原型链概念。直到找到原型链的尽头也就是Object.prototype。</li></ul><p><img src="/imageO/proto.png" alt="原型链"></p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 <strong>Object.prototype</strong> 所以这就是我们新建的对象为什么能够使用 toString() 等方法的原因。</p><p>特点：</p><p>JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p><h3 id="js-获取原型的方法？"><a href="#js-获取原型的方法？" class="headerlink" title="js 获取原型的方法？"></a>js 获取原型的方法？</h3><ol><li>p.<code>__proto__</code></li><li>p.constructor.prototype</li><li>Object.getPrototypeOf(p)</li></ol><h3 id="在-js-中不同进制数字的表示方式"><a href="#在-js-中不同进制数字的表示方式" class="headerlink" title="在 js 中不同进制数字的表示方式"></a>在 js 中不同进制数字的表示方式</h3><p>以 0X、0x 开头的表示为十六进制。</p><p>以 0、0O、0o 开头的表示为八进制。</p><p>以 0B、0b 开头的表示为二进制格式。</p>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS数据类型&amp;&amp;堆栈&amp;&amp;JS的基本规范</title>
    <link href="/2021/07/01/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&amp;&amp;%E5%A0%86%E6%A0%88&amp;&amp;JS%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83/"/>
    <url>/2021/07/01/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&amp;&amp;%E5%A0%86%E6%A0%88&amp;&amp;JS%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<p>JS数据类型&amp;&amp;堆栈&amp;&amp;JS的基本规范</p><hr><h3 id="介绍-js-的基本数据类型"><a href="#介绍-js-的基本数据类型" class="headerlink" title="介绍 js 的基本数据类型"></a>介绍 js 的基本数据类型</h3><p>js 一共有六种基本数据类型，分别是 <code>Undefined、Null、Boolean、Number、String</code>，还有在 ES6 中新增的 Symbol 和 ES10 中新增的 BigInt 类型。</p><p>Symbol 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的<strong>全局变量冲突的问题</strong>。</p><p>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以<strong>安全地存储和操作大整数</strong>，即使这个数已经超出了 Number 能够表示的安全整数范围。</p><h3 id="JavaScript-有几种类型的值？你能画一下他们的内存图吗？"><a href="#JavaScript-有几种类型的值？你能画一下他们的内存图吗？" class="headerlink" title="JavaScript 有几种类型的值？你能画一下他们的内存图吗？"></a>JavaScript 有几种类型的值？你能画一下他们的内存图吗？</h3><p>涉及知识点：</p><ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><p>两种类型的区别是：存储位置不同。<br>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</p><p>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p><h4 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h4><p>js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。</p><p>基本数据类型 <code>Undefined、Null、Boolean、Number、String</code></p><p>复杂数据类型指的是 Object 类型，所有其他的如 Array、Date 等数据类型都可以理解为 Object 类型的子类。</p><p>两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值。</p><p><img src="/imageO/16.png" alt="栈"></p><p><img src="/imageO/17.png" alt="堆"></p><h3 id="什么是堆？什么是栈？它们之间有什么区别和联系？"><a href="#什么是堆？什么是栈？它们之间有什么区别和联系？" class="headerlink" title="什么是堆？什么是栈？它们之间有什么区别和联系？"></a>什么是堆？什么是栈？它们之间有什么区别和联系？</h3><p>堆和栈的概念存在于数据结构中和操作系统内存中。</p><p>在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全<br>二叉树是堆的一种实现方式。</p><p>在操作系统中，内存被分为栈区和堆区。</p><p>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p><p>堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。</p><h3 id="说几条写-JavaScript-的基本规范？"><a href="#说几条写-JavaScript-的基本规范？" class="headerlink" title="说几条写 JavaScript 的基本规范？"></a>说几条写 JavaScript 的基本规范？</h3><p>在平常项目开发中，我们遵守一些这样的基本规范，比如说：</p><p>（1）一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 var 声明，不允许出现两个连续的 var 声明，声明时<br>    如果变量没有值，应该给该变量赋值对应类型的初始值，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。</p><p>（2）代码中出现地址、时间等字符串时需要使用常量代替。</p><p>（3）在进行比较的时候吧，尽量使用’===’, ‘!==’代替’==’, ‘!=’。</p><p>（4）不要在内置对象的原型上添加方法，如 Array, Date。</p><p>（5）switch 语句必须带有 default 分支。</p><p>（6）for 循环必须使用大括号。</p><p>（7）if 语句必须使用大括号。</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://blog.csdn.net/jiangjuanjaun/article/details/80327342">JavaScript有几种类型的值？能否画一下它们的内存图；</a></p>]]></content>
    
    
    <categories>
      
      <category>JS进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS绘制三角形—border法</title>
    <link href="/2021/06/27/CSS%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2%E2%80%94border%E6%B3%95/"/>
    <url>/2021/06/27/CSS%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2%E2%80%94border%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="1-画三角形"><a href="#1-画三角形" class="headerlink" title="1. 画三角形"></a>1. 画三角形</h3><p>利用元素的 border 绘制三角形，先来看一下宽高均为 0，border 有宽度的效果是啥样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">0px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">0px</span>;</span><br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">50px</span> solid transparent;</span><br><span class="css">    <span class="hljs-attribute">border-color</span>: red blue chartreuse black;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="/imageO/10.png" alt="如图"></p><p>然后我们可以通过给任意三边的颜色设置为 transparent 即可分别实现任一方向的三角形。<br>通过设置某条边的宽度比其它边宽，来调整三角形的高度。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">border</span>-<span class="hljs-built_in">color</span>: <span class="hljs-built_in">transparent</span> <span class="hljs-built_in">transparent</span> chartreuse <span class="hljs-built_in">transparent</span>;<br></code></pre></td></tr></table></figure><h4 id="向上的箭头"><a href="#向上的箭头" class="headerlink" title="向上的箭头"></a>向上的箭头</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">  <span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/* 上 ，左右  下 */</span><br>        <span class="hljs-attribute">border-width</span>: <span class="hljs-number">0</span>  <span class="hljs-number">50px</span>  <span class="hljs-number">50px</span>;<br>        <span class="hljs-attribute">border-style</span>: solid;<br>        <span class="hljs-attribute">border-color</span>: transparent  transparent chartreuse;    <br>  &#125;<br>&lt;/style&gt;<br>&lt;<span class="hljs-selector-tag">div</span>&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure><p><img src="/imageO/11.png" alt="如图"></p><h4 id="向右的箭头"><a href="#向右的箭头" class="headerlink" title="向右的箭头"></a>向右的箭头</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">border-width</span>: <span class="hljs-number">50px</span> <span class="hljs-number">0</span> <span class="hljs-number">50px</span> <span class="hljs-number">50px</span>;<br>      <span class="hljs-attribute">border-style</span>: solid;<br>      <span class="hljs-attribute">border-color</span>: transparent chartreuse transparent;    <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/imageO/12.png" alt="如图"></p><h4 id="向下的箭头"><a href="#向下的箭头" class="headerlink" title="向下的箭头"></a>向下的箭头</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>       <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>       <span class="hljs-attribute">border-width</span>: <span class="hljs-number">50px</span>  <span class="hljs-number">50px</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-attribute">border-style</span>: solid;<br>       <span class="hljs-attribute">border-color</span>:chartreuse transparent  transparent;    <br> &#125;<br></code></pre></td></tr></table></figure><p><img src="/imageO/13.png" alt="如图"></p><h4 id="向左的箭头"><a href="#向左的箭头" class="headerlink" title="向左的箭头"></a>向左的箭头</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">border-width</span>:  <span class="hljs-number">50px</span>  <span class="hljs-number">50px</span>  <span class="hljs-number">50px</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">border-style</span>: solid;<br>      <span class="hljs-attribute">border-color</span>: transparent chartreuse transparent;    <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/imageO/14.png" alt="如图"></p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.cnblogs.com/lou-0820/p/10558799.html">博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue中的scoped坑点&amp;</title>
    <link href="/2021/06/23/Vue-scoped%E7%9A%84%E5%9D%91%E7%82%B9/"/>
    <url>/2021/06/23/Vue-scoped%E7%9A%84%E5%9D%91%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>上午遇到一个scoped的坑，在覆盖elementUI的走马灯(轮播图)组件，就是无法覆盖组件原有的样式。最后想要改变标签样式，唯有去掉scoped了</p><p>尤大的话：</p><p>scoped设计的初衷就是不能让当前组件的样式修改其他任何地方的样式，因为设计如此</p><p>scoped 会给当前组件的模块中的所有的元素都添加一个随机的属性</p><p>scoped会给当前组件中的所有的样式页添加一个随机的属性选择器</p><p>深度选择器  scss  ::v-deep  less  /deep/  stylus  &gt;&gt;&gt;</p><hr><h3 id="何为scoped？"><a href="#何为scoped？" class="headerlink" title="何为scoped？"></a>何为scoped？</h3><p>在vue文件中的style标签上，有一个特殊的属性：scoped。当一个style标签拥有scoped属性时，它的CSS样式就只能作用于当前的组件，也就是说，该样式只能适用于当前组件元素。通过该属性，可以使得组件之间的样式不互相污染。如果一个项目中的所有style标签全部加上了scoped，相当于实现了样式的模块化。</p><h3 id="scoped的实现原理"><a href="#scoped的实现原理" class="headerlink" title="scoped的实现原理"></a>scoped的实现原理</h3><p>vue中的scoped属性的效果主要通过PostCSS转译实现，如下是转译前的vue代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br>.example &#123;<br><span class="css">  <span class="hljs-attribute">color</span>: red;</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span>hi<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>转译后：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css"><span class="hljs-selector-class">.example</span><span class="hljs-selector-attr">[data-v-5558831a]</span> &#123;</span><br><span class="css">  <span class="hljs-attribute">color</span>: red;</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example&quot;</span> <span class="hljs-attr">data-v-5558831a</span>&gt;</span>hi<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>即：PostCSS给一个组件中的所有dom添加了一个独一无二的动态属性，然后，给CSS选择器额外添加一个对应的属性选择器来选择该组件中dom，这种做法使得样式只作用于含有该属性的dom——组件内部dom。</p><h3 id="为什么需要穿透scoped？"><a href="#为什么需要穿透scoped？" class="headerlink" title="为什么需要穿透scoped？"></a>为什么需要穿透scoped？</h3><p>scoped看起来很美，但是，在很多项目中，会出现这么一种情况，即：引用了第三方组件，需要在组件中局部修改第三方组件的样式，而又不想去除scoped属性造成组件之间的样式污染。此时只能通过特殊的方式，穿透scoped。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="xml">    外层 &gt;&gt;&gt; 第三方组件 </span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">        样式</span><br><span class="hljs-template-variable">    &#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>通过 &gt;&gt;&gt; 可以使得在使用scoped属性的情况下，穿透scoped，修改其他组件的值。</p><h3 id="曲线救国的方法"><a href="#曲线救国的方法" class="headerlink" title="曲线救国的方法"></a>曲线救国的方法</h3><p>其实，还拥有一种曲线救国的方法，即在定义一个含有scoped属性的style标签之外，再定义一个不含有scoped属性的style标签，即在一个vue组件中定义一个全局的style标签，一个含有作用域的style标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css"><span class="hljs-comment">/* global styles */</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="css"><span class="hljs-comment">/* local styles */</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面是给vue组件的根元素加个id，然后这个id是每个组件唯一的，通过这种方式在全局style修改第三方组件样式。</p><p>可以在全局style里只改第三方的，其他的还是放到scoped的style里面，稍微方便点</p><h5 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h5><p><a href="https://www.cnblogs.com/karthuslorin/p/9038854.html">博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>offsetHeight、scrollHeight、clientHeight</title>
    <link href="/2021/06/20/offsetHeight%E3%80%81scrollHeight%E3%80%81clientHeight/"/>
    <url>/2021/06/20/offsetHeight%E3%80%81scrollHeight%E3%80%81clientHeight/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="offsetXXX"><a href="#offsetXXX" class="headerlink" title="offsetXXX"></a>offsetXXX</h3><blockquote><p>offsetWidth/offsetHeight 是指一个元素的 CSS 「标准宽高」，它包含了边框、内边距、元素内容以及滚动条（如果存在的话）。</p></blockquote><p>借助 MDN 上的图片可以看到元素的 offsetWidth，这就是这个元素在页面中「实际占用的空间」，同时当元素的形状发生变化时（比如说放大或缩小），offsetWidth 就表示元素的布局宽高，并不代表实际渲染出来的宽高，如需获取渲染的宽高请使用 getBoundingClientRect() 方法计算得到真正的 offsetWidth</p><p><img src="/imageO/6.png" alt="offsewidth"></p><h3 id="clientXXX"><a href="#clientXXX" class="headerlink" title="clientXXX"></a>clientXXX</h3><blockquote><p>clientWidth/clientHeight 就表示一个元素的「内容宽高」，包含元素内容以及内边距</p></blockquote><p>也就是说如果你只想要获取「显示内容区域的大小」就是用 clientWidth</p><p><img src="/imageO/6.png" alt="clientwidth"></p><h3 id="scrollXXX"><a href="#scrollXXX" class="headerlink" title="scrollXXX"></a>scrollXXX</h3><blockquote><p>scrollWidth/scrollHeight 表示一个元素内容区域的实际大小，包括不在页面中的可滚动部分（内容和内边距）</p></blockquote><p>它可以理解为 clientXXX 的增强版，是整个内容的大小</p><p><img src="/imageO/8.png" alt="scrollxxx"></p><h3 id="xxxTop"><a href="#xxxTop" class="headerlink" title="xxxTop"></a>xxxTop</h3><ol><li><p>offsetTop 是当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系</p></li><li><p>scrollTop 在有滚动条的情况下，为元素可视区域距离元素顶部的像素，也就是已经滚动了多少距离</p></li></ol><p><img src="/imageO/9.png" alt="xxxtop"></p><h4 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h4><ol><li>offsetXXX 可以看作是 clientXXX + 外边框 border + 滚动条（有的话）</li><li>scrollXXX 可以看作是 clientXXX + 隐藏区域大小（如果有滚动的话）</li></ol>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axios拦截器</title>
    <link href="/2021/06/17/Vue&amp;&amp;axios%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <url>/2021/06/17/Vue&amp;&amp;axios%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>首先要知道登录不仅仅是拿着用户名和密码通过接口发给后端就大功告成了,要从几个方面考虑</p><ul><li>异步登录，通过登录接口拿到token</li><li>利用vuex的state管理token、用户信息等</li><li>利用axios拦截器，拦截每一次请求/响应来处理token</li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">token</span>是用户登录成功的标识，每一次请求数据时都要发送<span class="hljs-built_in">token</span>给后端验证 &amp; 接收后端返回状态码判断当前用户登录状态<br><br></code></pre></td></tr></table></figure><h4 id="登录的基本实现"><a href="#登录的基本实现" class="headerlink" title="登录的基本实现"></a>登录的基本实现</h4><p>点击按钮触发事件Login.vue文件中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript">methods: &#123;<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">submitHandler</span>(<span class="hljs-params">e</span>)</span> &#123;<br>    e.preventDefault();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.$http.get(<span class="hljs-string">&quot;/api/login&quot;</span>, &#123;<br>        params: <span class="hljs-built_in">this</span>.model,<br>      &#125;);<br>     <span class="hljs-keyword">if</span>(result.code==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>       <span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;settoken&#x27;</span>,result.token)<br>       <span class="hljs-built_in">window</span>.localStorage.setItem(<span class="hljs-string">&#x27;token&#x27;</span>,result.token)<br>     &#125;<span class="hljs-keyword">else</span>&#123;<br>       alert(result.messages)<br>     &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-built_in">console</span>.log(error);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>Vuex中 store中代码</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pf">export <span class="hljs-keyword">default</span> new Vuex.Store(&#123;<br>  <span class="hljs-keyword">state</span>: &#123;<br>    token: &#x27;&#x27;<br>  &#125;,<br>  mutations: &#123;<br>    // 设置vuex的token<br>    settoken(<span class="hljs-keyword">state</span>, token) &#123;<br>      <span class="hljs-keyword">state</span>.token = token<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a>axios拦截器</h4><p>我的拦截器目录是 src\setaxios.js</p><p>main.js中全局注册使用</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import  setaxios  from  <span class="hljs-string">&#x27;./setaxios&#x27;</span><br><span class="hljs-function"><span class="hljs-title">setaxios</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>setaxios.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span>  axios  <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">import</span>  store  <span class="hljs-keyword">from</span>  <span class="hljs-string">&#x27;./store/index&#x27;</span><br><span class="hljs-keyword">import</span>  router  <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router/index&#x27;</span><br><br><span class="hljs-comment">// http全局拦截</span><br><span class="hljs-comment">// token要放在我们请求的header上面带回去的后端</span><br><br><br><span class="hljs-keyword">export</span>  <span class="hljs-keyword">default</span>  <span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">setAxios</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-comment">// 请求拦截</span><br>  axios.interceptors.request.use(<br>    config=&gt;&#123;<br>      <span class="hljs-keyword">if</span>(store.state.token)&#123;<br>        config.headers.token=store.state.token;<br>      &#125;<br>      <span class="hljs-keyword">return</span>  config<br>    &#125;<br>)<br><span class="hljs-comment">// 每次的请求都是有返回的，都是先经过这个拦截器的</span><br>axios.interceptors.response.use(<br>  response=&gt;&#123;<br>    <span class="hljs-keyword">if</span>(response.status==<span class="hljs-number">200</span>)&#123;<br>      <span class="hljs-keyword">const</span>  data=response.data<br>      <span class="hljs-keyword">if</span>(data.code==-<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">// 登录过期  需要重新登录，清空vuex的token和localstorage的token</span><br>        store.commit(<span class="hljs-string">&#x27;settoken&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-built_in">localStorage</span>.removeItem(<span class="hljs-string">&#x27;token&#x27;</span>)<br>        <span class="hljs-comment">// 跳转到login页面</span><br>        router.replace(&#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/login&#x27;</span>&#125;)<br>      &#125;<br>      <span class="hljs-keyword">return</span>  data<br>    &#125;<br>    <span class="hljs-keyword">return</span>  response<br>  &#125;<br>)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/imageO/5.png" alt="token存储成功"></p><h4 id="为什么要使用vuex"><a href="#为什么要使用vuex" class="headerlink" title="为什么要使用vuex"></a>为什么要使用vuex</h4><p>因为通过登录得到的用户信息在多个组件中都会用到，使用vuex直接通过state或getter访问变量很方便。但不要为了使用vuex而使用vuex</p><h4 id="既然用了vuex为什么还要将token存放到localStorage-sessionStorage-cookie中去"><a href="#既然用了vuex为什么还要将token存放到localStorage-sessionStorage-cookie中去" class="headerlink" title="既然用了vuex为什么还要将token存放到localStorage/sessionStorage/cookie中去"></a>既然用了vuex为什么还要将token存放到localStorage/sessionStorage/cookie中去</h4><p>因为刷新会导致vuex的state中的变量重置为初始值（「变量值会丢失」）</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cookie、localStorage、sessionStorage&amp;&amp;token</title>
    <link href="/2021/06/16/cookie%E3%80%81localStorage%E3%80%81sessionStorage&amp;token/"/>
    <url>/2021/06/16/cookie%E3%80%81localStorage%E3%80%81sessionStorage&amp;token/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="什么是认证（Authentication）"><a href="#什么是认证（Authentication）" class="headerlink" title="什么是认证（Authentication）"></a>什么是认证（Authentication）</h3><p>通俗地讲就是验证当前用户的身份，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功）</p><p>互联网中的认证：</p><ol><li>用户名密码登录</li><li>邮箱发送登录链接</li><li>手机号接收验证码</li><li>只要你能收到邮箱/验证码，就默认你是账号的主人</li></ol><h3 id="什么是授权（Authorization）"><a href="#什么是授权（Authorization）" class="headerlink" title="什么是授权（Authorization）"></a>什么是授权（Authorization）</h3><p>用户授予第三方应用访问该用户某些资源的权限</p><p>你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限）</p><p>你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）</p><blockquote><p>实现授权的方式有：cookie、session、token、OAuth</p></blockquote><h3 id="cookie、localStorage、sessionStorage"><a href="#cookie、localStorage、sessionStorage" class="headerlink" title="cookie、localStorage、sessionStorage"></a>cookie、localStorage、sessionStorage</h3><h4 id="相同点：都保存在浏览器端"><a href="#相同点：都保存在浏览器端" class="headerlink" title="相同点：都保存在浏览器端"></a>相同点：都保存在浏览器端</h4><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ol><li>传递方式不同</li></ol><ul><li>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。</li><li>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li></ul><ol start="2"><li>数据大小不同</li></ol><ul><li>（cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。）  存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。</li><li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li></ul><ol start="3"><li>数据有效期不同</li></ol><ul><li>sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；</li><li>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；</li><li>cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。</li></ul><ol start="4"><li>作用域不同</li></ol><ul><li>sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</li><li>localStorage在所有同源窗口中都是共享的；</li><li>cookie也是在所有同源窗口中都是共享的。</li></ul><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p><strong>Token的引入</strong>：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。</p><p><strong>Token的定义</strong>：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。</p><p><strong>使用Token的目的</strong>：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p><p><strong>Token 是在服务端产生的</strong>。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位</p><h4 id="为什么要用-Token？"><a href="#为什么要用-Token？" class="headerlink" title="为什么要用 Token？"></a>为什么要用 Token？</h4><p>可以解决哪些问题呢？</p><ol><li><p>Token 完全由应用管理，所以它可以避开同源策略</p></li><li><p>Token 可以避免 CSRF 攻击(<a href="http://dwz.cn/7joLzx">http://dwz.cn/7joLzx</a>)</p></li><li><p>Token 可以是无状态的，可以在多个服务间共享</p></li></ol><h4 id="基于-Token-的身份验证"><a href="#基于-Token-的身份验证" class="headerlink" title="基于 Token 的身份验证"></a>基于 Token 的身份验证</h4><p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li><li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li></ol><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6844904009061367821#heading-7">一文彻底搞懂Cookie、Session、Token到底是什么</a></p><p><a href="https://juejin.cn/post/6844904034181070861#heading-6">傻傻分不清之 Cookie、Session、Token、JWT</a></p><p><a href="https://www.cnblogs.com/xuxinstyle/p/9675541.html">深入理解token</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Css单位px，rem，em，vw，vh的区别</title>
    <link href="/2021/06/16/Css%E5%8D%95%E4%BD%8Dpx%EF%BC%8Crem%EF%BC%8Cem%EF%BC%8Cvw%EF%BC%8Cvh%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/06/16/Css%E5%8D%95%E4%BD%8Dpx%EF%BC%8Crem%EF%BC%8Cem%EF%BC%8Cvw%EF%BC%8Cvh%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="px"><a href="#px" class="headerlink" title="px"></a>px</h3><p>px就是pixel像素的缩写，相对长度单位，网页设计常用的基本单位。像素px是相对于显示器屏幕分辨率而言的</p><h3 id="em"><a href="#em" class="headerlink" title="em"></a>em</h3><p>em是相对长度单位。相对于当前对象内文本的字体尺寸（参考物是父元素的font-size）</p><p>如当前父元素的字体尺寸未设置，则相对于浏览器的默认字体尺寸</p><p>特点：</p><ol><li><p>em的值并不是固定的；</p></li><li><p>em会继承父级元素的字体大小</p></li></ol><h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>rem是CSS3新增的一个相对单位，rem是相对于HTML根元素的字体大小（font-size）来计算的长度单位</p><p>如果你没有设置html的字体大小，就会以浏览器默认字体大小，一般是16px</p><p>优点是，只需要设置根目录的大小就可以把整个页面的成比例的调好</p><p>rem兼容性：除了IE8及更早版本外，所有浏览器均已支持rem</p><p>em与rem的区别：</p><blockquote><p>rem是相对于根元素（html）的字体大小，而em是相对于其父元素的字体大小</p></blockquote><p>两者使用规则：</p><p>如果这个属性根据它的font-size进行测量，则使用em<br>其他的一切事物属性均使用rem<br>这里提供了一个px、em、rem单位的转换工具：<a href="http://pxtoem.com/">http://pxtoem.com/</a></p><h3 id="vw、vh"><a href="#vw、vh" class="headerlink" title="vw、vh"></a>vw、vh</h3><p>vw、vh、vmax、vmin这四个单位都是基于视口</p><p>vw是相对视口（viewport）的宽度而定的，长度等于视口宽度的1/100</p><p>假如浏览器的宽度为200px，那么1vw就等于2px（200px/100）</p><p>vh是相对视口（viewport）的高度而定的，长度等于视口高度的1/100</p><p>假如浏览器的高度为500px，那么1vh就等于5px（500px/100）</p><p>vmin和vmax是相对于视口的高度和宽度两者之间的最小值或最大值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">如果浏览器的高为300px、宽为500px，那么1vmin就是3px，1vmax就是5px；如果浏览器的高为800px，宽为1080px，那么1vmin也是8px，1vmax也是10.8px<br></code></pre></td></tr></table></figure><h4 id="其他单位"><a href="#其他单位" class="headerlink" title="其他单位"></a>其他单位</h4><p>%（百分比）</p><p>一般来说就是相对于父元素</p><p>1、对于普通定位元素就是我们理解的父元素</p><p>2、对于position: absolute;的元素是相对于已定位的父元素</p><p>3、对于position: fixed;的元素是相对于ViewPort（可视窗口）</p><h4 id="vm"><a href="#vm" class="headerlink" title="vm"></a>vm</h4><p>css3新单位，相对于视口的宽度或高度中较小的那个</p><p>其中最小的那个被均分为100单位的vm</p><p>比如：浏览器高度900px，宽度1200px，取最小的浏览器高度，1 vm = 900px/100 = 9 px</p><p>缺点：兼容性差</p><h4 id="参考链接博客圆"><a href="#参考链接博客圆" class="headerlink" title="参考链接博客圆"></a>参考链接<a href="https://www.cnblogs.com/theblogs/p/10516098.html">博客圆</a></h4>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue&amp; 使用axios的多种方式</title>
    <link href="/2021/06/15/Vue&amp;&amp;axios%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/06/15/Vue&amp;&amp;axios%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="vue中使用axios的多种方式"><a href="#vue中使用axios的多种方式" class="headerlink" title="vue中使用axios的多种方式"></a>vue中使用axios的多种方式</h3><p>axios<br>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端</p><p>它本身具有以下特征：</p><ul><li>从浏览器中创建 XMLHttpRequest</li><li>从 node.js 发出 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>客户端支持防止 CSRF/XSRF</li></ul><h3 id="axios默认是不让ajax请求头部携带cookie的"><a href="#axios默认是不让ajax请求头部携带cookie的" class="headerlink" title="axios默认是不让ajax请求头部携带cookie的"></a>axios默认是不让ajax请求头部携带cookie的</h3><p>axios 解决跨域cookie丢失问题</p><p>设置 axios.defaults.withCredentials = true 即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ：">axios.defaults.withCredentials &#x3D; true;<br>var param &#x3D; new URLSearchParams();<br>param.append(&quot;vCode&quot;,vcode);<br>axios.post(&#39;http:&#x2F;&#x2F;localhost&#39;,param)<br>.then(function(res) &#123;<br>var rs&#x3D;res.data;<br>console.log(rs.data);<br>&#125;)<br>.catch(function(err) &#123;<br>console.log(err);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="配合vue"><a href="#配合vue" class="headerlink" title="配合vue"></a>配合vue</h3><p>目前主流的 Vue 项目，都选择 axios 来完成 ajax 请求</p><p>Axios 是一个基于 promise 的 HTTP 库</p><p>axios并没有install 方法，所以是不能使用vue.use()方法的。<br>那么难道每个文件都要来引用一次？解决方法有很多种：</p><ol><li><p>结合 vue-axios使用</p></li><li><p>axios 改写为 Vue 的原型属性</p></li><li><p>结合 Vuex的action</p></li></ol><h4 id="结合-vue-axios使用"><a href="#结合-vue-axios使用" class="headerlink" title="结合 vue-axios使用"></a>结合 vue-axios使用</h4><p>vue-axios</p><p>用于将axios集成到Vuejs的小包装器</p><p>github: <a href="https://github.com/axios/axios">https://github.com/axios/axios</a></p><p>安装： npm install –save axios vue-axios</p><p>vue-axios是按照vue插件的方式去写的。那么结合vue-axios，就可以去使用vue.use方法了</p><p>首先在主入口文件main.js中引用</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><span class="hljs-keyword">import</span> VueAxios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-axios&#x27;</span><br><br>Vue.use(VueAxios,axios);<br></code></pre></td></tr></table></figure><p>之后就可以使用了，在组件文件中的methods里去使用了</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">getNewsList()&#123;<br>      <span class="hljs-built_in">this</span>.axios.get(<span class="hljs-string">&#x27;api/getNewsList&#x27;</span>).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(response)</span>=&gt;</span>&#123;<br>        <span class="hljs-built_in">this</span>.newsList=response.data.data;<br>      &#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(response)</span>=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(response);<br>      &#125;)<br><br><br>    &#125;,<br></code></pre></td></tr></table></figure><blockquote><p>方法2： axios 改写为 Vue 的原型属性<br>首先在主入口文件main.js中引用，之后挂在vue的原型链上</p></blockquote><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br>Vue.prototype.$axios= axios<br><br>在组件中使用<br><br><br><span class="hljs-built_in">this</span>.$axios.get(<span class="hljs-string">&#x27;api/getNewsList&#x27;</span>).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(response)</span>=&gt;</span>&#123;<br>        <span class="hljs-built_in">this</span>.newsList=response.data.data;<br>      &#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(response)</span>=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(response);<br>      &#125;)<br></code></pre></td></tr></table></figure><p>方法3：结合vuex(待学)</p><h5 id="参考链接简书"><a href="#参考链接简书" class="headerlink" title="参考链接简书"></a>参考链接<a href="https://www.jianshu.com/p/4a872643f5ea">简书</a></h5>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何实现路由懒加载？</title>
    <link href="/2021/06/10/Vue%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <url>/2021/06/10/Vue%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p><p>结合 Vue 的异步组件 (opens new window)和 Webpack 的代码分割功能 (opens new window)，轻松实现路由组件的懒加载。</p><blockquote><p>vue-router路由懒加载（解决vue项目首次加载慢）</p></blockquote><p>也叫延迟加载，即在需要的时候进行加载，随用随载。</p><p>为什么需要懒加载？</p><p>像vue这种单页面应用，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，时间过长，会出啊先长时间的白屏，即使做了loading也是不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时</p><p>简单的说就是：进入首页不用一次加载过多资源造成用时过长！！！</p><blockquote><p>把不同路由对应的组件分割成不同的代码块，然后当路由被访问时才加载对应的组件即为路由的懒加载，可以加快项目的加载速度，提高效率</p></blockquote><p>写法一：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const router = <span class="hljs-built_in">new</span> VueRouter(&#123;<br>  routes: [<br>    &#123;<br>      <span class="hljs-type">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>      <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;Home&#x27;</span>，<br>      component:() = <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/home&#x27;</span>)<br>  &#125;<br>  ]<br>&#125;)<br><br></code></pre></td></tr></table></figure><blockquote><p>使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</p></blockquote><p>写法二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// r就是resolve</span><br><span class="hljs-keyword">const</span> List = <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-built_in">require</span>.ensure([], <span class="hljs-function">() =&gt;</span> r(<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@/components/list&#x27;</span>)), <span class="hljs-string">&#x27;list&#x27;</span>);<br><span class="hljs-comment">// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 </span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> Router(&#123;<br>  routes: [<br>  &#123;<br>    path: <span class="hljs-string">&#x27;/list&#x27;</span>,<br>    component: List,<br>    name: <span class="hljs-string">&#x27;list&#x27;</span><br>  &#125;<br> ]<br>&#125;))<br></code></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html#%E6%8A%8A%E7%BB%84%E4%BB%B6%E6%8C%89%E7%BB%84%E5%88%86%E5%9D%97">路由懒加载</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue单向数据流与双向数据绑定的理解</title>
    <link href="/2021/05/29/Vue%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%8E%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2021/05/29/Vue%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%8E%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<hr><h4 id="一：单向数据流"><a href="#一：单向数据流" class="headerlink" title="一：单向数据流"></a>一：单向数据流</h4><p>单向数据流的意思是指数据的改变只能从一个方向修改。</p><p>举个栗子：如一个父组件有两个子组件，分别为1和2。父组件向子组件传递数据，两个组件都接收到了父组件传递过来的数据，在组件1中修改父组件传递过来的数据，子组件2和父组件的值不会发生变化。这就是单向的数据流，子组件不能直接改变父组件的状态。但是如果父组件改变相应的数据，两个子组件的数据也会发生相应的改变。</p><h4 id="二：双向数据绑定"><a href="#二：双向数据绑定" class="headerlink" title="二：双向数据绑定"></a>二：双向数据绑定</h4><p>由MVVM框架实现，MVVM的组成：View，ViewModel，Model。其中View 和 Model不能直接通信，要通过ViewModel来进行通信。</p><p>举个栗子：例如，当Model部分数据发生改变时，由于vue中Data Binding将底层数据和Dom层进行了绑定，ViewModel通知View层更新视图；当在视图 View数据发生变化也会同步到Model中。View和Model之间的同步完全是自动的，不需要人手动的操作DOM。</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://zhuanlan.zhihu.com/p/70538875">知乎</a></p><p><a href="https://juejin.cn/post/6844903504834740232">掘金</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git冲突与解决方法</title>
    <link href="/2021/05/28/Git%E5%86%B2%E7%AA%81%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2021/05/28/Git%E5%86%B2%E7%AA%81%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="Git冲突与解决方法"><a href="#Git冲突与解决方法" class="headerlink" title="Git冲突与解决方法"></a>Git冲突与解决方法</h3><h4 id="1-git冲突的场景"><a href="#1-git冲突的场景" class="headerlink" title="1. git冲突的场景"></a>1. git冲突的场景</h4><p><strong>情景一：多个分支代码合并到一个分支时；</strong></p><p><strong>情景二：多个分支向同一个远端分支推送代码时；</strong></p><p>实际上，push操作即是将本地代码merge到远端库分支上。</p><p>关于push和pull其实就分别是用本地分支合并到远程分支 和 将远程分支合并到本地分支</p><p>所以这两个过程中也可能存在冲突。</p><p>git的合并中产生冲突的具体情况：</p><h5 id="lt-1-gt-两个分支中修改了同一个文件（不管什么地方）"><a href="#lt-1-gt-两个分支中修改了同一个文件（不管什么地方）" class="headerlink" title="　&lt;1&gt; 两个分支中修改了同一个文件（不管什么地方）"></a><strong>　&lt;1&gt; 两个分支中修改了同一个文件</strong>（不管什么地方）</h5><h5 id="lt-2-gt-两个分支中修改了同一个文件的名称"><a href="#lt-2-gt-两个分支中修改了同一个文件的名称" class="headerlink" title="　&lt;2&gt;两个分支中修改了同一个文件的名称"></a><strong>　&lt;2&gt;两个分支中修改了同一个文件的名称</strong></h5><p>两个分支中分别修改了不同文件中的部分，不会产生冲突，可以直接将两部分合并。</p><h4 id="2-冲突解决方法"><a href="#2-冲突解决方法" class="headerlink" title="2. 冲突解决方法"></a>2. 冲突解决方法</h4><ol><li>情景一：在当前分支上，直接修改冲突代码—&gt;add—&gt;commit。</li><li>情景二：在本地当前分支上，修改冲突代码—&gt;add—&gt;commit—&gt;push</li></ol><p> 注：借用vim或者IDE或者直接找到冲突文件，修改。</p><h4 id="3、实战演示"><a href="#3、实战演示" class="headerlink" title="3、实战演示"></a>3、实战演示</h4><p>（1）情景</p><p>　　本地库中两个不同分支，修改同一个文件同一代码块，两分支先后将修改合并到master分支上，master在合并第二个分支代码时，报错：合并冲突。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.cnblogs.com/gavincoder/p/9071959.html">Git冲突与解决方法</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ajax常见面试题</title>
    <link href="/2021/05/28/ajax%E9%9D%A2%E8%AF%95/"/>
    <url>/2021/05/28/ajax%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="什么是ajax？ajax作用是什么？"><a href="#什么是ajax？ajax作用是什么？" class="headerlink" title="什么是ajax？ajax作用是什么？"></a>什么是ajax？ajax作用是什么？</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">异步的javascript和<span class="hljs-keyword">xml</span>  <span class="hljs-title">AJAX</span> 是一种用于创建快速动态网页的技术。  ajax用来与后台交互<br></code></pre></td></tr></table></figure><h3 id="原生js-ajax请求有几个步骤？分别是什么"><a href="#原生js-ajax请求有几个步骤？分别是什么" class="headerlink" title="原生js ajax请求有几个步骤？分别是什么"></a>原生js ajax请求有几个步骤？分别是什么</h3><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-comment">//创建 XMLHttpRequest 对象</span><br><span class="hljs-keyword">var</span> ajax = <span class="hljs-keyword">new</span> XMLHttpRequest();<br><span class="hljs-comment">//规定请求的类型、URL 以及是否异步处理请求。</span><br>ajax.open(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-built_in">url</span>,<span class="hljs-literal">true</span>);<br><span class="hljs-comment">//发送信息至服务器时内容编码类型</span><br>ajax.setRequestHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>); <br><span class="hljs-comment">//发送请求</span><br>ajax.send(<span class="hljs-literal">null</span>);  <br><span class="hljs-comment">//接受服务器响应数据</span><br>ajax.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (obj.readyState == <span class="hljs-number">4</span> &amp;&amp; (obj.status == <span class="hljs-number">200</span> || obj.status == <span class="hljs-number">304</span>)) &#123; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="ajax几种请求方式？他们的优缺点？"><a href="#ajax几种请求方式？他们的优缺点？" class="headerlink" title="ajax几种请求方式？他们的优缺点？"></a>ajax几种请求方式？他们的优缺点？</h3><p>常用的post,get,delete。不常用copy、head、link等等。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Get</span><br><span class="hljs-keyword">GET</span>请求的数据会附加在URL之后，用问号分割，多个参数用&amp;进行连接。<br><span class="hljs-keyword">GET</span>请求的数据会暴露在地址栏中。<br><span class="hljs-keyword">GET</span>请求URL的编码格式采用的是ASCII编码，而不是Unicode编码。<br><span class="hljs-keyword">GET</span>请求传输大小有限制，大小在<span class="hljs-number">2</span>KB。<br><span class="hljs-keyword">GET</span>相对安全性较差，会被浏览器主动缓存。<br><span class="hljs-keyword">GET</span>产生一个TCP数据包，head和data一起发送。<br><span class="hljs-keyword">GET</span>浏览器回退无害。<br><br><br>POST<br>POST请求会把数据放置在HTTP请求包的包体中，不会直接暴露给用户。<br>POST请求，理论上大小是不会限制的，但是实际上各个服务器会规定POST提交数据大小。<br>POST相对<span class="hljs-keyword">Get</span>更安全，因为参数不会保存浏览器立式或者是web服务器日志中。<br>POST产生两个TCP数据包，<span class="hljs-keyword">header</span>先发送，服务器响应<span class="hljs-number">100</span>ms然后继续，发送data，服务器<span class="hljs-number">200</span>然后返回数据。<br>POST浏览器回退重新请求。<br></code></pre></td></tr></table></figure><h3 id="什么情况造成跨域？"><a href="#什么情况造成跨域？" class="headerlink" title="什么情况造成跨域？"></a>什么情况造成跨域？</h3><p>同源策略限制 不同源会造成跨域。以下任意一种情况不同，都是不同源。</p><p><img src="/imageO/2.png" alt="图片"></p><h3 id="跨域解决方案有哪些？"><a href="#跨域解决方案有哪些？" class="headerlink" title="跨域解决方案有哪些？"></a>跨域解决方案有哪些？</h3><p>跨域，指的是浏览器不能执行其他网站的脚本。浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。<br>解决办法：</p><ol><li>JSONP：注意JSONP只支持GET请求，不支持POST请求。( 只能解决get跨域(问的最多))<br>原理：ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。 —   callback</li></ol><p>步骤：</p><ol><li>去创建一个script标签</li><li>script的src属性设置接口地址</li><li>接口参数,必须要带一个自定义函数名 要不然后台无法返回数据。</li><li>通过定义函数名去接收后台返回数据</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>去创建一个script标签<br>var  script = document.createElement(<span class="hljs-string">&quot;script&quot;</span>);<br><span class="hljs-regexp">//</span>script的src属性设置接口地址 并带一个callback回调函数名称<br>script.src = <span class="hljs-string">&quot;http://127.0.0.1:8888/index.php?callback=jsonpCallback&quot;</span>;<br><span class="hljs-regexp">//</span>插入到页面<br>document.head.appendChild(script);<br><span class="hljs-regexp">//</span>通过定义函数名去接收后台返回数据<br><span class="hljs-keyword">function</span> jsonpCallback(data)&#123;<br>    <span class="hljs-regexp">//</span>注意  jsonp返回的数据是json对象可以直接使用<br>    <span class="hljs-regexp">//</span>ajax  取得数据是json字符串需要转换成json对象才可以使用。<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>代理：写后端接口，在后端调用页面拿到返回值返回给html文件。相当于绕过了浏览器，就不会存在跨域问题。例；(nigx反向代理)</p></li><li><p>CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</p></li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin:*&#x27;</span>);<span class="hljs-comment">//允许所有来源访问</span><br><span class="hljs-selector-tag">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Method:POST,GET&#x27;</span>);<span class="hljs-comment">//允许访问的方式</span><br></code></pre></td></tr></table></figure><ol start="4"><li>proxy代理 目前常用方式,通过服务器设置代理</li><li>window.postMessage() 利用h5新特性window.postMessage()</li></ol><h4 id="http常见状态码有哪些？"><a href="#http常见状态码有哪些？" class="headerlink" title="http常见状态码有哪些？"></a>http常见状态码有哪些？</h4><p>一: 2开头状态码</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span>xx (成功)表示成功处理了请求的状态代码<br><span class="hljs-symbol">200 </span>(成功) 服务器已成功处理了请求。 通常。<br></code></pre></td></tr></table></figure><p>二: 3开头状态码</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span>xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。<br><span class="hljs-symbol">304 </span>(未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br></code></pre></td></tr></table></figure><p>三: 4开头状态码</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">4</span>xx<span class="hljs-comment">(请求错误)</span> 这些状态代码表示请求可能出错，妨碍了服务器的处理<br><span class="hljs-number">1</span>:<span class="hljs-number">400</span> <span class="hljs-comment">(错误请求)</span> 服务器不理解请求的语法。<br> <br><span class="hljs-number">2</span>:<span class="hljs-number">403</span> <span class="hljs-comment">(禁止)</span> 服务器拒绝请求。<br><br><span class="hljs-number">3</span>:<span class="hljs-number">404</span> <span class="hljs-comment">(未找到)</span> 服务器找不到请求的网页。<br></code></pre></td></tr></table></figure><p>四: 5开头状态码</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span>xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错<br><span class="hljs-symbol">500 </span>(服务器内部错误) 服务器遇到错误，无法完成请求。<br><br><span class="hljs-symbol">501 </span>(尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br><br><span class="hljs-symbol">502 </span>(错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。<br><br><span class="hljs-symbol">503 </span>(服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。<br><br><span class="hljs-symbol">504 </span>(网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br><br><span class="hljs-symbol">505 </span>(HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。<br><br></code></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844903573529034759">ajax常见面试题</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从输入URL到浏览器显示页面过程中都发生了什么？</title>
    <link href="/2021/05/27/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%BF%87%E7%A8%8B%E9%9D%A2%E8%AF%95/"/>
    <url>/2021/05/27/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%BF%87%E7%A8%8B%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="URL的输入到浏览器解析的一系列事件"><a href="#URL的输入到浏览器解析的一系列事件" class="headerlink" title="URL的输入到浏览器解析的一系列事件"></a>URL的输入到浏览器解析的一系列事件</h3><ol><li>浏览器根据请求的url交给DNS域名解析</li><li>发起TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束。</li></ol><blockquote><p>简单说说，浏览器根据请求的url交给dns域名解析，查找真正的ip地址，向服务器发起请求；服务器交给后台处理后，返回数据，浏览器会接收到文件数据，比如，html,js，css，图像等；然后浏览器会对加载到的资源进行语法解析，建立相应的内部数据结构；载入解析到得资源文件，渲染页面，完成显示页面效果。</p></blockquote><p>不够清楚明白吗？</p><h4 id="那就再次详细一下，从浏览器接收url，开始进行网络请求线程，发出一个完整的HTTP请求，从服务器端接收请求到对应的后台接收到请求，然后是后台和前台的http交互；其中的缓存问题（http的缓存），浏览器接收到http数据包后的解析流程，css的可视化格式模型，js引擎解析过程等；其他呈现页面效果"><a href="#那就再次详细一下，从浏览器接收url，开始进行网络请求线程，发出一个完整的HTTP请求，从服务器端接收请求到对应的后台接收到请求，然后是后台和前台的http交互；其中的缓存问题（http的缓存），浏览器接收到http数据包后的解析流程，css的可视化格式模型，js引擎解析过程等；其他呈现页面效果" class="headerlink" title="那就再次详细一下，从浏览器接收url，开始进行网络请求线程，发出一个完整的HTTP请求，从服务器端接收请求到对应的后台接收到请求，然后是后台和前台的http交互；其中的缓存问题（http的缓存），浏览器接收到http数据包后的解析流程，css的可视化格式模型，js引擎解析过程等；其他呈现页面效果"></a>那就再次详细一下，从浏览器接收url，开始进行网络请求线程，发出一个完整的HTTP请求，从服务器端接收请求到对应的后台接收到请求，然后是后台和前台的http交互；其中的缓存问题（http的缓存），浏览器接收到http数据包后的解析流程，css的可视化格式模型，js引擎解析过程等；其他呈现页面效果</h4><p>这里就需要你对浏览器内核的理解：其中主要的渲染引擎和JS引擎，这里了解一下你对浏览器内核的理解。</p><ol><li><p>渲染引擎，是负责取得网页的内容，整理信息，以及计算网页的显示方式，然后输出到显示器上。</p></li><li><p>JS引擎是用于解析和执行javascript来实现网页的动态效果。</p></li></ol><blockquote><p>浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。其实最开始渲染引擎和JS引擎是没有区分明确的，不过后来JS引擎越来越独立，so，内核就倾向于渲染引擎。</p></blockquote><blockquote><p>对于资源请求/获取,资源响应/页面渲染，会给网络带宽和设备资源带来压力，这个时候就会考虑到web的性能优化。</p></blockquote><h4 id="通过DNS解析域名的实际IP地址"><a href="#通过DNS解析域名的实际IP地址" class="headerlink" title="通过DNS解析域名的实际IP地址"></a>通过DNS解析域名的实际IP地址</h4><p>发送至 DNS 服务器并获得域名对应的 WEB 服务器的 ip 地址。</p><p>DNS 解析首先会从你的浏览器的缓存中去寻找是否有这个网址对应的 IP 地址，如果没有就向OS系统的 DNS 缓存中寻找，如果没有就是路由器的 DNS 缓存， 如果没有就是 ISP 的DNS 缓存中寻找。 所以，缓存的寻找过程就是： 浏览器 -&gt; 系统 -&gt; 路由器 -&gt; ISP。 如果在某一个缓存中找到的话，就直接跳到下一步。 如果都没有找到的话，就会向 ISP 或者公共的域名解析服务发起 DNS 查找请求。这个查找的过程还是一个递归查询的过程。</p><h5 id="检查浏览器是否有缓存"><a href="#检查浏览器是否有缓存" class="headerlink" title="检查浏览器是否有缓存"></a>检查浏览器是否有缓存</h5><p>通过Cache-Control和Expires来检查是否命中强缓存，命中则直接取本地磁盘的html（状态码为200 from disk(or memory) cache，内存or磁盘）；</p><p>如果没有命中强缓存，则会向服务器发起请求（先进行下一步的TCP连接），服务器通过Etag和Last-Modify来与服务器确认返回的响应是否被更改（协商缓存），若无更改则返回状态码（304 Not Modified）,浏览器取本地缓存；</p><p>若强缓存和协商缓存都没有命中则返回请求结果。</p><h4 id="与-WEB-服务器建立-TCP-连接"><a href="#与-WEB-服务器建立-TCP-连接" class="headerlink" title="与 WEB 服务器建立 TCP 连接"></a>与 WEB 服务器建立 TCP 连接</h4><p>TCP 协议通过三次握手建立连接。</p><p>客户端通过 SYN 报文段发送连接请求，确定服务端是否开启端口准备连接。状态设置为 SYN_SEND;</p><p>服务器如果有开着的端口并且决定接受连接，就会返回一个 SYN+ACK 报文段给客户端，状态设置为 SYN_RECV；</p><p>客户端收到服务器的 SYN+ACK 报文段，向服务器发送 ACK 报文段表示确认。此时客户端和服务器都设置为 ESTABLISHED 状态。连接建立，可以开始数据传输了。</p><p>翻译成大白话就是：</p><p>客户端：你能接收到我的消息吗？</p><p>服务端：可以的，那你能接收到我的回复吗？</p><p>客户端：可以，那我们开始聊正事吧。</p><p>为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人。</p><p>为什么不是4次？：3次够了第四次浪费</p><h4 id="浏览器发送HTTP请求"><a href="#浏览器发送HTTP请求" class="headerlink" title="浏览器发送HTTP请求"></a>浏览器发送HTTP请求</h4><p>首先科补一个小知识，HTTP的端口为80/8080，而HTTPS的端口为443</p><p>发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口 请求报文由请求行，请求抱头，请求正文组成。</p><p>请求行<br>请求行的格式为Method Request-URL HTTP-Version CRLF eg: GET index.html HTTP/1.1 常用的方法有: GET,POST, PUT, DELETE, OPTIONS, HEAD。</p><p>常见的请求方法区别<br>这里主要展示GET和POST的区别</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-keyword">Get</span><br><span class="hljs-keyword">GET</span>请求的数据会附加在URL之后，用问号分割，多个参数用&amp;进行连接。<br><br><span class="hljs-keyword">GET</span>请求的数据会暴露在地址栏中。<br><br><span class="hljs-keyword">GET</span>请求URL的编码格式采用的是ASCII编码，而不是<span class="hljs-keyword">Unicode</span>编码。<br><br><span class="hljs-keyword">GET</span>请求传输大小有限制，大小在<span class="hljs-number">2</span>KB。<br><br><span class="hljs-keyword">GET</span>相对安全性较差，会被浏览器主动缓存。<br><br><span class="hljs-keyword">GET</span>产生一个TCP数据包，head和data一起发送。<br><br><span class="hljs-keyword">GET</span>浏览器回退无害。<br></code></pre></td></tr></table></figure><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">POST</span><br><span class="hljs-keyword">POST</span>请求会把数据放置在HTTP请求包的包体中，不会直接暴露给用户。<br><br><span class="hljs-keyword">POST</span>请求，理论上大小是不会限制的，但是实际上各个服务器会规定<span class="hljs-keyword">POST</span>提交数据大小。<br><br><span class="hljs-keyword">POST</span>相对Get更安全，因为参数不会保存浏览器立式或者是web服务器日志中。<br><br><span class="hljs-keyword">POST</span>产生两个TCP数据包，header先发送，服务器响应100ms然后继续，发送data，服务器200然后返回数据。<br><br><span class="hljs-keyword">POST</span>浏览器回退重新请求。<br></code></pre></td></tr></table></figure><h4 id="服务器处理请求并返回HTTP报文"><a href="#服务器处理请求并返回HTTP报文" class="headerlink" title="服务器处理请求并返回HTTP报文"></a>服务器处理请求并返回HTTP报文</h4><p>它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，分成三份，状态码 ，响应报头和响应报文(你从服务器请求的HTML,CSS,JS文件就放在这里面)</p><h4 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h4><p>解析HTML形成DOM树</p><p>解析CSS形成CSSOM 树</p><p>合并DOM树和CSSOM树形成渲染树</p><p>浏览器开始渲染并绘制页面 这个过程涉及两个比较重要的概念回流和重绘，DOM结点都是以盒模型形式存在，需要浏览器去计算位置和宽度等，这个过程就是回流。等到页面的宽高，大小，颜色等属性确定下来后，浏览器开始绘制内容，这个过程叫做重绘。浏览器刚打开页面一定要经过这两个过程的，但是这个过程非常非常非常消耗性能，所以我们应该尽量减少页面的回流和重绘</p><h4 id="CSS阻塞情况以及优化"><a href="#CSS阻塞情况以及优化" class="headerlink" title="CSS阻塞情况以及优化"></a>CSS阻塞情况以及优化</h4><p>1、<strong>style</strong>标签中的样式：由HTML解析器进行解析，<strong>不会</strong>阻塞浏览器渲染(可能会产生“闪屏现象”)，不会阻塞DOM解析</p><p>2、<strong>link</strong>引入的CSS样式：由CSS解析器进行解析，<strong>会</strong>阻塞浏览器渲染，会阻塞后面的js语句执行，不阻塞DOM的解析</p><p>3、优化：使用CDN节点进行外部资源加速，对CSS进行压缩，优化CSS代码(不要使用太多层选择器)</p><h4 id="JS阻塞问题"><a href="#JS阻塞问题" class="headerlink" title="JS阻塞问题"></a>JS阻塞问题</h4><p>1、js会阻塞后续DOM的解析，原因是：浏览器不知道后续脚本的内容，如果先去解析了下面的DOM，而随后的js删除了后面所有的DOM，那么浏览器就做了无用功，浏览器无法预估脚本里面具体做了什么操作，例如像document.write这种操作，索性全部停住，等脚本执行完了，浏览器再继续向下解析DOM<br>2、js会阻塞页面渲染，原因是：js中也可以给DOM设置样式，浏览器等该脚本执行完毕，渲染出一个最终结果，避免做无用功。<br>3、js会阻塞后续js的执行，原因是维护依赖关系，例如：必须先引入jQuery再引入bootstrap</p><h4 id="资源加载阻塞"><a href="#资源加载阻塞" class="headerlink" title="资源加载阻塞"></a>资源加载阻塞</h4><p>无论css阻塞，还是js阻塞，都不会阻塞浏览器加载外部资源（图片、视频、样式、脚本等）<br>原因：浏览器始终处于一种：“先把请求发出去”的工作模式，只要是涉及到网络请求的内容，无论是：图片、样式、脚本，都会先发送请求去获取资源，至于资源到本地之后什么时候用，由浏览器自己协调。这种做法效率很高。</p><h4 id="为什么CSS解析顺序从右到左"><a href="#为什么CSS解析顺序从右到左" class="headerlink" title="为什么CSS解析顺序从右到左"></a>为什么CSS解析顺序从右到左</h4><p>如果是从左到右的话：</p><p>1、第一次从爷节点 -&gt; 子节点 -&gt; 孙节点1<br>2、第一次从爷节点 -&gt; 子节点 -&gt; 孙节点2<br>3、第一次从爷节点 -&gt; 子节点 -&gt; 孙节点3</p><p>如果三次都匹配不到的话，那至少也得走三次：爷节点 -&gt; 子节点 -&gt; 孙节点，这就做了很多无用功啊</p><p>如果是从右到左的话：</p><p>1、第一次从孙节点1，找不到，停止<br>2、第一次从孙节点2，找不到，停止<br>3、第一次从孙节点3，找不到，停止<br>这样的话，尽早发现找不到，尽早停止，可以少了很多无用功。</p><h4 id="什么是重绘回流"><a href="#什么是重绘回流" class="headerlink" title="什么是重绘回流"></a>什么是重绘回流</h4><p>1、重绘：重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。<br>2、回流：渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排，或回流<br>3、”重绘”不一定需要”重排”，比如改变某个网页元素的颜色，就只会触发”重绘”，不会触发”重排”，因为布局没有改变。<br>4、”重排”大多数情况下会导致”重绘”，比如改变一个网页元素的位置，就会同时触发”重排”和”重绘”，因为布局改变了。</p><h4 id="浏览器缓存分类"><a href="#浏览器缓存分类" class="headerlink" title="浏览器缓存分类"></a>浏览器缓存分类</h4><h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5><p>不会向服务器发送请求，直接从本地缓存中获取数据<br>请求资源的的状态码为: 200 ok(from memory cache)<br>优先级：cache-control &gt; expires</p><h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><p>向服务器发送请求，服务器会根据请求头的资源判断是否命中协商缓存<br>如果命中，则返回304状态码通知浏览器从缓存中读取资源<br>优先级：Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6850037263116533773#heading-4">从浏览器地址栏输入url到显示页面的步骤</a></p><p><a href="https://juejin.cn/post/6844903832435032072#heading-0">URL的输入到浏览器解析的一系列事件</a><br><a href="https://juejin.cn/post/6986416221323264030#heading-7">「自我检验」输入URL发生了啥？希望你顺便懂这15个知识点</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebSocket和Socket.io介绍以及聊天室功能实现</title>
    <link href="/2021/05/22/socket%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    <url>/2021/05/22/socket%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>在介绍 Socket.io 之前，首先需要说一说什么是 WebSocket。</p><p>详细了解参考：</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">MDN上的介绍</a></p><p><a href="https://www.zhihu.com/question/20215561">知乎上的介绍</a></p><p><a href="http://www.cnblogs.com/mazg/p/5467960.html">WebSocket 与 Socket.io 介绍</a><br>为什么需要WebSocket</p><p>我们知道，在 HTML5 之前，客户端和服务器通过 HTTP 协议交换数据，但是，HTTP 协议具有两个特点：</p><ul><li><p><strong>HTTP 协议是一种单向的网络协议</strong>。在建立连接后，它只允许客户端 Browser/UA (User Agent) 向服务器 WebServer 发送请求后，WebServer 才能返回相应的数据。而 WebServer 不能主动推送数据给 Browser/UA。</p></li><li><p><strong>HTTP 协议是无状态的</strong>。客户端向服务器发送连接请求中会包含 identity info（鉴别信息），每次当一个连接结束时，服务器就会将这些鉴别信息丢掉，客户端再次发送 HTTP 请求时，就需要重新发送这些信息。</p></li></ul><p>现在，假设我们需要开发一个基于 Web 的应用程序，需要获取服务器的实时数据，比如股票的实时行情、聊天室的聊天内容等，这就需要客户端和服务器之间反复进行 HTTP 通信，客户端不断发送请求，去获取当前的实时数据。下面介绍两种常见的方式：</p><ul><li><strong>ajax 轮询</strong></li></ul><p>ajax 轮询的原理非常简单，就是让浏览器定时（隔几秒）向服务器发送一次请求，询问是否有新的数据，如果有就返回最新数据，浏览器接收到后将最新数据显示出来，然后重复这一过程。</p><ul><li><strong>Long Polling</strong></li></ul><p>Long Polling 的原理与 ajax 轮询的原理差不多，都是采用轮询的方式，它是 Polling 的一种改进。客户端发送请求到服务器后，服务器并不立即响应客户端，而是保持住这次连接，当有新的数据时，才返回给客户端，客户端接收到数据，进行展示，再立即发送一个新的请求给服务器，并重复这个过程。如果服务器的数据长期没有更新，一段时间后，这个请求就会超时，客户端收到超时消息后，再立即发送一个新的请求给服务器。</p><p>从上面可以看出，这两种方式都<strong>需要不断的建立 HTTP 连接，然后等待服务器处理。</strong></p><p>在这样的情况下，假如客户端能有一种新的网络协议，可以支持客户端和服务器的双向通信的就好了。于是，WebSocket 应运而生。</p><h3 id="Websocket是什么样的协议，具体有什么优点"><a href="#Websocket是什么样的协议，具体有什么优点" class="headerlink" title="Websocket是什么样的协议，具体有什么优点"></a>Websocket是什么样的协议，具体有什么优点</h3><p>Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。</p><p>首先Websocket是基于HTTP协议的，或者说借用了HTTP的协议来完成一部分握手。在握手阶段是一样的</p><h4 id="WebSocket-协议"><a href="#WebSocket-协议" class="headerlink" title="WebSocket 协议"></a>WebSocket 协议<strong></h4><p>WebSocket 是 HTML5 新增的一种通信协议。<strong>WebSocket 协议是一种持久化的双向通信协议，它建立在TCP之上，同 HTTP 一样通过 TCP 来传输数据</strong>，但是它和 HTTP 最大的不同有两点：</p><p>WebSocket 是一种双向通信协议，在建立连接后，WebSocket 服务器和 Browser/UA(浏览器) 都能主动的向对方发送或接收数据，就像 Socket 一样，不同的是 WebSocket 是一种建立在 Web 基础上的一种简单模拟 Socket 的协议。</p><p>WebSocket 需要通过握手连接，类似于 TCP 它也需要客户端和服务器端进行握手连接，连接成功后才能相互通信。</p><h4 id="WebSocket-工作流程"><a href="#WebSocket-工作流程" class="headerlink" title="WebSocket 工作流程"></a>WebSocket 工作流程</h4><p>浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。因为 WebSocket 连接本质上就是一个 TCP 连接，所以在数据传输的稳定性和数据传输量的大小方面，和传统轮询以技术比较，具有很大的性能优势。</p><p>为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息 “Upgrade: WebSocket” 表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p><h3 id="基于-nodeJs-的-webSocket-框架-socket-io"><a href="#基于-nodeJs-的-webSocket-框架-socket-io" class="headerlink" title="基于 nodeJs 的 webSocket 框架 socket.io"></a>基于 nodeJs 的 webSocket 框架 socket.io</h3><p>socket.io 是这篇文章的主角，因为它对 webSocket 做了一个非常完善的封装， 并且提出了 多房间  多命名空间的 概念，让多聊天室同时存在不再是一个问题，所以，下面就会详细的来介绍下 socket.io 这个框架</p><p>Socket.io 是一个完全由 JavaScript 实现、基于 Node.js、支持 WebSocket 协议的用于实时通信、跨平台的开源框架，它包括了客户端的 JavaScript 和服务器端的 Node.js。</p><p>Socket.io 设计的目标是支持任何的浏览器，任何 Mobile 设备。支持主流的 PC 浏览器 (IE,Safari,Chrome,Firefox,Opera等)，Mobile 浏览器(iphone Safari/ipad Safari/Android WebKit/WebOS WebKit等)。</p><p>但是，WebSocket 协议是 HTML5 新推出的协议，浏览器对它的支持并不完善，由此可以看出，Socket.io 不可能仅仅是对 WebSocket 的实现，它还支持其他的通信方式，如上面介绍过的 ajax 轮询和 Long Polling。根据浏览器的支持程度，自主选择使用哪种方式进行通讯。</p><p>Socket.io 支持的通信方式：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs smali">WebSocket<br>Adobe Flash Socket<br>AJAX long-polling<br>AJAX multipart streaming<br>Forever IFrame<br>JSONP polling<br></code></pre></td></tr></table></figure><h3 id="Socket-io-的使用"><a href="#Socket-io-的使用" class="headerlink" title="Socket.io 的使用"></a>Socket.io 的使用</h3><p>node 端使用 express 框架</p><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>服务器端：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save socket.io</span><br></code></pre></td></tr></table></figure><p>浏览器端（引入本地文件）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/socket.io/socket.io.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>浏览器端（CDN 加速）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="创建-io-服务器"><a href="#创建-io-服务器" class="headerlink" title="创建 io 服务器"></a>创建 io 服务器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)();<br><span class="hljs-keyword">var</span> server = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>).Server(app);<br><span class="hljs-keyword">var</span> io = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;socket.io&#x27;</span>)(server);<br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>&#123;<br>    res.sendFile(__dirname + <span class="hljs-string">&#x27;/index.html&#x27;</span>);<br>&#125;);<br><br>server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;App listening on port 3000!&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>Socket.IO 提供了默认事件（如：connect, message, disconnect）。另外，Socket.IO允许发送并接收自定义事件。</p><blockquote><p>监听客户端连接，回调函数会传递本次连接的socket</p></blockquote><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">io.<span class="hljs-keyword">on</span>(‘connection’,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(socket)</span><span class="hljs-comment">&#123; &#125;</span>);</span><br></code></pre></td></tr></table></figure><blockquote><p>给所有客户端广播消息</p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">io</span>.sockets.emit(‘<span class="hljs-type">String</span>’,<span class="hljs-class"><span class="hljs-keyword">data</span>);</span><br></code></pre></td></tr></table></figure><blockquote><p>给指定的客户端发送自定义事件</p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">socket</span>.emit(‘<span class="hljs-type">String</span>’, <span class="hljs-class"><span class="hljs-keyword">data</span>);</span><br><span class="hljs-title">io</span>.sockets.socket(socketid).emit(‘<span class="hljs-type">String</span>’, <span class="hljs-class"><span class="hljs-keyword">data</span>);</span><br></code></pre></td></tr></table></figure><blockquote><p>接收客户端发送的自定义事件</p></blockquote><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">socket.<span class="hljs-keyword">on</span>(‘<span class="hljs-keyword">String</span>’,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span>);</span><br></code></pre></td></tr></table></figure><blockquote><p>给除了自己以外的客户端广播消息</p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">socket</span>.broadcast.emit(“msg”, <span class="hljs-class"><span class="hljs-keyword">data</span>);</span><br></code></pre></td></tr></table></figure><h4 id="房间"><a href="#房间" class="headerlink" title="房间"></a>房间</h4><p>房间是 Socket.IO 提供的一个非常好用的功能。房间相当于为指定的一些客户端提供了一个命名空间，所有在房间里的广播和通信都不会影响到房间以外的客户端。</p><p>使用 join() 方法将 socket 加入房间：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">io.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-keyword">function</span>(socket)&#123;<br>    socket.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;group1&#x27;</span>, <span class="hljs-keyword">function</span> (data) &#123;<br>        socket.<span class="hljs-keyword">join</span>(<span class="hljs-string">&#x27;group1&#x27;</span>);<br>    &#125;);<br>    socket.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;group2&#x27;</span>,<span class="hljs-keyword">function</span>(data)&#123;<br>        socket.<span class="hljs-keyword">join</span>(<span class="hljs-string">&#x27;group2&#x27;</span>);<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>使用 leave() 方法离开房间：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">socket.leave(‘<span class="hljs-built_in">some</span> <span class="hljs-built_in">room</span>’);<br></code></pre></td></tr></table></figure><p>向房间中除了当前 socket 的其他 socket 发送消息</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">socket.broadcast.to<span class="hljs-comment">(‘group1’)</span>.emit<span class="hljs-comment">(‘event_name’, data)</span>;<br></code></pre></td></tr></table></figure><p>broadcast方法允许当前socket client不在该分组内</p><p>向房间中所有的 socket 发送消息</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">io</span>.sockets.<span class="hljs-keyword">in</span>(‘group1’).emit(‘event_name’, <span class="hljs-class"><span class="hljs-keyword">data</span>);</span><br></code></pre></td></tr></table></figure><p>获取连接的客户端 socket</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">io</span><span class="hljs-selector-class">.sockets</span><span class="hljs-selector-class">.clients</span>()<span class="hljs-selector-class">.forEach</span>(function (socket) &#123;<br>    <span class="hljs-comment">//.....</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>获取所有房间（分组）信息</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">io<span class="hljs-selector-class">.sockets</span><span class="hljs-selector-class">.manager</span>.rooms<br></code></pre></td></tr></table></figure><p>来获取此socketid进入的房间信息</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">io<span class="hljs-selector-class">.sockets</span><span class="hljs-selector-class">.manager</span><span class="hljs-selector-class">.roomClients</span><span class="hljs-selector-attr">[socket.id]</span><br></code></pre></td></tr></table></figure><p>获取particular room中的客户端，返回所有在此房间的socket实例</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">io<span class="hljs-selector-class">.sockets</span><span class="hljs-selector-class">.clients</span>(‘particular room’)<br></code></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/socket.io/socket.io.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> socket = io();</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样就加载了 socket.io-client。 socket.io-client 暴露了一个 io 全局变量，然后连接服务器。</p><p>请注意我们在调用 io() 时没有指定任何 URL，因为它默认将尝试连接到提供当前页面的主机。</p><blockquote><p>监听服务器消息</p></blockquote><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso">socket.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;msg&#x27;</span>,function(<span class="hljs-built_in">data</span>)&#123;<br>    console.<span class="hljs-keyword">log</span>(<span class="hljs-built_in">data</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>socket.on(“String”,function(data){}) 监听服务端发送的消息, String 参数与服务器端 socket.emit(‘String’, data) 第一个参数 String 相同。</p><blockquote><p>向服务器发送消息</p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">socket</span>.emit(‘msg’, <span class="hljs-class"><span class="hljs-keyword">data</span>);</span><br></code></pre></td></tr></table></figure><blockquote><p>监听 socket 断开与重连</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">socket.on(<span class="hljs-string">&#x27;disconnect&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;与服务器断开&quot;</span>);<br>&#125;);<br><br>socket.on(<span class="hljs-string">&#x27;reconnect&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;重新连接到服务器&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>客户端 socket.on() 监听的事件</p><ul><li>connect：连接成功</li><li>connecting：正在连接</li><li>disconnect：断开连接</li><li>connect_failed：连接失败</li><li>error：错误发生，并且无法被其他事件类型所处理</li><li>message：同服务器端message事件</li><li>anything：同服务器端anything事件</li><li>reconnect_failed：重连失败</li><li>reconnect：成功重连</li><li>reconnecting：正在重连</li></ul><h3 id="聊天室"><a href="#聊天室" class="headerlink" title="聊天室"></a>聊天室</h3><p>流程：</p><ol><li>创建 socket 服务器</li><li>浏览器建立 socket 连接</li><li>页面输入聊天内容，点击 “发送” 按钮，向自定义 socket 事件 “chat” 发送聊天信息</li><li>服务器监听浏览器 “chat” 事件，当接收到浏览器发来的聊天信息时，将信息发送给所有连接了 socket 的浏览器</li><li>浏览器监听服务器发来的 “chat” 事件，接收到聊天信息时，在页面上显示</li></ol><h4 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h4><p><a href="http://mengyujing.com/socket-io%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%81%8A%E5%A4%A9%E5%AE%A4%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/">WebSocket和Socket.io介绍以及聊天室功能实现</a></p><p><a href="https://www.bilibili.com/video/BV17i4y1t71B">聊天室</a></p>]]></content>
    
    
    <categories>
      
      <category>聊天室</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WebSocket</tag>
      
      <tag>Socket.io</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数的防抖与节流</title>
    <link href="/2021/05/16/JS&amp;%E9%98%B2%E6%8A%96&amp;%E8%8A%82%E6%B5%81/"/>
    <url>/2021/05/16/JS&amp;%E9%98%B2%E6%8A%96&amp;%E8%8A%82%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>函数防抖和节流，都是控制事件触发频率的方法。应用场景有很多，输入框持续输入，将输入内容远程校验、多次触发点击事件、onScroll等等。</p><hr><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>函数防抖，这里的抖动就是执行的意思，而一般的抖动都是持续的，多次的。假设函数持续多次执行，我们希望让它冷静下来再执行。也就是当持续触发事件的时候，函数是完全不执行的，等最后一次触发结束的一段时间之后，再去执行。</p><p>分解一下需求：</p><h4 id="持续触发不执行"><a href="#持续触发不执行" class="headerlink" title="持续触发不执行"></a>持续触发不执行</h4><h4 id="不触发的一段时间-最后一次点击-之后再执行"><a href="#不触发的一段时间-最后一次点击-之后再执行" class="headerlink" title="不触发的一段时间(最后一次点击)之后再执行"></a>不触发的一段时间(最后一次点击)之后再执行</h4><p>那么怎么实现上述的目标呢？我们先看这一点：在不触发的一段时间之后再执行，那就需要个定时器呀，定时器里面调用我们要执行的函数，将arguments传入。</p><p>封装一个函数，让持续触发的事件监听是我们封装的这个函数，将目标函数作为回调（func）传进去，等待一段时间过后执行目标函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func, delay</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      func.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)<br>    &#125;, delay)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二点实现了，再看第一点：持续触发不执行。我们先思考一下，是什么让我们的函数执行了呢？是上边的setTimeout。OK，那现在的问题就变成了持续触发，不能有setTimeout。这样直接在事件持续触发的时候，清掉定时器就好了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func, delay</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> timeout<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timeout) <span class="hljs-comment">// 如果持续触发，那么就清除定时器，定时器的回调就不会执行。</span><br>    timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      func.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)<br>    &#125;, delay)<br>  &#125;<br>&#125;<br>用法：<br><br>  box.onmousemove = debounce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>    box.innerHTML = <span class="hljs-string">`<span class="hljs-subst">$&#123;e.clientX&#125;</span>, <span class="hljs-subst">$&#123;e.clientY&#125;</span>`</span><br>  &#125;, <span class="hljs-number">1000</span>)<br><br></code></pre></td></tr></table></figure><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>节流的意思是让函数有节制地执行，而不是毫无节制的触发一次就执行一次。什么叫有节制呢？就是在一段时间内，只执行一次。</p><p>同样，我们分解一下：</p><h4 id="持续触发并不会执行多次"><a href="#持续触发并不会执行多次" class="headerlink" title="持续触发并不会执行多次"></a>持续触发并不会执行多次</h4><h4 id="第一次执行之后-到一定时间再去执行"><a href="#第一次执行之后-到一定时间再去执行" class="headerlink" title="(第一次执行之后)到一定时间再去执行"></a>(第一次执行之后)到一定时间再去执行</h4><p>思考一下，持续触发，并不会执行，但是到时间了就会执行。抓取一个关键的点：就是执行的时机。要做到控制执行的时机，我们可以通过一个开关，与定时器setTimeout结合完成。</p><p>函数执行的前提条件是开关打开，持续触发时，持续关闭开关，等到setTimeout到时间了，再把开关打开，函数就会执行了。</p><p>我们看一下代码怎么实现：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">function <span class="hljs-title">throttle</span><span class="hljs-params">(func, delay)</span> </span>&#123;<br>    let run = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">function</span> () &#123;<br>      <span class="hljs-keyword">if</span> (!run) &#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-comment">// 如果开关关闭了，那就直接不执行下边的代码</span><br>      &#125;<br>      run = <span class="hljs-literal">false</span> <span class="hljs-comment">// 持续触发的话，run一直是false，就会停在上边的判断那里</span><br>      <span class="hljs-built_in">setTimeout</span>(() =&gt; &#123;<br>        func.<span class="hljs-built_in">apply</span>(<span class="hljs-keyword">this</span>, arguments)<br>        run = <span class="hljs-literal">true</span> <span class="hljs-comment">// 定时器到时间之后，会把开关打开，我们的函数就会被执行</span><br>      &#125;, delay)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>调用的时候：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">box.onmousemove = throttle(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  box.innerHTML = <span class="hljs-string">`<span class="hljs-subst">$&#123;e.clientX&#125;</span>, <span class="hljs-subst">$&#123;e.clientY&#125;</span>`</span><br>&#125;, <span class="hljs-number">1000</span>)<br><br></code></pre></td></tr></table></figure><p>这样，就实现了节流，节流还可以用时间间隔去控制，就是记录上一次函数的执行时间，与当前时间作比较，如果当前时间与上次执行时间的时间差大于一个值，就执行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>防抖和节流巧妙地用了setTimeout，来控制函数执行的时机，优点很明显，可以节约性能，不至于多次触发复杂的业务逻辑而造成页面卡顿。</p><h3 id="介绍节流防抖原理、区别以及应用"><a href="#介绍节流防抖原理、区别以及应用" class="headerlink" title="介绍节流防抖原理、区别以及应用"></a>介绍节流防抖原理、区别以及应用</h3><h4 id="防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如-1-秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待-1-秒，直到能最终执行"><a href="#防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如-1-秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待-1-秒，直到能最终执行" class="headerlink" title="防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行"></a>防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行</h4><h4 id="节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次"><a href="#节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次" class="headerlink" title="节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次"></a>节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次</h4><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>防抖：搜索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染。<br>节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 防抖函数  一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>fn要被节流的函数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>delay规定的时间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>    <span class="hljs-comment">//记录上一次的延时器</span><br>    <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>       <span class="hljs-comment">//清除上一次的演示器</span><br>        <span class="hljs-built_in">clearTimeout</span>(timer);<br>        <span class="hljs-comment">//重新设置新的延时器</span><br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-comment">//修正this指向问题</span><br>            fn.apply(<span class="hljs-built_in">this</span>);<br>        &#125;, delay); <br>    &#125;<br>&#125;<br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>).onclick = debounce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;按钮被点击了&#x27;</span> + <span class="hljs-built_in">Date</span>.now());<br>&#125;, <span class="hljs-number">1000</span>);<br>* 节流函数 一个函数执行一次后，只有大于设定的执行周期才会执行第二次。有个需要频繁触发的函数，出于优化性能的角度，在规定时间内，只让函数触发的第一次生效，后面的不生效。<br><br><br> * <span class="hljs-meta">@param</span> fn要被节流的函数<br> * <span class="hljs-meta">@param</span> delay规定的时间<br> */<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>    <span class="hljs-comment">//记录上一次函数触发的时间</span><br>    <span class="hljs-keyword">var</span> lastTime = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">//记录当前函数触发的时间</span><br>        <span class="hljs-keyword">var</span> nowTime = <span class="hljs-built_in">Date</span>.now();<br>        <span class="hljs-keyword">if</span>(nowTime - lastTime &gt; delay)&#123;<br>            <span class="hljs-comment">//修正this指向问题</span><br>            fn.call(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-comment">//同步执行结束时间</span><br>            lastTime = nowTime;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">document</span>.onscroll = throttle(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;scllor事件被触发了&#x27;</span> + <span class="hljs-built_in">Date</span>.now());<br>&#125;, <span class="hljs-number">200</span>); <br><br><br></code></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/72923073?utm_source=qq&utm_medium=social&utm_oi=993958266707247104">参考文章：函数的防抖和节流是个啥？？？</a><br><a href="https://juejin.cn/post/7016593221815910408#heading-53">介绍节流防抖原理、区别以及应用</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS&amp;call&amp;apply&amp;bind的用法和区别</title>
    <link href="/2021/05/14/Js&amp;call&amp;apply&amp;bind/"/>
    <url>/2021/05/14/Js&amp;call&amp;apply&amp;bind/</url>
    
    <content type="html"><![CDATA[<p>call和bind它们最主要的作用，是改变 this 的指向。在平时的工作中，除了在写一些基础类，或者公用库方法的时候会用到它们，其他时候 call 和 apply 的应用场景并不多。</p><p>不过，突然遇到的时候，需要想一下才能转过弯来。所以今天，就让我们好好地探究一下，这两个方法的区别以及一些妙用。最后，还会介绍与之用法相似的 bind 的方法。</p><hr><h3 id="call-和-apply-的共同点"><a href="#call-和-apply-的共同点" class="headerlink" title="call 和 apply 的共同点"></a>call 和 apply 的共同点</h3><p>它们的共同点是，<strong>都能够改变函数执行时的上下文</strong>，将一个对象的方法交给另一个对象来执行，并且是立即执行的。</p><p>为何要改变执行上下文？举一个生活中的小例子：平时没时间做饭的我，周末想给孩子炖个腌笃鲜尝尝。但是没有适合的锅，而我又不想出去买。所以就问邻居借了一个锅来用，这样既达到了目的，又节省了开支，一举两得。</p><p>改变执行上下文也是一样的，A 对象有一个方法，而 B 对象因为某种原因，也需要用到同样的方法，那么这时候我们是单独为 B 对象扩展一个方法呢，还是借用一下 A 对象的方法呢？当然是借用 A 对象的啦，既完成了需求，又减少了内存的占用。</p><p>另外，它们的写法也很类似，<strong>调用 call 和 apply 的对象，必须是一个函数 Function</strong>。接下来，就会说到具体的写法，那也是它们区别的主要体现。</p><h3 id="call-和-apply-的区别"><a href="#call-和-apply-的区别" class="headerlink" title="call 和 apply 的区别"></a>call 和 apply 的区别</h3><p>它们的区别，主要体现在参数的写法上。先来看一下它们各自的具体写法。</p><ol><li>call 的写法<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Function.call(obj,<span class="hljs-comment">[param1<span class="hljs-comment">[,param2<span class="hljs-comment">[,…<span class="hljs-comment">[,paramN]</span>]</span>]</span>]</span>)<br></code></pre></td></tr></table></figure></li></ol><p>需要注意以下几点：</p><p>调用 call 的对象，必须是个函数 Function。<br>call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。</p><p>第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">function</span> <span class="hljs-keyword">func</span> (a,b,c) &#123;&#125;<br><br><span class="hljs-keyword">func</span>.call(obj, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-regexp">//</span> <span class="hljs-keyword">func</span> 接收到的参数实际上是 <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br><br><span class="hljs-keyword">func</span>.call(obj, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br><span class="hljs-regexp">//</span> <span class="hljs-keyword">func</span> 接收到的参数实际上是 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],undefined,undefined<br></code></pre></td></tr></table></figure><ol start="2"><li>apply 的写法</li></ol><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">Function</span>.<span class="hljs-built_in">apply</span>(obj[,argArray])<br></code></pre></td></tr></table></figure><p>需要注意的是：</p><p>它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。</p><p>第二个参数，必须<code>是数组或者类数组</code>，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">func</span>.apply(obj, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br><span class="hljs-regexp">//</span> <span class="hljs-keyword">func</span> 接收到的参数实际上是 <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br><br><span class="hljs-keyword">func</span>.apply(obj, &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-number">3</span>,<br>    length: <span class="hljs-number">3</span><br>&#125;)<br><span class="hljs-regexp">//</span> <span class="hljs-keyword">func</span> 接收到的参数实际上是 <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="什么是类数组？"><a href="#什么是类数组？" class="headerlink" title="什么是类数组？"></a>什么是类数组？</h4><p>先说数组，这我们都熟悉。它的特征有：可以通过角标调用，如 array[0]；具有长度属性length；可以通过 for 循环或forEach方法，进行遍历。</p><p>那么，类数组是什么呢？顾名思义，就是具备与数组特征类似的对象。比如，下面的这个对象，就是一个类数组。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">let</span> <span class="hljs-string">arrayLike = &#123;</span><br>    <span class="hljs-attr">0</span>: <span class="hljs-string">1,</span><br>    <span class="hljs-attr">1</span>: <span class="hljs-string">2,</span><br>    <span class="hljs-attr">2</span>: <span class="hljs-string">3,</span><br>    <span class="hljs-attr">length</span>: <span class="hljs-string">3</span><br><span class="hljs-attr">&#125;;</span><br></code></pre></td></tr></table></figure><p>类数组 arrayLike 可以通过角标进行调用，具有length属性，同时也可以通过 for 循环进行遍历。</p><p>类数组，还是比较常用的，只是我们平时可能没注意到。比如，我们获取 DOM 节点的方法，返回的就是一个类数组。再比如，在一个方法中使用 arguments 获取到的所有参数，也是一个类数组。</p><p>但是需要注意的是：类数组无法使用 forEach、splice、push 等数组原型链上的方法，毕竟它不是真正的数组。</p><h4 id="call-和-apply-的用途"><a href="#call-和-apply-的用途" class="headerlink" title="call 和 apply 的用途"></a>call 和 apply 的用途</h4><p>下面会分别列举 call 和 apply 的一些使用场景。声明：例子中没有哪个场景是必须用 call 或者必须用 apply 的，只是个人习惯这么用而已。</p><p>call 的使用场景<br>1、对象的继承。如下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">superClass</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.a = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">this</span>.print = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subClass</span> (<span class="hljs-params"></span>) </span>&#123;<br>    superClass.call(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">this</span>.print();<br>&#125;<br><br>subClass();<br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>subClass 通过 call 方法，继承了 superClass 的 print 方法和 a 变量。此外，subClass 还可以扩展自己的其他方法。</p><p>2、借用方法。还记得刚才的类数组么？如果它想使用 Array 原型链上的方法，可以这样：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> domNodes = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>prototype.slice.call(document.get<span class="hljs-constructor">ElementsByTagName(<span class="hljs-string">&quot;*&quot;</span>)</span>);<br></code></pre></td></tr></table></figure><p>这样，domNodes 就可以应用 Array 下的所有方法了。</p><h4 id="bind-的使用"><a href="#bind-的使用" class="headerlink" title="bind 的使用"></a>bind 的使用</h4><p>最后来说说 bind。在 MDN 上的解释是：bind() 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。</p><p>它的语法如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Function.bind(thisArg<span class="hljs-comment">[, arg1<span class="hljs-comment">[, arg2<span class="hljs-comment">[, ...]</span>]</span>]</span>)<br></code></pre></td></tr></table></figure><p>bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是，bind 方法的返回值是函数，并且需要稍后调用，才会执行。而 apply 和 call 则是立即调用。</p><p>来看下面这个例子：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl">function add (a, b) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br>function <span class="hljs-function"><span class="hljs-keyword">sub</span> (<span class="hljs-title">a</span>, <span class="hljs-title">b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a - b;<br>&#125;<br><br>add.bind(<span class="hljs-function"><span class="hljs-keyword">sub</span>, 5, 3)</span>; // 这时，并不会返回 <span class="hljs-number">8</span><br>add.bind(<span class="hljs-function"><span class="hljs-keyword">sub</span>, 5, 3)</span>(); // 调用后，返回 <span class="hljs-number">8</span><br><br></code></pre></td></tr></table></figure><p>如果 bind 的第一个参数是 null 或者 undefined，this 就指向全局对象 window。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。</p><p>bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844903768132157447#heading-1">「干货」细说 call、apply 以及 bind 的区别和用法</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP 方法get和post的区别</title>
    <link href="/2021/05/13/get&amp;post/"/>
    <url>/2021/05/13/get&amp;post/</url>
    
    <content type="html"><![CDATA[<p>前景<br>现在在前端面试中还有一些面试官会问get和post的区别。对于目前我们能了解get和post在什么场景下使用，使用方式有什么区别，以及如何提交数据这些基本上就可以了。</p><hr><h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><p>GET请求的数据会附加在URL之后，用问号分割，多个参数用&amp;进行连接。</p><p>GET请求的数据会暴露在地址栏中。</p><p>GET请求URL的编码格式采用的是ASCII编码，而不是Unicode编码。</p><p>GET请求传输大小有限制，大小在2KB。</p><p>GET相对安全性较差，会被浏览器主动缓存。</p><p>GET产生一个TCP数据包，head和data一起发送。</p><p>GET浏览器回退无害。</p><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>POST请求会把数据放置在HTTP请求包的包体中，不会直接暴露给用户。</p><p>POST请求，理论上大小是不会限制的，但是实际上各个服务器会规定POST提交数据大小。</p><p>POST相对Get更安全，因为参数不会保存浏览器立式或者是web服务器日志中。</p><p>POST产生两个TCP数据包，header先发送，服务器响应100ms然后继续，发送data，服务器200然后返回数据。</p><p>POST浏览器回退重新请求。</p><h4 id="其他http方法"><a href="#其他http方法" class="headerlink" title="其他http方法"></a>其他http方法</h4><p>PUT 方法<br>PUT 用于将数据发送到服务器来创建/更新资源。</p><p>POST 和 PUT之间的区别在于 PUT 请求是幂等的（idempotent）。也就是说，多次调用相同的 PUT 请求将始终产生相同的结果。相反，重复调用POST请求具有多次创建相同资源的副作用。</p><p>HEAD 方法<br>HEAD 与 GET 几乎相同，但没有响应主体。</p><p>换句话说，如果 GET /users 返回用户列表，那么 HEAD /users 将发出相同的请求，但不会返回用户列表。<br>HEAD 请求对于在实际发出 GET 请求之前（例如在下载大文件或响应正文之前）检查 GET 请求将返回的内容很有用。</p><p>DELETE 方法<br>DELETE 方法删除指定的资源。</p><p>OPTIONS 方法<br>OPTIONS 方法描述目标资源的通信选项。</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://juejin.cn/post/6854573213523902477">这年头还有面试问get和post的区别？</a></p><p><a href="https://www.w3school.com.cn/tags/html_ref_httpmethods.asp">HTML 请求方法</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>get&amp;post</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS&amp;this指向</title>
    <link href="/2021/05/12/JS&amp;this%E6%8C%87%E5%90%91/"/>
    <url>/2021/05/12/JS&amp;this%E6%8C%87%E5%90%91/</url>
    
    <content type="html"><![CDATA[<hr><h4 id="谈谈-This-对象的理解。"><a href="#谈谈-This-对象的理解。" class="headerlink" title="谈谈 This 对象的理解。"></a>谈谈 This 对象的理解。</h4><p>在 ES5 中，其实 this 的指向，始终坚持一个原理：<strong>this 永远指向最后调用它的那个对象&gt;</strong>，来，跟着我朗读三遍：this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象。记住这句话，this 你已经了解一半了。</p><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模<br>式来判断。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span><br>谈一谈你对<span class="hljs-keyword">this</span>的理解，以及在各种环境下的<span class="hljs-keyword">this</span><br>在浏览器里，在全局范围内<span class="hljs-keyword">this</span>指向window对象<br>在函数中，<span class="hljs-keyword">this</span>永远指向最后调用他的那个对象(箭头函数除外)。<br>在构造函数中，<span class="hljs-keyword">this</span>指向new出来的新对象。<br>call、apply、bind中的<span class="hljs-keyword">this</span>被强绑定在指定的那个对象上。<br>箭头函数<span class="hljs-keyword">this</span>为父作用域的<span class="hljs-keyword">this</span>，不是调用时的<span class="hljs-keyword">this</span>。<br></code></pre></td></tr></table></figure><p>在我之前的一篇文章你不知道的执行上下文中有提到过 this，对那篇文章进行概括就是：</p><ol><li>上下文是在函数调用的时候被创建的。</li><li>this 是组成上下文的一部分。<br>因此每次函数被调用的时候就会产生一个新的 this。具体的分为下面几种。</li></ol><h4 id="作为普通函数在全局环境中被调用"><a href="#作为普通函数在全局环境中被调用" class="headerlink" title="作为普通函数在全局环境中被调用"></a>作为普通函数在全局环境中被调用</h4><p>在全局环境里面，this 永远指向 window，因此在全局环境里作为普通函数被调用的时候，this 也是指向 window(这里仅指在浏览器环境下，不考虑Node)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Abby&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//window</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name); <span class="hljs-comment">//Abby</span><br>&#125;<br><br>fn();<br></code></pre></td></tr></table></figure><p>这里，fn 其实是作为 window 的一个方法被调用的，而 name 也是 window 的一个属性，因此 fn() 实际上就是 window.fn()。</p><h4 id="作为对象的属性被调用"><a href="#作为对象的属性被调用" class="headerlink" title="作为对象的属性被调用"></a>作为对象的属性被调用</h4><p>如果函数作为一个对象的属性方法，并且被调用的时候，this 就指向这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Jane&#x27;</span>;<br><span class="hljs-keyword">var</span> person = &#123;<br>    name: <span class="hljs-string">&#x27;Abby&#x27;</span>,<br>    sayName: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;<br>&#125;;<br><span class="hljs-keyword">var</span> sayNameWin = person.sayName;<br><br>person.sayName(); <span class="hljs-comment">//Abby</span><br>sayNameWin(); <span class="hljs-comment">//Jane   作为 window 的方法被调用的</span><br></code></pre></td></tr></table></figure><p>在这里，sayName 方法是作为 person 的一个属性方法被调用的，因此指向 person，但是 sayNameWin 方法却是作为 window 的一个属性方法被调用的，因此 console.log 的值是 Jane。我们再看一个变形。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person1 = &#123;<br>    name: <span class="hljs-string">&#x27;Jane&#x27;</span>,<br>    sayName: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> person2 = &#123;<br>    name: <span class="hljs-string">&#x27;Abby&#x27;</span>,<br>    sayName: person1.sayName<br>&#125;<br><br>person2.sayName(); <span class="hljs-comment">//Abby  作为 person2 的属性方法被调用</span><br></code></pre></td></tr></table></figure><p>但是当在在对象方法中再定义函数，这时候 this 又是 window 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Jane&#x27;</span>;<br><span class="hljs-keyword">var</span> person = &#123;<br>    name: <span class="hljs-string">&#x27;Abby&#x27;</span>,<br>    sayName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);      <span class="hljs-comment">//window</span><br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);    <span class="hljs-comment">//Jane</span><br>        &#125;<br>        fn();<br>    &#125;<br>&#125;<br><br>person.sayName();<br></code></pre></td></tr></table></figure><p>如果想让 this 指向 person 的话，只需要用 that 保存下来 this 的值即可，也可以使用 apply 等改变 this。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Jane&#x27;</span>;<br><span class="hljs-keyword">var</span> person = &#123;<br>    name: <span class="hljs-string">&#x27;Abby&#x27;</span>,<br>    sayName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(that);      <span class="hljs-comment">//Object &#123;name: &quot;Abby&quot;&#125;</span><br>            <span class="hljs-built_in">console</span>.log(that.name);    <span class="hljs-comment">//Abby</span><br>        &#125;<br>        fn();<br>    &#125;<br>&#125;<br><br>person.sayName();<br></code></pre></td></tr></table></figure><h4 id="作为构造函数被调用"><a href="#作为构造函数被调用" class="headerlink" title="作为构造函数被调用"></a>作为构造函数被调用</h4><p>作为构造函数被调用的时候，this 代表它即将 new 出来的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">//Person &#123;name: &quot;Abby&quot;&#125;</span><br>&#125;<br><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;Abby&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(person.name);  <span class="hljs-comment">//Abby</span><br>如果不加 <span class="hljs-keyword">new</span>,表示即作为普通函数调用，指向 <span class="hljs-built_in">window</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">//window</span><br>&#125;<br><br>Person(<span class="hljs-string">&#x27;Jane&#x27;</span>); <br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.name); <span class="hljs-comment">//Jane</span><br></code></pre></td></tr></table></figure><h4 id="作为-call-apply-bind-方法的调用"><a href="#作为-call-apply-bind-方法的调用" class="headerlink" title="作为 call/apply/bind 方法的调用"></a>作为 call/apply/bind 方法的调用</h4><p>作为 call/apply/bind 方法被调用的时候指向传入的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>    name: <span class="hljs-string">&#x27;Abby&#x27;</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//Object &#123;name: &quot;Abby&quot;&#125;</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name); <span class="hljs-comment">//Abby</span><br>&#125;<br><br>fn.apply(person);<br></code></pre></td></tr></table></figure><h4 id="严格模式下面"><a href="#严格模式下面" class="headerlink" title="严格模式下面"></a>严格模式下面</h4><p>在严格模式下，在全局环境中执行函数调用的时候 this 并不会指向 window 而是会指向 undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">person</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//undefined</span><br>&#125;;<br>person();<br></code></pre></td></tr></table></figure><h4 id="setTimeout、setInterval中的this"><a href="#setTimeout、setInterval中的this" class="headerlink" title="setTimeout、setInterval中的this"></a>setTimeout、setInterval中的this</h4><p>《 javascript 高级程序设计》中写到：“超时调用的代码都是在全局执行域中执行的”。setTimeout/setInterval 执行的时候，this 默认指向 window 对象，除非手动改变 this 的指向。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Jane&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;Abby&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.sayName=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//window</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name); <span class="hljs-comment">//Jane</span><br>        &#125;;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-built_in">this</span>.sayName, <span class="hljs-number">10</span>);<br>    &#125;<br><br><span class="hljs-keyword">var</span> person=<span class="hljs-keyword">new</span> Person();<br></code></pre></td></tr></table></figure><p>在这里如果想改变 this，可是使用 apply/call/bind 等，也可以使用 that 保存 this.</p><p>setTimeout 中的回调函数在严格模式下也指向 window 而不是 undefined (是个坑)</p><p>因为 setTimeout 的回调函数如果没有指定的 this ，会做一个隐式的操作，将全局上下文注入进去，不管是在严格还是非严格模式下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">person</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">//window</span><br>&#125;<br><span class="hljs-built_in">setTimeout</span>(person, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h4 id="构造函数-prototype-属性"><a href="#构造函数-prototype-属性" class="headerlink" title="构造函数 prototype 属性"></a>构造函数 prototype 属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Jane&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;Abby&#x27;</span>;<br>&#125;<br>Person.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);        <span class="hljs-comment">// Person &#123;name: &quot;Abby&quot;&#125;</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);      <span class="hljs-comment">// Abby</span><br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br>person.sayName();<br></code></pre></td></tr></table></figure><p>在 Person.prototype.sayName 函数中，this 指向的 person 对象。即便是在整个原型链中,this 也代表当前对象的值。</p><ol start="8"><li><p>Eval函数<br>在 Eval 中，this 指向当前作用域的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Jane&#x27;</span>;<br><span class="hljs-keyword">var</span> person = &#123;<br>    name: <span class="hljs-string">&#x27;Abby&#x27;</span>,<br>    getName: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;console.log(this.name)&quot;</span>);<br>    &#125;<br>&#125;<br>person.getName();  <span class="hljs-comment">//Abby</span><br>    <br><span class="hljs-keyword">var</span> getNameWin=person.getName;<br>getNameWin();  <span class="hljs-comment">//Jane</span><br></code></pre></td></tr></table></figure><p>在这里，和不使用 Eval ，作为对象的方法调用的时候得出的结果是一样的。</p></li><li><p>箭头函数</p></li></ol><p>箭头函数里面 this 始终指向外部对象，因为箭头函数没有 this，因此它自身不能进行new实例化，同时也不能使用 call, apply, bind 等方法来改变 this 的指向。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>    name: <span class="hljs-string">&#x27;Abby&#x27;</span>,<br>    sayName: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> fn = <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);   <span class="hljs-comment">//Object &#123;name: &quot;Abby&quot;&#125;</span><br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name); <span class="hljs-comment">//Abby</span><br>            &#125;<br>        &#125;<br>        fn()();<br>    &#125;<br>&#125;<br><br>person.sayName();<br></code></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://zhuanlan.zhihu.com/p/26766112?utm_source=qq&utm_medium=social&utm_oi=993958266707247104">十分钟读懂 JavaScript 中的 this</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-Symbol&amp;promise、generator、async/await&amp;rest参数</title>
    <link href="/2021/05/11/Es6async&amp;await/"/>
    <url>/2021/05/11/Es6async&amp;await/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="ES6-Symbol"><a href="#ES6-Symbol" class="headerlink" title="ES6 Symbol"></a>ES6 Symbol</h3><p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。</p><p>基本用法<br>Symbol 函数栈不能用 new 命令，因为 Symbol 是原始数据类型，不是对象。可以接受一个字符串作为参数，为新创建的 Symbol 提供描述，用来显示在控制台或者作为字符串的时候使用，便于区分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sy = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;KK&quot;</span>);<br><span class="hljs-built_in">console</span>.log(sy);   <span class="hljs-comment">// Symbol(KK)</span><br><span class="hljs-keyword">typeof</span>(sy);        <span class="hljs-comment">// &quot;symbol&quot;</span><br> <br><span class="hljs-comment">// 相同参数 Symbol() 返回的值不相等</span><br><span class="hljs-keyword">let</span> sy1 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;kk&quot;</span>); <br>sy === sy1;       <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="Symbol-类型的注意点？"><a href="#Symbol-类型的注意点？" class="headerlink" title="Symbol 类型的注意点？"></a>Symbol 类型的注意点？</h4><ol><li>Symbol 函数前不能使用 new 命令，否则会报错。</li><li>Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</li><li>Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。</li><li>Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</li><li>Symbol.for 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</li><li>Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。</li></ol><h3 id="promise、generator、async-await"><a href="#promise、generator、async-await" class="headerlink" title="promise、generator、async/await"></a>promise、generator、async/await</h3><h4 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h4><p>优点：解决了回调地狱的问题<br>缺点：无法取消 Promise ，错误需要通过回调函数来捕获</p><h4 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h4><p>生成器内部的代码是以自然的同步 / 顺序方式表达任务的一系列步骤</p><h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><p>优点：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题</p><p>缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。</p><ol><li>async 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。</li></ol><p>await 关键字仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testAwait</span>(<span class="hljs-params"></span>)</span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>       <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;testAwait&quot;</span>);<br>          resolve();<br>       &#125;, <span class="hljs-number">1000</span>);<br>   &#125;);<br>&#125;<br> <br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">helloAsync</span>(<span class="hljs-params"></span>)</span>&#123;<br>   <span class="hljs-keyword">await</span> testAwait();<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;helloAsync&quot;</span>);<br> &#125;<br>helloAsync();<br><span class="hljs-comment">// testAwait</span><br><span class="hljs-comment">// helloAsync</span><br></code></pre></td></tr></table></figure><h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><ol><li>ES6引入rest 参数，用于获取函数的实参，用来代替arguments</li></ol><p>使用…rest形式设置剩余形参，支持无限参数<br>// 剩余参数，转化成数组</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> restParams = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>    console.log(args.toString());<span class="hljs-comment">//1, 2, 3, 4, 5</span><br>&#125;<br><br>restParams(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><ol start="2"><li><p>rest 参数必须要放到参数最后</p></li><li><p>[…]扩展运算符能将[数组] 转换为都好分隔的参数序列</p></li><li><p>数组的合并</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">&lt;script&gt;<br>    const A = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>];<br>    const B = [<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>];<br>    <span class="hljs-regexp">//</span> const C = A.concat(B); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>]<br>    const C = [...A, ...B]; <span class="hljs-regexp">//</span>[<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>] 能展开<br>    console.log(C);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ol start="5"><li>数组的克隆  </li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> A = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>];<br><span class="hljs-keyword">const</span> C = [...A]; <span class="hljs-comment">//[&quot;a&quot;, &quot;b&quot;]</span><br>console.<span class="hljs-built_in">log</span>(C);<br></code></pre></td></tr></table></figure><ol start="6"><li>将伪数组转为真正的数组</li></ol><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">const divs = document.<span class="hljs-keyword">query</span>SelectorAll(<span class="hljs-string">&quot;div&quot;</span>);<br>const <span class="hljs-keyword">div</span>Arr = [...divs];<br>console.log(<span class="hljs-keyword">div</span>Arr); //[<span class="hljs-keyword">div</span>, <span class="hljs-keyword">div</span>, <span class="hljs-keyword">div</span>]<br></code></pre></td></tr></table></figure><h4 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h4><p>之所以叫「语法」糖，不只是因为加糖后的代码功能与加糖前保持一致，更重要的是，<code>糖在不改变其所在位置的语法结构的前提下，实现了运行时等价</code>。可以简单理解为，加糖后的代码编译后跟加糖前一毛一样。</p><p>之所以叫语法「糖」，是因为加糖后的代码写起来很爽，包括但不限于：<code>代码更简洁流畅，代码更语义自然...</code> 写得爽，看着爽，就像吃了糖。效率高，错误少</p><p>PS: 据说还有一种叫做「语法盐」的东西，主要目的是通过反人类的语法，让你更痛苦的写代码。其实它同样能达到避免代码书写错误的效果，但编程效率应该是降低了，毕竟提高了语法学习门槛，让人咸到忧伤…</p><p>我觉着 js 里的对象原型继承有点「咸」，不然 ES6 也不会急着加糖（纯吐槽）</p><p>最基本的，for循环就是一个语法糖：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">for <span class="hljs-params">(var <span class="hljs-attr">i</span> = 0; i &lt; 5; i++)</span>&#123;<br>    <span class="hljs-string">...</span> <br>&#125;<br></code></pre></td></tr></table></figure><p>而这个实际上跟while没啥区别：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">var</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>)&#123;<br>    <span class="hljs-params">...</span><br>    i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单说，语法糖就是为了避免coder出现错误并提高效率的语法层面的一种优雅的解决方案。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844904121380667399#heading-26">promise、generator、async/await</a></p><p><a href="https://www.runoob.com/w3cnote/es6-async.html">ES6 async 函数</a></p><p><a href="https://www.zhihu.com/question/20651624?sort=created">什么是语法糖？</a></p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFC--块级格式化上下文</title>
    <link href="/2021/05/10/BFC/"/>
    <url>/2021/05/10/BFC/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><blockquote><p>BFC是Block Formatting Context，也就是块级格式化上下文，是用于布局块级盒子的一块渲染区域。</p></blockquote><blockquote><p>简单来说就是，BFC是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。那么怎么使用BFC呢，BFC可以看做是一个CSS元素属性</p></blockquote><p>文档流其实分为<code>普通流</code>、<code>定位流</code>和<code>浮动流</code>三种，普通流其实就是指BFC中的FC，也即格式化上下文。</p><p>普通流：元素按照其在 HTML 中的先后位置从上到下、从左到右布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行。</p><p>格式化上下文：页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用</p><h3 id="BFC的几条规则："><a href="#BFC的几条规则：" class="headerlink" title="BFC的几条规则："></a>BFC的几条规则：</h3><ol><li><p>BFC 区域内的元素外边距会发生重叠。</p></li><li><p>BFC 区域内的元素不会与浮动元素重叠。</p></li><li><p>计算 BFC 区域的高度时，浮动元素也参与计算。</p></li><li><p>BFC 区域就相当于一个容器，内部的元素不会影响到外部，同样外部的元素也不会影响到内部。</p></li></ol><h3 id="BFC的应用："><a href="#BFC的应用：" class="headerlink" title="BFC的应用："></a>BFC的应用：</h3><ol><li>清除浮动：父元素设置overflow: hidden触发BFC实现清除浮动，防止父元素高度塌陷，后面的元素被覆盖，实现文字环绕等等。</li></ol><ol start="2"><li>消除相邻元素垂直方向的边距重叠：第二个子元素套一层，并设置overflow: hidden，构建BFC使其不影响外部元素。</li></ol><ol start="3"><li>消除父子元素边距重叠，父元素设置overflow: hidden</li></ol><h3 id="触发BFC的方式："><a href="#触发BFC的方式：" class="headerlink" title="触发BFC的方式："></a>触发BFC的方式：</h3><ol><li>float 不为 none，浮动元素所在的区域就是一个 BFC 区域。</li><li>position 的值不是 static 或 relative 的元素所在的区域就是一个 BFC 区域</li><li>display为 table-cell 的表格单元格元素所在的区域也是一个 BFC 区域</li><li>overflow 不为 visible 的元素所在的区域也是一个 BFC 区域</li></ol><p>这里简单列举几个触发BFC使用的CSS属性</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">overflow: hidden<br>display: <span class="hljs-keyword">inline</span>-block<br>position: absolute<br>position: fixed<br>display: table-cell<br>display: flex<br></code></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2MDM1Mzg1MA==&mid=2247495021&idx=1&sn=186ac3b00483aed484cf45c06135da2b&chksm=ea685738dd1fde2e71d24f6964223437281536ab34f40dc30a9097327c45858cfb65c1c32494&mpshare=1&scene=23&srcid=0508lZZ1YlHc5VKp7BtD81qU&sharer_sharetime=1620473387155&sharer_shareid=06281d72abe265bef7cbe940688c4d2b#rd">前端面经</a></p><p><a href="https://juejin.cn/post/6950082193632788493#heading-0">面试官：请说说什么是BFC？大白话讲清楚</a></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详情页&amp;对全局事件解绑&amp;递归组件实现详情页</title>
    <link href="/2021/05/08/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%B9%9D)/"/>
    <url>/2021/05/08/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%B9%9D)/</url>
    
    <content type="html"><![CDATA[<p><a href="https://gitee.com/Pengzhenglong/Travel">项目地址</a><br><a href="https://www.bilibili.com/video/BV1654y1576K/">视频演示地址</a></p><hr><h3 id="详情页动态路由及banner布局"><a href="#详情页动态路由及banner布局" class="headerlink" title="详情页动态路由及banner布局"></a>详情页动态路由及banner布局</h3><p>实现点击以下能够进入详情页</p><p><img src="/image1/34.png" alt="点击进入详情页"></p><p>src\pages\home\components\Recommend.vue中router-link</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">&lt;router-link</span><br><span class="xml">  tag=&quot;li&quot;</span><br><span class="xml">  class=&quot;item border-bottom&quot;</span><br><span class="xml">  v-for=&quot;item of list&quot;</span><br><span class="xml">  :key=&quot;item.id&quot;</span><br><span class="xml">  :to=&quot;/detail/ + item.id&quot;</span><br><span class="xml">&gt;</span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-img&quot;</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;item.imgUrl&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span></span><br><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-info&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-title&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.title</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-desc&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.desc</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-button&quot;</span>&gt;</span>查看详情<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>src\router\index.js路由配置</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span>  Detail  <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/pages/detail/Detail&#x27;</span><br>Vue.use(Router)<br><br>export <span class="hljs-keyword">default</span> <span class="hljs-built_in">new</span> Router(&#123;<br>  routes: [<br>    &#123;<br>      <span class="hljs-type">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>      <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;Home&#x27;</span>,<br>      component: Home<br>    &#125;,&#123;<br>      <span class="hljs-type">path</span>:<span class="hljs-string">&#x27;/city&#x27;</span>,<br>      <span class="hljs-type">name</span>:<span class="hljs-string">&#x27;City&#x27;</span>,<br>      component:City<br>    &#125;,&#123;<br>      <span class="hljs-type">path</span>:<span class="hljs-string">&#x27;/detail/:id&#x27;</span>,<br>      <span class="hljs-type">name</span>:<span class="hljs-string">&#x27;Detail&#x27;</span>,<br>      component:Detail<br>    &#125;<br>  ]<br>&#125;) <br><br></code></pre></td></tr></table></figure><p>src\pages\detail\Detail.vue</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">detail-banner</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">detail-banner</span>&gt;</span></span><br><span class="xml">    </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">detail-header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">detail-header</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">import DetailBanner from &quot;./components/Banner&quot;;</span><br><span class="xml">import DetailHeader from &quot;./components/Header&quot;;</span><br><span class="xml">export default </span><span class="xquery">&#123;</span><br><span class="xquery"> <span class="hljs-built_in"> name</span>: <span class="hljs-string">&quot;Detail&quot;</span>,</span><br><span class="xquery">  components: &#123;</span><br><span class="xquery">    DetailBanner,</span><br><span class="xquery">    DetailHeader</span><br><span class="xquery">  &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/image1/35.png" alt="实现效果"></p><h4 id="详情页对全局事件解绑"><a href="#详情页对全局事件解绑" class="headerlink" title="详情页对全局事件解绑"></a>详情页对全局事件解绑</h4><p>全局事件<br>详情页绑定了一个全局事件，当我在详情页面中滚动，这个样写没有问题，但是当我去到其他页面，在滚动时，你就会发现，刚刚你绑定在详情页中的滚动事件，在这个页面也被执行了，这肯定是有问题的。</p><p>其实在我们使用了keep-alive标签后，会有两个生命周期函数分别是：activated、deactivated</p><p>activated：页面展示的时候被执行        </p><p>deactivated：页面被隐藏或者页面即将被替换成新的页面时被执行           </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">activated <span class="hljs-literal">()</span> &#123;<br>    window.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">scroll</span>&#x27;, <span class="hljs-params">this</span>.<span class="hljs-params">handleScroll</span>)</span><br>&#125;,<br>deactivated <span class="hljs-literal">()</span> &#123;<br>    window.remove<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">scroll</span>&#x27;, <span class="hljs-params">this</span>.<span class="hljs-params">handleScroll</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是页面被展示的执行scroll，页面被隐藏的时候移除scroll事件</p><p>src\pages\detail\components\Header.vue部分代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;div&quot;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header-abs&quot;</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;showAbs&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont header-abs-back&quot;</span>&gt;</span><span class="hljs-symbol">&amp;#xe624;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header-fixed&quot;</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;!showAbs&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;opacityStyle&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont header-fixed-back&quot;</span>&gt;</span><span class="hljs-symbol">&amp;#xe624;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>      景点详情<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;DetailHeader&quot;</span>,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      showAbs: <span class="hljs-literal">true</span>,</span><br>      opacityStyle: 0<br>    &#125;;<br>  &#125;,<br>  methods: &#123;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">handleScroll</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-keyword">const</span> top = <span class="hljs-built_in">document</span>.documentElement.scrollTop;</span><br>      if (top &gt; 60) &#123;<br><span class="javascript">        <span class="hljs-keyword">let</span> opacity = top / <span class="hljs-number">140</span>;</span><br>        opacity = opacity &gt; 1 ? 1 : opacity;<br><span class="javascript">        <span class="hljs-built_in">this</span>.opacityStyle = &#123; opacity &#125;;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.showAbs = <span class="hljs-literal">false</span>;</span><br><span class="javascript">      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.showAbs = <span class="hljs-literal">true</span>;</span><br>      &#125;<br>    &#125;<br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">activated</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-comment">//绑定了一个scroll事件，一旦它被执行，this.handleScroll方法会被执行</span></span><br><span class="javascript">    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;scroll&quot;</span>, <span class="hljs-built_in">this</span>.handleScroll);</span><br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">deactivated</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&quot;scroll&quot;</span>, <span class="hljs-built_in">this</span>.handleScroll);</span><br>  &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="递归组件实现详情页"><a href="#递归组件实现详情页" class="headerlink" title="递归组件实现详情页"></a>递归组件实现详情页</h3><p>递归组件的意思就是在组件自身调用组件自身。</p><p>数据 detail.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;ret&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;data&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;sightName&quot;</span>: <span class="hljs-string">&quot;大连圣亚海洋世界(AAAA景区)&quot;</span>,<br>    <span class="hljs-attr">&quot;bannerImg&quot;</span>: <span class="hljs-string">&quot;http://img1.qunarzz.com/sight/p0/201404/23/04b92c99462687fa1ba45c1b5ba4ad77.jpg_600x330_bf9c4904.jpg&quot;</span>,<br>    <span class="hljs-attr">&quot;gallaryImgs&quot;</span>: [<span class="hljs-string">&quot;http://img1.qunarzz.com/sight/p0/201404/23/04b92c99462687fa1ba45c1b5ba4ad77.jpg_800x800_70debc93.jpg&quot;</span>, <span class="hljs-string">&quot;http://img1.qunarzz.com/sight/p0/1709/76/7691528bc7d7ad3ca3.img.png_800x800_9ef05ee7.png&quot;</span>],<br>    <span class="hljs-attr">&quot;categoryList&quot;</span>: [&#123;<br>        <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;成人票&quot;</span>,<br>        <span class="hljs-attr">&quot;children&quot;</span>: [&#123;<br>          <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;成人三馆联票&quot;</span>,<br>          <span class="hljs-attr">&quot;children&quot;</span>: [&#123;<br>            <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;成人三馆联票 - 某一连锁店销售&quot;</span><br>          &#125;]<br>        &#125;,&#123;<br>          <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;成人五馆联票&quot;</span><br>        &#125;]<br>      &#125;, &#123;<br>        <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;学生票&quot;</span><br>      &#125;, &#123;<br>        <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;儿童票&quot;</span><br>      &#125;, &#123;<br>        <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;特惠票&quot;</span><br>      &#125;]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>src\pages\detail\components\List.vue</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) of list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-title  border-bottom&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-title-icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">        </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.title</span> &#125;&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;item.children&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-children&quot;</span>&gt;</span></span><br><span class="xml">        //使用递归组件</span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">detail-list</span> <span class="hljs-attr">:list</span>=<span class="hljs-string">&quot;item.children&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">detail-list</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">import Detail from &quot;../Detail.vue&quot;;</span><br><span class="xml">export default &#123;</span><br><span class="xml">  components: &#123; Detail &#125;,</span><br><span class="xml">  name: &quot;DetailList&quot;,</span><br><span class="xml">  props: &#123;</span><br><span class="xml">    list: Array</span><br><span class="xml">  &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;stylus&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="xml">.item-title-icon</span><br><span class="xml">    position: relative</span><br><span class="xml">    left: .06rem</span><br><span class="xml">    top: .06rem</span><br><span class="xml">    display: inline-block</span><br><span class="xml">    width: .36rem</span><br><span class="xml">    height: .36rem</span><br><span class="xml">    background: url(http://s.qunarzz.com/piao/image/touch/sight/detail.png) 0 -.45rem no-repeat</span><br><span class="xml">    margin-right: .1rem</span><br><span class="xml">    background-size: .4rem 3rem</span><br><span class="xml">.item-title</span><br><span class="xml">    line-height :.8rem</span><br><span class="xml">    font-size: 0.32rem</span><br><span class="xml">    padding : 0 .2rem</span><br><span class="xml">.item-children</span><br><span class="xml">    padding:0 .2rem</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><p>上面代码中，在 list-children 这个元素下，先做了一个判断，当 item.children 下有值的时候，调用一下自身，也就是 detail-list 这个组件，这个组件也是通过属性的形式，传一个 list，因为在 list.vue 中已经通过 props 接收到 list 了，而且外层已经循环过 list 了，现在要获取 list 下的 children 中的数据，所以直接让这个 list 属性等于 item.children 就可以了。因为数据存在层级关系，可以通过添加样式呈现出来，效果如下图：</p><p><img src="/image1/36.png" alt="效果"></p><h4 id="keep-alive不缓存"><a href="#keep-alive不缓存" class="headerlink" title="keep-alive不缓存"></a>keep-alive不缓存</h4><p>在Detail.vue页面中，当我点击了其他景点后，它也是不会发送请求的，那么Detail页面就不会重新渲染了。</p><p>可以使用keep-alive的exclude属性，给它默认设置为Detail，用途是每次进入Detail页面都会发送请求</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">keep</span>-alive exclude=<span class="hljs-string">&quot;Detail&quot;</span>&gt;   <span class="hljs-comment">//使用 exclude 属性，可以设置不需要缓存的页面</span><br>   &lt;router-<span class="hljs-keyword">view</span>/&gt;<br>&lt;/<span class="hljs-keyword">keep</span>-alive&gt;<br></code></pre></td></tr></table></figure><h4 id="页面路由切换回到最顶部"><a href="#页面路由切换回到最顶部" class="headerlink" title="页面路由切换回到最顶部"></a>页面路由切换回到最顶部</h4><p><img src="/image1/37.png" alt="代码添加"></p><p>让页面切换后始终回到页面最顶部</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">scrollBehavior (<span class="hljs-keyword">to</span>, <span class="hljs-keyword">from</span>, savedPosition) &#123;<br><span class="hljs-built_in">      return</span> &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span> &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="在项目中加入基础动画"><a href="#在项目中加入基础动画" class="headerlink" title="在项目中加入基础动画"></a>在项目中加入基础动画</h3><p>让图片点击时有若影若现的效果</p><p>新建一个组件，通过插槽的方式传递<br>src\common\fade\FadeAnimation.vue</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;FadeAnimation&quot;</span></span><br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;stylus&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><br>.v-enter, .v-leave-to<br><span class="css">    <span class="hljs-attribute">opacity</span> :<span class="hljs-number">0</span></span><br>.v-enter-activate, .v-leave-activate<br><span class="css">  <span class="hljs-attribute">transition</span> :opacity  .<span class="hljs-number">5s</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>src\pages\detail\components\Banner.vue中使用,部分代码</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xquery">    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">fade-animation</span>&gt;</span></span><br><span class="xml">      &lt;common-gallary</span><br><span class="xml">        :imgs=&quot;bannerImgs&quot;</span><br><span class="xml">        v-show=&quot;showGallary&quot;</span><br><span class="xml">        @close=&quot;handleGallaryClose&quot;</span><br><span class="xml">      &gt;&lt;/common-gallary</span><br><span class="xml">    &gt;<span class="hljs-tag">&lt;/<span class="hljs-name">fade-animation</span>&gt;</span></span><br><br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">import CommonGallary from &quot;common/gallary/Gallary&quot;;</span><br><span class="xml">import FadeAnimation from &quot;common/fade/FadeAnimation&quot;;</span><br><span class="xml">export default </span><span class="xquery">&#123;</span><br><span class="xquery"> <span class="hljs-built_in"> name</span>: <span class="hljs-string">&quot;DetailBanner&quot;</span>,</span><br><span class="xquery">  components: &#123;</span><br><span class="xquery">    CommonGallary,</span><br><span class="xquery">    FadeAnimation</span><br><span class="xquery">  &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>至此，项目基本完结…</p>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三次握手和四次挥手</title>
    <link href="/2021/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <url>/2021/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="TCP-协议三次握手"><a href="#TCP-协议三次握手" class="headerlink" title="TCP 协议三次握手"></a>TCP 协议三次握手</h3><p>客户端-发送带有SYN标致的数据包-一次握手–服务端</p><p>服务端-发送带有SYN/ACK标致的数据包-二次握手-客户端</p><p>客户端-发送带有ACK的数据包-三次握手-服务端</p><h4 id="目的：-建立可靠的通信通道-，数据的发送和接收（双方正常）"><a href="#目的：-建立可靠的通信通道-，数据的发送和接收（双方正常）" class="headerlink" title="目的：    建立可靠的通信通道 ，数据的发送和接收（双方正常）"></a>目的：    建立可靠的通信通道 ，数据的发送和接收（双方正常）</h4><blockquote><p>翻译成大白话就是： 客户端：你能接收到我的消息吗？ 服务端：可以的，那你能接收到我的回复吗？ 客户端：可以，那我们开始聊正事吧。</p></blockquote><h4 id="为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人-为什么不是4次？：3次够了第四次浪费"><a href="#为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人-为什么不是4次？：3次够了第四次浪费" class="headerlink" title="为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人 为什么不是4次？：3次够了第四次浪费"></a>为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人 为什么不是4次？：3次够了第四次浪费</h4><p><img src="/image/25.png" alt="三次握手"></p><h3 id="TCP-协议四次挥手"><a href="#TCP-协议四次挥手" class="headerlink" title="TCP 协议四次挥手"></a>TCP 协议四次挥手</h3><p>客户端-发送一个FIN,用来关闭客户端到服务器的数据传输<br>服务器-收到这个FIN,它发回一个ACK，确认序号为收到的序号加1.和SYN一样，一个FIN将占用一个序号<br>服务器-关闭与客户端的连接，发送一个FIN给客户端<br>客户端-发回ACK报文确认，并将确认序号设置为收到序号加1             </p><p><img src="/image/26.png" alt="四次挥手"></p><ol><li>为什么不是两次？              </li></ol><p>两次情况客户端说完结束就立马断开不再接收，无法确认服务端是否接收到断开消息，但且服务端可能还有消息未发送完。<br>2. 为什么不是三次？    </p><p>3次情况服务端接收到断开消息，向客户端发送确认接受消息，客户端未给最后确认断开的回复。</p><ol start="3"><li>为什么要四次挥手</li></ol><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p><h4 id="TCP作为一种可靠的传输控制协议，其核心思想就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求。"><a href="#TCP作为一种可靠的传输控制协议，其核心思想就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求。" class="headerlink" title="TCP作为一种可靠的传输控制协议，其核心思想就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求。"></a>TCP作为一种可靠的传输控制协议，其核心思想就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求。</h4>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>TCP 协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue&amp;Vuex</title>
    <link href="/2021/05/07/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%B8%83)/"/>
    <url>/2021/05/07/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%B8%83)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="Vuex介绍"><a href="#Vuex介绍" class="headerlink" title="Vuex介绍"></a>Vuex介绍</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化. Vuex 解决了<strong>多个视图依赖于同一状态</strong>和<strong>来自不同视图的行为需要变更同一状态</strong>的问题，将开发者的精力聚焦于数据的更新而不是数据在组件之间的传递上</p><ol><li>多个视图依赖于同一状态。</li><li>来自不同视图的行为需要变更同一状态。</li></ol><p>对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。</p><p>因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！</p><p><img src="/image1/33.png" alt="Vuex"></p><h3 id="怎么使用vuex"><a href="#怎么使用vuex" class="headerlink" title="怎么使用vuex"></a>怎么使用vuex</h3><p>第一步安装</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install vuex <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>第二步创建store</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;<br>Vue.use(Vuex);<br><span class="hljs-comment">//不是在生产环境debug为true</span><br><span class="hljs-keyword">const</span> debug = process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span>;<br><span class="hljs-comment">//创建Vuex实例对象</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>    strict:debug,<span class="hljs-comment">//在不是生产环境下都开启严格模式</span><br>    state:&#123;<br>    &#125;,<br>    getters:&#123;<br>    &#125;,<br>    mutations:&#123;<br>    &#125;,<br>    actions:&#123;<br>    &#125;<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure><p>第三步注入vuex</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span>;<br><span class="hljs-built_in">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  router,<br>  store,<br>  components: &#123; App &#125;,<br>  <span class="hljs-keyword">template</span>: <span class="hljs-string">&#x27;&lt;App/&gt;&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="Vuex各个模块"><a href="#Vuex各个模块" class="headerlink" title="Vuex各个模块"></a>Vuex各个模块</h3><ol><li>state：用于数据的存储，是store中的唯一数据源</li><li>getters：如vue中的计算属性一样，基于state数据的二次包装，常用于数据的筛选和多个数据的相关性计算</li><li>mutations：类似函数，改变state数据的唯一途径，且不能用于处理异步事件</li><li>actions：类似于mutation，用于提交mutation来改变状态，而不直接变更状态，可以包含任意异步操作</li><li>modules：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护</li></ol><h3 id="Vuex实例应用"><a href="#Vuex实例应用" class="headerlink" title="Vuex实例应用"></a>Vuex实例应用</h3><p>// 父组件</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ChildA</span>/&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ChildB</span>/&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  import ChildA from &#x27;./components/ChildA&#x27; // 导入A组件</span><br><span class="xml">  import ChildB from &#x27;./components/ChildB&#x27; // 导入B组件</span><br><br><span class="xml">  export default </span><span class="xquery">&#123;</span><br><span class="xquery">   <span class="hljs-built_in"> name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,</span><br><span class="xquery">    components: &#123;ChildA, ChildB&#125;</span><span class="xml"> // 注册A、B组件</span><br><span class="xml">  &#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>// 子组件childA</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;childA&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是A组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;transform&quot;</span>&gt;</span>点我让B组件接收到数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>因为你点了B，所以我的信息发生了变化：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">BMessage</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  export default &#123;</span><br><span class="xml">    data() &#123;</span><br><span class="xml">      return &#123;</span><br><span class="xml">        AMessage: &#x27;Hello，B组件，我是A组件&#x27;</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    computed: &#123;</span><br><span class="xml">      BMessage() &#123;</span><br><span class="xml">        // 这里存储从store里获取的B组件的数据</span><br><span class="xml">        return this.$store.state.BMsg</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    methods: &#123;</span><br><span class="xml">      transform() &#123;</span><br><span class="xml">        // 触发receiveAMsg，将A组件的数据存放到store里去</span><br><span class="xml">        this.$store.commit(&#x27;receiveAMsg&#x27;, &#123;</span><br><span class="xml">          AMsg: this.AMessage</span><br><span class="xml">        &#125;)</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>// 子组件 childB</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;childB&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是B组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;transform&quot;</span>&gt;</span>点我让A组件接收到数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>因为你点了A，所以我的信息发生了变化：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">AMessage</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  export default &#123;</span><br><span class="xml">    data() &#123;</span><br><span class="xml">      return &#123;</span><br><span class="xml">        BMessage: &#x27;Hello，A组件，我是B组件&#x27;</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    computed: &#123;</span><br><span class="xml">      AMessage() &#123;</span><br><span class="xml">        // 这里存储从store里获取的A组件的数据</span><br><span class="xml">        return this.$store.state.AMsg</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    methods: &#123;</span><br><span class="xml">      transform() &#123;</span><br><span class="xml">        // 触发receiveBMsg，将B组件的数据存放到store里去</span><br><span class="xml">        this.$store.commit(&#x27;receiveBMsg&#x27;, &#123;</span><br><span class="xml">          BMsg: this.BMessage</span><br><span class="xml">        &#125;)</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>vuex的store,js</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs pf">import Vue <span class="hljs-keyword">from</span> &#x27;vue&#x27;<br>import Vuex <span class="hljs-keyword">from</span> &#x27;vuex&#x27;<br>Vue.use(Vuex)<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">state</span> = &#123;<br>  // 初始化A和B组件的数据，等待获取<br>  AMsg: &#x27;&#x27;,<br>  BMsg: &#x27;&#x27;<br>&#125;<br><br><span class="hljs-keyword">const</span> mutations = &#123;<br>  receiveAMsg(<span class="hljs-keyword">state</span>, payload) &#123;<br>    // 将A组件的数据存放于<span class="hljs-keyword">state</span><br>    <span class="hljs-keyword">state</span>.AMsg = payload.AMsg<br>  &#125;,<br>  receiveBMsg(<span class="hljs-keyword">state</span>, payload) &#123;<br>    // 将B组件的数据存放于<span class="hljs-keyword">state</span><br>    <span class="hljs-keyword">state</span>.BMsg = payload.BMsg<br>  &#125;<br>&#125;<br><br>export <span class="hljs-keyword">default</span> new Vuex.Store(&#123;<br>  <span class="hljs-keyword">state</span>,<br>  mutations<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://vuex.vuejs.org/zh/">Vue官方文档</a></p><p><a href="https://juejin.cn/post/6844903887162310669#heading-16">vue中8种组件通信方式, 值得收藏!</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Vuex的实现数据共享&amp;localStorage&amp;keep-alive</title>
    <link href="/2021/05/07/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E5%85%AB)/"/>
    <url>/2021/05/07/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E5%85%AB)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="使用Vuex的实现数据共享"><a href="#使用Vuex的实现数据共享" class="headerlink" title="使用Vuex的实现数据共享"></a>使用Vuex的实现数据共享</h3><p>需求：我们点击城市页时首页的城市也能改变</p><p>City.vue和Home.vue是没有一个共用的父级组价的，这样两个页面是没有一个共用的父级组件进行中转。方法一：使用Bus总线(比较麻烦)</p><p>方法二：Vuex(数据框架)<br>main.js引入store</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span>  store  <span class="hljs-keyword">from</span>  <span class="hljs-string">&#x27;./store&#x27;</span><br><span class="hljs-built_in">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  router,<br>  store,<br>  components: &#123; App &#125;,<br>  <span class="hljs-keyword">template</span>: <span class="hljs-string">&#x27;&lt;App/&gt;&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>src\store\index.js 代码：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pf">import Vue <span class="hljs-keyword">from</span> &#x27;vue&#x27;<br>import Vuex <span class="hljs-keyword">from</span> &#x27;vuex&#x27;<br>import  <span class="hljs-keyword">state</span>  <span class="hljs-keyword">from</span>  &#x27;./<span class="hljs-keyword">state</span>&#x27;<br>import  mutations <span class="hljs-keyword">from</span>  &#x27;./mutation&#x27;<br>Vue.use(Vuex)<br>export <span class="hljs-keyword">default</span>  new  Vuex.Store(&#123;<br>    <span class="hljs-keyword">state</span>,<br>    mutations<br>&#125;)<br></code></pre></td></tr></table></figure><p>src\store\mutation.js</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pf">export <span class="hljs-keyword">default</span>&#123;<br>        changeCity(<span class="hljs-keyword">state</span>,city)&#123;<br>            <span class="hljs-keyword">state</span>.city=city<br>            try&#123;<br>                localStorage.city=city<br>            &#125;catch(e)&#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>src\store\state.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span>  defaultCity  =<span class="hljs-string">&#x27;北京&#x27;</span><br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">localStorage</span>.city)&#123;<br>        defaultStatus=<span class="hljs-built_in">localStorage</span>.city<br>    &#125;<br>&#125;<span class="hljs-keyword">catch</span>(e)&#123;&#125;<br><span class="hljs-keyword">export</span>  <span class="hljs-keyword">default</span>&#123;<br>        city: defaultCity<br><br>&#125;<br></code></pre></td></tr></table></figure><p>src\pages\city\components\List.vue使用部分代码其他页面修改同理</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs gradle">    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;&#123;&#123; <span class="hljs-keyword">this</span>.currentCity &#125;&#125;&lt;/<span class="hljs-keyword">div</span>&gt;<br>      &lt;<span class="hljs-keyword">div</span><br>            <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;item  border-bottom&quot;</span><br>            v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;innerItem of item&quot;</span><br>            :key=<span class="hljs-string">&quot;innerItem.id&quot;</span><br>            @click=<span class="hljs-string">&quot;handleCityClick(innerItem.name)&quot;</span><br>          &gt;<br>            &#123;&#123; innerItem.name &#125;&#125;<br>          &lt;/<span class="hljs-keyword">div</span>&gt;<br><br><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;&#123;&#123; <span class="hljs-keyword">this</span>.$store.state.city &#125;&#125;&lt;/<span class="hljs-keyword">div</span>&gt;<br>  methods: &#123;<br>    handleCityClick(city) &#123;<br>      <span class="hljs-keyword">this</span>.$store.commit(<span class="hljs-string">&quot;changeCity&quot;</span>, city); <br>      <span class="hljs-comment">//页面跳转--编程式导航push</span><br>      <span class="hljs-keyword">this</span>.$router.<span class="hljs-keyword">push</span>(<span class="hljs-string">&quot;/&quot;</span>);<br>    &#125;<br>  &#125;,<br></code></pre></td></tr></table></figure><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>刚开始在实现首页右上角城市定位显示的时候，src 目录下新建了一个 store 目录，存储了 Vuex 中的默认数据，city 直接设置成了“北京”，但是其实这样去写，是有问题的，点击城市，会改变这个 city，但是当页面刷新了，就又变回了北京。      </p><p>考虑到在真实的项目中，如果你这次选中了一个城市，下次再打开这个网页的时候，上次选的城市还应该在的，怎么解决这个问题呢？         </p><p>这时可以借助 HTML5 中提供了一个新的 api，叫做 localStorage，它可以实现本地存储，在这里也就是实现保存城市的功能。         </p><p>store/index.js中，这样去写代码，当用户尝试去改变城市的时候，我不但把 state 中的 city 改了，同时还去存一个 localStorage，直接写 localStorage.city = city 就可以了。然后让 stare 中 city 的默认值是 localStorage.city || “北京”，就可以了。也就是 city 的值我默认先去 localStorage 中取，如果取不到，才用默认的 “北京”。</p><p>store/index.js中，这样去写代码，当用户尝试去改变城市的时候，我不但把 state 中的 city 改了，同时还去存一个 localStorage，直接写 localStorage.city = city 就可以了。然后让 stare 中 city 的默认值是 localStorage.city || “北京”，就可以了。也就是 city 的值我默认先去 localStorage 中取，如果取不到，才用默认的 “北京”。</p><p>store/index.js</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pf">import Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br>import Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span>;<br>Vue.use(Vuex);<br>export <span class="hljs-keyword">default</span> new Vuex.Store(&#123;<br>    <span class="hljs-keyword">state</span>: &#123;<br>        city: localStorage.city || <span class="hljs-string">&quot;北京&quot;</span><br>    &#125;,<br>    mutations: &#123;<br>        changeCity(<span class="hljs-keyword">state</span>, city) &#123;<br>            <span class="hljs-keyword">state</span>.city = city;<br>            localStorage.city = city;<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>这个时候打开页面，当用户选择一个城市，然后刷新页面，可以看到上次选择的城市还在。但是当使用 localStorage 的时候，建议在外层包裹一个 try{ }catch(e){ }，因为在某些浏览器，如果用户关闭了本地存储这样的功能，或者使用隐身模式，使用 localStorage 可能导致浏览器直接抛出异常，代码就运行不了了，为了避免这种问题，建议在外层加一个 try{ }catch(e){ }，怎么加呢？</p><p>先定义一个默认的 defaultCity 等于“北京”，然后写一个 try{ }catch(e){ }，这样写：如果有 localStorage.city，default.city 就等于 localStorage.city，下边 state 中的 city 就可以等于 defaultCity 了，同样在 mutations 的 changeCity 中也要写一个 try{ }catch(e)：</p><p>store/index.js</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs pf">import Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br>import Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span>;<br>Vue.use(Vuex);<br><br>let <span class="hljs-keyword">default</span>City = <span class="hljs-string">&quot;北京&quot;</span><br>try &#123;<br>    if (localStorage.city) &#123;<br>        <span class="hljs-keyword">default</span>City = localStorage.city;<br>    &#125;<br>&#125; catch (e) &#123; &#125;<br><br>export <span class="hljs-keyword">default</span> new Vuex.Store(&#123;<br>    <span class="hljs-keyword">state</span>: &#123;<br>        city: <span class="hljs-keyword">default</span>City<br>    &#125;,<br>    mutations: &#123;<br>        changeCity(<span class="hljs-keyword">state</span>, city) &#123;<br>            <span class="hljs-keyword">state</span>.city = city;<br>            try &#123;<br>                localStorage.city = city;<br>            &#125; catch (e) &#123; &#125;<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>现在我们看到 store/index.js 这个文件慢慢的变得复杂起来了，实际上，在真正的项目开发和之中，会做进一步的拆分，也就是把这个文件拆分为 State、Actions、Mutations，在 store 中创建一个文件叫 state.js（只存储公用数据），然后把设置默认数据的这块代码放进去，并通过 export 导出，内容就是在 index.js 中定义的 state 对象里的内容：代<br>码见上面方法二中：</p><p>这样，我们就将 vuex 的代码拆分成了 State、Actions、Mutations 这几个部分，未来它的维护性也会得到比较大的提高。</p><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>使用 keep-alive 优化网页性能</p><p>当写完城市列表响应代码，启动服务，打开页面，这样看不存在什么问题，基本的一些业务逻辑都已经实现了，但是在控制台中打开 Network 网络这个选项，选择 XHR，当初次进入首页的时候，请求了一个 index.json 的文件，然后切换到列表页，又请求了一个 city.json，然后再回到首页，index.json 又请求了一次，再次去列表页，city.json 又请求了一次，也就是，每一次路由发生变化的时候，Ajax 都会重新的被发送。</p><p><img src="/image1/29.png" alt="ajax"></p><p>思考是什么原因导致这样的问题呢，打开 Home.vue 首页这个组件，每一次打开这个首页的时候，都会被重新的渲染，所以 mounted 这个钩子就会被重新的执行，那么这个 Ajax 数据就会被重新获取，那么这么能让它只获取一次呢？</p><p>打开 main.js，可以看到入口组件是 App 这个组件，再打开 App.vue，router-view 显示的是当前地址所对应的内容，我们可以在外层包裹一个 keep-alive 的一个标签，他是 Vue 自带的一个标签，他的意思就是我的路由的内容被加载一次后，我就把路由中的内容放到内存之中，下一次再进入这个路由的时候，不需要重新渲染这个组件，去重新执行钩子函数，只要去内存里把以前的内容拿出来就可以。</p><p><img src="/image1/30.png" alt="keep-alive"></p><p>这个时候，回到页面上，再打开 Network，进入到列表页，选择城市再返回首页，就不会再去加载 index.json 了，同样再进入列表页，也不会再去加载 city.json 了，他直接会从内存中调数据，而不会重新去法 Ajax 请求了。</p><p><img src="/image1/31.png" alt="keep-alive"></p><p>这样还是存在逻辑上的问题的，当我在“北京”的时候，首页显示的是“北京”的内容，当切换为“上海”时，首页就应该显示“上海”的内容，所以城市发生改变的时候，首页还需要重新发一次 Ajax 请求，来获取不同城市的数据信息，我们对这一块做一个调整。</p><p>打开 Home.vue 组件，改一下 axios 请求地址这里，在他的后面带一个参数，让他等于 Vuex 中存的当前的城市，所以还需要在 Home.vue 组件中引用 Vuex，import { mapState } from “vuex”，然后再加一个计算属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">computed:&#123;<br>    ...<span class="hljs-built_in">mapState</span>([<span class="hljs-string">&#x27;city&#x27;</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>获取到城市对应的内容，然后就可以在发 Ajax 的时候，把 city 放在请求的参数里面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">axios.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;/api/index.json?city=&quot;</span> + <span class="hljs-keyword">this</span>.city)<br>.then(<span class="hljs-keyword">this</span>.getHomeInfoSucc);<br></code></pre></td></tr></table></figure><p>这个时候，我们打开页面，可以看到请求参数里已经携带了当前的城市：</p><p>但是，例如当你切换了城市“桂林”，回到首页，并没有重新发 Ajax 请求，虽然上面的城市变成了“桂林”，但是底下的内容还是“北京”的内容，我们希望底下的内容跟着变，该怎么做呢？</p><p>当我们在 App.vue 中用了 keep-alive 的时候，这块的内容已经被缓存起来了，他直接取得是缓存里的数据，那如何去改变缓存里的数据呢？当你使用 keep-alive 的时候，组件中会多出一个生命周期函数 activted，</p><p><img src="/image1/32.png" alt="active"></p><p>可以在 mounted 和 activated 两个生命周期函数下打印一些内容，到浏览器上看一下他俩的执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;mounted&quot;</span>);<br>    <span class="hljs-built_in">this</span>.getHomeInfo();<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">activated</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;activted&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>打开页面，可以看到，mounted 和 activated 都会执行，当切换了城市，再回到首页的时候，组件的 mounted 就不会执行了，就只有 activated 会被执行，那么我们借助 activated 这个生命周期函数就可以实现我们想要的功能了。</p><p>首先在页面被挂载的时候，也就是 mounted 中一定会去发一个 Ajax 请求，当页面重新被显示的时候，activated 一定会被重新的执行，那么我们就可以在页面每次重新显示的时候，可以判断当前页面上的城市和上次页面上显示的城市是否是相同的，如果不相同的，就再发一次 Ajax 请求。</p><p>先在 data 中设置一个数据 lastCity，默认值是空，接着当页面被挂载的时候，让它等于 this.city，对上一次的城市做一个保存：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">mounted() &#123;<br>    <span class="hljs-keyword">this</span>.lastCity = <span class="hljs-keyword">this</span>.city<br>    <span class="hljs-keyword">this</span>.getHomeInfo();<br>&#125;<br></code></pre></td></tr></table></figure><p>当页面被重新激活的时候，我们在 activted 中这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">activated() &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.lastCity != <span class="hljs-keyword">this</span>.city)&#123;<br>        <span class="hljs-keyword">this</span>.lastCity = <span class="hljs-keyword">this</span>.city<br>        <span class="hljs-keyword">this</span>.getHomeInfo();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果上一次的城市 lastCity 不等于当前城市的时候，就重新发一个 Ajax 请求，直接调用上面 getHomeInfo 方法就可以了。当上次的 city 和这次的 city 不一样时，还需要让他等于这次的 city。回到页面上，可以看到当切换的城市和上次的城市一样时，Ajax 就不会请求 city.json 了，当不一样时，才会去请求 city.json。</p><p>回到代码里面，通过 activted 这样一个 keep-alive 新增的生命周期函数，结合 lastCity 这样一个临时缓存变量，就实现了首页代码性能优化的调整。</p>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue去哪儿项目&amp;搜索功能实现</title>
    <link href="/2021/05/06/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%B8%83)/"/>
    <url>/2021/05/06/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%B8%83)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="搜索功能实现"><a href="#搜索功能实现" class="headerlink" title="搜索功能实现"></a>搜索功能实现</h3><p><img src="/image1/28.png" alt="效果图"></p><p>src\pages\city\components\Search.vue部分代码</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs maxima">&lt;div class=<span class="hljs-string">&quot;search-content&quot;</span> ref=<span class="hljs-string">&quot;search&quot;</span> v-<span class="hljs-built_in">show</span>=<span class="hljs-string">&quot;keyword&quot;</span>&gt;<br>&lt;ul&gt;<br>    &lt;<span class="hljs-built_in">li</span><br>    class=<span class="hljs-string">&quot;search-item  border-bottom&quot;</span><br>    v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;item of list&quot;</span><br>    :<span class="hljs-built_in">key</span>=<span class="hljs-string">&quot;item.id&quot;</span><br>    &gt;<br>    &#123;&#123; item.name &#125;&#125;<br>    &lt;/<span class="hljs-built_in">li</span>&gt;<br>    &lt;<span class="hljs-built_in">li</span> class=<span class="hljs-string">&quot;search-item  border-bottom&quot;</span> v-<span class="hljs-built_in">show</span>=<span class="hljs-string">&quot;hasNoData&quot;</span>&gt;<br>    没有找到匹配数据<br>    &lt;/<span class="hljs-built_in">li</span>&gt;<br>&lt;/ul&gt;<br>&lt;/div&gt;<br><br> .search-<span class="hljs-built_in">content</span><br>          z-index:<span class="hljs-number">1</span><br>          overflow :hidden<br>          <span class="hljs-built_in">position</span>:absolute<br>          top: <span class="hljs-number">1.</span>58<span class="hljs-built_in">rem</span><br>          right:<span class="hljs-number">0</span><br>          left:<span class="hljs-number">0</span><br>          bottom:<span class="hljs-number">0</span><br>          <span class="hljs-built_in">background</span>:#eee<br>          .search-item<br>            line-<span class="hljs-built_in">height</span> :.62<span class="hljs-built_in">rem</span><br>            padding-left :.2<span class="hljs-built_in">rem</span><br>            <span class="hljs-built_in">color</span>:#<span class="hljs-number">666</span><br>            <span class="hljs-built_in">background</span>:#fff<br></code></pre></td></tr></table></figure><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;search&quot;</span>&gt;</span></span><br><span class="xml">      &lt;input</span><br><span class="xml">        v-model=&quot;keyword&quot;</span><br><span class="xml">        class=&quot;search-input&quot;</span><br><span class="xml">        type=&quot;text&quot;</span><br><span class="xml">        placeholder=&quot;输入城市名或拼音&quot;</span><br><span class="xml">      /&gt;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;search-content&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;search&quot;</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;keyword&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">          &lt;li</span><br><span class="xml">            class=&quot;search-item  border-bottom&quot;</span><br><span class="xml">            v-for=&quot;item of list&quot;</span><br><span class="xml">            :key=&quot;item.id&quot;</span><br><span class="xml">          &gt;</span><br><span class="xml">            </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.name</span> &#125;&#125;</span><br><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;search-item  border-bottom&quot;</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;hasNoData&quot;</span>&gt;</span></span><br><span class="xml">            没有找到匹配数据</span><br><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">import Bscroll from &quot;better-scroll&quot;;</span><br><span class="xml">export default &#123;</span><br><span class="xml">  name: &quot;CitySearch&quot;,</span><br><span class="xml">  props: &#123;</span><br><span class="xml">    cities: Object</span><br><span class="xml">  &#125;,</span><br><span class="xml">  data() &#123;</span><br><span class="xml">    return &#123;</span><br><span class="xml">      keyword: &quot;&quot;,</span><br><span class="xml">      list: [],</span><br><span class="xml">      timer: null</span><br><span class="xml">    &#125;;</span><br><span class="xml">  &#125;,</span><br><span class="xml">  computed: &#123;</span><br><span class="xml">    hasNoData() &#123;</span><br><span class="xml">      return !this.list.length;</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;,</span><br><span class="xml">  watch: &#123;</span><br><span class="xml">    keyword() &#123;</span><br><span class="xml">      if (this.timer) &#123;</span><br><span class="xml">        clearTimeout(this.timer);</span><br><span class="xml">      &#125;</span><br><span class="xml">      if (!this.keyword) &#123;</span><br><span class="xml">        this.list = [];</span><br><span class="xml">        return;</span><br><span class="xml">      &#125;</span><br><span class="xml">      //防抖节流函数</span><br><span class="xml">      this.timer = setTimeout(() =&gt; &#123;</span><br><span class="xml">        const result = [];</span><br><span class="xml">        for (let i in this.cities) &#123;</span><br><span class="xml">          this.cities[i].forEach(value =&gt; &#123;</span><br><span class="xml">            if (</span><br><span class="xml">              value.spell.indexOf(this.keyword) &gt; -1 ||</span><br><span class="xml">              value.name.indexOf(this.keyword) &gt; -1</span><br><span class="xml">            ) &#123;</span><br><span class="xml">              result.push(value);</span><br><span class="xml">            &#125;</span><br><span class="xml">          &#125;);</span><br><span class="xml">        &#125;</span><br><span class="xml">        this.list = result;</span><br><span class="xml">      &#125;, 100);</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;,</span><br><span class="xml">  mounted() &#123;</span><br><span class="xml">    this.scroll = new Bscroll(this.$refs.search);</span><br><span class="xml">  &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>【性能优化–节流】<br>函数节流：通过设定一个时间周期，只要在这个周期内函数就不执行。</p><p>【防抖】<br>写一个侦听器 watch，在里边监听 keyword 的改变，考虑到性能优化，使用防抖的方式来实现，先在 data 中定义一个 timer 定时器，默认值为 null，然后在监听 keyword 的方法中，判断，当 timer 不为 null 时，清除这个定时器。下面写这个定时器的方法，当延时 100ms 的时候，箭头函数会被执行。</p>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue去哪儿项目&amp;兄弟组件间联动&amp;节流</title>
    <link href="/2021/05/05/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E5%85%AD)/"/>
    <url>/2021/05/05/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E5%85%AD)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="兄弟组件间联动-重要"><a href="#兄弟组件间联动-重要" class="headerlink" title="兄弟组件间联动(重要)"></a>兄弟组件间联动(重要)</h3><p>实现功能：点击城市列表页面右侧的字母，列表选项会滚动到对应的字母区域。</p><blockquote><p>兄弟组件的传值，可以通过 bus 总线的形式来传值。但是因为我们现在这个非父子组件比较简单，可以让 Alphabet.vue 组件将值传递给父组件 City.vue 组件，然后 City.vue 组件再将值转发给 List.vue 组件，这样就实现了兄弟组件的传值。【子组件给父组件，父组件再转给另一个子组件】。这样，在 Alphabet.vue 中点击右侧字母，会获取到对应的字母。</p></blockquote><p>src\pages\city\components\Alphabet.vue</p><p>在循环的元素上加一个点击事件，例如 handleLetterClick，然后在 methods 中写这个事件方法：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span></span><br><span class="xml">    &lt;li</span><br><span class="xml">      class=&quot;item&quot;</span><br><span class="xml">      v-for=&quot;item of letters&quot;</span><br><span class="xml">      :key=&quot;item&quot;</span><br><span class="xml">      :ref=&quot;item&quot;</span><br><span class="xml">      @click=&quot;handleLetterClick&quot;</span><br><span class="xml">    &gt;</span><br><span class="xml">      </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item</span>&#125;&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">methods: &#123;</span><br><span class="xml">    handleLetterClick(e) &#123;</span><br><span class="xml">        this.$emit(&quot;change&quot;, e.target.innerHTML);</span><br><span class="xml">    &#125;</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>首先在父组件 City.vue 里的 data 中定义一个 letter，默认值是空，在 handleLetterClick 方法中，当接受到外部传来的 letter 的时候，让 this.letter = letter。</p><p>City.vue部分代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;city-list :cities=<span class="hljs-string">&quot;cities&quot;</span> :hot=<span class="hljs-string">&quot;hotCities&quot;</span> :letter=<span class="hljs-string">&quot;letter&quot;</span>&gt;&lt;/city-list&gt;<br>&lt;city-alphabet :cities=<span class="hljs-string">&quot;cities&quot;</span> @change=<span class="hljs-string">&quot;handLetterChange&quot;</span>&gt;&lt;/city-alphabet&gt;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  name: <span class="hljs-string">&quot;City&quot;</span>,<br>  components: &#123;<br>    CityHeader,<br>    CitySearch,<br>    CityList,<br>    CityAlphabet<br>  &#125;,<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">handLetterChange</span>(<span class="hljs-params">letter</span>)</span> &#123;<br>      <span class="hljs-comment">// console.log(letter);</span><br>      <span class="hljs-built_in">this</span>.letter = letter;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 存放数据</span><br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      cities: &#123;&#125;,<br>      hotCities: [],<br>      letter: <span class="hljs-string">&quot;&quot;</span><br>    &#125;;<br>  &#125;,<br><br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>接下来，将父组件接收到的这个数据转发给子组件 List.vue，父组件是通过属性props向子组件传值的。</p><p>最后只需要把 letter 传递给子组件 List.vue 就可以了，在 City.vue 组件的模板 city-list 中通过 :letter=”letter” 向子组件 List 传值，在 props 中接收这个 letter，并且验证类型为 String 类型。</p><p>List.vue</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">props:</span> &#123;<br><span class="hljs-symbol">    hot:</span> Array,<br><span class="hljs-symbol">    cities:</span> Object,<br><span class="hljs-symbol">    letter:</span> String<br>  &#125;<br></code></pre></td></tr></table></figure><p>这样就实现了兄弟组件的传值。</p><h4 id="【项目难点】"><a href="#【项目难点】" class="headerlink" title="【项目难点】"></a>【项目难点】</h4><p>接下来要做的是，当 List.vue 发现 letter 有改变的时候，就需要让组件显示的列表项跟 letter 相同的首字母的列表项要显示出来，怎么做呢？</p><ol><li>这个时候就要借助一个侦听器，监听letter的变化；</li></ol><p>better-scroll 给提供了这样一个接口，scroll.scorllToElement，如果 letter 不为空的时候，就调用 this.scroll.scrollToElement() 这个方法，可以让滚动区自动滚到某一个元素上，那么怎么传这个元素呢？在循环城市这一块中，给循环项加一个 ref 引用来获取当前 Dom 元素，等于 key，然后回到侦听器的 letter 中，定义一个 element，它就等于通过 ref 获取到的元素：</p><p>src\pages\city\components\List.vue</p><p>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;area&quot;</span> v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(item, key) of cities&quot;</span> :key=<span class="hljs-string">&quot;key&quot;</span> :ref=<span class="hljs-string">&quot;key&quot;</span>&gt;<br><br>watch: &#123;<br><span class="hljs-function"><span class="hljs-title">letter</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// console.log(this.letter);</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.letter) &#123;<br>    <span class="hljs-keyword">const</span> element = <span class="hljs-built_in">this</span>.$refs[<span class="hljs-built_in">this</span>.letter][<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">this</span>.scroll.scrollToElement(element);<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候就可以通过字母获取到对应的区域，然后把 element 传入 scrollToElement 里，注意，上边代码最后加了一个 [0]，这是因为如果不加，通过 ref 或的内容就是一个数组，这个数组里的第一个元素才是真正的 DOM 元素，这个时候，点击右侧字母表，就可以跳到对应的字母下的城市列表了。</p><p>点击跳转的功能实现了</p><ol start="2"><li>接下来再实现一下滑动右侧字母表，左侧城市列表切换的效果。</li></ol><p>知识补充</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">touchstart</span>事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。<br><br><span class="hljs-variable">touchmove</span>事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用<span class="hljs-function"><span class="hljs-title">preventDefault</span>()事件可以阻止滚动。</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-variable">touchend</span>事件：当手指从屏幕上离开的时候触发。</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-variable">touchcancel</span>事件：当系统停止跟踪触摸的时候触发。关于这个事件的确切出发时间，文档中并没有具体说明，咱们只能去猜测了。</span><br></code></pre></td></tr></table></figure><p>src\pages\city\components\Alphabet.vue部分代码</p><p>思路：绑定三个新的事件， @touchstart @touchmove @touchend，然后定义一个标识位，    touchStatus: false,开始@touchstart=true,结束@touchend=false</p><p>首先我们要知道我们滑动的是第几个字母–思路：先获得A字母到顶部的高度，然后滑动后获得当前位置距离顶部的高度，做一个差值就能算出当前位置距离A的高度了，除以每个字母的高度就能得到当前是第几个字母了，然后去取对应的字母触发一个change事件给外部。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span></span><br><span class="xml">    &lt;li</span><br><span class="xml">      class=&quot;item&quot;</span><br><span class="xml">      v-for=&quot;item of letters&quot;</span><br><span class="xml">      :key=&quot;item&quot;</span><br><span class="xml">      :ref=&quot;item&quot;</span><br><span class="xml">      @touchstart=&quot;handleTouchStart&quot;</span><br><span class="xml">      @touchmove=&quot;handleTouchMove&quot;</span><br><span class="xml">      @touchend=&quot;handleTouchEnd&quot;</span><br><span class="xml">      @click=&quot;handleLetterClick&quot;</span><br><span class="xml">    &gt;</span><br><span class="xml">      </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item</span> &#125;&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">export default &#123;</span><br><span class="xml">  name: &quot;CityAlphabet&quot;,</span><br><span class="xml">  props: &#123;</span><br><span class="xml">    cities: Object</span><br><span class="xml">  &#125;,</span><br><span class="xml">//计算属性得到一个字母数组[&#x27;A&#x27;,&#x27;B&#x27;,......]</span><br><span class="xml">  computed: &#123;</span><br><span class="xml">    letters() &#123;</span><br><span class="xml">      const letters = [];</span><br><span class="xml">      for (let i in this.cities) &#123;</span><br><span class="xml">        letters.push(i);</span><br><span class="xml">      &#125;</span><br><span class="xml">      return letters;</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;,</span><br><span class="xml">  data() &#123;</span><br><span class="xml">    return &#123;</span><br><span class="xml">      touchStatus: false,</span><br><span class="xml">    &#125;;</span><br><span class="xml">  &#125;,</span><br><span class="xml">  methods: &#123;</span><br><span class="xml">    handleLetterClick(e) &#123;</span><br><span class="xml">      // console.log(e.target.innerText);</span><br><span class="xml">      this.$emit(&quot;change&quot;, e.target.innerText);</span><br><span class="xml">    &#125;,</span><br><span class="xml">    handleTouchStart() &#123;</span><br><span class="xml">      this.touchStatus = true;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    handleTouchMove(e) &#123;</span><br><span class="xml">      if (this.touchStatus) &#123;</span><br><span class="xml">        //startY 计算的是A的顶部距离上沿的距离  </span><br><span class="xml">        //HTMLElement.offsetTop 为只读属性，它返回当前元素相对于其 offsetParent 元素的顶部内边距的距离。</span><br><span class="xml">        const startY = this.$refs[&quot;A&quot;][0].offsetTop;//74</span><br><span class="xml">        //clientY 事件属性clientY 事件属性返回当事件被触发时鼠标指针向对于浏览器页面（客户区）的垂直坐标。 客户区指的是当前窗口。</span><br><span class="xml">        const touchY = e.touches[0].clientY - 79;</span><br><span class="xml">        const index = Math.floor((touchY - startY) / 20); //20为每个字母的高度，index计算出来为每个字母的下标0，1，2，3，4...</span><br><span class="xml">        if (index &gt;= 0 &amp;&amp; index &lt; this.letters.length) &#123;</span><br><span class="xml">          this.$emit(&quot;change&quot;, this.letters[index]);</span><br><span class="xml">        &#125;</span><br><span class="xml">      &#125;</span><br><br><span class="xml">    &#125;,</span><br><span class="xml">    handleTouchEnd() &#123;</span><br><span class="xml">      this.touchStatus = false;</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="列表切换性能优化"><a href="#列表切换性能优化" class="headerlink" title="列表切换性能优化"></a>列表切换性能优化</h3><h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><p>手指在城市字母表中滑动时，会触发无数次handleTouchMove这个函数，这就对性能影响很大。</p><p>函数节流：通过设定一个时间周期，只要在这个周期内函数就不执行。</p><p>实现方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br>      <span class="hljs-comment">// if (this.touchStatus) &#123;</span><br>      <span class="hljs-comment">//   const startY = this.$refs[&quot;A&quot;][0].offsetTop;</span><br>      <span class="hljs-comment">//   const touchY = e.touches[0].clientY - 79;</span><br>      <span class="hljs-comment">//   const index = Math.floor((touchY - startY) / 20); //20为每个字母的高度</span><br>      <span class="hljs-comment">//   if (index &gt;= 0 &amp;&amp; index &lt; this.letters.length) &#123;</span><br>      <span class="hljs-comment">//     this.$emit(&quot;change&quot;, this.letters[index]);</span><br>      <span class="hljs-comment">//   &#125;</span><br>      <span class="hljs-comment">// &#125;  </span><br><span class="hljs-comment">//节流   </span><br>handleTouchMove(e) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.touchStatus) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.timer) &#123;<br>          clearTimeout(<span class="hljs-keyword">this</span>.timer);<br>        &#125;<br>        <span class="hljs-keyword">this</span>.timer = setTimeout(() =&gt; &#123;<br>          <span class="hljs-keyword">const</span> touchY = e.touches[<span class="hljs-number">0</span>].clientY - <span class="hljs-number">79</span>;<br>          <span class="hljs-keyword">const</span> index = Math.floor((touchY - <span class="hljs-keyword">this</span>.startY) / <span class="hljs-number">20</span>); <span class="hljs-comment">//20为每个字母的高度</span><br>          <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; <span class="hljs-keyword">this</span>.letters.length) &#123;<br>            <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">&quot;change&quot;</span>, <span class="hljs-keyword">this</span>.letters[index]);<br>          &#125;<br>        &#125;, <span class="hljs-number">16</span>);<br>      &#125;<br>    &#125;,<br></code></pre></td></tr></table></figure><p>这里设置的周期是16ms，16ms这个代码只会执行一次，大大优化了性能</p><ol><li>offsetTop的值是固定的，我们每一次去执行这个方法就会去运算一次，性能很低</li></ol><p>解决： data()中 先定义startY: 0,分析：页面刚加载的时候，Alphabet.vue中什么都不会显示出来，当City.vue中ajax获取数据后，Citys的值才发生变化，Alphabet才被渲染出来。当往Alphabet中传入的数据发生变化时，Alphabet才会被重新渲染，当Alphabet重新渲染之后，updated() 这个生命周期就会被执行，这个时候页面已经展示了城市字母列表的所有内容，这个时候我们去计算offsetTop就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>   <span class="hljs-keyword">return</span> &#123;<br>     touchStatus: <span class="hljs-literal">false</span>,<br>     startY: <span class="hljs-number">0</span>,<br>     timer: <span class="hljs-literal">null</span><br>   &#125;;<br> &#125;,<br> <span class="hljs-function"><span class="hljs-title">updated</span>(<span class="hljs-params"></span>)</span> &#123;<br>   <span class="hljs-built_in">this</span>.startY = <span class="hljs-built_in">this</span>.$refs[<span class="hljs-string">&quot;A&quot;</span>][<span class="hljs-number">0</span>].offsetTop;<br> &#125;,<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue&amp;v-for循环6种技巧</title>
    <link href="/2021/05/04/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E5%85%AD)/"/>
    <url>/2021/05/04/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E5%85%AD)/</url>
    
    <content type="html"><![CDATA[<hr><p>在最基本的用法中，它们的用法如下。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&#x27;product in products&#x27;</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">product.name</span> &#125;&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br></code></pre></td></tr></table></figure><hr><h3 id="1-始终在v-for循环中使用key"><a href="#1-始终在v-for循环中使用key" class="headerlink" title="1.始终在v-for循环中使用key"></a>1.始终在v-for循环中使用key</h3><p>首先，我们将讨论大多数Vue开发人员已经知道的常见最佳做法——在 v-for 循环中使用 :key。通过设置一个惟一的键属性，它可以确保组件以您期望的方式工作。</p><p>果我们不使用key，Vue将尝试使DOM尽可能高效，这可能意味着 v-for 元素可能会出现乱序或其他不可预测的行为。如果我们对每个元素都有唯一的键引用，那么我们就可以更好地准确地预测DOM将如何操作。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> </span></span><br><span class="xml">    v-for=&#x27;product in products&#x27;</span><br><span class="xml">    :key=&#x27;product._id&#x27;  </span><br><span class="xml">  &gt;</span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">product.name</span> &#125;&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="2-在一个范围内循环"><a href="#2-在一个范围内循环" class="headerlink" title="2.在一个范围内循环"></a>2.在一个范围内循环</h3><p>尽管大多数情况下，v-for 用于遍历数组或对象，但在某些情况下，我们肯定只希望循环执行一定次数。</p><p>例如，假设我们正在为在线商店创建一个分页系统，而我们只希望每页显示10个产品。使用一个变量来跟踪当前的页码，我们可以像这样处理分页。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&#x27;index in 10&#x27;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&#x27;index&#x27;</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">products</span>[page * 10 + index] &#125;&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="3-不要在循环中使用v-if"><a href="#3-不要在循环中使用v-if" class="headerlink" title="3.不要在循环中使用v-if"></a>3.不要在循环中使用v-if</h3><p>一个超级常见的错误是使用 v-if 来过滤 v-for 循环的数据。尽管这看起来很直观，但它会导致一个巨大的性能问题——VueJS优先考虑 v-for 而不是 v-if 指令。</p><p>这意味着您的组件将循环遍历每个元素，然后检查 v-if 条件以确定是否应渲染。因此，实际上，无论条件是什么，您都将遍历数组的每个项目。</p><p>不要这样：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">// BAD CODE!</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> </span></span><br><span class="xml">    v-for=&#x27;product in products&#x27; </span><br><span class="xml">    :key=&#x27;product._id&#x27; </span><br><span class="xml">    v-if=&#x27;product.price &lt; 50&#x27;</span><br><span class="xml">  &gt;</span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">product.name</span> &#125;&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="4-使用计算属性或方法代替"><a href="#4-使用计算属性或方法代替" class="headerlink" title="4.使用计算属性或方法代替"></a>4.使用计算属性或方法代替</h3><p>为避免上述问题，我们应该在遍历模板中的数据之前对其进行过滤。有两种非常相似的方法：</p><p>使用计算属性<br>使用过滤方法<br>让我们快速地介绍一下这两种方法。</p><p>首先，我们只需要设置一个计算属性，为了获得与之前的v-if相同的功能，代码应如下所示。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&#x27;products in productsUnderFifty&#x27;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&#x27;product._id&#x27;</span> &gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">product.name</span> &#125;&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><br><span class="xml">// ...</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  export default &#123;</span><br><span class="xml">    data () &#123;</span><br><span class="xml">      return &#123;</span><br><span class="xml">        products: []</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    computed: &#123;</span><br><span class="xml">      productsUnderFifty: function () &#123;</span><br><span class="xml">        return this.products.filter(product =&gt; product.price &lt; 50)</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>下面的代码几乎相同，但是使用方法改变了我们访问模板中的值的方式，如果我们希望能够将变量传递给筛选器，那么方法是最好的选择。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&#x27;products in productsUnderPrice(50)&#x27;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&#x27;product._id&#x27;</span> &gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">product.name</span> &#125;&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><br><span class="xml">// ...</span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  export default &#123;</span><br><span class="xml">    data () &#123;</span><br><span class="xml">      return &#123;</span><br><span class="xml">        products: []</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;,</span><br><span class="xml">    methods: &#123;</span><br><span class="xml">      productsUnderPrice (price) &#123;</span><br><span class="xml">        return this.products.filter(product =&gt; product.price &lt; price)</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="5-在循环中访问项目的索引"><a href="#5-在循环中访问项目的索引" class="headerlink" title="5.在循环中访问项目的索引"></a>5.在循环中访问项目的索引</h3><p>除了遍历数组和访问每个元素之外，我们还可以跟踪每个项的索引。</p><p>为此，我们必须在项目后添加一个索引值，它非常简单，可用于分页，显示列表索引，显示排名等。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&#x27;(products, index) in products&#x27;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&#x27;product._id&#x27;</span> &gt;</span></span><br><span class="xml">    Product #</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">index</span> &#125;&#125;</span><span class="xml">: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">product.name</span> &#125;&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="6-遍历一个对象"><a href="#6-遍历一个对象" class="headerlink" title="6.遍历一个对象"></a>6.遍历一个对象</h3><p>到目前为止，我们只真正看过使用 v-for 遍历数组，但是我们可以轻松地遍历对象的键值对。     </p><p>与访问元素的索引类似，我们必须向循环中添加另一个值。如果我们用一个参数遍历一个对象，我们将遍历所有的项。     </p><p>如果我们添加另一个参数，我们将获得items 和 key，如果添加第三个，我们还可以访问 v-for 循环的索引。     </p><p>假设我们要遍历产品中的每个媒体资源。  </p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&#x27;(products, index) in products&#x27;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&#x27;product._id&#x27;</span> &gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&#x27;(item, key, index) in product&#x27;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&#x27;key&#x27;</span>&gt;</span></span><br><span class="xml">      </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item</span> &#125;&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>引用文章<br><a href="https://juejin.cn/post/6844904121825230856#heading-0">在Vue.js中编写更好的v-for循环的6种技巧</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue去哪儿项目&amp;城市选择页面&amp;动态数据渲染</title>
    <link href="/2021/05/04/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%BA%94)/"/>
    <url>/2021/05/04/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%BA%94)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="城市选择页面路由配置"><a href="#城市选择页面路由配置" class="headerlink" title="城市选择页面路由配置"></a>城市选择页面路由配置</h3><p><img src="/image1/22.png" alt="城市页面路由配置"></p><ol><li>页面跳转</li></ol><p>src\pages\home\components\Header.vue中 <code>router-link to=&quot;/city&quot;</code>实现点击右上角页面跳转</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/city&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header-right&quot;</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">this.city</span> &#125;&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont  arrow-cron&quot;</span>&gt;</span><span class="hljs-symbol">&amp;#xe64a;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这里router-link会使字体颜色发生变化，这是因为router-link在div外层加了个a标签，我们可以给header-right加一个颜色color:#fff</p><ol start="2"><li>src\pages\city\components\Header.vue代码实现</li></ol><p><img src="/image1/23.png" alt="城市页面Header实现代码"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><br>    城市选择<br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont header-back&quot;</span>&gt;</span><span class="hljs-symbol">&amp;#xe624;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;CityHeader&quot;</span></span><br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;stylus&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="css"><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;~styles/varibles.styl&#x27;</span>;</span><br>.header<br><span class="css">   <span class="hljs-attribute">position</span>: relative</span><br><span class="css">   <span class="hljs-attribute">overflow</span> :hidden</span><br><span class="css">   <span class="hljs-attribute">height</span>: $headerHeight</span><br><span class="css">   <span class="hljs-attribute">line-height</span> :$headerHeight</span><br><span class="css">   <span class="hljs-attribute">text-align</span>:center</span><br><span class="css">   <span class="hljs-attribute">color</span>:<span class="hljs-number">#fff</span></span><br><span class="css">   <span class="hljs-attribute">background</span> :$bgColor</span><br><span class="css">   <span class="hljs-attribute">font-size</span>:.<span class="hljs-number">32rem</span></span><br>   .header-back<br><span class="css">       <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span></span><br><span class="css">       <span class="hljs-attribute">left</span>:<span class="hljs-number">0</span></span><br><span class="css">       <span class="hljs-attribute">position</span>:absolute</span><br><span class="css">       <span class="hljs-attribute">width</span> <span class="hljs-number">0.64rem</span></span><br><span class="css">       <span class="hljs-attribute">text-align</span>:center</span><br><span class="css">       <span class="hljs-attribute">font-size</span> :.<span class="hljs-number">4rem</span></span><br><span class="css">       <span class="hljs-attribute">color</span>:<span class="hljs-number">#fff</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ol start="3"><li>src\pages\city\City.vue引入使用上面的组件</li></ol><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">city-header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">city-header</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">import CityHeader from &quot;./components/Header&quot;;</span><br><span class="xml">export default </span><span class="xquery">&#123;</span><br><span class="xquery"> <span class="hljs-built_in"> name</span>: <span class="hljs-string">&quot;City&quot;</span>,</span><br><span class="xquery">  components: &#123;</span><br><span class="xquery">    CityHeader,</span><br><span class="xquery">  &#125;</span><span class="xml">,</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="搜索框布局"><a href="#搜索框布局" class="headerlink" title="搜索框布局"></a>搜索框布局</h3><p><img src="/image1/24.png" alt="城市页面搜索框样式"></p><p>src\pages\city\components\Search.vue代码实现</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">template</span>&gt;<br>&lt;div <span class="hljs-keyword">class</span>=&quot;search&quot;&gt;<br>    &lt;<span class="hljs-keyword">input</span><br>    v-model=&quot;keyword&quot;<br>    <span class="hljs-keyword">class</span>=&quot;search-input&quot;<br>    <span class="hljs-keyword">type</span>=&quot;text&quot;<br>    placeholder=&quot;输入城市名或拼音&quot;<br>    /&gt;<br>&lt;/<span class="hljs-keyword">template</span>&gt;<br>&lt;script&gt;<br>export <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-type">name</span>: &quot;CitySearch&quot;,<br>&#125;&lt;/script&gt;<br>&lt;style lang=&quot;stylus&quot; scoped&gt;<br>@<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;~styles/varibles.styl&#x27;</span>;<br>    .<span class="hljs-keyword">search</span><br>       height:<span class="hljs-number">0.72</span>rem<br>       padding:<span class="hljs-number">0</span>  <span class="hljs-number">.1</span>rem<br>       background:$bgColor<br>       .<span class="hljs-keyword">search</span>-<span class="hljs-keyword">input</span><br>           <span class="hljs-type">box</span>-sizing:border-<span class="hljs-type">box</span><br>           width :<span class="hljs-number">100</span>%<br>           height: <span class="hljs-number">0.62</span>rem<br>           padding:<span class="hljs-number">0</span> <span class="hljs-number">.1</span>rem<br>           <span class="hljs-type">line</span>-height :<span class="hljs-number">.62</span>rem<br>           <span class="hljs-type">text</span>-align :center<br>           border-radius: <span class="hljs-number">0.06</span>rem<br>           color:#<span class="hljs-number">666</span><br>      .<span class="hljs-keyword">search</span>-content<br>          z-<span class="hljs-keyword">index</span>:<span class="hljs-number">1</span><br>          overflow :hidden<br>          position:absolute<br>          top: <span class="hljs-number">1.58</span>rem<br>          right:<span class="hljs-number">0</span><br>          left:<span class="hljs-number">0</span><br>          bottom:<span class="hljs-number">0</span><br>          background:#eee<br>          .<span class="hljs-keyword">search</span>-item<br>            <span class="hljs-type">line</span>-height :<span class="hljs-number">.62</span>rem<br>            padding-left :<span class="hljs-number">.2</span>rem<br>            color:#<span class="hljs-number">666</span><br>            background:#fff<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h3 id="列表布局"><a href="#列表布局" class="headerlink" title="列表布局"></a>列表布局</h3><p><img src="/image1/25.png" alt="城市列表"></p><p>部分代码样式：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;template&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span>&gt;<br>      &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;area&quot;</span>&gt;<br>        &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;title  border-topbottom&quot;</span>&gt;当前城市&lt;/<span class="hljs-keyword">div</span>&gt;<br>        &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;buttom-list&quot;</span>&gt;<br>          &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;buttom-wrapper&quot;</span>&gt;<br>            &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;北京&lt;/<span class="hljs-keyword">div</span>&gt;<br>          &lt;/<span class="hljs-keyword">div</span>&gt;<br>        &lt;/<span class="hljs-keyword">div</span>&gt;<br>      &lt;/<span class="hljs-keyword">div</span>&gt;<br>      &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;area&quot;</span>&gt;<br>        &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;title  border-topbottom&quot;</span>&gt;热门城市&lt;/<span class="hljs-keyword">div</span>&gt;<br>        &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;buttom-list&quot;</span>&gt;<br>          &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;buttom-wrapper&quot;</span> v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;item of hot&quot;</span> :key=<span class="hljs-string">&quot;item.id&quot;</span>&gt;<br>            &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;&#123;&#123; <span class="hljs-built_in">item</span>.<span class="hljs-built_in">name</span> &#125;&#125;&lt;/<span class="hljs-keyword">div</span>&gt;<br>          &lt;/<span class="hljs-keyword">div</span>&gt;<br>        &lt;/<span class="hljs-keyword">div</span>&gt;<br>      &lt;/<span class="hljs-keyword">div</span>&gt;<br>      &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;area&quot;</span> v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(item, key) of cities&quot;</span> :key=<span class="hljs-string">&quot;key&quot;</span> :<span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;key&quot;</span>&gt;<br>        &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;title   border-topbottom&quot;</span>&gt;&#123;&#123; key &#125;&#125;&lt;/<span class="hljs-keyword">div</span>&gt;<br>        &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item-list&quot;</span>&gt;<br>          &lt;<span class="hljs-keyword">div</span><br>            <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item  border-bottom&quot;</span><br>            v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;innerItem of item&quot;</span><br>            :key=<span class="hljs-string">&quot;innerItem.id&quot;</span><br>          &gt;<br>            &#123;&#123; innerItem.<span class="hljs-built_in">name</span> &#125;&#125;<br>          &lt;/<span class="hljs-keyword">div</span>&gt;<br>        &lt;/<span class="hljs-keyword">div</span>&gt;<br>      &lt;/<span class="hljs-keyword">div</span>&gt;<br>    &lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/template&gt;<br><br>&lt;style lang=<span class="hljs-string">&quot;stylus&quot;</span> scoped&gt;<br>@import &#x27;~styles/varibles.styl&#x27;;<br>.header<br>  display:flex<br>  line-height: $headerHeight<br>  background: $bgColor<br>  color: <span class="hljs-comment">#fff</span><br>  .header-left<br>    width <span class="hljs-number">.64</span>rem<br>    float:left<br>    .<span class="hljs-keyword">back</span>-icon<br>      <span class="hljs-built_in">text</span>-align:center<br>      font-size:<span class="hljs-number">.4</span>rem<br>  .header-input<br>     flex:<span class="hljs-number">1</span><br>     line-height:<span class="hljs-number">.64</span>rem<br>     height: <span class="hljs-number">.64</span>rem<br>     margin-top: <span class="hljs-number">.12</span>rem<br>     margin-left: <span class="hljs-number">.2</span>rem<br>     padding-left:<span class="hljs-number">.2</span>rem<br>     background: <span class="hljs-comment">#fff</span><br>     border-radius: <span class="hljs-number">.1</span>rem<br>     color:<span class="hljs-comment">#ccc</span><br>  .header-right<br>     width: <span class="hljs-number">1.24</span>rem<br>     float:right<br>     <span class="hljs-built_in">text</span>-align:center<br>     color:<span class="hljs-comment">#fff</span><br>     .arrow-icon<br>       margin-left :<span class="hljs-number">-.04</span>rem<br>       font-size :<span class="hljs-number">.24</span>rem<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><p><img src="/image1/25.png" alt="城市列表"></p><h3 id="Better-scroll的使用及字母表布局"><a href="#Better-scroll的使用及字母表布局" class="headerlink" title="Better-scroll的使用及字母表布局"></a>Better-scroll的使用及字母表布局</h3><p>问题：列表布局中.list加了一个绝对定位和overflow:hidden这会导致页面是无法拖动的</p><p>解决：我们可以使用一个第三方的包Better-scroll</p><p><a href="https://github.com/ustbhuangyi/better-scroll">Github地址</a></p><ol><li>安装</li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">npm install better-<span class="hljs-keyword">scroll</span> --<span class="hljs-keyword">save</span><br></code></pre></td></tr></table></figure><ol start="2"><li>使用(符合这个dom结构)</li></ol><p>BetterScroll的最常见应用场景是列表滚动。让我们看看它的HTML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    ...<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- you can put some other DOMs here, it won&#x27;t affect the scrolling</span><br><span class="hljs-comment">&lt;/div&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>具体使用</li></ol><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> Bscroll <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;better-scroll&quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;div <span class="hljs-keyword">class</span>=&quot;list&quot; <span class="hljs-keyword">ref</span>=&quot;wrapper&quot;&gt;  //<span class="hljs-keyword">ref</span>帮助我们获取该dom元素<br><br> //生命周期函数，载入后<br>  mounted() &#123;<br>  this.scroll = <span class="hljs-built_in">new</span> Bscroll(this.$refs.<span class="hljs-keyword">wrapper</span>);<br>&#125;,<br></code></pre></td></tr></table></figure><ol start="4"><li>效果：上拉与下拉能够实现，并且有弹性动画效果，非常流畅</li></ol><h4 id="字母表布局"><a href="#字母表布局" class="headerlink" title="字母表布局"></a>字母表布局</h4><p><img src="/image1/26.png" alt="右侧字母表布局"></p><ol><li>创建组件src\pages\city\components\Alphabet.vue</li></ol><p>部分代码样式</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>  &gt;</span></span><br><span class="xml">      </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item</span> &#125;&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">export default &#123;</span><br><span class="xml">  name: &quot;CityAlphabet&quot;,</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;stylus&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="xml">@import &#x27;~styles/varibles.styl&#x27;;</span><br><span class="xml">    .list</span><br><span class="xml">        display:flex</span><br><span class="xml">        flex-direction :column</span><br><span class="xml">        justify-content :center</span><br><span class="xml">        position:absolute</span><br><span class="xml">        top 1.58rem</span><br><span class="xml">        right 0</span><br><span class="xml">        bottom:0</span><br><span class="xml">        width 0.4rem</span><br><span class="xml">        .item</span><br><span class="xml">            text-align:center</span><br><span class="xml">            line-height :.4rem</span><br><span class="xml">            color:$bgColor</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="城市列表页面动态数据渲染"><a href="#城市列表页面动态数据渲染" class="headerlink" title="城市列表页面动态数据渲染"></a>城市列表页面动态数据渲染</h3><p>利用ajax获取数据</p><ol><li>准备好的本地模拟数据</li></ol><p><img src="/image1/27.png" alt="数据"></p><ol start="2"><li>ajax请求一般我们会放在最外层组件中获取，这样一次就能够获取到所有组件需要的内容</li></ol><p>src\pages\city\City.vue这里我们在City.vue中发送</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">city-header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">city-header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">city-search</span> <span class="hljs-attr">:cities</span>=<span class="hljs-string">&quot;cities&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">city-search</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">city-list</span> <span class="hljs-attr">:cities</span>=<span class="hljs-string">&quot;cities&quot;</span> <span class="hljs-attr">:hot</span>=<span class="hljs-string">&quot;hotCities&quot;</span> <span class="hljs-attr">:letter</span>=<span class="hljs-string">&quot;letter&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">city-list</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">city-alphabet</span> <span class="hljs-attr">:cities</span>=<span class="hljs-string">&quot;cities&quot;</span> @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;handLetterChange&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">city-alphabet</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> CityHeader <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Header&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> CitySearch <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Search&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> CityList <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/List&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> CityAlphabet <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Alphabet&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;City&quot;</span>,</span><br>  components: &#123;<br>    CityHeader,<br>    CitySearch,<br>    CityList,<br>    CityAlphabet<br>  &#125;,<br>  methods: &#123;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">getCityInfo</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      axios.get(<span class="hljs-string">&quot;/api/city.json&quot;</span>).then(<span class="hljs-built_in">this</span>.handleGetCityIngoSucc);</span><br>    &#125;,<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">handleGetCityIngoSucc</span>(<span class="hljs-params">res</span>)</span> &#123;</span><br>      res = res.data;<br>      if (res.ret &amp;&amp; res.data) &#123;<br><span class="javascript">        <span class="hljs-keyword">const</span> data = res.data;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.cities = data.cities;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.hotCities = data.hotCities;</span><br>      &#125;<br>    &#125;,<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">handLetterChange</span>(<span class="hljs-params">letter</span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-comment">// console.log(letter);</span></span><br><span class="javascript">      <span class="hljs-built_in">this</span>.letter = letter;</span><br>    &#125;<br>  &#125;,<br><span class="javascript">  <span class="hljs-comment">// 存放数据</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br>      cities: &#123;&#125;,<br>      hotCities: [],<br><span class="javascript">      letter: <span class="hljs-string">&quot;&quot;</span></span><br>    &#125;;<br>  &#125;,<br><span class="javascript">  <span class="hljs-comment">// 生命周期函数</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">this</span>.getCityInfo();</span><br>  &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>父组件向子组件传数据</li></ol><p>例：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">&lt;city-list <span class="hljs-symbol">:cities=<span class="hljs-string">&quot;cities&quot;</span></span> <span class="hljs-symbol">:hot=<span class="hljs-string">&quot;hotCities&quot;</span></span> <span class="hljs-symbol">:letter=<span class="hljs-string">&quot;letter&quot;</span>&gt;&lt;/city-list&gt;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>子组件通过props接收</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts">export <span class="hljs-class">default </span>&#123;<br><span class="hljs-symbol">  name:</span> <span class="hljs-string">&quot;CityList&quot;</span>,<br><span class="hljs-symbol">  props:</span> &#123;<br><span class="hljs-symbol">    hot:</span> Array,<br><span class="hljs-symbol">    cities:</span> Object,<br><span class="hljs-symbol">    letter:</span> String<br>  &#125;,<br></code></pre></td></tr></table></figure><ol start="5"><li>v-for渲染数据</li></ol><p>循环数组</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;buttom-wrapper&quot;</span> v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;item of hot&quot;</span> :key=<span class="hljs-string">&quot;item.id&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;&#123;&#123; <span class="hljs-built_in">item</span>.<span class="hljs-built_in">name</span> &#125;&#125;&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>循环对象(这里我们使用了二次循环)</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;area&quot;</span> v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(item, key) of cities&quot;</span> :key=<span class="hljs-string">&quot;key&quot;</span> :<span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;key&quot;</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;title   border-topbottom&quot;</span>&gt;&#123;&#123; key &#125;&#125;&lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item-list&quot;</span>&gt;<br>    &lt;<span class="hljs-keyword">div</span><br>      <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;item  border-bottom&quot;</span><br>      v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;innerItem of item&quot;</span><br>      :key=<span class="hljs-string">&quot;innerItem.id&quot;</span><br>    &gt;<br>      &#123;&#123; innerItem.<span class="hljs-built_in">name</span> &#125;&#125;<br>    &lt;/<span class="hljs-keyword">div</span>&gt;<br>  &lt;/<span class="hljs-keyword">div</span>&gt;<br>      &lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue去哪儿项目&amp;Ajax获取首页数据</title>
    <link href="/2021/05/03/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E5%9B%9B)/"/>
    <url>/2021/05/03/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E5%9B%9B)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="Ajax获取首页数据–axios"><a href="#Ajax获取首页数据–axios" class="headerlink" title="Ajax获取首页数据–axios"></a>Ajax获取首页数据–axios</h3><ol><li>项目安装axios </li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm  install  axios <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>分析：首页由5个组件组成，每一个组件都有自己的数据，那么每个组件都发送一个ajax请求。如果这样做首页就会发送5个ajax请求，网站的性能会很低。</p><p>解决：Home.vue组件中发送ajax是最好的选择，这个组件获取ajax请求的数据传给每个子组件中，只用请求一次。</p><ol start="2"><li>引入axios</li></ol><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>使用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//&#x27;/static/mock/index.json&#x27;</span><br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">getHomeInfo</span>(<span class="hljs-params"></span>)</span> &#123;<br>      axios.get(<span class="hljs-string">&quot;/api/index.json&quot;</span>).then(<span class="hljs-built_in">this</span>.getHomeInfoSucc);<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">//mounted (载入后) 在el 被新创建的 vm.$el替换，并挂载到实例上去之后调用</span><br>  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.getHomeInfo();<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里我们的使用的是本地模拟的数据json文件,开发环境中使用转发机制</p><p>vue中提供了一个代理功能</p><p><img src="/image1/20.png" alt="代理"></p><p>index.json</p><p><img src="/image1/21.png" alt="本地json文件"></p><h3 id="首页父子组件数据传递"><a href="#首页父子组件数据传递" class="headerlink" title="首页父子组件数据传递"></a>首页父子组件数据传递</h3><p>Home.vue</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">home-header</span> <span class="hljs-attr">:city</span>=<span class="hljs-string">&quot;city&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">home-header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">home-swiper</span> <span class="hljs-attr">:list</span>=<span class="hljs-string">&quot;swiperList&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">home-swiper</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">home-icons</span> <span class="hljs-attr">:list</span>=<span class="hljs-string">&quot;iconList&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">home-icons</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">home-recommend</span> <span class="hljs-attr">:list</span>=<span class="hljs-string">&quot;recommendList&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">home-recommend</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">home-weekend</span> <span class="hljs-attr">:list</span>=<span class="hljs-string">&quot;weekendList&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">home-weekend</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> HomeHeader <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Header&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> HomeSwiper <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Swiper&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> HomeIcons <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Icons&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> HomeRecommend <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Recommend&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> HomeWeekend <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Weekend&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;Home&quot;</span>,</span><br>  components: &#123;<br>    HomeHeader,<br>    HomeSwiper,<br>    HomeIcons,<br>    HomeRecommend,<br>    HomeWeekend<br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      city: <span class="hljs-string">&quot;&quot;</span>,</span><br>      swiperList: [],<br>      iconList: [],<br>      recommendList: [],<br>      weekendList: []<br>    &#125;;<br>  &#125;,<br>  methods: &#123;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">getHomeInfo</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      axios.get(<span class="hljs-string">&quot;/api/index.json&quot;</span>).then(<span class="hljs-built_in">this</span>.getHomeInfoSucc);</span><br>    &#125;,<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">getHomeInfoSucc</span>(<span class="hljs-params">res</span>)</span> &#123;</span><br>      res = res.data;<br>      if (res.ret &amp;&amp; res.data) &#123;<br><span class="javascript">        <span class="hljs-keyword">const</span> data = res.data;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.city = res.data.city;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.swiperList = data.swiperList;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.iconList = data.iconList;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.recommendList = data.recommendList;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.weekendList = data.weekendList;</span><br>      &#125;<br>    &#125;<br>  &#125;,<br><span class="javascript">  <span class="hljs-comment">//mounted (载入后) 在el 被新创建的 vm.$el替换，并挂载到实例上去之后调用</span></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-built_in">this</span>.getHomeInfo();</span><br>  &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>父组件给子组件传值<br>使用props，父组件可以使用props向子组件传递数据。</p><ol><li>Swiper.vue中小问题</li></ol><p>默认显示的是最后一页的图片</p><p>分析：当页面还没接收数据的时候，也就是还没接收ajax获取的Array数组时，这时候接收的是外面获取的空数组。<br>解决</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;swiper :<span class="hljs-attribute">options</span>=<span class="hljs-string">&quot;swiperOptions&quot;</span> <span class="hljs-attribute">v-if</span>=<span class="hljs-string">&quot;showSwiper&quot;</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  name: <span class="hljs-string">&quot;HomeSwiper&quot;</span>,</span><br>  props: &#123;<br><span class="javascript">    list: <span class="hljs-built_in">Array</span></span><br>  &#125;,<br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br>      swiperOptions: &#123;<br><span class="javascript">        pagination: <span class="hljs-string">&quot;.swiper-pagination&quot;</span>,</span><br><span class="javascript">        loop: <span class="hljs-literal">true</span> <span class="hljs-comment">//能够循环滑动，false只能滑倒最后，或最前</span></span><br>      &#125;<br>    &#125;;<br>  &#125;,<br>  computed: &#123;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">showSwiper</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.list.length;</span><br>    &#125;<br>  &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue去哪儿项目首页开发&amp;首页轮播图&amp;推荐组件开发</title>
    <link href="/2021/05/02/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%B8%89)/"/>
    <url>/2021/05/02/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="首页轮播图"><a href="#首页轮播图" class="headerlink" title="首页轮播图"></a>首页轮播图</h3><ol><li>第三方轮播插件使用</li></ol><p>Github地址<br><a href="https://github.com/surmon-china/vue-awesome-swiper">vue-awesome-swiper</a></p><p>安装：项目文件夹路径中,这里我们安装的是@2.6.7版本，其他版本可能兼容性等问题</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> install swiper vue-awesome-swiper@<span class="hljs-number">2</span>.<span class="hljs-number">6</span>.<span class="hljs-number">7</span> --save<br></code></pre></td></tr></table></figure><ol start="2"><li>引用(这里我们引用到全局中，因为各个页面可能都会使用)</li></ol><p>main.js</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> Vue from &#x27;vue&#x27;<br><span class="hljs-keyword">import</span> VueAwesomeSwiper from &#x27;vue-awesome-swiper&#x27;<br><br>//这里我们使用这个版本<br>// <span class="hljs-keyword">import</span> style (&gt;= <span class="hljs-type">Swiper</span> 6.<span class="hljs-title">x</span>)<br><span class="hljs-keyword">import</span> &#x27;swiper/swiper-bundle.css&#x27;<br><br>// <span class="hljs-keyword">import</span> style (&lt;= <span class="hljs-type">Swiper</span> 5.<span class="hljs-title">x</span>)<br><span class="hljs-keyword">import</span> &#x27;swiper/css/swiper.css&#x27;<br><br><span class="hljs-type">Vue</span>.use(<span class="hljs-type">VueAwesomeSwiper</span>, /* &#123; <span class="hljs-keyword">default</span> options with global component &#125; */)<br></code></pre></td></tr></table></figure><ol start="3"><li>使用</li></ol><p>Swiper.vue</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">template</span>&gt;<br>  &lt;div <span class="hljs-keyword">class</span>=&quot;wrapper&quot;&gt;<br>    &lt;swiper :<span class="hljs-keyword">options</span>=&quot;swiperOptions&quot; v-<span class="hljs-keyword">if</span>=&quot;showSwiper&quot;&gt;<br>      &lt;swiper-slide v-<span class="hljs-keyword">for</span>=&quot;item of list&quot; :key=&quot;item.id&quot;&gt;<br>        &lt;img <span class="hljs-keyword">class</span>=&quot;swiper-img&quot; :src=&quot;item.imgUrl&quot; alt=&quot;&quot; /&gt;<br>      &lt;/swiper-slide&gt;<br><br>      &lt;div <span class="hljs-keyword">class</span>=&quot;swiper-pagination&quot; slot=&quot;pagination&quot;&gt;&lt;/div&gt;<br>    &lt;/swiper&gt;<br>  &lt;/div&gt;<br>&lt;/<span class="hljs-keyword">template</span>&gt;<br>&lt;script&gt;<br>export <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-type">name</span>: &quot;HomeSwiper&quot;,<br>  props: &#123;<br>    list: <span class="hljs-keyword">Array</span><br>  &#125;,<br>  data() &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      swiperOptions: &#123;<br>        pagination: &quot;.swiper-pagination&quot;,<br>        <span class="hljs-keyword">loop</span>: <span class="hljs-keyword">true</span><br>      &#125;<br>    &#125;;<br>  &#125;,<br>  computed: &#123;<br>    showSwiper() &#123;<br>      <span class="hljs-keyword">return</span> this.list.length;<br>    &#125;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;stylus&quot; scoped&gt;<br>// 样式穿透，不受scoped控制了<br>.<span class="hljs-keyword">wrapper</span> &gt;&gt;&gt; .swiper-pagination-bullet-active<br>    background:#fff<br>.<span class="hljs-keyword">wrapper</span><br>    overflow hidden<br>    width:<span class="hljs-number">100</span>%<br>    height:<span class="hljs-number">0</span><br>    padding-bottom :<span class="hljs-number">31.25</span>%<br>    background  :#eee<br>    .swiper-img<br>        width:<span class="hljs-number">100</span>%<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><h4 id="占位"><a href="#占位" class="headerlink" title="占位"></a>占位</h4><p>图片是可替代资源，在页面显然时，会先将页面中静态的内容渲染上去，等数据返回后，在进行重新渲染，这样页面就会出现抖动，影响用户体验，同时性能也比较低。</p><p>可以用下面的css代码对这些可替换资源先进行占位，页面大体框架在第一次渲染后就能呈现给用户，数据获取到后，替换相应的内容就可，就不会出现抖动了。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.<span class="hljs-attribute">icon</span>-img<br>    <span class="hljs-attribute">overflow</span>: hidden<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span><br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span><br>    <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">100%</span><br></code></pre></td></tr></table></figure><p><img src="/image1/15.png" alt="样式，可以滑动"></p><h3 id="图标区域页面布局"><a href="#图标区域页面布局" class="headerlink" title="图标区域页面布局"></a>图标区域页面布局</h3><p>新建一个组件<br>src\pages\home\components\Icons.vue</p><p>在Home.vue中引入并使用</p><p>icons.vue代码</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icons&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">swiper</span> <span class="hljs-attr">:options</span>=<span class="hljs-string">&quot;swiperOptions&quot;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">swiper-slide</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(page, index) of pages&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item of page&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon-img&quot;</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon-img-content&quot;</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">&quot;item.imgUrl&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon-desc&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.desc</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">swiper-slide</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">swiper</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">export default &#123;</span><br><span class="xml">  name: &quot;HomeIcons&quot;,</span><br><span class="xml">  props: &#123;</span><br><span class="xml">    list: Array</span><br><span class="xml">  &#125;,</span><br><span class="xml">  data() &#123;</span><br><span class="xml">    return &#123;</span><br><span class="xml">      swiperOptions: &#123;</span><br><span class="xml">        autoplay: false</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;;</span><br><span class="xml">  &#125;,</span><br><span class="xml">  computed: &#123;</span><br><span class="xml">    pages() &#123;</span><br><span class="xml">      const pages = [];</span><br><span class="xml">      this.list.forEach((item, index) =&gt; &#123;</span><br><span class="xml">        const page = Math.floor(index / 8);</span><br><span class="xml">        if (!pages[page]) &#123;</span><br><span class="xml">          pages[page] = [];</span><br><span class="xml">        &#125;</span><br><span class="xml">        pages[page].push(item);</span><br><span class="xml">      &#125;);</span><br><span class="xml">      return pages;</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;stylus&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="xml">@import &#x27;~styles/varibles.styl&#x27;;</span><br><span class="xml">@import &#x27;~styles/mixins.styl&#x27;;</span><br><span class="xml">.icons  &gt;&gt;&gt; .swiper-container</span><br><span class="xml">  width:100%</span><br><span class="xml">  height:0</span><br><span class="xml">  padding-bottom:50%</span><br><span class="xml">.icons</span><br><span class="xml">  margin-top:.1rem</span><br><span class="xml">  .icon</span><br><span class="xml">    position :relative</span><br><span class="xml">    overflow :hidden</span><br><span class="xml">    float:left</span><br><span class="xml">    width:25%</span><br><span class="xml">    height:0</span><br><span class="xml">    padding-bottom :25%</span><br><span class="xml">    .icon-img</span><br><span class="xml">        position:absolute</span><br><span class="xml">        top:0</span><br><span class="xml">        left:0</span><br><span class="xml">        right:0</span><br><span class="xml">        bottom:.44rem</span><br><span class="xml">        box-sizing:border-box</span><br><span class="xml">        padding:.1rem</span><br><span class="xml">        .icon-img-content</span><br><span class="xml">            display:block</span><br><span class="xml">            margin 0 auto</span><br><span class="xml">            height:100%</span><br><span class="xml">    .icon-desc</span><br><span class="xml">       position :absolute</span><br><span class="xml">       left:0</span><br><span class="xml">       right:0</span><br><span class="xml">       bottom:0</span><br><span class="xml">       height:.44rem</span><br><span class="xml">       line-height :.44rem</span><br><span class="xml">       color:#darkTextColor</span><br><span class="xml">       text-align :center</span><br><span class="xml">       ellipsis()</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><p><img src="/image1/17.png" alt="效果"></p><p>文字太长后面文字用….表示的Css样式</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">overflow :hidden <br>white-space :nowrap <br>text-overflow :ellipsis<br></code></pre></td></tr></table></figure><p>由于这个样式很多地方都会用到，所以我们可以借助stylus的mixins.styl将它封装.</p><p><img src="/image1/16.png" alt="封装"></p><p>使用：</p><p>导入</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;~styles/mixins.styl&#x27;</span>;<br></code></pre></td></tr></table></figure><p>css中使用</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl">.icon-<span class="hljs-variable">desc</span><br>   <span class="hljs-function"><span class="hljs-title">ellipsis</span>()</span><br></code></pre></td></tr></table></figure><h3 id="推荐组件开发"><a href="#推荐组件开发" class="headerlink" title="推荐组件开发"></a>推荐组件开发</h3><p><img src="/image1/18.png" alt="效果"></p><p>新建一个组件<br>src\pages\home\components\Recommend.vue</p><p>在Home.vue中引入并使用</p><p>Recommend.vue代码</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span></span><br><span class="xml">      热销推荐</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item  border-bottom&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item of list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-img&quot;</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;item.imgUrl&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span></span><br><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-info&quot;</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-title&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.title</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-desc&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.desc</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-button&quot;</span>&gt;</span>查看详情<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">export default &#123;</span><br><span class="xml">  name: &quot;HomeRecommend&quot;,</span><br><span class="xml">  props: &#123;</span><br><span class="xml">    list: Array</span><br><span class="xml">  &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;stylus&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="xml">@import &#x27;~styles/mixins.styl&#x27;;</span><br><span class="xml">.title</span><br><span class="xml">    margin-top :.2rem</span><br><span class="xml">    line-height :.8rem</span><br><span class="xml">    background:#eee</span><br><span class="xml">    text-indent:.2rem</span><br><span class="xml">.item</span><br><span class="xml">    overflow: hidden</span><br><span class="xml">    display:flex</span><br><span class="xml">    height :1.9rem</span><br><span class="xml">    .item-img</span><br><span class="xml">       width 1.7rem</span><br><span class="xml">       height 1.7rem</span><br><span class="xml">       padding:.1rem</span><br><span class="xml">    .item-info</span><br><span class="xml">        flex:1</span><br><span class="xml">        padding:.1rem</span><br><span class="xml">        min-width:0</span><br><span class="xml">        .item-title</span><br><span class="xml">            line-height :.54rem</span><br><span class="xml">            font-size :.32rem</span><br><span class="xml">            ellipsis()</span><br><span class="xml">        .item-desc</span><br><span class="xml">            line-height :.4rem</span><br><span class="xml">            color:#ccc</span><br><span class="xml">            ellipsis()</span><br><span class="xml">        .item-button</span><br><span class="xml">            line-height :.44rem</span><br><span class="xml">            margin-top:.16rem</span><br><span class="xml">            background #ff9300</span><br><span class="xml">            padding:0 .2rem</span><br><span class="xml">            border radius 0.06rem</span><br><span class="xml">            color:#fff</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><h3 id="周末游组件开发"><a href="#周末游组件开发" class="headerlink" title="周末游组件开发"></a>周末游组件开发</h3><p><img src="/image1/19.png" alt="效果"></p><p>新建一个组件<br>src\pages\home\components\Weekend.vue</p><p>在Home.vue中引入并使用</p><p>Weekend.vue代码</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span></span><br><span class="xml">      周末去哪儿</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item  border-bottom&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item of list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-img-warpper&quot;</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-img&quot;</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;item.imgUrl&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-info&quot;</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-title&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.title</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-desc&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">item.desc</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">export default &#123;</span><br><span class="xml">  name: &quot;HomeWeekend&quot;,</span><br><span class="xml">  props: &#123;</span><br><span class="xml">    list: Array</span><br><span class="xml">  &#125;</span><br><span class="xml">&#125;;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;stylus&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="xml">@import &#x27;~styles/mixins.styl&#x27;;</span><br><span class="xml">.title</span><br><span class="xml">    line-height :.8rem</span><br><span class="xml">    background:#eee</span><br><span class="xml">    text-indent:.2rem</span><br><span class="xml">.item-img-warpper</span><br><span class="xml">    overflow:hidden</span><br><span class="xml">    height:0</span><br><span class="xml">    padding-bottom :37.9%</span><br><span class="xml">.item-img</span><br><span class="xml">    width 100%</span><br><span class="xml">.item-info</span><br><span class="xml">    padding:.1rem</span><br><span class="xml">    .item-title</span><br><span class="xml">        line-height :.54rem</span><br><span class="xml">        font-size :.32rem</span><br><span class="xml">        ellipsis()</span><br><span class="xml">    .item-desc</span><br><span class="xml">        line-height :.4rem</span><br><span class="xml">        color:#ccc</span><br><span class="xml">        ellipsis()</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue去哪儿项目首页开发&amp;首页header区域</title>
    <link href="/2021/05/02/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%BA%8C)/"/>
    <url>/2021/05/02/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="首页header区域"><a href="#首页header区域" class="headerlink" title="首页header区域"></a>首页header区域</h3><ol><li>安装开发依赖包(项目目录下)<br>stylus：CSS的预处理框架，即将stylus转换为css使用<br>stylus-loader：让webpack理解stylus<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm  install  stylus <span class="hljs-comment">--save</span><br>npm  install  stylus-loader  <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure></li></ol><p>参考使用文章：<br><a href="https://juejin.cn/post/6844903696409722894">『前端干货篇』：你不知道的Stylus</a><br><a href="www.zhangxinxu.com/jq/stylus/">张鑫旭大大的Stylus文章</a></p><p>使用过程中报错：npm run dev后报错<br>Vue中使用Stylus报错：Module build failed: TypeError: this.getOptions is not a function</p><p>报错原因<br>stylus-loader版本过高，更改为<a href="mailto:&#115;&#x74;&#121;&#108;&#x75;&#115;&#x2d;&#x6c;&#x6f;&#x61;&#x64;&#x65;&#114;&#64;&#x33;&#46;&#x30;&#46;&#x31;">&#115;&#x74;&#121;&#108;&#x75;&#115;&#x2d;&#x6c;&#x6f;&#x61;&#x64;&#x65;&#114;&#64;&#x33;&#46;&#x30;&#46;&#x31;</a>即可</p><p>再次安装stylus</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm uninstall stylus stylus-loader <span class="hljs-regexp">//</span>删除之前的loader<br>npm install stylus stylus-loader@<span class="hljs-number">3.0</span>.<span class="hljs-number">1</span> --save-dev <span class="hljs-regexp">//</span>再次安装<br></code></pre></td></tr></table></figure><ol start="2"><li>src\pages\home\components路径下新建一个Header.vue</li></ol><p>页面组件化，对于Home这个页面可以被拆分成多个小组件，Header.vue可以放在compons中被使用</p><ol start="3"><li>引入组件使用</li></ol><p><img src="/image1/8.png" alt="使用组件"></p><ol start="4"><li>Header.vue页面样式</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs maxima">&lt;template&gt;<br>  &lt;div class=<span class="hljs-string">&quot;header&quot;</span>&gt;<br>    &lt;div class=<span class="hljs-string">&quot;header-left&quot;</span>&gt;返回&lt;/div&gt;<br>    &lt;div class=<span class="hljs-string">&quot;header-input&quot;</span>&gt;输入城市/景点/游玩/主题&lt;/div&gt;<br>    &lt;div class=<span class="hljs-string">&quot;header-right&quot;</span>&gt;城市&lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  name: <span class="hljs-string">&quot;HomeHeader&quot;</span><br>&#125;;<br>&lt;/script&gt;<br><br>&lt;<span class="hljs-built_in">style</span> lang=<span class="hljs-string">&quot;stylus&quot;</span> scoped&gt;<br>.header<br>  <span class="hljs-built_in">display</span>:flex<br>  line-<span class="hljs-built_in">height</span>: .86<span class="hljs-built_in">rem</span><br>  <span class="hljs-built_in">background</span> #<span class="hljs-number">00bcd4</span><br>  <span class="hljs-built_in">color</span>: #fff<br>  .header-left<br>    <span class="hljs-built_in">width</span> .64<span class="hljs-built_in">rem</span><br>    <span class="hljs-built_in">float</span>:left<br>  .header-input<br>     flex:<span class="hljs-number">1</span><br>     line-<span class="hljs-built_in">height</span>:.64<span class="hljs-built_in">rem</span><br>     <span class="hljs-built_in">height</span>: .64<span class="hljs-built_in">rem</span><br>     margin-top .12<span class="hljs-built_in">rem</span><br>     margin-left: .2<span class="hljs-built_in">rem</span><br>     <span class="hljs-built_in">background</span>: #fff<br>     <span class="hljs-built_in">border</span>-<span class="hljs-built_in">radius</span>: .1<span class="hljs-built_in">rem</span><br>     <span class="hljs-built_in">color</span>:#ccc<br>  .header-right<br>     <span class="hljs-built_in">width</span>: <span class="hljs-number">1.</span>24<span class="hljs-built_in">rem</span><br>     <span class="hljs-built_in">float</span>:right<br>     text-align:<span class="hljs-built_in">center</span><br>&lt;/<span class="hljs-built_in">style</span>&gt;<br><br></code></pre></td></tr></table></figure><p>补充：<code>&lt;style lang=&quot;stylus&quot; scoped&gt;</code><br>我们写的这个组件不要对其他组件产生影响，使用scoped可以限制.header的样式只对当前组件有效，不对其他组件有影响<br>当<code> &lt;style&gt;</code> 标签有 scoped 属性时，它的 CSS 只作用于当前组件中的元素。</p><p>完成效果：</p><p><img src="/image1/9.png" alt="使用组件"></p><h3 id="iconfont的使用和代码优化"><a href="#iconfont的使用和代码优化" class="headerlink" title="iconfont的使用和代码优化"></a>iconfont的使用和代码优化</h3><p><img src="/image1/10.png" alt="iconfont下载使用"></p><ol><li>将以下文件放入项目静态资源中,这里我们修改一下引用路径</li></ol><p><img src="/image1/11.png" alt="资源引入"></p><ol><li>引入iconfont</li></ol><p>由于我们几乎所有页面都要使用iconfont，所以我们可以在main.js中引用</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;styles/iconfont.css&#x27;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>使用，这里的代码是Unicode编码</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont back-icon&quot;</span>&gt;</span><span class="hljs-symbol">&amp;#xe624;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont&quot;</span>&gt;</span><span class="hljs-symbol">&amp;#xe632;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont  arrow-cron&quot;</span>&gt;</span><span class="hljs-symbol">&amp;#xe64a;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>css样式(省略)</p><ol start="4"><li>代码优化</li></ol><p>整个Header背景色都是一个绿色的内容，我们这个网页很多地方都会用到这个背景色，我们可以将这个颜色单独放在一个变量中，然后单独的去引用。未来网站颜色风格需要切换，只需要去改变这一个变量，全局都会改变，这个可维护性会有很大的提升</p><p>解决：</p><p>全局变量文件</p><p><img src="/image1/12.png" alt="全局变量文件"></p><p>引入使用：</p><p><img src="/image1/13.png" alt="引入与使用"></p><ol start="5"><li>引入优化</li></ol><p>起别名：</p><p><img src="/image1/14.png" alt="起别名"></p><p>使用：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">&#x27;~styles/varibles.styl&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这里我们修改了webpack中的配置项时，一定要重启项目，否者会报错</p>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue去哪儿项目环境搭建</title>
    <link href="/2021/05/01/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%B8%80)/"/>
    <url>/2021/05/01/Vue%E5%8E%BB%E5%93%AA%E5%84%BF%E5%AE%9E%E6%88%98(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="项目环境准备"><a href="#项目环境准备" class="headerlink" title="项目环境准备"></a>项目环境准备</h3><ol><li>安装node</li><li>Gitee创建一个自己的仓库</li></ol><p><img src="/image1/1.png" alt="仓库"></p><ol start="3"><li><p>git ssh本地免密</p></li><li><p>git  clone 项目到本地电脑</p></li><li><p>全局安装vue-cli</p></li></ol><p><img src="/image1/2.png" alt="全局安装"></p><ol start="6"><li>项目初始化</li></ol><p><img src="/image1/3.png" alt="初始化项目"></p><ol start="7"><li>项目启动</li></ol><p>npm  run  dev</p><p><img src="/image1/4.png" alt="启动成功"></p><p>目录结构</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs verilog">readme              <span class="hljs-comment">//项目的说明文件</span><br><span class="hljs-keyword">package</span><span class="hljs-variable">.json</span>         <span class="hljs-comment">//第三方依赖包配置</span><br><span class="hljs-keyword">package</span><span class="hljs-variable">.lock</span><span class="hljs-variable">.json</span>    <span class="hljs-comment">//帮助我们去确定安装的第三方依赖包的具体的版本，保持团队编程的统一</span><br>license             <span class="hljs-comment">//开源协议的说明</span><br>index<span class="hljs-variable">.html</span>          <span class="hljs-comment">//项目默认的首页模版文件</span><br><span class="hljs-variable">.postcssrc</span><span class="hljs-variable">.js</span>        <span class="hljs-comment">//对 postcss 的配置项</span><br><span class="hljs-variable">.gitignore</span>          <span class="hljs-comment">//不需要上传到 git 上的文件管理 </span><br><span class="hljs-variable">.eslintrc</span><span class="hljs-variable">.js</span>        <span class="hljs-comment">//对写的代码检测是否标准做一个检测</span><br><span class="hljs-variable">.eslintignore</span>       <span class="hljs-comment">//配置不需要 eslintrc 检测工具检测的文件</span><br><span class="hljs-variable">.editorconfig</span>       <span class="hljs-comment">//配置编辑器总风格统一的自动化格式的语法</span><br><span class="hljs-variable">.babelrc</span>            <span class="hljs-comment">//项目写的代码是 Vue 的大文件组件的代码的写法，所以需要通过 babel 这种语法解析器做一些语法上的转换，最终转换成浏览器能够编译执行的代码，babel 需要做额外配置时，就放在文件里面</span><br><span class="hljs-keyword">static</span>                  <span class="hljs-comment">//static 目录放的是静态资源，要用到的静态图片啊或者后续需要模拟的 json 数据</span><br>node_modules                 <span class="hljs-comment">//项目中需要用到的第三方 node 包</span><br>src                         <span class="hljs-comment">//放的是项目的源代码</span><br>src/main<span class="hljs-variable">.js</span>                  <span class="hljs-comment">//整个项目的入口文件</span><br>src/app<span class="hljs-variable">.vue</span>                 <span class="hljs-comment">//整个项目最原始的根组件</span><br>src/router/index<span class="hljs-variable">.js</span>          <span class="hljs-comment">//项目的路由放置位置</span><br>src/components               <span class="hljs-comment">//项目中要用到的小组件</span><br>src/assets                  <span class="hljs-comment">//项目中需要用到的图片</span><br><span class="hljs-keyword">config</span>                      <span class="hljs-comment">//放置项目配置文件</span><br><span class="hljs-keyword">config</span>/index<span class="hljs-variable">.js</span>              <span class="hljs-comment">//放基础配置</span><br><span class="hljs-keyword">config</span>/dev<span class="hljs-variable">.ent</span><span class="hljs-variable">.js</span>            <span class="hljs-comment">//开发环境配置信息</span><br><span class="hljs-keyword">config</span>/prod<span class="hljs-variable">.ent</span><span class="hljs-variable">.js</span>           <span class="hljs-comment">//线上环境配置信息</span><br>build                      <span class="hljs-comment">//放置项目打包的 webpack 配置信息，vue-cli 会自动构建</span><br>build/webpack<span class="hljs-variable">.base</span><span class="hljs-variable">.conf</span><span class="hljs-variable">.js</span>   <span class="hljs-comment">//基础的 webpack 配置信息</span><br>build/webpack<span class="hljs-variable">.dev</span><span class="hljs-variable">.conf</span><span class="hljs-variable">.js</span>    <span class="hljs-comment">//开发环境的 webpack 配置信息</span><br>build/webpack<span class="hljs-variable">.prod</span><span class="hljs-variable">.conf</span><span class="hljs-variable">.js</span>   <span class="hljs-comment">//线上环境的 webpack 配置信息</span><br></code></pre></td></tr></table></figure><h3 id="项目代码初始化"><a href="#项目代码初始化" class="headerlink" title="项目代码初始化"></a>项目代码初始化</h3><p>由于做的是webapp，所以需要针对移动端，做相应的准备。</p><ol><li> meta标签相关设置</li></ol><p>项目中的  index.html</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>效果：页面比例始终是1：1，用户通过手指操作缩放是无效的</p><ol start="2"><li>引入reset.css<br>目的：重置页面样式</li></ol><p>因为在不同移动端、不同浏览器上页面的初始样式是不一样的，引入reset.css为了保证在每个浏览器上展示出的初始效果是一样的</p><ol start="3"><li>引入border.css</li></ol><p>目的：解决移动端1像素边框问题  原因，不同手机上显示的像素不同(可能有二倍屏，多倍屏)</p><p>main.js中代码导入</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span>  fastClick  <span class="hljs-keyword">from</span>  <span class="hljs-string">&#x27;fastclick&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./assets/styles/reset.css&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./assets/styles/border.css&#x27;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>项目中安装fastclick</li></ol><p>npm install fastclick –save</p><p>目的：解决移动端300ms延迟问题</p><p>移动端浏览器click事件为什么会有300ms的延迟呢？因为在手机上有个双击方案 —— 在手机上快速点击两下，实现页面放大；再次双击，恢复到原始比例。</p><p>那它是如何实现的呢？浏览器在捕捉到第一次点击事件后，会等待一段时间，如果在这段时间内，用户没有再次进行点击操作的话，就执行单击事件；如果用户进行了第二次点击操作的话，就会执行双击事件。这段等待的时间大约300ms。</p><ol start="5"><li>Iconfont阿里巴巴矢量图标注册账号使用</li></ol><h3 id="单页应用与多页应用"><a href="#单页应用与多页应用" class="headerlink" title="单页应用与多页应用"></a>单页应用与多页应用</h3><p><img src="/image1/5.png" alt="对比"></p><p>本项目页面采用的是单页页面</p><h3 id="项目下方报error解决"><a href="#项目下方报error解决" class="headerlink" title="项目下方报error解决"></a>项目下方报error解决</h3><p>问题：由于esLint校验导致报错或警告</p><p><img src="/image1/6.png" alt="error"></p><p>解决</p><p><img src="/image1/7.png" alt="注释"></p>]]></content>
    
    
    <categories>
      
      <category>Vue项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue&amp;插槽</title>
    <link href="/2021/05/01/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%BA%94)/"/>
    <url>/2021/05/01/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%BA%94)/</url>
    
    <content type="html"><![CDATA[<p>槽，也就是slot，是组件的一块HTML模板，这块模板显示不显示、以及怎样显示由父组件来决定。 实际上，一个slot最核心的两个问题在这里就点出来了，是显示不显示和怎样显示。</p><p>由于插槽是一块模板，所以，对于任何一个组件，从模板种类的角度来分，其实都可以分为非插槽模板和插槽模板两大类。 非插槽模板指的是html模板，比如‘div、span、ul、table’这些，非插槽模板的显示与隐藏以及怎样显示由组件自身控制；插槽模板是slot，它是一个空壳子，因为它的显示与隐藏以及最后用什么样的html模板显示由父组件控制。但是插槽显示的位置却由子组件自身决定，slot写在组件template的什么位置，父组件传过来的模板将来就显示在什么位置。</p><hr><h3 id="单个插槽-默认插槽-匿名插槽"><a href="#单个插槽-默认插槽-匿名插槽" class="headerlink" title="单个插槽 | 默认插槽 | 匿名插槽"></a>单个插槽 | 默认插槽 | 匿名插槽</h3><p>首先是单个插槽，单个插槽是vue的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置name属性。</p><p>单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（name属性）不同就可以了。</p><p>下面通过一个例子来展示。</p><p>父组件：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;template&gt;<br>    &lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">father</span>&quot;&gt;<br>        &lt;<span class="hljs-symbol">h3</span>&gt;这里是父组件&lt;/<span class="hljs-symbol">h3</span>&gt;<br>        &lt;<span class="hljs-symbol">child</span>&gt;<br>            &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">tmpl</span>&quot;&gt;<br>              &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>              &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>              &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>              &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>              &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">5</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>              &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">6</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>            &lt;/<span class="hljs-symbol">div</span>&gt;<br>        &lt;/<span class="hljs-symbol">child</span>&gt;<br>    &lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;/<span class="hljs-symbol">template</span>&gt;<br></code></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>这里是子组件<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这个例子里，因为父组件在里面写了html模板，那么子组件的匿名插槽这块模板就是下面这样。也就是说，子组件的匿名插槽被使用了，是被下面这块模板使用了。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">tmpl</span>&quot;&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">3</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">4</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">5</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>  &lt;<span class="hljs-symbol">span</span>&gt;菜单<span class="hljs-symbol">6</span>&lt;/<span class="hljs-symbol">span</span>&gt;<br>&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>匿名插槽没有name属性，所以是匿名插槽，那么，插槽加了name属性，就变成了具名插槽。具名插槽可以在一个组件中出现N次，出现在不同的位置。下面的例子，就是一个有两个具名插槽和单个插槽的组件，这三个插槽被父组件用同一套css样式显示了出来，不同的是内容上略有区别。</p><p>父组件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>这里是父组件<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tmpl&quot;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;up&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单4<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单5<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单6<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tmpl&quot;</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;down&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-4<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-5<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-6<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tmpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-&gt;1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-&gt;2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-&gt;3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-&gt;4<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-&gt;5<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>菜单-&gt;6<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;template&gt;<br>  &lt;div <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">child</span>&quot;&gt;<br>    // 具名插槽<br>    &lt;<span class="hljs-symbol">slot</span> <span class="hljs-symbol">name</span>=&quot;<span class="hljs-symbol">up</span>&quot;&gt;&lt;/<span class="hljs-symbol">slot</span>&gt;<br>    &lt;<span class="hljs-symbol">h3</span>&gt;这里是子组件&lt;/<span class="hljs-symbol">h3</span>&gt;<br>    // 具名插槽<br>    &lt;<span class="hljs-symbol">slot</span> <span class="hljs-symbol">name</span>=&quot;<span class="hljs-symbol">down</span>&quot;&gt;&lt;/<span class="hljs-symbol">slot</span>&gt;<br>    // 匿名插槽<br>    &lt;<span class="hljs-symbol">slot</span>&gt;&lt;/<span class="hljs-symbol">slot</span>&gt;<br>  &lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;/<span class="hljs-symbol">template</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="具名插槽的缩写"><a href="#具名插槽的缩写" class="headerlink" title="具名插槽的缩写"></a>具名插槽的缩写</h4><p>跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header：</p><h3 id="作用域插槽-带数据的插槽"><a href="#作用域插槽-带数据的插槽" class="headerlink" title="作用域插槽 | 带数据的插槽"></a>作用域插槽 | 带数据的插槽</h3><p>最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的template里面写</p><p>匿名插槽</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;slot&gt;</span><span class="hljs-section">&lt;/slot&gt;</span><br></code></pre></td></tr></table></figure><p>具名插槽</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;up&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是作用域插槽要求，在slot上面绑定数据。也就是你得写成大概下面这个样子。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs elixir">&lt;slot name=<span class="hljs-string">&quot;up&quot;</span> <span class="hljs-symbol">:data=<span class="hljs-string">&quot;data&quot;</span>&gt;&lt;/slot&gt;</span><br> export default &#123;<br>    <span class="hljs-symbol">data:</span> function()&#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-symbol">data:</span> [<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-string">&#x27;lisi&#x27;</span>,<span class="hljs-string">&#x27;wanwu&#x27;</span>,<span class="hljs-string">&#x27;zhaoliu&#x27;</span>,<span class="hljs-string">&#x27;tianqi&#x27;</span>,<span class="hljs-string">&#x27;xiaoba&#x27;</span>]<br>      &#125;<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>我们前面说了，插槽最后显示不显示是看父组件有没有在child下面写模板，像下面那样。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;child&gt;</span><br>   <span class="hljs-attribute">html</span>模板<br><span class="hljs-section">&lt;/child&gt;</span><br></code></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://juejin.cn/post/6844903555837493256#heading-0">深入理解vue中的slot与slot-scope</a></p><p><a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD">官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue&amp;组件之间的传值通信&amp;props$&amp;$emits&amp;ref/refs</title>
    <link href="/2021/05/01/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/"/>
    <url>/2021/05/01/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="vue变量赋值的时候，在什么时候用双引号，什么时候用单引号，什么时候不用引号"><a href="#vue变量赋值的时候，在什么时候用双引号，什么时候用单引号，什么时候不用引号" class="headerlink" title="vue变量赋值的时候，在什么时候用双引号，什么时候用单引号，什么时候不用引号"></a>vue变量赋值的时候，在什么时候用双引号，什么时候用单引号，什么时候不用引号</h3><p>变量值赋值的时候要根据是什么类型来给对应的符号</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">String 字符串 类型的加双引号       <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;陈钰&quot;</span>;<br><br>char   字符     类型的加单引号       <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;男&#x27;</span>;<br><br>boolean 布尔值  类型的不加引号     <span class="hljs-attribute">isShow</span>=<span class="hljs-literal">true</span>;<br><br>number 数字      类型的不加引号     <span class="hljs-attribute">num</span>=18;<br><br>只要不是char字符类型，String字符串类型，其他的类型都不需要加引号<br></code></pre></td></tr></table></figure><p>在vue中也是如此，只不过在data里面的赋值符号要改一下,把等号改为冒号，把最后面的分号改为逗号</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> 字符串 类型的加双引号       name:<span class="hljs-string">&quot;陈钰&quot;</span>,<br><br><span class="hljs-keyword">char</span>   字符     类型的加单引号       sex:<span class="hljs-string">&#x27;男&#x27;</span>,<br><br><span class="hljs-keyword">boolean</span> 布尔值  类型的不加引号     isShow:<span class="hljs-literal">true</span>,<br><br>number 数字      类型的不加引号     num:<span class="hljs-number">18</span>,<br></code></pre></td></tr></table></figure><p>在计算机语言中，大多数单引号表示的是一个字符，双引号表示的是表示一个字符串</p><p>前端HTML和Javascript建议统一使用双引号</p><p>在<code>&#123;&#123;&#125;&#125;</code>内的双引号内的是字符串<br>在标签的属性中的双引号内的变量</p><h3 id="请详细说下你对vue生命周期的理解"><a href="#请详细说下你对vue生命周期的理解" class="headerlink" title="请详细说下你对vue生命周期的理解"></a>请详细说下你对vue生命周期的理解</h3><p>vue生命周期总共分为8个阶段: 创建前/后，载入前/后，更新前/后， 销毁前/后。</p><ul><li>beforeCreate （创建前）vue实例的挂载元素$el和数据对象 data都是undefined, 还未初始化</li><li>created (创建后) 完成了 data数据初始化, el还未初始化</li><li>beforeMount (载入前) vue实例的$el和data都初始化了, 相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。</li><li>mounted (载入后) 在el 被新创建的 vm.$el替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互</li><li>beforeUpdate (更新前) 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。</li><li>updated （更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li><li>beforeDestroy (销毁前） 在实例销毁之前调用。实例仍然完全可用。</li><li>destroyed (销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</li></ul><h3 id="组件之间的传值通信"><a href="#组件之间的传值通信" class="headerlink" title="组件之间的传值通信"></a>组件之间的传值通信</h3><p>组件之间通讯分为三种: 父传子、子传父、兄弟组件之间的通讯<br>父组件通过props的方式向子组件传递数据，而通过$emit 子组件可以向父组件通信。          </p><ol><li>父组件给子组件传值<br>使用props，父组件可以使用props向子组件传递数据。</li></ol><p>父组件vue模板father.vue:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child.vue&#x27;</span>;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>    components: &#123;<br>        child<br>    &#125;,<br>    data () &#123;<br><span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">            message: <span class="hljs-string">&#x27;father message&#x27;</span>;</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子组件vue模板child.vue:</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">msg</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">export default &#123;</span><br><span class="xml">    props: &#123;</span><br><span class="xml">        msg: &#123;</span><br><span class="xml">            type: String,</span><br><span class="xml">            required: true</span><br><span class="xml">        &#125;</span><br><span class="xml">    &#125;</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="2"><li>子组件向父组件通信<br>父组件向子组件传递事件方法，子组件通过$emit触发事件，回调给父组件。</li></ol><p>父组件vue模板father.vue:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child</span> @<span class="hljs-attr">msgFunc</span>=<span class="hljs-string">&quot;func&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child.vue&#x27;</span>;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>    components: &#123;<br>        child<br>    &#125;,<br>    methods: &#123;<br>        func (msg) &#123;<br><span class="javascript">            <span class="hljs-built_in">console</span>.log(msg);</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子组件vue模板child.vue:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>点我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>    props: &#123;<br>        msg: &#123;<br><span class="javascript">            type: <span class="hljs-built_in">String</span>,</span><br><span class="javascript">            required: <span class="hljs-literal">true</span></span><br>        &#125;<br>    &#125;,<br>    methods () &#123;<br>        handleClick () &#123;<br><span class="javascript">            <span class="hljs-comment">//........</span></span><br><span class="javascript">            <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;msgFunc&#x27;</span>);</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>非父子, 兄弟组件之间通信<br>vue2中废弃了dispatch和broadcast广播和分发事件的方法。父子组件中可以用props和$emit()。如何实现非父子组件间的通信，可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，然后通过分别调用Bus事件触发和监听来实现通信和参数传递。 Bus.js可以是这样:<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vue()<br></code></pre></td></tr></table></figure>在需要通信的组件都引入Bus.js:<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toBus&quot;</span>&gt;</span>子组件传给兄弟组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">import Bus from &#x27;../common/js/bus.js&#x27;</span><br><span class="xml">export default</span><span class="xquery">&#123;</span><br><span class="xquery">methods: &#123;</span><br><span class="xquery">    toBus () &#123;</span><br><span class="xquery">        Bus.<span class="hljs-variable">$emit</span>(<span class="hljs-string">&#x27;on&#x27;</span>, <span class="hljs-string">&#x27;来自兄弟组件&#x27;</span>)</span><br><span class="xquery">    &#125;</span><br><span class="xml">  &#125;</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>另一个组件也import Bus.js 在钩子函数中监听on事件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Bus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../common/js/bus.js&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        message: <span class="hljs-string">&#x27;&#x27;</span><br>      &#125;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>       Bus.$on(<span class="hljs-string">&#x27;on&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> &#123;<br>         <span class="hljs-built_in">this</span>.message = msg<br>       &#125;)<br>     &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="ref-refs"><a href="#ref-refs" class="headerlink" title="ref / refs"></a>ref / refs</h3><p>访问子组件实例或子元素<br>尽管存在 prop 和事件，有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。为了达到这个目的，你可以通过 ref 这个 attribute 为子组件赋予一个 ID 引用。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">&lt;<span class="hljs-keyword">base</span>-input <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;usernameInput&quot;</span>&gt;&lt;/<span class="hljs-keyword">base</span>-input&gt;<br></code></pre></td></tr></table></figure><p>现在在你已经定义了这个 ref 的组件里，你可以使用：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">this</span>.$<span class="hljs-built_in">ref</span>s.usernameInput<br></code></pre></td></tr></table></figure><p>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据， 我们看一个ref 来访问组件的例子:</p><p>// 子组件 A.vue</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      name: <span class="hljs-string">&#x27;Vue.js&#x27;</span><br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    sayHello () &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>// 父组件 app.vue</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">component-a</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;comA&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component-a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br>    mounted () &#123;<br><span class="javascript">      <span class="hljs-keyword">const</span> comA = <span class="hljs-built_in">this</span>.$refs.comA;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(comA.name);  <span class="hljs-comment">// Vue.js</span></span><br><span class="javascript">      comA.sayHello();  <span class="hljs-comment">// hello</span></span><br>    &#125;<br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>$refs 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 $refs。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2021/04/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%A7%A3(%E4%B8%80)/"/>
    <url>/2021/04/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%A7%A3(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h2 id="操作系统相当于一个特殊的软件：这种软件对上服务着我们用户的程序，对下管理硬件。"><a href="#操作系统相当于一个特殊的软件：这种软件对上服务着我们用户的程序，对下管理硬件。" class="headerlink" title="操作系统相当于一个特殊的软件：这种软件对上服务着我们用户的程序，对下管理硬件。"></a>操作系统相当于一个特殊的软件：这种软件对上服务着我们用户的程序，对下管理硬件。</h2><h3 id="操作系统主要做什么"><a href="#操作系统主要做什么" class="headerlink" title="操作系统主要做什么"></a>操作系统主要做什么</h3><p><img src="/image/24.1.png" alt="管理硬件，管理应用"></p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>假设你的键盘按下了ctrl+deletel键要求马上给一个反馈杀死某个程序，机器内核跑的好好的，突然过来一个东西，这时候会断掉一下。这叫做操作系统中断。</p><h3 id="进程，线程（-）"><a href="#进程，线程（-）" class="headerlink" title="进程，线程（*）"></a>进程，线程（*）</h3><p>程序：硬盘上某一个可执行文件就是程序  (例如：qq.exe)</p><p>你双击一下就是一个进程，你再双击一下就又是一个进程，进程就是这个程序跑起来了，放到内存里开始执行了，CPU开始执行他的指令了就叫一个进程。在这个进程中有好多个工作是并行进行的，比如（qq在显示页面，网络传输，存盘），那么是怎么执行的呢，就是通过线程来。</p><h4 id="纤程"><a href="#纤程" class="headerlink" title="纤程"></a>纤程</h4><p>在一个线程中还可以做并行任务，一个线程里面不同的执行路径同时可以执行的那种，叫纤程。java中叫fiber.</p><h2 id="区别：进程是分配资源的单位，线程进行执行，调度单位。"><a href="#区别：进程是分配资源的单位，线程进行执行，调度单位。" class="headerlink" title="区别：进程是分配资源的单位，线程进行执行，调度单位。"></a>区别：进程是分配资源的单位，线程进行执行，调度单位。</h2><p>（解释：如果我启动一个进程的时候，我是会分配一个内存空间的，这个是虚拟内存最后映射到物理内存上也是会给它分配物理空间的，起线程的时候不会给线程分配任何物理空间，这个线程共享了进程的物理空间）</p><h3 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3><p>一共有四种，了解这两种宏外核，微内核（还有系统外核，VMM）</p><p>功能：<br>调度CPU，内存管理，管理文件，管理文件系统，处理中断，管理应用，进行进程调度</p><p><img src="/image/24.2.png" alt="功能"></p><ol><li>宏内核–操作系统的东西全部都集中在一起<br>操作系统的核心包括周边的东西叫宏内核</li></ol><p><img src="/image/24.3.png" alt="宏内核"></p><ol start="2"><li>微内核—-全球的大厂商的都在做，微软，苹果，谷歌，华为。华为首先推出商用的鸿蒙系统。<h4 id="微内核的核心就干一个事就是进程调度。"><a href="#微内核的核心就干一个事就是进程调度。" class="headerlink" title="微内核的核心就干一个事就是进程调度。"></a>微内核的核心就干一个事就是进程调度。</h4>所有的东西都是以内核为核心，cpu调度文件系统则访问内核，内核去访问文件系统。核心非常小，周围一堆的插件。缺点是运行速度稍低，优点是你可以做到非常灵活的部署，可以做到很灵活的拆装。</li></ol><p><img src="/image/24.4.png" alt="微内核"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript同步与异步</title>
    <link href="/2021/04/27/JS%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/"/>
    <url>/2021/04/27/JS%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p>JavaScript起源<br>技术的出现,和应用场景密切相关的。JavaScript诞生于1995年。当时，它的主要目的是处理以前由服务器端语言（如Perl）负责的一些输入验证操作。在JavaScript问世之前，必须把表单数据发送到服务器端才能确定用户是否没有填写某个必填域，是否输入了无效的值。Netscape Navigator希望通过JavaScript来解决这个问题。起初名字为livescript，但是后来Netscape(网景)与Sun公司成立了一个开发联盟。Netscape为了搭上媒体热炒Java的顺风车，临时把LiveScript改名为JavaScript，所以从本质上来说JavaScript和Java没什么关系（趁热度）。 如今，JavaScript的用途早已不再局限于简单的数据验证，而是具备了与浏览器窗口及其内容等几乎所有方面交互的能力。今天的JavaScript已经成为一门功能全面的编程语言</p><p>总结:js最初的用途是为来实现用户与浏览器的交互</p><hr><h3 id="JS为何是单线程的？"><a href="#JS为何是单线程的？" class="headerlink" title="JS为何是单线程的？"></a>JS为何是单线程的？</h3><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成这门语言的核心特征，将来也不会改变。</p><p>注：所谓单线程，是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个</p><h3 id="计算机的同步与异步（重点）–与生活中相反"><a href="#计算机的同步与异步（重点）–与生活中相反" class="headerlink" title="计算机的同步与异步（重点）–与生活中相反"></a>计算机的同步与异步（重点）–与生活中相反</h3><p>计算机领域中的同步（Synchronous）和异步（Asynchronous）和我们生活中的同步和异步的概念是恰好相反的。生活中的同步，突出的是‘同’，相同的步伐，是咱俩一起行动，比如一起去逛街吃饭饭睡觉觉。异步则是你忙你的，我忙我的，步调不致且互不干扰。难到计算机里的同步和异步不是这样？确实不是。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>计算机中的同步就是排队等待，假如你是第一百零一个备胎，那你只能等前面的一百个爆了之后才能‘处理’你。异步就是，尽管你是第一百零一个，她还是能照顾到你的感受。</p><h4 id="同步："><a href="#同步：" class="headerlink" title="同步："></a>同步：</h4><p>同步的定义：是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么，这个进程将会一直等待下去，直到收到返回信息才继续执行下去。</p><p>特点：<br>同步是阻塞模式；<br>同步是按顺序执行，执行完一个再执行下一个，需要等待，协调运行；                    </p><h4 id="异步："><a href="#异步：" class="headerlink" title="异步："></a>异步：</h4><p>是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。<br>特点：<br>异步是非阻塞模式，无需等待；<br>异步是彼此独立，在等待某事件的过程中，继续做自己的事，不需要等待这一事件完成后再工作。线程是异步实现的一个方式。</p><h4 id="同步与异步的优缺点："><a href="#同步与异步的优缺点：" class="headerlink" title="同步与异步的优缺点："></a>同步与异步的优缺点：</h4><p>同步可以避免出现死锁，读脏数据的发生。一般共享某一资源的时候，如果每个人都有修改权限，同时修改一个文件，有可能使一个读取另一个人已经删除了内容，就会出错，同步就不会出错。但，同步需要等待资源访问结束，浪费时间，效率低。</p><p>异步可以提高效率，但，安全性较低。</p><h3 id="js单线程为什么会有’异步’问题"><a href="#js单线程为什么会有’异步’问题" class="headerlink" title="js单线程为什么会有’异步’问题"></a>js单线程为什么会有’异步’问题</h3><p>js是同步的？<br>是的，单线程，那肯定只能同步(排队)执行咯</p><p>js为什么需要异步?<br>如果JS中不存在异步,只能自上而下执行,万一上一行解析时间很长,那么下面的代码就会被阻塞。 对于用户而言,阻塞就意味着”卡死”,这样就导致了很差的用户体验</p><p>js单线程又是如何实现异步的呢?<br>通过事件循环(event loop) 实现’异步’</p><p>经典问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>)<br>&#125;,<span class="hljs-number">0</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>)  <br><span class="hljs-comment">//       1，3，2</span><br></code></pre></td></tr></table></figure><p>也就是说,setTimeout里的函数并没有立即执行,而是延迟了一段时间,满足一定条件后,才去执行的,这类代码,我们叫异步代码。</p><p>所以,这里我们首先知道了JS里的一种分类方式,就是将任务分为: 同步任务和异步任务</p><p><img src="/image/23.png" alt="如图"></p><p>虽然JS是单线程的但是浏览器的内核是多线程的，在浏览器的内核中不同的异步操作由不同的浏览器内核模块调度执行，异步操作会将相关回调添加到任务队列中。而不同的异步操作添加到任务队列的时机也不同，如 onclick, setTimeout, ajax 处理的方式都不同，这些异步操作是由浏览器内核的 webcore 来执行的，webcore 包含上图中的3种 webAPI，分别是 DOM Binding、network、timer模块。</p><p>按照这种分类方式:JS的执行机制是</p><p>首先判断js代码是同步还是异步,同步就进入主进程,异步就进入event table<br>异步任务在event table中注册函数,当满足触发条件后,被推入event queue<br>同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主进程中 以上三步循环执行,这就是event loop<br>总结：同步可以保证顺序一致，但是容易导致阻塞；异步可以解决阻塞问题，但是会改变顺序性，根据不同的需要去写你的代码。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844903810263941134">前端面试：js同步与异步问题</a></p><p><a href="https://www.cnblogs.com/sunshine-blog/p/8392576.html">《计算机操作系统》总结（三）—同步与异步</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript闭包</title>
    <link href="/2021/04/26/JS%E9%97%AD%E5%8C%85%E7%90%86%E8%A7%A3/"/>
    <url>/2021/04/26/JS%E9%97%AD%E5%8C%85%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>闭包并不是需要学习新的语法才能使用的工具。闭包的产生是基于词法作用域写代码时自然产生的结果。换句话说，你不需要要为了闭包而写闭包，闭包在我们写的代码中随处可见。当你真正了解闭包之后，会发现，哦~，原来我以前所敲的代码中已经出现了很多闭包！</p><hr><h3 id="一个小-demo"><a href="#一个小-demo" class="headerlink" title="一个小 demo"></a>一个小 demo</h3><p>仔细看看下面的例子我们会感到奇怪，明明都是调用result(),为什么结果会不一样呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> count=<span class="hljs-number">500</span> <span class="hljs-comment">//全局作用域</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<span class="hljs-comment">//函数全局作用域</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    count++;<span class="hljs-comment">//函数内部作用域</span><br>    <span class="hljs-built_in">console</span>.log(count);<br>    <span class="hljs-keyword">return</span> count;<br>  &#125;<br>  <span class="hljs-keyword">return</span> foo2;<span class="hljs-comment">//返回函数</span><br>&#125;<br><span class="hljs-keyword">let</span> result = foo1();<br>result();<span class="hljs-comment">//结果为1</span><br>result();<span class="hljs-comment">//结果为2</span><br></code></pre></td></tr></table></figure><p>首先foo1()返回的是一个foo2()函数,当我们调用result()的时候就会返回foo2()执行的函数,foo2()里面有什么呢? 首先我们看到如下有一个count变量,但是没有定义.我们根据JavaScript的作用域链的定义可知,当函数内部的变量没有定义的时候,就会采用冒泡的方式,向上一级寻找.上一级没有接着上一级找,直到最顶层window. 如果都没有,就会报undefined的错误.这里我们在foo1()中找到了count,于是count+1,第一次输出的是1,没有什么问题.</p><p>但是第二次我们再执行result()的时候就出现了问题,为什么会是2呢?按照流程,首先再foo2()函数内部寻找count,没有然后到外层寻找,找到了count=0,这时候count+1应该为1才对.这里就涉及到闭包的问题了.</p><p><img src="/image/22.png" alt="debugger"></p><p>首先我们在原来的代码中加一个debugger,然后到谷歌浏览器右键检查,点击sources就可以看到右边有一个Closure,浏览器的可视化已经证实了这的确是一个闭包.并且count=1已经存储在了Closure之中.也就说明count=1没有被销毁,等下次在调用result()的时候count=2.</p><h3 id="认识作用域"><a href="#认识作用域" class="headerlink" title="认识作用域"></a>认识作用域</h3><p>作用域包括：</p><ol><li>全局作用域</li><li>函数作用域</li><li>块级作用域(es6 新出,解决 var 问题, 新增 let, const)</li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">var</span> <span class="hljs-keyword">count</span> = 100; <span class="hljs-comment">//全局作用域</span><br> function foo1() &#123;<br>   <span class="hljs-keyword">var</span> <span class="hljs-keyword">count</span> = 0; <span class="hljs-comment">//函数全局作用域</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">count</span>; <span class="hljs-comment">//返回函数</span><br> &#125;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">count</span> == 1) &#123;<br>   <span class="hljs-comment">//块级作用域</span><br>   console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">count</span>);<br> &#125;<br></code></pre></td></tr></table></figure><p>上面代码简单可以看出作用域分类,需要注意是,一个函数(function)也是块级作用域,简单来说,一般有 {}都可以算做是一个块级作用域.</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>作用域里面嵌套作用域,就形成了作用域链. 外部作用域无法访问内部的作用域,看如下例子</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">function foo()&#123;<br><span class="hljs-selector-tag">var</span> n=<span class="hljs-number">1</span><br>function foo2()&#123;<br>  <span class="hljs-selector-tag">var</span> m=<span class="hljs-number">1</span><br>  console<span class="hljs-selector-class">.log</span>(n) <span class="hljs-comment">//1</span><br>&#125;<br><span class="hljs-function"><span class="hljs-title">foo2</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br>console<span class="hljs-selector-class">.log</span>(n) <span class="hljs-comment">//err: n is not defined</span><br></code></pre></td></tr></table></figure><p>上述代码中在全局中无法访问内部的n,但是在嵌套的内部foo2()可以访问外部的函数,这就是作用域产生的特殊效果.</p><p>明白了作用域链,我们再来看个例子(很有迷惑性,仔细看看哦):</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">var name = <span class="hljs-string">&#x27;Mike&#x27;</span>; <span class="hljs-regexp">//</span>第一次定义name<br> <span class="hljs-keyword">function</span> showName() &#123;<br>   console.log(name);  <span class="hljs-regexp">//</span>输出 Mike 还是 Jay ？     <br> &#125;<br><br> <span class="hljs-keyword">function</span> changeName() &#123;<br>   var name = <span class="hljs-string">&#x27;Jay&#x27;</span>; <span class="hljs-regexp">//</span>重新定义name<br>   showName(); <span class="hljs-regexp">//</span>调用showName()<br> &#125;<br> changeName();<span class="hljs-regexp">//</span>Mike<br><br></code></pre></td></tr></table></figure><p>以上两个输出的均为Mike,在这里我们引出了一个新的概念,词法作用域 作用域有两种模型:</p><ul><li>词法作用域（静态）：js查找是按照代码书写时候的位置来决定的，而不是按照调用时候位置</li><li>动态作用域：目前还有使用的有Perl，Bash (可以自行了解)</li></ul><ol><li>调用changeName()时,找到这个函数</li><li>定义var name = “Jay”</li><li>调用showName()</li><li>在changeName()里面查找是否有showName()这个方法,发现没有,向外层查找,找到了</li><li>调用console.log(name),在函数内部查找有没有name,没有,向外查找,找到了,name=”Mike”</li><li>输出Mike</li></ol><h2 id="闭包：闭包就是能够读取其他函数内部变量的函数"><a href="#闭包：闭包就是能够读取其他函数内部变量的函数" class="headerlink" title="闭包：闭包就是能够读取其他函数内部变量的函数"></a>闭包：闭包就是能够读取其他函数内部变量的函数</h2><h3 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h3><p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p><p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p><h3 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h3><p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。<br>怎么来理解这句话呢？请看下面的代码。<br>Js代码</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>nAdd = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;<br>n += <span class="hljs-number">1</span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123;<br>alert(n);<br>&#125;<br><span class="hljs-keyword">return</span> f2;<br>&#125;<br><span class="hljs-keyword">var</span> result = f1();<br>result(); <span class="hljs-comment">// 999</span><br>nAdd();<br>result(); <span class="hljs-comment">// 1000</span><br></code></pre></td></tr></table></figure><p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p><p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p><p>这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个</p><p>匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/6844904161268482062#heading-4">javascript 近乎神话般的概念：闭包</a></p><p><a href="https://my.oschina.net/u/3693769/blog/1544436">JavaScript 闭包</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVC&amp;MVVM</title>
    <link href="/2021/04/26/MVC&amp;MVVM%E7%90%86%E8%A7%A3/"/>
    <url>/2021/04/26/MVC&amp;MVVM%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>MVVM和MVC总结</p><hr><h3 id="什么是MVVM？"><a href="#什么是MVVM？" class="headerlink" title="什么是MVVM？"></a>什么是MVVM？</h3><p>MVVM 由 Model、View、ViewModel 三部分构成</p><ol><li>View 层</li></ol><p>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。</p><ol start="2"><li><p>Model 层<br>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</p></li><li><p>ViewModel 是一个同步View 和 Model的对象；</p></li></ol><p><img src="/image/20.1.png" alt="MVVM"></p><p>MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用</p><p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p><h3 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h3><p>MVC是Model-View-Controller的缩写，即模型—视图—控制器</p><ul><li>Model：后端传递的 数据 。</li><li>View：所看到的 页面 。</li><li>Controller：页面 业务逻辑 。</li></ul><ol><li>MVC是 单向通信。即View和Model，必须通过Controller来承上启下。</li><li>使用MVC的 目的 就是 将M和V的代码分离 。</li></ol><h3 id="MVC和MVVM的区别"><a href="#MVC和MVVM的区别" class="headerlink" title="MVC和MVVM的区别"></a>MVC和MVVM的区别</h3><p>mvc 和 mvvm 都是一种设计思想。主要就是 把mvc 中 Controller 演变成 mvvm 中的viewModel。MVC和MVVM的区别并不是VM完全取代了C，只是在MVC的基础上增加了一层VM，只不过是弱化了C的概念，ViewModel存在目的在于抽离Controller中展示的业务逻辑，而不是替代Controller，其它视图操作业务等还是应该放在Controller中实现。</p><h4 id="mvvm-主要解决了-mvc-中大量的-DOM-操作使页面渲染性能降低，加载速度变慢，影响用户体验的缺点。当-Model-频繁发生变化，开发者都需要主动更新到-View-。MVVM实现的是业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。"><a href="#mvvm-主要解决了-mvc-中大量的-DOM-操作使页面渲染性能降低，加载速度变慢，影响用户体验的缺点。当-Model-频繁发生变化，开发者都需要主动更新到-View-。MVVM实现的是业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。" class="headerlink" title="mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验的缺点。当 Model 频繁发生变化，开发者都需要主动更新到 View 。MVVM实现的是业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。"></a>mvvm 主要解决了 mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验的缺点。当 Model 频繁发生变化，开发者都需要主动更新到 View 。MVVM实现的是业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。</h4><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://juejin.cn/post/6844903918753808398#heading-20">什么是 MVVM？</a></p><p><a href="https://zhuanlan.zhihu.com/p/192341615">知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>豆瓣&amp;搜索页面布局&amp;详情评分bug解决</title>
    <link href="/2021/04/25/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E5%85%AD)/"/>
    <url>/2021/04/25/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E5%85%AD)/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV17p4y1b7eP">项目视频演示地址</a></p><hr><h3 id="搜索页面样式布局完成"><a href="#搜索页面样式布局完成" class="headerlink" title="搜索页面样式布局完成"></a>搜索页面样式布局完成</h3><p>要完成样式</p><p><img src="/image/19.11.png" alt="页面样式"></p><ol><li>search.wxml</li></ol><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cos">&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;item-list-group&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;item-group&quot;</span>&gt;<br>&lt;image  src=<span class="hljs-string">&quot;https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2635676317.webp&quot;</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;thumbnail&quot;</span>&gt;&lt;/image&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;info-group&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;六人-泰坦尼克上的中国幸存者&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;rate-year&quot;</span>&gt;<span class="hljs-number">8.5</span>分/<span class="hljs-number">2020</span>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>search.wxss</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-list-group</span>&#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10</span>rpx  <span class="hljs-number">20</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.item-list-group</span>  <span class="hljs-selector-class">.item-group</span>&#123;<br>  <span class="hljs-attribute">padding</span>:<span class="hljs-number">10</span>rpx <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">/* 底部分割线 */</span><br>  <span class="hljs-attribute">border-bottom</span>:<span class="hljs-number">1px</span>  solid <span class="hljs-number">#e4e4e4</span>;<br>  <span class="hljs-comment">/* 左右分布布局 */</span><br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><span class="hljs-selector-class">.item-group</span> <span class="hljs-selector-class">.thumbnail</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">80</span>rpx;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.item-group</span> <span class="hljs-selector-class">.info-group</span>&#123;<br>  <span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">display</span>:flex;<br>  <span class="hljs-attribute">flex-direction</span>: column;<br>  <span class="hljs-attribute">justify-content</span>: space-between;<br>&#125;<br><br><span class="hljs-selector-class">.info-group</span> <span class="hljs-selector-class">.title</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.info-group</span> <span class="hljs-selector-class">.rate-year</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#7b7b7b</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>样式渲染完成，采用flex布局</p><h3 id="搜索功能实现"><a href="#搜索功能实现" class="headerlink" title="搜索功能实现"></a>搜索功能实现</h3><ol><li>搜索请求实现</li></ol><p>分析：1.在输入框中输入输入文字，那么就应该要获取到输入框中的文字了，但是输入框是单独放在<br>一个searchbar组件中，我们要获取的话没有那么方便   </p><p> 2.解决：在组件中监听输入框中input事件，将监听到的input输入框中输入的东西及时反馈，然后组件监听得到后再区触发另外一个事件，这样就可以传到外面了。</p><ol start="2"><li>代码实现</li></ol><p>bindinput事件是只要你在输入框中新增删除文字它都会去执行事件</p><p><img src="/image/19.13.png" alt="绑定事件"></p><p>searchbar.js</p><p>方法实现，组件主要复制将信息传递出去，执行在search中，这样职责划分更明确</p><p><img src="/image/19.14.png" alt="绑定事件"></p><p>search.wxml绑定查找事件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">searchbar</span>  <span class="hljs-attr">bindsearchinput</span>=<span class="hljs-string">&quot;onSearchInputEvent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">searchbar</span>&gt;</span><br></code></pre></td></tr></table></figure><p>serch.js监听事件</p><p><img src="/image/19.15.png" alt="绑定事件"></p><p>此时控制台type类型变为searchinput类型,能够得到用户输入的值</p><ol start="3"><li>发送网路请求url</li></ol><p>url.js</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">searchUrl: <span class="hljs-keyword">function</span> <span class="hljs-title"></span>(q) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">&quot;https://m.douban.com/rexxar/api/v2/search?type=movie&amp;q=&quot;</span> + q<br>&#125;<br></code></pre></td></tr></table></figure><p>network.js</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">// 搜索item</span><br>getSearch:function(<span class="hljs-keyword">params</span>)&#123;<br>  <span class="hljs-built_in">var</span> q =<span class="hljs-keyword">params</span>.q;<br>  <span class="hljs-built_in">var</span>  url = globalurls.searchUrl(q);<br>  wx.request(&#123;<br>    url: url,<br>    success:function(res)&#123;<br>      <span class="hljs-comment">// console.log(res);</span><br>      <span class="hljs-built_in">var</span>  subjects = res.<span class="hljs-built_in">data</span>.subjects;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">params</span>.success)&#123;<br>        <span class="hljs-keyword">params</span>.success(subjects);<br>      &#125;<br>    &#125;<br>  &#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>search.js</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">onSearchInputEvent:<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span></span>&#123;<br><span class="hljs-keyword">var</span>  that= <span class="hljs-keyword">this</span>;<br><span class="hljs-comment">// console.log(event)</span><br><span class="hljs-keyword">var</span>  value = event.detail.value;<br>network.getSearch(&#123;<br>  q:value,<br>  success:<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(subjects)</span></span>&#123;<br>        that.setData(&#123;<br>          subjects:subjects<br>        &#125;)<br>  &#125;<br>&#125;)<br>&#125;,<br></code></pre></td></tr></table></figure><p>因豆瓣Api限制访问，经常请求不到数据</p><p><img src="/image/19.12.png" alt="能够搜索"></p><ol start="4"><li>此时能够拿到数据，我们将数据渲染到页面</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">searchbar</span>  <span class="hljs-attr">bindsearchinput</span>=<span class="hljs-string">&quot;onSearchInputEvent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">searchbar</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-list-group&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">subjects</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span></span></span><br><span class="xml"> class=&quot;item-group&quot;  wx:key =&quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.id</span>&#125;&#125;</span><span class="xml">&quot;</span><br><span class="xml"> <span class="hljs-comment">&lt;!-- 绑定了一个点击事件，这样点击item可以跳转到详情页面中 --&gt;</span></span><br><span class="xml"> bindtap=&quot;onItemTapEvent&quot;  data-id=&quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.id</span>&#125;&#125;</span><span class="xml">&quot; &gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">image</span>  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.pic.normal</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;thumbnail&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;info-group&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rate-year&quot;</span>&gt;</span> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.rating.value</span>&#125;&#125;</span><span class="xml">分</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.year</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>绑定了一个点击事件，这样点击item可以跳转到详情页面中,同时获取id</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">bindtap</span>=<span class="hljs-string">&quot;onItemTapEvent&quot;</span>  <span class="hljs-class"><span class="hljs-keyword">data</span>-id=&quot;&#123;&#123;<span class="hljs-title">item</span>.<span class="hljs-title">id</span>&#125;&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>search.js</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gml">onItemTapEvent:<span class="hljs-keyword">function</span>(event)&#123;<br>   <span class="hljs-comment">// console.log(event)</span><br>   <span class="hljs-keyword">var</span> <span class="hljs-symbol">id</span> = event.currentTarget.dataset.<span class="hljs-symbol">id</span>;<br>   <span class="hljs-comment">// 跳转到某一个页面</span><br>   wx.navigateTo(&#123;<br>     url: <span class="hljs-string">&#x27;/pages/detail/detail?type=movie&amp;id=&#x27;</span>+<span class="hljs-symbol">id</span>,<br>   &#125;)<br> &#125;<br></code></pre></td></tr></table></figure><p>至此，点击电影也可以跳转到详情页面了</p><h3 id="历史搜索记录布局"><a href="#历史搜索记录布局" class="headerlink" title="历史搜索记录布局"></a>历史搜索记录布局</h3><p><img src="/image/19.16.png" alt="要完成的样式"></p><p>search.wxml</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cos">&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;history-list-group&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;history-title&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;历史记录&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;clear&quot;</span>&gt;清除&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;navigator  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;history-group&quot;</span>&gt;泰坦尼克号&lt;/navigator&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br></code></pre></td></tr></table></figure><p>search.wxss</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.history-list-group</span>&#123;<br>  <span class="hljs-attribute">padding</span>:<span class="hljs-number">10</span>rpx <span class="hljs-number">20</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.history-list-group</span> <span class="hljs-selector-class">.history-title</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: space-between;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20</span>rpx  <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#f9f9f9</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">28</span>rpx;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#9e9e9e</span>;<br>&#125;<br><span class="hljs-selector-class">.history-list-group</span>  <span class="hljs-selector-class">.history-group</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20</span>rpx <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">border-bottom</span>:<span class="hljs-number">1px</span>  solid  <span class="hljs-number">#e4e4e4</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>优化：history-group可以将它变为一个navigator组件，因为历史搜索是不需要任何操作的，可以直接从本地读取</p><h4 id="历史记录功能实现"><a href="#历史记录功能实现" class="headerlink" title="历史记录功能实现"></a>历史记录功能实现</h4><p>由于豆瓣api次数限制控制，搜索有时候请求不到，故这里并未实现</p><p><a href="https://study.163.com/course/courseLearn.htm?courseId=1208961810#/learn/video?lessonId=1278472316&courseId=1208961810">学习思路</a></p><h3 id="详情评分bug解决"><a href="#详情评分bug解决" class="headerlink" title="详情评分bug解决"></a>详情评分bug解决</h3><p>所有电影，综艺，电视剧评分均为9.7，因为我们这里写成固定的了</p><p><img src="/image/19.17.png" alt="rate"></p><p>代码修改</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">stars</span> <span class="hljs-attr">rate</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.rating.value</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">stars</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/image/19.18.png" alt="问题"></p><p>评论的评分是能够接收的，同理上面的星星评分也是能设置进来的。</p><p>分析：stars.js中代码问题</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">  lifetimes:&#123;<br>attached:<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">this</span>.updateRate();<br>&#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>问题原因：attached生命周期函数执行时，rate还没有设置进来，因为rate是通过网络请求加载出来的，需要时间加载进来，所以这时候rate为0默认值。</p><p>解决</p><p>stars.js</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs axapta">  properties: &#123;<br>  rate:&#123;<br>        type:Number,<br>        value:<span class="hljs-number">0</span>,<br>        observer: function(newVal, oldVal,changePath) &#123;<br>          <span class="hljs-comment">// 属性值变化时执行,newVal就是新设置的数据，old是旧数据</span><br>          <span class="hljs-keyword">this</span>.updateRate();<br>        &#125;<br>      &#125; <br>      &#125;,<br>methods: &#123;<br>updateRate:function()&#123;<br>  <span class="hljs-built_in">var</span>  that = <span class="hljs-keyword">this</span>;<br>  <span class="hljs-built_in">var</span>  rate= that.properties.rate;<br>  <span class="hljs-built_in">var</span>  inRate = parseInt(rate);<br>  <span class="hljs-built_in">var</span>  light = parseInt(rate/<span class="hljs-number">2</span>);<br>  <span class="hljs-built_in">var</span>  half = inRate%<span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">var</span>  gray  = <span class="hljs-number">5</span>-light-half;<br>  <span class="hljs-built_in">var</span> lights = [];<br>  <span class="hljs-built_in">var</span>  halfs = [];<br>  <span class="hljs-built_in">var</span>  grays = [];<br>  <span class="hljs-comment">// for循环遍历存放到数组中</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">var</span>  <span class="hljs-keyword">index</span>=<span class="hljs-number">1</span>;<span class="hljs-keyword">index</span>&lt;=light;<span class="hljs-keyword">index</span>++)&#123;<br>    lights.push(<span class="hljs-keyword">index</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">var</span>  <span class="hljs-keyword">index</span>=<span class="hljs-number">1</span>;<span class="hljs-keyword">index</span>&lt;=half;<span class="hljs-keyword">index</span>++)&#123;<br>    halfs.push(<span class="hljs-keyword">index</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">var</span>  <span class="hljs-keyword">index</span>=<span class="hljs-number">1</span>;<span class="hljs-keyword">index</span>&lt;=gray;<span class="hljs-keyword">index</span>++)&#123;<br>    grays.push(<span class="hljs-keyword">index</span>);<br>  &#125;<br>  <span class="hljs-comment">// 评分设置</span><br>  <span class="hljs-built_in">var</span>   ratetext = rate &amp;&amp; rate&gt;<span class="hljs-number">0</span>?rate.toFixed(<span class="hljs-number">1</span>):<span class="hljs-string">&quot;未评分&quot;</span><br>  <span class="hljs-comment">//数组获取到后 修改 data 中的值</span><br>  that.setData(&#123;<br>    lights:lights,<br>    halfs:halfs,<br>    grays:grays,<br>    ratetext:ratetext,<br>  &#125;);<br>&#125;<br>&#125;,<br><br>lifetimes:&#123;<br>attached:function()&#123;<br>  <span class="hljs-keyword">this</span>.updateRate();<br>  &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>至此，问题解决了</p><blockquote><p>问题的核心元素是：代码之前执行是放在一个attached中，这个函数是被加载到页面中才会去执行，加载到页面中我们的数据没有从网络中请求到，这时候数据就是默认的0，我们可以用observer函数，一旦监听到改变了评分的值，就可以重新设置一下这个值。</p></blockquote><p><img src="/image/19.20.png" alt="星星加载成功"></p><h4 id="项目Github地址"><a href="#项目Github地址" class="headerlink" title="项目Github地址"></a><a href="https://github.com/Pengzhenglong/doubanxiaochengxu">项目Github地址</a></h4>]]></content>
    
    
    <categories>
      
      <category>WX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WX</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>豆瓣&amp;评论列表页实现</title>
    <link href="/2021/04/24/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E4%BA%94)/"/>
    <url>/2021/04/24/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E4%BA%94)/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="评论列表页实现"><a href="#评论列表页实现" class="headerlink" title="评论列表页实现"></a>评论列表页实现</h2><p><img src="/image/19.png" alt="实现点击该页面跳转后"></p><h3 id="完成布局和样式"><a href="#完成布局和样式" class="headerlink" title="完成布局和样式"></a>完成布局和样式</h3><ol><li>先创建comment页面app.json中</li></ol><p>可以将该页面放在第一位,这样方便后面调试页面在第一页</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;pages/comment/comment&quot;</span>,<br></code></pre></td></tr></table></figure><p>ctrl+s保存后生成页面</p><ol start="2"><li>comment.wxml代码</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-group&quot;</span></span></span><br><span class="xml">bindtap=&quot;onItemTapEvent&quot;&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">image</span>    <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;thumbnail&quot;</span>  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">thumbnail</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-title&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">text</span>   <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-rate&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">rate</span>&#125;&#125;</span><span class="xml">分<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><ol start="3"><li>comment.wxss样式</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;<br>  <span class="hljs-attribute">padding</span>:<span class="hljs-number">20</span>rpx  <span class="hljs-number">30</span>rpx;<br>&#125;<br><br><span class="hljs-selector-class">.item-group</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: flex-start;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.item-group</span> <span class="hljs-selector-class">.thumbnail</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50</span>rpx;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">10</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10</span>rpx;<br>&#125;<br><br><span class="hljs-selector-class">.item-group</span>  <span class="hljs-selector-class">.item-title</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>  <span class="hljs-attribute">color</span> : <span class="hljs-number">#41be57</span>;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">10</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10</span>rpx;<br>&#125;<br><br><span class="hljs-selector-class">.item-group</span>  <span class="hljs-selector-class">.item-rate</span>&#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">28</span>rpx;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#ccc</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成后效果</p><p><img src="/image/19.1.png" alt="样式"></p><ol start="4"><li>将comment页面降级，实现跳转功能</li></ol><p>app.json</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">&quot;pages/<span class="hljs-keyword">index</span>/<span class="hljs-keyword">index</span><span class="hljs-string">&quot;,</span><br><span class="hljs-string">&quot;</span>pages/comment/comment<span class="hljs-string">&quot;,</span><br></code></pre></td></tr></table></figure><ol start="5"><li>detail.wxml中实现跳转url</li></ol><p>url 中接收了从上一页传递到下一页的一些参数?后面的</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">navigator</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;more-comment&quot;</span> </span></span><br><span class="xml">url=&quot;/pages/comment/comment?id=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">id</span>&#125;&#125;</span><span class="xml">&amp;type=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">type</span>&#125;&#125;</span><span class="xml">&amp;thumbnail=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.cover.image.small.url</span>&#125;&#125;</span><span class="xml">&amp;title=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.title</span>&#125;&#125;</span><span class="xml">&amp;rate=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.rating.value</span>&#125;&#125;</span><span class="xml">&quot; &gt;查看更多短评<span class="hljs-tag">&lt;/<span class="hljs-name">navigator</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><p>此时我们在comment.js中打印一下数据</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">onLoad: <span class="hljs-keyword">function</span> (<span class="hljs-keyword">options</span>) &#123;<br>  console.log(<span class="hljs-keyword">options</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：没有打印id和type</p><p><img src="/image/19.2.png" alt="问题"></p><p>解决：detail.js中虽然获取到了type和id，但是没有保存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">that.setData(&#123;<br><span class="hljs-built_in">id</span>:<span class="hljs-built_in">id</span>,<br><span class="hljs-built_in">type</span>:<span class="hljs-built_in">type</span><br>&#125;)<br></code></pre></td></tr></table></figure><ol start="6"><li>comment.js中保存数据</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">onLoad: <span class="hljs-keyword">function</span> (options) &#123;<br>   <span class="hljs-keyword">var</span>  <span class="hljs-literal">that</span>=<span class="hljs-built_in">this</span>;<br>   <span class="hljs-literal">that</span>.setData(options);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>渲染数据</li></ol><p>修改以下数据，从url中获取的参数，渲染到页面，会根据点击实现数据的改变</p><p><img src="/image/19.3.png" alt="修改"></p><h3 id="点击完成页面跳转"><a href="#点击完成页面跳转" class="headerlink" title="点击完成页面跳转"></a>点击完成页面跳转</h3><ol><li>能够点击头像完成上一页的跳转</li></ol><p><img src="/image/19.4.png" alt="能够点击跳转"></p><p>分析：能够通过rul或js实现</p><ol start="2"><li>这里我们通过js实现,绑定一个点击事件</li></ol><p><img src="/image/19.5.png" alt="绑定一个点击事件"></p><ol start="3"><li>comment.js函数实现</li></ol><p>这里我们调用的是微信的Api,返回到上一页</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">onItemTapEvent:<span class="hljs-built_in">function</span>(event)&#123;<br>  wx.<span class="hljs-built_in">navigateBack</span>(&#123;&#125;)<br>&#125;,<br><br></code></pre></td></tr></table></figure><p>问题，这里返回到的是上一页的最下面，不是很好</p><p>解决： 在detail界面中加上一个滚动事件，一旦页面show出来了，就展示在最上面</p><p>detail.js</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 生命周期函数--监听页面显示</span><br><span class="hljs-comment"> */</span><br>onShow: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;<br>    wx.pageScrollTo(&#123;<br>      scrollTop:<span class="hljs-number">0</span>,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>问题解决。</p><h3 id="加载评论数据"><a href="#加载评论数据" class="headerlink" title="加载评论数据"></a>加载评论数据</h3><ol><li><p>分析，影评和上面的标题的左右间距都一样，所以可以将它放在.container中</p></li><li><p>wxml代码</p></li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-comment">&lt;!-- 影评 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;comment-title&quot;</span>&gt;</span>全部影评(</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">total</span>&#125;&#125;</span><span class="xml">)<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">onecomment</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">comments</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">onecomment</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>wxss代码</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.comment-title</span>&#123;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">60</span>rpx;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">40</span>rpx;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="评论列表页面抽取注册成组件"><a href="#评论列表页面抽取注册成组件" class="headerlink" title="评论列表页面抽取注册成组件"></a>评论列表页面抽取注册成组件</h3><p><img src="/image/19.6.png" alt="分析"></p><p>评论的样式和布局之前已经在详情页中已经做了，我们在这里没有必要再写一遍，我们可以将之前评论的样式和布局单独抽取出来，做成一个组件，然后直接使用组件，非常方便。</p><ol><li><p>创建一个onecomment组件</p></li><li><p>将detail中的comment代码剪切到onecomment中</p></li></ol><p><img src="/image/19.7.png" alt="代码"></p><ol start="3"><li>将css代码剪切到onecomment中</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 左边固定，右边内容适配 */</span><br> <span class="hljs-selector-class">.comment-group</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: flex-start;<br>  <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">40</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.comment-group</span> <span class="hljs-selector-class">.left-comment</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">70</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.left-comment</span>  <span class="hljs-selector-class">.avatar</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">70</span>rpx;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">70</span>rpx;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>&#125;<br><span class="hljs-selector-class">.comment-group</span>  <span class="hljs-selector-class">.right-comment</span>&#123;<br>  <span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-selector-class">.right-comment</span>   <span class="hljs-selector-class">.username-rate</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: flex-start;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br><span class="hljs-selector-class">.username-rate</span> <span class="hljs-selector-class">.username</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">36</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.release-time</span>&#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#b3b3b3</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">10</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.content</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#353535</span>;<br>  <span class="hljs-attribute">margin-top</span>:<span class="hljs-number">10</span>rpx;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>再onecomment中设置一个属性，这样我们可以使用使数据显示</li></ol><p>onecomment.js</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">properties:</span> &#123;<br><span class="hljs-symbol">      item:</span>&#123;<br><span class="hljs-symbol">        type:</span>Object,<br><span class="hljs-symbol">        value:</span>&#123;&#125;<br>      &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>onecomment.wxml代码</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;comment-group&quot;</span> &gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left-comment&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">image</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;avatar&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.user.avatar</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"> <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right-comment&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;username-rate&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.user.name</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">stars</span>  <span class="hljs-attr">rate</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.rating.value</span>*<span class="hljs-number">2</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">starsize</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">istext</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">false</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">stars</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;release-time&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.create_time</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.comment</span>&#125;&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="5"><li>detail中使用先注册组件</li></ol><p>detail.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;stars&quot;</span>:<span class="hljs-string">&quot;/components/stars/stars&quot;</span>,<br>    <span class="hljs-attr">&quot;onecomment&quot;</span>:<span class="hljs-string">&quot;/components/onecomment/onecomment&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>detail.wxml中使用</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">onecomment</span>  <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">comments</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">onecomment</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>其他样式和之前一样，但是出现了问题：星星样式没了</p><p>解决：再onecomment中注册stars组件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;component&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;stars&quot;</span>:<span class="hljs-string">&quot;/components/stars/stars&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成。</p><h3 id="请求评论数据"><a href="#请求评论数据" class="headerlink" title="请求评论数据"></a>请求评论数据</h3><ol><li>comment.js</li></ol><p>请求数据，先导入network.js</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">import</span>  &#123;network&#125;  <span class="hljs-keyword">from</span>  <span class="hljs-string">&quot;../../utils/network.js&quot;</span>;<br><br>  onLoad: <span class="hljs-keyword">function</span> (options) &#123;<br>     <span class="hljs-keyword">var</span>  <span class="hljs-literal">that</span>=<span class="hljs-built_in">this</span>;<br>     <span class="hljs-literal">that</span>.setData(options);<br>    network.getItemComments(&#123;<br>      type:options.type,<br>      id:options.id,<br>      start:<span class="hljs-number">1</span>,<br>      count:<span class="hljs-number">20</span>,<br>      success:<span class="hljs-keyword">function</span>(data)&#123;<br>        <span class="hljs-keyword">var</span>  total = data.total;<br>        <span class="hljs-keyword">var</span>  comments = data.interests;<br>        <span class="hljs-literal">that</span>.setData(&#123;<br>          total:total,<br>          comments:comments<br>        &#125;)<br>      &#125;<br>    &#125;)<br>  &#125;,<br></code></pre></td></tr></table></figure><ol start="2"><li>comment中注册组件</li></ol><p>comment.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;onecomment&quot;</span>:<span class="hljs-string">&quot;/components/onecomment/onecomment&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>使用组件</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;onecomment&quot;</span>:<span class="hljs-string">&quot;/components/onecomment/onecomment&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成</p><h3 id="翻页按钮布局"><a href="#翻页按钮布局" class="headerlink" title="翻页按钮布局"></a>翻页按钮布局</h3><p>要完成样式</p><p><img src="/image/19.8.png" alt="样式"></p><ol><li>comment.wxml代码</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-btn-group&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-btn&quot;</span><span class="hljs-attr">bindtap</span>=<span class="hljs-string">&quot;onPrePageTap&quot;</span></span><br><span class="hljs-tag">&gt;</span>上一页<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-btn&quot;</span><span class="hljs-attr">bindtap</span>=<span class="hljs-string">&quot;onNextPageTap&quot;</span></span><br><span class="hljs-tag">&gt;</span>下一页<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>comment.wxss代码</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.page-btn-group</span>&#123;<br>  <span class="hljs-attribute">margin-top</span>:<span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">display</span>:flex;<br>  <span class="hljs-comment">/* 水平方向从左到右 */</span><br>  <span class="hljs-attribute">justify-content</span>: flex-start;<br>  <span class="hljs-comment">/* 垂直反向居中 */</span><br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.page-btn</span>&#123;<br>  <span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">60</span>rpx;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#898989</span>;<br>  <span class="hljs-attribute">border-color</span>:<span class="hljs-number">#898989</span>;<br>  <span class="hljs-attribute">line-height</span>:<span class="hljs-number">60</span>rpx;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="翻页功能实现"><a href="#翻页功能实现" class="headerlink" title="翻页功能实现"></a>翻页功能实现</h3><p>优化用户体验，从用户角度出发，给用户更好的体验</p><ol><li>点击绑定事件</li></ol><p><img src="/image/19.10.png" alt="绑定"></p><ol start="2"><li>comment.js实现</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span>  &#123;network&#125;  from  <span class="hljs-string">&quot;../../utils/network.js&quot;</span>;<br>Page(&#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 页面的初始数据</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">data</span>: &#123;<br>      total:<span class="hljs-number">0</span>,<br>      start:<span class="hljs-number">1</span>,<br>      count:<span class="hljs-number">20</span><br>  &#125;,<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 生命周期函数--监听页面加载</span><br><span class="hljs-comment">   */</span><br>onLoad: function (options) &#123;<br>     <span class="hljs-keyword">var</span>  that=<span class="hljs-keyword">this</span>;<br>    that.setData(options);<br>    <span class="hljs-comment">// 传入的为第一页</span><br>    that.getComments(<span class="hljs-number">1</span>);<br>  &#125;,<br><span class="hljs-comment">// 传入一个start参数</span><br>getComments:function(start)&#123;<br><span class="hljs-keyword">var</span>  that= <span class="hljs-keyword">this</span>;<br><span class="hljs-keyword">var</span> type  = that.<span class="hljs-keyword">data</span>.type;<br><span class="hljs-keyword">var</span>  id = that.<span class="hljs-keyword">data</span>.id;<br><span class="hljs-comment">// loading判断用户点击是上一页还是下一页</span><br><span class="hljs-keyword">if</span>(start&gt;that.<span class="hljs-keyword">data</span>.start)&#123;<br>  that.setData(&#123;<br>    nextLoading:<span class="hljs-literal">true</span><br>  &#125;);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  that.setData(&#123;<br>    preLoading:<span class="hljs-literal">true</span><br>  &#125;);<br>&#125;<br>  network.getItemComments(&#123;<br>    type:type,<br>    id:id,<br>    start:start,<br>    count:<span class="hljs-number">20</span>,<br>    success:function(<span class="hljs-keyword">data</span>)&#123;<br>      <span class="hljs-keyword">var</span>  total = <span class="hljs-keyword">data</span>.total;<br>      <span class="hljs-keyword">var</span>  comments = <span class="hljs-keyword">data</span>.interests;<br>      that.setData(&#123;<br>        total:total,<br>        comments:comments,<br>        start:start,<br>        <span class="hljs-comment">// 数据请求完毕loading关闭</span><br>        preLoading:<span class="hljs-literal">false</span>,<br>        nextLoading:<span class="hljs-literal">false</span><br>      &#125;);<br>      <span class="hljs-comment">// 优化，点击下一页或上一页返回为最上面</span><br>        wx.pageScrollTo(&#123;<br>          scrollTop: <span class="hljs-number">0</span>,<br>        &#125;)<br>    &#125;<br>  &#125;)<br>&#125;,<br><span class="hljs-comment">// 返回上一页</span><br>  onItemTapEvent:function(event)&#123;<br>    wx.navigateBack(&#123;&#125;)<br>  &#125;,<br><span class="hljs-comment">// 上一页</span><br>  onPrePageTap:function(event)&#123;<br>    <span class="hljs-keyword">var</span>  that= <span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">var</span>  oldStar= that.<span class="hljs-keyword">data</span>.start;<br>    <span class="hljs-keyword">var</span> count = that.<span class="hljs-keyword">data</span>.count;<br>    <span class="hljs-keyword">if</span>(oldStar-count&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">var</span>  start =  oldStar-count; <br>        that.getComments(start);<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 下一页</span><br>  onNextPageTap:function(event)&#123;<br>      <span class="hljs-keyword">var</span>  that=<span class="hljs-keyword">this</span>;<br>      <span class="hljs-keyword">var</span> oldStart = that.<span class="hljs-keyword">data</span>.start;<br>      <span class="hljs-keyword">var</span>  start = oldStart+that.<span class="hljs-keyword">data</span>.count;<br>      that.getComments(start);<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>基本完成</p><p><img src="/image/19.9.png" alt="完成"></p>]]></content>
    
    
    <categories>
      
      <category>WX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WX</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>豆瓣&amp;详情页面固定样式完成&amp;详情页短评数据获取与渲染</title>
    <link href="/2021/04/23/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/"/>
    <url>/2021/04/23/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="详情页面固定样式完成"><a href="#详情页面固定样式完成" class="headerlink" title="详情页面固定样式完成"></a>详情页面固定样式完成</h3><h4 id="详情页面header完成"><a href="#详情页面header完成" class="headerlink" title="详情页面header完成"></a>详情页面header完成</h4><p>要完成的样式<br><img src="/image/18.png" alt="要完成的样式"></p><ol><li>创建detail页面</li></ol><p>app.json中,<strong>将detail放在最前面方便后面调试</strong></p><p><img src="/image/18.1.png" alt="保存生成detail页面"></p><ol start="2"><li>分析布局</li></ol><p><img src="/image/18.2.png" alt="分析"></p><ol start="3"><li>detail.wxml代码编写</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-header&quot;&gt;<br>  &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-title&quot;&gt; 肖申克的救赎(<span class="hljs-number">1994</span>) &lt;/<span class="hljs-keyword">view</span>&gt;<br>  &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-detail&quot;&gt;<br>    &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;left-detail&quot;&gt;<br>      &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-rate&quot;&gt;<br>        &lt;stars rate=&quot;9.7&quot;&gt;&lt;/stars&gt;<br>        &lt;<span class="hljs-type">text</span> <span class="hljs-keyword">class</span>=&quot;comment-persons&quot;&gt;<span class="hljs-number">203894</span>评价&lt;/<span class="hljs-type">text</span>&gt;<br>      &lt;/<span class="hljs-keyword">view</span>&gt;<br>      &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-sub-detail&quot;&gt;<br>        &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-type&quot;&gt; <span class="hljs-number">142</span>分钟 剧情 / 犯罪 &lt;/<span class="hljs-keyword">view</span>&gt;<br>        &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-show&quot;&gt; <span class="hljs-number">1994</span><span class="hljs-number">-10</span><span class="hljs-number">-14</span>(美国) &lt;/<span class="hljs-keyword">view</span>&gt;<br>        &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-actors&quot;&gt;<br>          导演: 弗兰克·德拉邦特/ 主演: 蒂姆·罗宾斯<br>        &lt;/<span class="hljs-keyword">view</span>&gt;<br>      &lt;/<span class="hljs-keyword">view</span>&gt;<br>    &lt;/<span class="hljs-keyword">view</span>&gt;<br>    &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;right-detail&quot;&gt;<br>      &lt;image<br>        src=&quot;https://img2.doubanio.com/view/photo/s_ratio_poster/public/p480747492.webp&quot;<br>      &gt;&lt;/image&gt;<br>    &lt;/<span class="hljs-keyword">view</span>&gt;<br>  &lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br></code></pre></td></tr></table></figure><p>detail.wxss代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-header</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">60</span>rpx <span class="hljs-number">30</span>rpx;<br>&#125;<br><br><span class="hljs-selector-class">.item-header</span> <span class="hljs-selector-class">.item-title</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50</span>rpx;<br>&#125;<br><br><span class="hljs-selector-class">.item-header</span> <span class="hljs-selector-class">.item-detail</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: space-between;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br><br><span class="hljs-selector-class">.item-detail</span> <span class="hljs-selector-class">.left-detail</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br><br><span class="hljs-selector-class">.left-detail</span> <span class="hljs-selector-class">.item-rate</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: flex-start;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br><br><span class="hljs-selector-class">.item-rate</span> <span class="hljs-selector-class">.comment-persons</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">28</span>rpx;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ccc</span>;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br><br><span class="hljs-selector-class">.item-detail</span> <span class="hljs-selector-class">.right-detail</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200</span>rpx;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300</span>rpx;<br>&#125;<br><br><span class="hljs-selector-class">.right-detail</span> image &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-class">.item-sub-detail</span> &#123;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>&#125;<br><br><span class="hljs-selector-class">.item-sub-detail</span> view &#123;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">10</span>rpx;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>效果图</p><p><img src="/image/18.3.png" alt="效果图片"></p><h4 id="标签布局和样式完成"><a href="#标签布局和样式完成" class="headerlink" title="标签布局和样式完成"></a>标签布局和样式完成</h4><p><img src="/image/18.4.png" alt="样式"></p><p>detail.wxml代码</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-tags&quot;&gt;<br>  &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-tags-title&quot;&gt;豆瓣成员常用标签&lt;/<span class="hljs-keyword">view</span>&gt;<br>  &lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;item-tags-list&quot;&gt;<br>    &lt;<span class="hljs-type">text</span>&gt;黑色幽默&lt;/<span class="hljs-type">text</span>&gt;&lt;<span class="hljs-type">text</span>&gt;小人物&lt;/<span class="hljs-type">text</span>&gt;&lt;<span class="hljs-type">text</span>&gt;戏剧&lt;/<span class="hljs-type">text</span><br>    &gt;&lt;<span class="hljs-type">text</span>&gt;方言&lt;/<span class="hljs-type">text</span>&gt;&lt;<span class="hljs-type">text</span>&gt;中国大陆&lt;/<span class="hljs-type">text</span>&gt;&lt;<span class="hljs-type">text</span>&gt;人性&lt;/<span class="hljs-type">text</span><br>    &gt;&lt;<span class="hljs-type">text</span>&gt;剧情&lt;/<span class="hljs-type">text</span>&gt;<br>  &lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br></code></pre></td></tr></table></figure><p>detail.wxss代码</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.item-tags-title</span>&#123;<br>  <span class="hljs-comment">/* 设置元素的下外边距 */</span><br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">10</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.item-tags</span>&#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">30</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.item-tags</span> <span class="hljs-selector-class">.item-tags-title</span>&#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#b3b3b3</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>  <span class="hljs-attribute">margin-bottom</span>:<span class="hljs-number">20</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.item-tags</span> <span class="hljs-selector-class">.item-tags-list</span>&#123;<br>  <span class="hljs-attribute">display</span>:flex;<br>  <span class="hljs-attribute">justify-content</span>: flex-start;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>&#125;<br><span class="hljs-selector-class">.item-tags-list</span> text&#123;<br>  <span class="hljs-attribute">padding</span>:<span class="hljs-number">10</span>rpx <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#f5f5f5</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>  <span class="hljs-attribute">columns</span>: <span class="hljs-number">#353535</span>;<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="详情页布局完成"><a href="#详情页布局完成" class="headerlink" title="详情页布局完成"></a>详情页布局完成</h4><p>分析：</p><p><img src="/image/18.5.png" alt="要完成的样式"></p><p>detail.wxml</p><p>这里的头像图片和文字我们先从豆瓣网获取，方便页面布局显示</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cos">&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;comment-list-group&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;comment-title&quot;</span>&gt;短评(<span class="hljs-number">202220297</span>)&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;comment-group&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;left-comment&quot;</span>&gt;<br>&lt;image  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;avatar&quot;</span> src=<span class="hljs-string">&quot;https://img3.doubanio.com/icon/u218767230-1.jpg&quot;</span>&gt;&lt;/image&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;right-comment&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;username-rate&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;羚锐&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;stars  rate=<span class="hljs-string">&quot;5&quot;</span> starsize=<span class="hljs-string">&quot;30&quot;</span> istext=<span class="hljs-string">&quot;&#123;&#123;false&#125;&#125;&quot;</span> &gt;&lt;/stars&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;release-time&quot;</span>&gt;<span class="hljs-number">2018</span>-<span class="hljs-number">12</span>-<span class="hljs-number">03</span>   <span class="hljs-number">12</span>:<span class="hljs-number">22</span>:<span class="hljs-number">22</span>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;这部纪录片上映也等了很久，就像这段历史被揭开的时间也是等待了太久，<br>这几个人的人生或许仍然不能被探索清楚，但至少已经开始被发掘，其实这不仅是关于八个中国乘客，也是那一代华人移民故事，方的故事尤为震撼，<br>一个从冰海里挣扎出来的幸存者，又如此努力在美国讨生活还要帮助亲友，他的故事比电影更加传奇。<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br><br> &lt;navigator <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;more-comment&quot;</span>&gt;查看更多短评&lt;/navigator&gt;<br></code></pre></td></tr></table></figure><p>detail.wxss</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.comment-list-group</span>&#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">60</span>rpx <span class="hljs-number">30</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.comment-list-group</span>  <span class="hljs-selector-class">.comment-title</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#b3b3b3</span>;<br>&#125;<br><span class="hljs-comment">/* 左边固定，右边内容适配 */</span><br><span class="hljs-selector-class">.comment-list-group</span>  <span class="hljs-selector-class">.comment-group</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: flex-start;<br>  <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">40</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.comment-group</span> <span class="hljs-selector-class">.left-comment</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">70</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.left-comment</span>  <span class="hljs-selector-class">.avatar</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">70</span>rpx;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">70</span>rpx;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;<br>&#125;<br><span class="hljs-selector-class">.comment-group</span>  <span class="hljs-selector-class">.right-comment</span>&#123;<br>  <span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-selector-class">.right-comment</span>   <span class="hljs-selector-class">.username-rate</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: flex-start;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br><span class="hljs-selector-class">.username-rate</span> <span class="hljs-selector-class">.username</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">36</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.release-time</span>&#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#b3b3b3</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">10</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.content</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">32</span>rpx;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#353535</span>;<br>  <span class="hljs-attribute">margin-top</span>:<span class="hljs-number">10</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.more-comment</span>&#123;<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">36</span>rpx;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#41be57</span>;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">60</span>rpx;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：星星这里出现了评分数字</p><p><img src="/image/18.6.png" alt="要完成的样式"></p><p>解决：</p><p>在stars.js文件中定义一个属性，是否需要文本</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">istext:</span>&#123;<br><span class="hljs-symbol">  type:</span>Boolean,<br><span class="hljs-symbol">  value:</span>true<br>&#125;<br></code></pre></td></tr></table></figure><p>stars.wxml中<br><img src="/image/18.7.png" alt="代码添加判断"></p><p>detail.wxml代码</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">stars</span>  <span class="hljs-attr">rate</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">starsize</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">istext</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">false</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">stars</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/image/18.8.png" alt="页面完成"></p><h2 id="以下是将详情页的数据转换为真实从网上获取的数据"><a href="#以下是将详情页的数据转换为真实从网上获取的数据" class="headerlink" title="以下是将详情页的数据转换为真实从网上获取的数据"></a>以下是将详情页的数据转换为真实从网上获取的数据</h2><h3 id="详情页入口参数设置"><a href="#详情页入口参数设置" class="headerlink" title="详情页入口参数设置"></a>详情页入口参数设置</h3><ol><li>分析：进入详情页面有多种途径，1从首页中电影，电视剧，综艺都可以进入，2从列表页面也可以点击进入</li></ol><p>所以我们要对点击进入详情页面进行入口设置，因为(电影，电视剧，综艺)三个的url类型是不同的，所以获取详情页前要传递类型和item的id过去，告诉它我们传递的类型和id</p><ol start="2"><li>接下来我们来到首页index.wxml中，发现页面是在indexmodul中，而页面是写在itemview中</li></ol><p>之前我们只是在itemview中写了一些样式，并没有跳转的链接</p><p>itemview.js中定义类型</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">itemurl:</span>&#123;<br><span class="hljs-symbol">  type:</span>String,<br><span class="hljs-symbol">  value:</span><span class="hljs-string">&quot;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>itemview.wxml url跳转链接</p><p><img src="/image/18.9.png" alt="url"></p><ol start="3"><li>indexmodule设置跳转页面</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">itemview</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">items</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>  <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>  <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> </span></span><br><br><span class="xml">itemurl=&quot;/pages/detail/detail?type=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">type</span>&#125;&#125;</span><span class="xml">&amp;id=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.id</span>&#125;&#125;</span><span class="xml">&quot;</span><br><span class="xml">&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">itemview</span>&gt;</span>  </span><br></code></pre></td></tr></table></figure><ul><li>可以实现，但是我们还需要传递两个参数 type和id(通过查询字符串的方式?)</li></ul><p>indexmodule.js  属性设置</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">type</span>:&#123;<br>  <span class="hljs-keyword">type</span>:<span class="hljs-keyword">String</span>,<br>  value:<span class="hljs-string">&quot;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以后在使用这个组件的时候要传递一个字符串type进来，index页面中。</p><p><img src="/image/18.10.png" alt="type"></p><ul><li>id 的传递—item中有一个属性id</li></ul><p>id=</p><p>首页中点击可以获取到数据</p><p><img src="/image/18.11.png" alt="console"></p><ol start="4"><li>列表页面实现获取list</li></ol><p>它直接使用的就是itemview,所以我们就只需要传递url</p><p>list.js</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pony"><span class="hljs-keyword">var</span>  that= <span class="hljs-literal">this</span>;<br><span class="hljs-keyword">var</span>  <span class="hljs-keyword">type</span> = options.<span class="hljs-keyword">type</span>;<br>that.setData(&#123;<br>  <span class="hljs-keyword">type</span>:<span class="hljs-keyword">type</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><img src="/image/18.12.png" alt="console"></p><p>点击type和id都能获取</p><h3 id="详情页item详情数据获取"><a href="#详情页item详情数据获取" class="headerlink" title="详情页item详情数据获取"></a>详情页item详情数据获取</h3><p>详情页面参数已经可以获取了</p><ol><li><p>detail.js </p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span>  <span class="hljs-keyword">type</span> =options.<span class="hljs-keyword">type</span>;<br><span class="hljs-keyword">var</span>  id=options.id;<br></code></pre></td></tr></table></figure></li><li><p>导入详情页面的三个url到url.js中</p></li></ol><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">movieDetail:</span> <span class="hljs-string">&quot;https://m.douban.com/rexxar/api/v2/movie/&quot;</span>,<br><span class="hljs-symbol">tvDetail:</span> <span class="hljs-string">&quot;https://m.douban.com/rexxar/api/v2/tv/&quot;</span>,<br><span class="hljs-symbol">showDetail:</span> <span class="hljs-string">&quot;https://m.douban.com/rexxar/api/v2/tv/&quot;</span>,<br></code></pre></td></tr></table></figure><ol start="3"><li>network.js 文件中定义一个新的函数来获取网络请求</li></ol><p><img src="/image/18.13.png" alt="获取网络请求"></p><p>最后成功获取通过success函数回调返回item</p><ol start="4"><li>detail.js中导入network</li></ol><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span>  &#123;network&#125;  <span class="hljs-keyword">from</span>  <span class="hljs-string">&quot;../../utils/network&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/image/18.14.png" alt="获取打印数据"></p><p>此时点击首页一个数据发现控制台200的状态并打印了数据，发现通过url可以获取到数据</p><h3 id="详情页面item数据渲染"><a href="#详情页面item数据渲染" class="headerlink" title="详情页面item数据渲染"></a>详情页面item数据渲染</h3><h4 id="将获取到的item的数据设置到界面上"><a href="#将获取到的item的数据设置到界面上" class="headerlink" title="将获取到的item的数据设置到界面上"></a>将获取到的item的数据设置到界面上</h4><ol><li>detail.js中保存data数据</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">var</span> <span class="hljs-literal">that</span>  =<span class="hljs-built_in">this</span>;<br><br>  <span class="hljs-literal">that</span>.setData(&#123;<br>              item:item<br>            &#125;)<br> <span class="hljs-regexp">// console.log(item)  //</span>打印查看数据列表<br></code></pre></td></tr></table></figure><p><img src="/image/18.15.png" alt="控制台数据答应"></p><ol start="2"><li>detail.wxml中修改</li></ol><p><img src="/image/18.17.png" alt="修改位置"></p><ol start="3"><li>detail.js中代码</li></ol><p><img src="/image/18.16.png" alt="部分细节处理"></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs axapta">onLoad: function (options) &#123;<br>        <span class="hljs-built_in">var</span> that  =<span class="hljs-keyword">this</span>;<br>        <span class="hljs-built_in">var</span>  type =options.type;<br>        <span class="hljs-built_in">var</span>  id=options.id;<br><br>        network.getItemDetail(&#123;<br>          type:type,<br>          id:id,<br>          success:function(item)&#123;<br>            <span class="hljs-built_in">var</span>  genres= item.genres;<br>           <span class="hljs-comment">//字符串拼接  电影类型</span><br>           genres = genres.<span class="hljs-keyword">join</span>(<span class="hljs-string">&quot;/&quot;</span>);<br>           item.genres = genres;<br><br>           <span class="hljs-built_in">var</span>   actors = item.actors;<br>           <span class="hljs-built_in">var</span>  actorNames = [];<br>             <span class="hljs-comment">//slice函数截取数组的一部分，slice(0,3)左闭右开取(0,1,2)，演员数组太多，取三个返回</span><br>           <span class="hljs-keyword">if</span>(actors.length&gt;<span class="hljs-number">3</span>)&#123;<br>             actors = actors.slice(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);<br>           &#125;<br>        <span class="hljs-comment">//    for循环压入数组中</span><br>           <span class="hljs-keyword">for</span>(<span class="hljs-built_in">var</span>  <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;<span class="hljs-keyword">index</span>&lt;actors.length;<span class="hljs-keyword">index</span>++)&#123;<br>             <span class="hljs-built_in">var</span>  actor  = actors[<span class="hljs-keyword">index</span>];<br>             actorNames.push(actor.name);<br>           &#125;<br>           actorNames = actorNames.<span class="hljs-keyword">join</span>(<span class="hljs-string">&quot;/&quot;</span>);<br>           <span class="hljs-built_in">var</span>  director  = item.directors[<span class="hljs-number">0</span>].name;<br>           <span class="hljs-built_in">var</span>  authors = director+<span class="hljs-string">&quot;(导演)/&quot;</span>+actorNames;<br>           item.authors = authors;<br><br>            that.setData(&#123;<br>              item:item<br>            &#125;)<br>           <span class="hljs-comment">// console.log(item)</span><br>          &#125;<br>        &#125;);<br> &#125;<br></code></pre></td></tr></table></figure><p><img src="/image/18.18.png" alt="页面数据可以从网络上请求改变"></p><h4 id="标签完成"><a href="#标签完成" class="headerlink" title="标签完成"></a>标签完成</h4><p>标签数据获取与数据渲染</p><p><img src="/image/18.19.png" alt="如图"></p><ol><li>url.js设置</li></ol><p><img src="/image/18.20.png" alt="url设置"></p><ol start="2"><li>network.js函数设置</li></ol><p><img src="/image/18.21.png" alt="network.js"></p><ol start="3"><li>detail.js中触发该函数</li></ol><p>tags用来接收调用network.js中函数返回传的参数</p><p><img src="/image/18.22.png" alt="detail.js"></p><ol start="4"><li>修改detail.wxml代码</li></ol><p>wx:for循环中，默认的下标名称的index,默认的值的名称的item</p><p><img src="/image/18.23.png" alt="wx:for"></p><h4 id="详情页短评数据获取与渲染"><a href="#详情页短评数据获取与渲染" class="headerlink" title="详情页短评数据获取与渲染"></a>详情页短评数据获取与渲染</h4><ol><li>url链接获取</li></ol><p>url.js代码</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xquery">// 默认传一个<span class="hljs-keyword">start</span>=<span class="hljs-number">0</span><span class="hljs-built_in">,count</span> =<span class="hljs-number">3</span><br>movieComments: <span class="hljs-keyword">function</span><span class="hljs-built_in">(id</span>,<span class="hljs-keyword">start</span>=<span class="hljs-number">0</span><span class="hljs-built_in">,count</span>=<span class="hljs-number">3</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;https://m.douban.com/rexxar/api/v2/movie/&#x27;</span> +<span class="hljs-built_in"> id</span> + <span class="hljs-string">&#x27;/interests?count=&#x27;</span> +<span class="hljs-built_in"> count</span> + <span class="hljs-string">&#x27;&amp;start=&#x27;</span> + <span class="hljs-keyword">start</span>;<br>&#125;,<br>tvComments: <span class="hljs-keyword">function</span><span class="hljs-built_in">(id</span>,<span class="hljs-keyword">start</span>=<span class="hljs-number">0</span><span class="hljs-built_in">,count</span>=<span class="hljs-number">3</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;https://m.douban.com/rexxar/api/v2/tv/&#x27;</span> +<span class="hljs-built_in"> id</span> + <span class="hljs-string">&#x27;/interests?count=&#x27;</span> +<span class="hljs-built_in"> count</span> + <span class="hljs-string">&#x27;&amp;start=&#x27;</span> + <span class="hljs-keyword">start</span>;<br>&#125;,<br>showComments: <span class="hljs-keyword">function</span><span class="hljs-built_in">(id</span>,<span class="hljs-keyword">start</span>=<span class="hljs-number">0</span><span class="hljs-built_in">,count</span>=<span class="hljs-number">3</span>)&#123;<br>  <span class="hljs-keyword">return</span> this.tvComments<span class="hljs-built_in">(id</span>,<span class="hljs-keyword">start</span><span class="hljs-built_in">,count</span>);<br>&#125;,<br><br></code></pre></td></tr></table></figure><ol start="2"><li>network.js写一个获取网络请求的接口</li></ol><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">// 获取短评</span><br>  getItemComments:function(<span class="hljs-keyword">params</span>)&#123;<br>    <span class="hljs-built_in">var</span>  <span class="hljs-keyword">type</span> =<span class="hljs-keyword">params</span>.<span class="hljs-keyword">type</span>;<br>    <span class="hljs-built_in">var</span>  id= <span class="hljs-keyword">params</span>.id;<br>    <span class="hljs-built_in">var</span>  start = <span class="hljs-keyword">params</span>.start?<span class="hljs-keyword">params</span>.start:<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">var</span> count  = <span class="hljs-keyword">params</span>.count?<span class="hljs-keyword">params</span>.count:<span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">var</span>  url=<span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;movie&#x27;</span>)&#123;<br>      url = globalurls.movieComments(id,start,count);<br>    &#125;<span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">type</span> ===<span class="hljs-string">&#x27;tv&#x27;</span>)&#123;<br>      url = globalurls.tvComments(id,start,count);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      url  =globalurls.showComments(id,start,count);<br>    &#125;<br>    wx.request(&#123;<br>      url:url,<br>      success:function(res)&#123;<br>        <span class="hljs-built_in">var</span>  <span class="hljs-built_in">data</span>  =res.<span class="hljs-built_in">data</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">params</span>.success)&#123;<br>          <span class="hljs-keyword">params</span>.success(<span class="hljs-built_in">data</span>);<br>        &#125;<br>      &#125;<br>    &#125;)<br>  &#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>detail页面调用 detail.js文件种</li></ol><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">//  获取评论</span><br>network.getItemComments(&#123;<br>  <span class="hljs-keyword">type</span>:<span class="hljs-keyword">type</span>,<br>  id:id,<br>  success:function(<span class="hljs-built_in">data</span>)&#123;<br>    <span class="hljs-built_in">var</span>  totalComment = <span class="hljs-built_in">data</span>.total;<br>    <span class="hljs-built_in">var</span>  comments= <span class="hljs-built_in">data</span>.interests;<br>    that.setData(&#123;<br>      totalComment:totalComment,<br>      comments:comments<br>    &#125;)<br>    <span class="hljs-comment">// console.log(data)</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="4"><li><p>控制台能够打印200状态，并获取到data</p></li><li><p>数据渲染到detail.wxml种</p></li></ol><p>变量修改</p><p><img src="/image/18.24.png" alt="wxml代码修改"></p><ol start="6"><li>页面效果</li></ol><p><img src="/image/18.25.png" alt="真实数据"></p>]]></content>
    
    
    <categories>
      
      <category>WX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WX</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>豆瓣&amp;itemview重构&amp;列表数据渲染成真实数据</title>
    <link href="/2021/04/22/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E4%B8%89)/"/>
    <url>/2021/04/22/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="电影列表页面布局"><a href="#电影列表页面布局" class="headerlink" title="电影列表页面布局"></a>电影列表页面布局</h3><h4 id="itemview重构"><a href="#itemview重构" class="headerlink" title="itemview重构"></a>itemview重构</h4><p>分析：首页和更多页面的布局基本一样，所以我们可以将首页布局代码拿过来直接用         </p><p>(我们在代码的时候发现有些东西是重复的，我们可以将代码单独抽取出来，然后再哪个地方需要使用的时候再引用，这样相当于对代码进行了重构，方便后期对代码进行管理)</p><p><img src="/image/17.1.png" alt="首页代码"></p><ol><li>首页代码在indexmodul组件中，所以我们去该组价中再进行代码优化</li></ol><ol start="2"><li><p>在components中新建一个itemview组件</p></li><li><p>将indexmodule.wxml中的代码剪切到itemview.wxml中</p></li></ol><p>navigator也可以拿过去，因为后期我们点击一个电影也会跳转到详情页面中</p><p><img src="/image/17.2.png" alt="itemview.wxml"></p><ol start="4"><li>将样式代码页抽取到itemview.wxss中</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs css"> <span class="hljs-selector-class">.item-navigator</span>&#123;<br>  <span class="hljs-attribute">width</span>:<span class="hljs-number">200</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>&#125;<br><br><span class="hljs-selector-class">.item-navigator</span>  <span class="hljs-selector-class">.item-group</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.item-group</span> <span class="hljs-selector-class">.thumbnail-group</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">284</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.thumbnail-group</span> <span class="hljs-selector-class">.thumbnail</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><span class="hljs-selector-class">.item-group</span> <span class="hljs-selector-class">.item-title</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">28</span>rpx;<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-comment">/* 文本过长处理 */</span><br>  <span class="hljs-attribute">text-overflow</span>:ellipsis;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="5"><li>展示items，应该要传一个items属性过来</li></ol><p><img src="/image/17.3.png" alt="问题"></p><p>解决： 在itemsview.js文件中</p><p><img src="/image/17.4.png" alt="属性"></p><ol start="6"><li>注册组件</li></ol><p><img src="/image/17.5.png" alt="注册组件"></p><ol start="7"><li>使用组件</li></ol><p><img src="/image/17.6.png" alt="使用组件"></p><ol start="8"><li>问题</li></ol><p>右边距没有了</p><p><img src="/image/17.7.png" alt="问题"></p><p>解决：我们把itemview单独放在一个当中使用了，所以item-navigator只有一个则last-of-type就是它本身<br>将该代码删除就可以了</p><p><img src="/image/17.8.png" alt="解决"></p><ol start="9"><li>此时星星组件不见了，将星星组件放到itemview.json文件中使用</li></ol><p><img src="/image/17.9.png" alt="解决"></p><p>以上操作方便了我们后期布局</p><h4 id="创建列表页"><a href="#创建列表页" class="headerlink" title="创建列表页"></a>创建列表页</h4><ol><li>创建列表页面</li></ol><p>在app.json中添加该行代码保存就会自动创建页面</p><p><img src="/image/17.10.png" alt="创建页面"></p><ol start="2"><li><p>分析：电影，电视剧，综艺三个列表页面都是相同的样式，唯独不一样的是数据，所以我们完全没有必要为这三个弄三个单独的页面。我们完全可以使用同一个页面，后期我们传不同的参数过去，告诉它我现在要获取电影，电视剧，综艺.这样可以达到重用。</p></li><li><p>列表页入口</p></li></ol><p>应该有一个入口可以来到列表页–更多</p><p>在首页添加url</p><p><img src="/image/17.11.png" alt="moreurl"></p><ol start="4"><li>列表页搜索栏<br>列表页也应该有搜索栏,将之前的searchbar组件拿过来使用</li></ol><p>注册list.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;searchbar&quot;</span>:<span class="hljs-string">&quot;/components/searchbar/searchbar&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 list.wxml</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">searchbar</span>  <span class="hljs-attr">isnavigator</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">true</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">searchbar</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这时候列表页出现了搜索栏</p><ol start="5"><li>电影排列–flex布局</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">itemview</span>  <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">items</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>  <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>  <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">itemview</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>由于.container在app.wxss中存在，这里我们将app.wxss代码删除掉</p><ol start="6"><li>电影数据获取</li></ol><p>在list.js的onLoad函数中调用电影列表数据</p><ul><li>导入network.js</li></ul><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> &#123;network&#125;  <span class="hljs-keyword">from</span>  <span class="hljs-string">&quot;../../utils/network.js&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><p>请求数据</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">onLoad: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(options)</span> </span>&#123;<br>    <span class="hljs-keyword">var</span>  that= <span class="hljs-keyword">this</span>;<br>          <span class="hljs-comment">// 请求的电影数据</span><br>      network.getMovieList(&#123;<br>        success:<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(items)</span></span>&#123;<br>          that.setData(&#123;<br>            items: items<br>          &#125;);    <br>        &#125;&#125;<br></code></pre></td></tr></table></figure></li><li><p>css样式</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: space-between;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">30</span>rpx;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="列表数据渲染成真实数据"><a href="#列表数据渲染成真实数据" class="headerlink" title="列表数据渲染成真实数据"></a>列表数据渲染成真实数据</h3><ol><li>分析：电影，电视剧，综艺用的都是list页面中的，这时候我们要怎么去区分它呢？</li></ol><p>我们可以在首页index中传一个参数过去，当点击更多的时候，我们list页面得到这个参数就可以根据参数发送不同的请求</p><p>传递参数</p><p><img src="/image/17.12.png" alt="type"></p><p>list.js中接收参数</p><p><img src="/image/17.13.png" alt="接收"></p><ol start="2"><li>怎么能够获取所有正在热映的电影，电视剧，综艺？</li></ol><p>分析：我们在首页中就已经写过网络请求的代码，不过我们写的count=7,我们现在要获取所有的数据，之前的代码也可以重用。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lasso"> wx.request(&#123;<br>   <span class="hljs-comment">//  豆瓣电影接口</span><br>    url: globalurls.movieList,<br>    <span class="hljs-built_in">data</span>:&#123;<br>      count:count<br>     &#125;,<br>    success:function(res)&#123;<br>     <span class="hljs-comment">// console.log(res)</span><br>      <span class="hljs-built_in">var</span>   movies = res.<span class="hljs-built_in">data</span>.subjects;<br>       <span class="hljs-keyword">if</span>(<span class="hljs-keyword">params</span> &amp;&amp; <span class="hljs-keyword">params</span>.success)&#123;<br>         <span class="hljs-keyword">params</span>.success(movies)<br>       &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>解决：将network.js文件进行重构<br>我们network.js 文件在list文件中也用的到，所以放在全局文件中比较合适，可以放在utils中。网络请求代码不是很多，所以我们这里放在一个文件中是可以的。</p><ol start="3"><li>在utils中新建一个network.js文件</li></ol><p>将原来的network.js文件代码拷贝过来，原来文件可以删除了</p><p>此时将所有相关引用路径更改</p><p>network.js代码</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs sqf">import  &#123;globalurls&#125;  <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;urls.js&quot;</span><br><br>const  network=&#123;<br>  <br>getMovieList:function(<span class="hljs-built_in">params</span>)&#123;<br><span class="hljs-built_in">params</span>.<span class="hljs-built_in">type</span>= <span class="hljs-string">&quot;movie&quot;</span>;<br>this.getItemList(<span class="hljs-built_in">params</span>);<br>&#125;,<br>getTVList:function(<span class="hljs-built_in">params</span>)&#123;<br>    <span class="hljs-built_in">params</span>.<span class="hljs-built_in">type</span>= <span class="hljs-string">&quot;tv&quot;</span>;<br>    this.getItemList(<span class="hljs-built_in">params</span>);<br>     &#125; ,<br>getShowList: function(<span class="hljs-built_in">params</span>)&#123;<br>    <span class="hljs-built_in">params</span>.<span class="hljs-built_in">type</span>= <span class="hljs-string">&quot;show&quot;</span>;<br>    this.getItemList(<span class="hljs-built_in">params</span>);<br>&#125;,<br><br><br><span class="hljs-comment">// 获取item列表 params获取传递参数type</span><br>getItemList:function(<span class="hljs-built_in">params</span>)&#123;<br>  <span class="hljs-comment">// 获取不同url</span><br>  var  url=<span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">params</span>.<span class="hljs-built_in">type</span> === <span class="hljs-string">&quot;movie&quot;</span>)&#123;<br>    url= globalurls.movieList;<br>  &#125;<span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">params</span>.<span class="hljs-built_in">type</span>===<span class="hljs-string">&quot;tv&quot;</span>)&#123;<br>    url = globalurls.tvList;<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    url= globalurls.showList;<br>  &#125;<br>  var <span class="hljs-built_in">count</span> = <span class="hljs-built_in">params</span>.<span class="hljs-built_in">count</span> ? <span class="hljs-built_in">params</span>.<span class="hljs-built_in">count</span> : <span class="hljs-number">7</span>;<br>  wx.request(&#123;<br>    <span class="hljs-comment">//  豆瓣电影接口</span><br>     url: url,<br>     data:&#123;<br>       <span class="hljs-built_in">count</span>:<span class="hljs-built_in">count</span><br>     &#125;,<br>     success:function(res)&#123;<br>    <span class="hljs-comment">// item代表所有的项</span><br>       var   <span class="hljs-built_in">items</span> =res.data.subject_collection_items;<br>       var  itemsCount = <span class="hljs-built_in">items</span>.length;<br>       var  left = itemsCount%<span class="hljs-number">3</span>;<br>       <span class="hljs-keyword">if</span>(left===<span class="hljs-number">2</span>)&#123;<br>         <span class="hljs-built_in">items</span>.push(null);<br>       &#125;<br>       <span class="hljs-keyword">if</span>(<span class="hljs-built_in">params</span> &amp;&amp; <span class="hljs-built_in">params</span>.success)&#123;<br>        <span class="hljs-comment">//  将items传出</span><br>        <span class="hljs-built_in">params</span>.success( <span class="hljs-built_in">items</span>)<br>      &#125;<br>     &#125;,<br> &#125;);<br>&#125;<br>&#125;<br><br>export  &#123;network&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>在list.js中请求网络</li></ol><p>修改引入路径<br>import {network}  from  “../../utils/network.js”;</p><p>list.js代码</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs sqf">onLoad: function (options) &#123;<br>   var  that= this;<br>   var  <span class="hljs-built_in">type</span> = options.<span class="hljs-built_in">type</span>;<br>   var  title =<span class="hljs-string">&quot;&quot;</span>;<br>   <span class="hljs-comment">// 数据加载前</span><br>   wx.showLoading(&#123;<br>     title: <span class="hljs-string">&#x27;正在加载中...&#x27;</span>,<br>   &#125;)<br>   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">type</span> === <span class="hljs-string">&quot;movie&quot;</span>)&#123;<br>     <span class="hljs-comment">// 请求的电影数据</span><br>     network.getMovieList(&#123;<br>       success:function(<span class="hljs-built_in">items</span>)&#123;<br>         that.setData(&#123;<br>           <span class="hljs-built_in">items</span>: <span class="hljs-built_in">items</span><br>         &#125;);<br>         <span class="hljs-comment">// 数据加载完成</span><br>           wx.hideLoading();<br>       &#125;,<br>       <span class="hljs-comment">// 确保获取到所有数据</span><br>             <span class="hljs-built_in">count</span>:<span class="hljs-number">1000</span><br>     &#125;)<br>    title= <span class="hljs-string">&quot;电影&quot;</span><br>   &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">type</span>=== <span class="hljs-string">&quot;tv&quot;</span>)&#123;<br>     <span class="hljs-comment">// 请求电视剧的数据</span><br>     network.getTVList(&#123;<br>       success:function(<span class="hljs-built_in">items</span>)&#123;<br>         that.setData(&#123;<br>           <span class="hljs-built_in">items</span>: <span class="hljs-built_in">items</span><br>         &#125;);<br>         wx.hideLoading();<br>       &#125;,<br>       <span class="hljs-built_in">count</span>:<span class="hljs-number">1000</span><br>     &#125;);<br>     title = <span class="hljs-string">&quot;电视剧&quot;</span><br>   &#125;<span class="hljs-keyword">else</span>  &#123;<br>     <span class="hljs-comment">//请求综艺的数据</span><br>     network.getShowList(&#123;<br>       success:function(<span class="hljs-built_in">items</span>)&#123;<br>         that.setData(&#123;<br>           <span class="hljs-built_in">items</span>: <span class="hljs-built_in">items</span><br>         &#125;);<br>         wx.hideLoading();<br>       &#125;,<br>       <span class="hljs-built_in">count</span>:<span class="hljs-number">1000</span><br>     &#125;);<br>     title=<span class="hljs-string">&quot;综艺&quot;</span>;<br>   &#125;<br>   wx.setNavigationBarTitle(&#123;<br>     title:title,<br>   &#125;)<br> &#125;<br></code></pre></td></tr></table></figure><p>问题：发现页面不显示但是也没有报错，说明数据获取了但是没有渲染</p><p>问题：将原来的movies修改为items</p><p><img src="/image/17.14.png" alt="问题"></p><ol start="5"><li>优化</li></ol><p>当点击更多之后(电影，电视剧，综艺)三个上方均显示为豆瓣评分，这时候我们需要考虑到用户体验，将上面的数据进行修改。</p><p><img src="/image/17.15.png" alt="优化"></p><p>解决：在list.js文件中</p><p>微信的函数设置</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss">wx.setNavigationBarTitle(&#123;<br>  <span class="hljs-built_in">title</span>:<span class="hljs-built_in">title</span>,<br>&#125;)<br></code></pre></td></tr></table></figure><p>函数上面定义一个title</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">var  title</span> =<span class="hljs-string">&quot;&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="/image/17.16.png" alt="根据请求数据改变title"></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ol><li>如果底部剩余两个item就会出现一下情况，因为是flex布局</li></ol><p><img src="/image/17.17.png" alt="左右各一个,中间空"></p><ol start="2"><li>分析：</li></ol><ul><li>在主轴上的那布局排列总共有5中</li><li>1从左到右排列，最下面的可以但是上面的可能排列就不那么好看了，因为它的中间的间距你不好掌握</li><li>2中间间距相等的方式也不这么好，页面排列也不那么好看</li></ul><p>什么时候会产生这个问题，就是底部余2个，余1余活3个都不会产生</p><p>解决：这时候我们要迎合flex布局方式，在数据渲染的时候判断数据对3取余是不是等于2</p><p>当然我们还要对index页面进行分析，因为index页面也调用了network.js,因为首页是得到了7个数据，对3取余为1，所以对network.js处理是不会对页面有影响的。</p><p>代码解决network.js</p><p>如果余2就添加一个空的数据</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">var</span>  itemsCount = items.length;<br><span class="hljs-built_in">var</span>  <span class="hljs-built_in">left</span> = itemsCount%<span class="hljs-number">3</span>;<br><span class="hljs-built_in">if</span>(<span class="hljs-built_in">left</span>===<span class="hljs-number">2</span>)&#123;<br>  items.push(null);<br>&#125;<br></code></pre></td></tr></table></figure><p>新问题：出现一个未评分</p><p><img src="/image/17.18.png" alt="新问题"></p><p>解决：在itemview中判断是否传入值</p><p><img src="/image/17.19.png" alt="item解决"></p><ol start="3"><li>页面加载优化</li></ol><p>数据加载需要时间，如果长时间没有加载出来，用户体验会不好，会损失用户。</p><p>处理：调用小程序Api实现，</p><p><img src="/image/17.20.png" alt="三个同时作用"></p>]]></content>
    
    
    <categories>
      
      <category>WX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WX</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>豆瓣&amp;首页布局和数据获取&amp;首页模块重构&amp;网络请求模块重构</title>
    <link href="/2021/04/21/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
    <url>/2021/04/21/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="首页布局和数据获取"><a href="#首页布局和数据获取" class="headerlink" title="首页布局和数据获取"></a>首页布局和数据获取</h3><ol><li>将电影中假的数据变成真的数据(wx.request请求Api)</li></ol><p>首页js文件中获取，在onLoad中请求数据，这个页面一旦加载完毕就去请求</p><p>index.js</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs awk">/*<br>*生命周期函数-监听页面加载<br>*/<br>onLoad:<span class="hljs-keyword">function</span>(options)&#123;<br>  <span class="hljs-regexp">//</span> that方便后期使用当前Page对象<br>   var  that = this;<br>  <span class="hljs-regexp">//</span>  top20电影<br>   wx.request(&#123;<br>    <span class="hljs-regexp">//</span>  豆瓣电影接口<br>     url: <span class="hljs-string">&#x27;https://api.rixingyike.com/doubanapiv2/movie/top250?start=0&amp;count=10&#x27;</span>,<br>     success:<span class="hljs-keyword">function</span>(res)&#123;<br>      <span class="hljs-regexp">//</span> console.log(res)<br>       var   movies = res.data.subjects;<br>      <span class="hljs-regexp">//</span>  console.log(movies);<br>      &lt;!-- 保存movies数据 --&gt;<br>       that.setData(&#123;<br>         movies: movies<br>       &#125;);<br>    <br>     &#125;,<br> &#125;)<br>    <span class="hljs-regexp">//</span>  正在热映的电影<br>    wx.request(&#123;<br>      <span class="hljs-regexp">//</span>  豆瓣电影接口<br>       url: <span class="hljs-string">&#x27;https://api.rixingyike.com/doubanapiv2/movie/in_theaters?start=0&amp;count=10&#x27;</span>,<br>       success:<span class="hljs-keyword">function</span>(res)&#123;<br>        <span class="hljs-regexp">//</span> console.log(res)<br>         var   tvs = res.data.subjects;<br>         that.setData(&#123;<br>           tvs:tvs<br>         &#125;);<br>       &#125;,<br>   &#125;),<br>  <span class="hljs-regexp">//</span>  即将上映的电影<br>  wx.request(&#123;<br>    <span class="hljs-regexp">//</span>  豆瓣电影接口<br>     url: <span class="hljs-string">&#x27;https://api.rixingyike.com/doubanapiv2/movie/coming_soon?start=0&amp;count7&#x27;</span>,<br>     success:<span class="hljs-keyword">function</span>(res)&#123;<br>      <span class="hljs-regexp">//</span> console.log(res)<br>       var   shows = res.data.subjects;<br>       that.setData(&#123;<br>       shows:shows<br>       &#125;);<br>     &#125;,<br> &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/16.9.png" alt="数据放置,其他类型同理"></p><ol start="2"><li><p>由于豆瓣Api不对外开放，以上Api是我从网上得到进行处理的，部分数据加载不出来。</p></li><li><p>测试版本微信要勾选不校验合法域名才能网上获取数据</p></li></ol><p><img src="/image/16.10.png" alt="勾选不校验合法域名"></p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><blockquote><p>wx:key作用：<br>如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如<code> &lt;input/&gt;</code> 中的输入内容， <code>&lt;switch/&gt; </code>的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。<br>wx:key 的值以两种形式提供：                      </p></blockquote><ol><li>字符串或者数字，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。在写的时候，直接写这个 property 的名字就可以了，不需要写 item.property 的形式，并且不需要加中括号。                        </li><li>保留关键字 this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，*框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。</li></ol><blockquote><p>setData<br>如果以后想要修改 data 中的值，应该使用 setData 方法。 setData 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）。注意事项：</p></blockquote><ol><li>直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致。      </li><li>放到 data 中的值，只能使用可以 JSON 序列化的：字符串，数字，布尔值，对象，数组。否则将不会渲染。          </li><li>其中 key 可以以数据路径的形式给出，支持改变数组中的某一项或对象的某个属性，如<br>array[2].message ， a.b.c.d ，并且不需要在 this.data 中预先定义。    </li></ol><h3 id="首页模块重构"><a href="#首页模块重构" class="headerlink" title="首页模块重构"></a>首页模块重构</h3><p><img src="/image/16.11.png" alt="首页图片"></p><h4 id="分析：首页三个模块中90-以上的代码都是重复的，我们可以把它给重构"><a href="#分析：首页三个模块中90-以上的代码都是重复的，我们可以把它给重构" class="headerlink" title="分析：首页三个模块中90%以上的代码都是重复的，我们可以把它给重构"></a>分析：首页三个模块中90%以上的代码都是重复的，我们可以把它给重构</h4><p>把不同的东西提取出来，通过变量的方式表示，将以上一个模块做成一个组件。然后做成三个属性{电影，更多，循环的movies}</p><p><img src="/image/16.12.png" alt="分析"></p><ol><li>在components中新建一个indexmodules组件</li></ol><p>将index.wxml中的代码剪切到indexmodules.wxml中</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;module-group&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">view</span>   <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;module-top&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;module-title&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">navigator</span>  <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">moreurl</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;module-more&quot;</span>&gt;</span>更多<span class="hljs-tag">&lt;/<span class="hljs-name">navigator</span>&gt;</span> </span><br><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">scroll-view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;module-scroll-view&quot;</span>  <span class="hljs-attr">scroll-x</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">true</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">navigator</span>   <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">items</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>  <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item-title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-navigator&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-group&quot;</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;thumbnail-group&quot;</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;thumbnail&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.images.small</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-title&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">stars</span>  <span class="hljs-attr">rate</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.rating.average</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">stars</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">navigator</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">scroll-view</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">  </span><br></code></pre></td></tr></table></figure><p>将index.wxss中的代码剪切到indexmodules.wxss中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 最大模块 */</span><br><span class="hljs-selector-class">.module-group</span>&#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br><span class="hljs-comment">/* 顶部电影 更多flex布局 */</span><br><span class="hljs-selector-class">.module-group</span> <span class="hljs-selector-class">.module-top</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">36</span>rpx;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-comment">/* 主轴元素贴两边 */</span><br>  <span class="hljs-attribute">justify-content</span>: space-between;<br>&#125;<br><span class="hljs-comment">/* title字体颜色设置 */</span><br><span class="hljs-selector-class">.module-top</span> <span class="hljs-selector-class">.moudle-title</span>&#123;<br>  <span class="hljs-attribute">color</span>:<span class="hljs-number">#494949</span>;<br>&#125;<br><span class="hljs-comment">/* more颜色设置 */</span><br><span class="hljs-selector-class">.module-top</span> <span class="hljs-selector-class">.module-more</span>&#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#41be57</span>;<br>&#125;<br><br><span class="hljs-selector-class">.module-scroll-view</span>&#123;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">400</span>rpx;<br>  <span class="hljs-comment">/* 设置横向滚动 */</span><br>  <span class="hljs-attribute">white-space</span>: nowrap;<br>&#125;<br><span class="hljs-selector-class">.module-scroll-view</span> <span class="hljs-selector-class">.item-navigator</span>&#123;<br>  <span class="hljs-attribute">width</span>:<span class="hljs-number">200</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>&#125;<br><span class="hljs-comment">/* 最后一个的右边距 对齐 */</span><br><span class="hljs-selector-class">.module-scroll-view</span> <span class="hljs-selector-class">.item-navigator</span><span class="hljs-selector-pseudo">:last-of-type</span>&#123;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.item-navigator</span>  <span class="hljs-selector-class">.item-group</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.item-group</span> <span class="hljs-selector-class">.thumbnail-group</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">284</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.thumbnail-group</span> <span class="hljs-selector-class">.thumbnail</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><span class="hljs-selector-class">.item-group</span> <span class="hljs-selector-class">.item-title</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">28</span>rpx;<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-comment">/* 文本过长处理 */</span><br>  <span class="hljs-attribute">text-overflow</span>:ellipsis;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>将要渲染的数据定义成三个属性</li></ol><p>indexmodules.js文件中</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 组件的属性列表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-symbol">properties:</span> &#123;<br><span class="hljs-symbol">    title:</span>&#123;<br><span class="hljs-symbol">      type:</span>String,<br><span class="hljs-symbol">      value:</span><span class="hljs-string">&quot;&quot;</span><br>    &#125;,<br><span class="hljs-symbol">    moreurl:</span>&#123;<br><span class="hljs-symbol">      type:</span>String,<br><span class="hljs-symbol">      value:</span><span class="hljs-string">&quot;&quot;</span><br>    &#125;,<br><span class="hljs-symbol">    items:</span>&#123;<br><span class="hljs-symbol">      type:</span>Array,<br><span class="hljs-symbol">      value:</span>[]<br>    &#125;<br><br>&#125;,<br></code></pre></td></tr></table></figure><ol start="3"><li>组件引用</li></ol><p>index.json文件中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;searchbar&quot;</span>:<span class="hljs-string">&quot;/components/searchbar/searchbar&quot;</span>,<br>    <span class="hljs-attr">&quot;stars&quot;</span>:<span class="hljs-string">&quot;/components/stars/stars&quot;</span>,<br>    <span class="hljs-attr">&quot;indexmodule&quot;</span>:<span class="hljs-string">&quot;/components/indexmodule/indexmodule&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>组件使用</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-comment">&lt;!-- top20电影 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">indexmodule</span>  <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;电影&quot;</span>  <span class="hljs-attr">items</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">movies</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">indexmodule</span>&gt;</span></span><br><span class="xml"> <span class="hljs-comment">&lt;!-- 正在热映的电影 --&gt;</span></span><br><span class="xml"> <span class="hljs-tag">&lt;<span class="hljs-name">indexmodule</span>  <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;正在热映电影&quot;</span>  <span class="hljs-attr">items</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">tvs</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">indexmodule</span>&gt;</span></span><br><span class="xml"> <span class="hljs-comment">&lt;!-- 即将上映的电影 --&gt;</span></span><br><span class="xml"> <span class="hljs-tag">&lt;<span class="hljs-name">indexmodule</span>  <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;即将上映电影&quot;</span>  <span class="hljs-attr">items</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">shows</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">indexmodule</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><p><img src="/image/16.13.png" alt="组件使用"></p><ol start="5"><li>问题：此时评分不见了stars是放在indexmodule中使用，所以要在indexmodule.js中引用一下stars组件</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;component&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;stars&quot;</span>:<span class="hljs-string">&quot;/components/stars/stars&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时页面效果和之前一样了<br><img src="/image/16.11.png" alt="页面效果"></p><h3 id="网络请求模块重构"><a href="#网络请求模块重构" class="headerlink" title="网络请求模块重构"></a>网络请求模块重构</h3><h4 id="对index-js中的网络请求代码进行重构"><a href="#对index-js中的网络请求代码进行重构" class="headerlink" title="对index.js中的网络请求代码进行重构"></a>对index.js中的网络请求代码进行重构</h4><ol><li>index.js中只有这些网路请求的代码</li><li>代码重复较多</li><li>MVC思想 Model(数据data)  View(html,css)  Controller(控制器,起到指挥的作用，具体怎么去实现交给专门的模块,可以比喻成交警指挥交通并不会去开车)</li></ol><p><img src="/image/16.14.png" alt="代码示例"></p><h4 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h4><ol><li>将网络请求放入一个network.js文件中去完成</li></ol><p>将index.wxml中的request请求剪切到network.js中</p><p><img src="/image/16.15.png" alt="network.js"></p><ol start="2"><li>index.js 导入模块  import  {network}  from  “../../utils/network.js”</li></ol><p>代码处理，存储数据，其他模块进行相同处理<br><img src="/image/16.16.png" alt="network.js"></p><ol start="3"><li><p>这时候index.js就起到了一个控制器的作用，不会起到网络请求的的作用，真正的网络请求在network.js文件中。我们只负责调用。</p></li><li><p>考虑到后期我们点击更多列表页使用的ur和首页的url是一样的，所以我们可以把url链接单独抽取出来。</p></li></ol><p>在utils文件中单独创建一个文件用来存储这些链接urls.js</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts">const  globalurls=&#123;<br><span class="hljs-symbol">  movieList:</span> <span class="hljs-string">&quot;https://m.douban.com/rexxar/api/v2/subject_collection/movie_showing/items&quot;</span>,<br><span class="hljs-symbol">  tvList:</span> <span class="hljs-string">&quot;https://m.douban.com/rexxar/api/v2/subject_collection/tv_hot/items&quot;</span>,<br><span class="hljs-symbol">  showList:</span> <span class="hljs-string">&quot;https://m.douban.com/rexxar/api/v2/subject_collection/tv_variety_show/items&quot;</span>,<br>&#125;<br><span class="hljs-class">export </span>&#123;globalurls&#125;   <span class="hljs-comment">//导出</span><br></code></pre></td></tr></table></figure><p>network.js文件中修改代码</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">url:</span> globalurls.movieList,<br><span class="hljs-symbol">data:</span>&#123;<br><span class="hljs-symbol">  count:</span><span class="hljs-number">7</span><br> &#125;,<br></code></pre></td></tr></table></figure><h4 id="重构后首页效果与之前一样"><a href="#重构后首页效果与之前一样" class="headerlink" title="重构后首页效果与之前一样"></a>重构后首页效果与之前一样</h4><p>由于我的Api换了，所以数据发生了一些变化，之前代码一些数据获取代码可能之后不同</p><p><img src="/image/16.17.png" alt="首页"></p>]]></content>
    
    
    <categories>
      
      <category>WX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WX</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>豆瓣小程序&amp;入门&amp;搜索栏的实现&amp;评分星星布局</title>
    <link href="/2021/04/20/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <url>/2021/04/20/%E5%BE%AE%E4%BF%A1%E8%B1%86%E7%93%A3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<p>微信小程序由于适用性强、逻辑简要、开发迅速的特性，叠加具有海量活跃用户的腾讯公司背景，逐渐成为了轻量级单一功能应用场景的较佳承载方式，诸如电影购票、外卖点餐、移动商城、生活服务等场景服务提供商迅速切入了。<br>前段时间学习了一个微信小程序，将所学的html,css,js一起运用学习，下面是记录我的开发过程。</p><hr><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>下载微信开发者工具新建一个微信小程序即可,会出现以下目录结构：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- project.config.json：项目的配置文件。比如设置项目的名字，设置appid等。<br>- app.js：小程序逻辑处理。比如小程序加载完成执行的代码。<br>- app.json：小程序公共配置。比如小程序的页面，是否有tabbar等。<br>- app.wxss：小程序公共样式。在这个里面写的样式可以被所有页面使用。<br>- pages：存储小程序页面的。<br>- <span class="hljs-keyword">index</span>：页面的名称<br>- <span class="hljs-keyword">index</span>.js：<span class="hljs-keyword">index</span>页面的逻辑处理文件。<br>- <span class="hljs-keyword">index</span>.json：<span class="hljs-keyword">index</span>页面的配置文件。<br>- <span class="hljs-keyword">index</span>.wxml：<span class="hljs-keyword">index</span>页面的页面结构。<br>- <span class="hljs-keyword">index</span>.wxss：<span class="hljs-keyword">index</span>页面的样式。<br>- 其他页面<br></code></pre></td></tr></table></figure><p><img src="/image/16.1.PNG" alt="目录结构"></p><p>修改app.json文件全局配置</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;window&quot;</span>:&#123;<br>  <span class="hljs-string">&quot;backgroundTextStyle&quot;</span>:<span class="hljs-string">&quot;light&quot;</span>,<br>  <span class="hljs-string">&quot;navigationBarBackgroundColor&quot;</span>: <span class="hljs-string">&quot;#41be57&quot;</span>,<br>  <span class="hljs-string">&quot;navigationBarTitleText&quot;</span>: <span class="hljs-string">&quot;豆瓣评分&quot;</span>,<br>  <span class="hljs-string">&quot;navigationBarTextStyle&quot;</span>:<span class="hljs-string">&quot;white&quot;</span><br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="微信小程序组件封装"><a href="#微信小程序组件封装" class="headerlink" title="微信小程序组件封装"></a>微信小程序组件封装</h3><p>相信大家在开发小程序时会遇到某个功能多次使用的情况，比如弹出框。这个时候大家首先想到的是组件化开发，就是把弹出框封装成一个组件，然后哪里使用哪里就调用。</p><h3 id="搜索栏的实现1–主页search"><a href="#搜索栏的实现1–主页search" class="headerlink" title="搜索栏的实现1–主页search"></a>搜索栏的实现1–主页search</h3><p>因为搜索栏会在多处使用，所以把它做成组件是最好的，这样可以多处使用，实现代码的优化。</p><p><img src="/image/16.2.png" alt="新建组件"></p><ol><li>分析：搜索框由两部分组成，即外盒子和搜索框组成</li><li>在主页的时候是导航栏，在搜索页面的时候是搜索框。</li></ol><p><img src="/image/16.3.png" alt="搜索框"></p><ol start="2"><li>searchbar.wxml/.wxss代码实现</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;searchbar&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 导航栏 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">navigator</span>    <span class="hljs-attr">url</span>=<span class="hljs-string">&#x27;/pages/search/search&#x27;</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;search-navigator&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">navigator</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;search-input&#x27;</span>  <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;搜索&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 这里一保存ctrl+s就会自动生成/pages/search/search文件了 --&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.searchbar</span>&#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#41be57</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.search-navigator</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">60</span>rpx;<br>  <span class="hljs-attribute">background</span>:<span class="hljs-number">#fff</span>;<br>  <span class="hljs-attribute">border-radius</span>:  <span class="hljs-number">10</span>rpx;<br><br>  &lt;!-- 本地图片资源无法通过wxss获取，可以通过网络图片，或者base64，或者&lt;/image&gt;标签  这里我们使用网络转换的base图片 --&gt;<br><br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAPA0lEQVR4Xu2dj5UUNxLGpQgMERhHwBKBrUnAEIFxBOYiOByBIQKvIzBOYAQR3F4EhyM4iED3Pq/mPDvsTFep1b3qqq/f4wFvJc3qK/2mVKU/HQMfKkAFzioQqQ0VoALnFSAgHB1U4IICBITDgwoQEI4BKtCmAD1Im26s5UQBAuLE0OxmmwIEpE031nKiAAFxYmh2s00BAtKmG2s5UYCAODE0u9mmAAFp0421nChAQJwYmt1sU4CAtOnGWk4UICBO.....省略&quot;</span>);<br><br>  <span class="hljs-attribute">background-position</span>: center center;<br>  <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">8%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>组件被使用(在首页中使用)在index.json文件中注册</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;searchbar&quot;</span>:<span class="hljs-string">&quot;/components/searchbar/searchbar&quot;</span>,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>组件的使用</li></ol><p>index.html中代码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;searchbar&gt;</span><span class="hljs-section">&lt;/searchbar&gt;</span><br></code></pre></td></tr></table></figure><h3 id="搜索栏的实现2—search页面"><a href="#搜索栏的实现2—search页面" class="headerlink" title="搜索栏的实现2—search页面"></a>搜索栏的实现2—search页面</h3><ol><li>使用组件</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;searchbar&quot;</span>:<span class="hljs-string">&quot;/components/searchbar/searchbar&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/16.4.png" alt="组件的注册"></p><ol start="2"><li>组件使用</li></ol><p>search.wxml中代码</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;searchbar&gt;</span><span class="hljs-section">&lt;/searchbar&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>搜索页面searchbar.wxml</li></ol><p>将导航组将navigator添加到组件的属性列表</p><p><img src="/image/16.5.png" alt="添加属性"></p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;searchbar&quot;</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-comment">&lt;!--根据导航组件进行不同的渲染 --&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">navigator</span>  <span class="hljs-attr">wx:if</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">isnavigator</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>  <span class="hljs-attr">url</span>=<span class="hljs-string">&#x27;/pages/search/search&#x27;</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;search-navigator&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">navigator</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">wx:else</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;search-input-group&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&#x27;search-input&#x27;</span>  <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;搜索&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><p>首页index.wxml  </p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">searchbar</span>  <span class="hljs-attr">isnavigator</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">true</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">searchbar</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>搜索框样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.search-input-group</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">60</span>rpx;<br>  <span class="hljs-attribute">background</span>:<span class="hljs-number">#fff</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10</span>rpx;<br>  <span class="hljs-attribute">border-radius</span>:<span class="hljs-number">10</span>rpx;<br>  <span class="hljs-attribute">padding</span>:<span class="hljs-number">10</span>rpx <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>&#125;<br><span class="hljs-selector-class">.search-input</span>&#123;<br>  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="电影模块布局"><a href="#电影模块布局" class="headerlink" title="电影模块布局"></a>电影模块布局</h3><ol><li>分析：为一个模块而不是一个盒子，因为下面的是一样的模块，所以后面可以复用。</li></ol><p>wxml</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;module-group&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;module-top&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;module-title&quot;</span>&gt;</span>正在热映电影<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">navigator</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;module-more&quot;</span>&gt;</span>更多<span class="hljs-tag">&lt;/<span class="hljs-name">navigator</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">scroll-view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;module-scroll-view&quot;</span> <span class="hljs-attr">scroll-x</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">true</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span></span><br><span class="xml">    &lt;navigator</span><br><span class="xml">      wx:for=&quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">tvs</span>&#125;&#125;</span><span class="xml">&quot;</span><br><span class="xml">      wx:key=&quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item-title</span>&#125;&#125;</span><span class="xml">&quot;</span><br><span class="xml">      class=&quot;item-navigator&quot;</span><br><span class="xml">    &gt;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-group&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;thumbnail-group&quot;</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;thumbnail&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.images.small</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item-title&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">stars</span> <span class="hljs-attr">rate</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.rating.average</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">stars</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">navigator</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">scroll-view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>wxss</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 最大模块 */</span><br><span class="hljs-selector-class">.module-group</span>&#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br><span class="hljs-comment">/* 顶部电影 更多flex布局 */</span><br><span class="hljs-selector-class">.module-group</span> <span class="hljs-selector-class">.module-top</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">36</span>rpx;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-comment">/* 主轴元素贴两边 */</span><br>  <span class="hljs-attribute">justify-content</span>: space-between;<br>&#125;<br><span class="hljs-comment">/* title字体颜色设置 */</span><br><span class="hljs-selector-class">.module-top</span> <span class="hljs-selector-class">.moudle-title</span>&#123;<br>  <span class="hljs-attribute">color</span>:<span class="hljs-number">#494949</span>;<br>&#125;<br><span class="hljs-comment">/* more颜色设置 */</span><br><span class="hljs-selector-class">.module-top</span> <span class="hljs-selector-class">.module-more</span>&#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#41be57</span>;<br>&#125;<br><br><span class="hljs-selector-class">.module-scroll-view</span>&#123;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">40</span>rpx;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">400</span>rpx;<br>  <span class="hljs-comment">/* 设置横向滚动 */</span><br>  <span class="hljs-attribute">white-space</span>: nowrap;<br>&#125;<br><span class="hljs-selector-class">.module-scroll-view</span> <span class="hljs-selector-class">.item-navigator</span>&#123;<br>  <span class="hljs-attribute">width</span>:<span class="hljs-number">200</span>rpx;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>&#125;<br><span class="hljs-comment">/* 最后一个的右边距 对齐 */</span><br><span class="hljs-selector-class">.module-scroll-view</span> <span class="hljs-selector-class">.item-navigator</span><span class="hljs-selector-pseudo">:last-of-type</span>&#123;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.item-navigator</span>  <span class="hljs-selector-class">.item-group</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.item-group</span> <span class="hljs-selector-class">.item-title</span>&#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">28</span>rpx;<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-comment">/* 文本过长处理 */</span><br>  <span class="hljs-attribute">text-overflow</span>:ellipsis;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/image/16.7.png" alt="css作用效果例图"></p><p>补充：</p><p>scroll-view：<br>有时候我们的一些视图在手机指定的宽度和高度不够存放。那么可以放在 scroll-view 中。<br>设置横向滚动：</p><ol><li>给 scroll-view 添加 scroll-x=”true” 属性。</li><li>给 scroll-view 添加 white-space:nowrap; 样式。</li><li>给 scroll-view 中的子元素设置为 display:inline-block; 。</li></ol><h3 id="评分星星布局1–初始化固定样式"><a href="#评分星星布局1–初始化固定样式" class="headerlink" title="评分星星布局1–初始化固定样式"></a>评分星星布局1–初始化固定样式</h3><p>wxml</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rate-group&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/imags/rate_light.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/imags/rate_half.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/imags/rate_gray.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span>8.0<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>图片来源本地</p><p><img src="/image/16.6.png" alt="星星图片"></p><p>wxss</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.rate-group</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-content</span>: center;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-attribute">color</span>:<span class="hljs-number">#ccc</span>;<br>  <span class="hljs-attribute">margin-top</span>:<span class="hljs-number">20</span>rpx;<br>&#125;<br><span class="hljs-selector-class">.rate-group</span>  image&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">20</span>rpx;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">20</span>rpx;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="评分星星布局2–组件化"><a href="#评分星星布局2–组件化" class="headerlink" title="评分星星布局2–组件化"></a>评分星星布局2–组件化</h3><h4 id="分析：评分的星星-高亮，半高亮，不亮星星-是通过评分数字变化的，而评分数字是变化的-不同电影-，所以我们可以将数字传进来计算星星的个数，这时候我们可以使用组件的方式。在组件当中我们定义一个属性评分，然后接收评分的数字在生命周期方法中计算星星-高亮，半高亮，不亮星星-，另一个好处是可以多处复用。"><a href="#分析：评分的星星-高亮，半高亮，不亮星星-是通过评分数字变化的，而评分数字是变化的-不同电影-，所以我们可以将数字传进来计算星星的个数，这时候我们可以使用组件的方式。在组件当中我们定义一个属性评分，然后接收评分的数字在生命周期方法中计算星星-高亮，半高亮，不亮星星-，另一个好处是可以多处复用。" class="headerlink" title="分析：评分的星星(高亮，半高亮，不亮星星)是通过评分数字变化的，而评分数字是变化的(不同电影)，所以我们可以将数字传进来计算星星的个数，这时候我们可以使用组件的方式。在组件当中我们定义一个属性评分，然后接收评分的数字在生命周期方法中计算星星(高亮，半高亮，不亮星星)，另一个好处是可以多处复用。"></a>分析：评分的星星(高亮，半高亮，不亮星星)是通过评分数字变化的，而评分数字是变化的(不同电影)，所以我们可以将数字传进来计算星星的个数，这时候我们可以使用组件的方式。在组件当中我们定义一个属性评分，然后接收评分的数字在生命周期方法中计算星星(高亮，半高亮，不亮星星)，另一个好处是可以多处复用。</h4><ol><li>创建stars组件</li></ol><p><img src="/image/16.8.png" alt="创建"></p><ol start="2"><li>将上面的wxml代码放入stars.wxml中，wxss同理</li></ol><ol start="3"><li>在index.json中导入使用<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;usingComponents&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;searchbar&quot;</span>:<span class="hljs-string">&quot;/components/searchbar/searchbar&quot;</span>,<br>    <span class="hljs-attr">&quot;stars&quot;</span>:<span class="hljs-string">&quot;/components/stars/stars&quot;</span>,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>index.wxml中使用<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;stars&gt;</span><span class="hljs-section">&lt;/stars&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="将数据变成活的"><a href="#将数据变成活的" class="headerlink" title="将数据变成活的"></a>将数据变成活的</h4><ol><li>定义属性<br>在stars的stars.js文件中定义星星的一些属性<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dts"> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 组件的属性列表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-symbol">properties:</span> &#123;<br><span class="hljs-symbol">rate:</span>&#123;<br><span class="hljs-symbol">      type:</span>Number,<br><span class="hljs-symbol">      value:</span><span class="hljs-number">0</span><br>    &#125;, <br><span class="hljs-symbol">starsize:</span>&#123;<br><span class="hljs-symbol">  type:</span>Number,<br><span class="hljs-symbol">  value:</span><span class="hljs-number">20</span> <span class="hljs-comment">//rpx</span><br>&#125;,<br><span class="hljs-symbol">fontsize:</span>&#123;<br><span class="hljs-symbol">  type:</span> Number,<br><span class="hljs-symbol">  value:</span><span class="hljs-number">20</span> <span class="hljs-comment">//rpx</span><br>&#125;,<br><span class="hljs-symbol">fontcolor:</span>&#123;<br><span class="hljs-symbol">  type:</span>String,<br><span class="hljs-symbol">  value:</span><span class="hljs-string">&quot;#ccc&quot;</span><br>&#125;<br>&#125;,<br></code></pre></td></tr></table></figure></li><li>在组件的生命周期实现(attached生命周期就是你的组件一旦被加载就会被执行)</li></ol><p>stars.js文件中的代码</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs excel">lifetim<span class="hljs-symbol">es:</span>&#123;<br>  attach<span class="hljs-symbol">ed:fu</span>nction()&#123;<br>    <span class="hljs-built_in">var</span>  that = this;<br>    <span class="hljs-built_in">var</span>  <span class="hljs-built_in">rate</span>= that.properties.rate;<br>    <span class="hljs-built_in">var</span>  inRate = parseInt(<span class="hljs-built_in">rate</span>);<br>    <span class="hljs-built_in">var</span>  light = parseInt(<span class="hljs-built_in">rate</span>/<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">var</span>  half = inRate%<span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">var</span>  gray  = <span class="hljs-number">5</span>-light-half;<br>    <span class="hljs-built_in">var</span> lights = [];<br>    <span class="hljs-built_in">var</span>  halfs = [];<br>    <span class="hljs-built_in">var</span>  grays = [];<br>    // for循环遍历存放到数组中<br>    for(<span class="hljs-built_in">var</span>  <span class="hljs-built_in">index</span>=<span class="hljs-number">1</span>;<span class="hljs-built_in">index</span>&lt;=light;<span class="hljs-built_in">index</span>++)&#123;<br>      lights.push(<span class="hljs-built_in">index</span>);<br>    &#125;<br>    for(<span class="hljs-built_in">var</span>  <span class="hljs-built_in">index</span>=<span class="hljs-number">1</span>;<span class="hljs-built_in">index</span>&lt;=half;<span class="hljs-built_in">index</span>++)&#123;<br>      halfs.push(<span class="hljs-built_in">index</span>);<br>    &#125;<br>    for(<span class="hljs-built_in">var</span>  <span class="hljs-built_in">index</span>=<span class="hljs-number">1</span>;<span class="hljs-built_in">index</span>&lt;=gray;<span class="hljs-built_in">index</span>++)&#123;<br>      grays.push(<span class="hljs-built_in">index</span>);<br>    &#125;<br>    // 评分设置<br>   <span class="hljs-built_in">var</span>   ratetext = <span class="hljs-built_in">rate</span> &amp;&amp; <span class="hljs-built_in">rate</span>&gt;<span class="hljs-number">0</span>?rate.toFixed(<span class="hljs-number">1</span>)<span class="hljs-symbol">:</span><span class="hljs-string">&quot;未评分&quot;</span><br>    //数组获取到后 修改 data 中的值<br>    that.setData(&#123;<br>      ligh<span class="hljs-symbol">ts:li</span>ghts,<br>      hal<span class="hljs-symbol">fs:ha</span>lfs,<br>      gra<span class="hljs-symbol">ys:gr</span>ays,<br>      ratete<span class="hljs-symbol">xt:ra</span>tetext,<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>修改wxml文件中样式</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;rate-group&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">image</span>   <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">starsize</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">rpx; height:</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">starsize</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">rpx&quot;</span>   <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">lights</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>    <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;this&quot;</span>   <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/imags/rate_light.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">image</span>   <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">starsize</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">rpx; height:</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">starsize</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">rpx&quot;</span>   <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">halfs</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>     <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;this&quot;</span>   <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/imags/rate_half.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">image</span>   <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">starsize</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">rpx; height:</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">starsize</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">rpx&quot;</span>    <span class="hljs-attr">wx:for</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">grays</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>    <span class="hljs-attr">wx:key</span>=<span class="hljs-string">&quot;this&quot;</span>    <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/imags/rate_gray.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">text</span>   <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-size:</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">fontsize</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">rpx;color:</span></span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">fontcolor</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string"> &quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">ratetext</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>补充： 生命周期：<br>组件本身的生命周期：<br>组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。<br>其中，最重要的生命周期是 created/attached/detached ，包含一个组件实例生命流程的最主要时间点。（注意：在2.2.3基础库之前，生命周期函数写在 Component 中就可以，在 2.2.3 后应该写在 lifetimes 中。）            </p><ol><li>组件实例刚刚被创建好时， created 生命周期被触发。此时，组件数据 this.data 就是在 Component 构造器中定义的数据 data 。此时还不能调用setData 。通常情况下，这个生命周期只应该用于给组件 this 添加一些自定义属性字段。                </li><li>在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。此时， this.data 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。                    </li><li>在组件离开页面节点树后，detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则detached 会被触发。       </li></ol>]]></content>
    
    
    <categories>
      
      <category>WX</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WX</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue&amp;计算属性&amp;计算属性缓存vs方法methods&amp;Vue侦听器</title>
    <link href="/2021/04/18/Vue&amp;computed%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
    <url>/2021/04/18/Vue&amp;computed%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>前言：插值表达式的语法相当简洁，使用起来也很方便。但是也不免暴露出它的一些缺点，最典型的就是无法进行复杂逻辑运算。所以，Vue才会自带计算属性的功能。</p><hr><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span></span><br><span class="xml">  </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">message.split</span>(<span class="hljs-name">&#x27;&#x27;</span>).reverse().join(<span class="hljs-name">&#x27;&#x27;</span>) &#125;&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中多包含此处的翻转字符串时，就会更加难以处理。</span><br><br><span class="xml">所以，对于任何复杂逻辑，你都应当使用计算属性。</span><br></code></pre></td></tr></table></figure><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>计算属性的本质就是辅助插值表达式来进行复杂逻辑运算的。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">msg</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">count</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  var vm = new Vue(&#123;</span><br><span class="xml">    el: &quot;#app&quot;,</span><br><span class="xml">    data: &#123;</span><br><span class="xml">      msg: &quot;hello  Vue&quot;,</span><br><span class="xml">    &#125;,</span><br><span class="xml">    computed: &#123;</span><br><span class="xml">      count: function () &#123;</span><br><span class="xml">        //切割，翻转，拼接</span><br><span class="xml">        return this.msg.split(&quot; &quot;).reverse().join(&quot;====&quot;); //Vue========hello</span><br><span class="xml">      &#125;,</span><br><span class="xml">    &#125;,</span><br><span class="xml">  &#125;);</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>上面这个案例就是一个computed的实例演示，我们通过代码不难看出：第一个p标记中的插值表达式显示的是原文，而第二个p标记中，显示的则是经过一系列API处理之后的文本内容。</p><p>其中，所有的API操作都放在了computed中的count方法中来实现，而最终插值表达式，只是将computed中处理完毕的属性绑定给自己即可。这也从另一个侧面证实了computed只负责进行复杂逻辑运算的特点。</p><h3 id="计算属性setter和getter"><a href="#计算属性setter和getter" class="headerlink" title="计算属性setter和getter"></a>计算属性setter和getter</h3><ol><li>计算属性一般是没有set方法，只读属性</li><li>使用getter方法较多<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">message</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">    const app = new Vue(&#123;</span><br><span class="xml">      el: &quot;#app&quot;,</span><br><span class="xml">      data: &#123;</span><br><span class="xml">        firstName: &quot;kobe&quot;,</span><br><span class="xml">        lastName: &quot;Bryant&quot;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">      // 计算属性一般是没有set方法，只读属性</span><br><span class="xml">      computed: &#123;</span><br><span class="xml">        // set中方法可以传参数</span><br><span class="xml">        //   fullName: &#123;</span><br><span class="xml">        //     set: function () &#123;</span><br><span class="xml">        //       console.log(&quot;----&quot;);</span><br><span class="xml">        //     &#125;,</span><br><span class="xml">        //   &#125;,</span><br><br><span class="xml">        fullName: &#123;</span><br><span class="xml">          get: function () &#123;</span><br><span class="xml">            return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="xml">          &#125;,</span><br><span class="xml">        &#125;,</span><br><span class="xml">        //与上面方法一样，一般只使用getter方法</span><br><span class="xml">        //   fullName: &#123;</span><br><span class="xml">        //     function() &#123;</span><br><span class="xml">        //       return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="xml">        //     &#125;,</span><br><span class="xml">        //   &#125;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">      methods: &#123;</span><br><span class="xml">         full : function () &#123;</span><br><span class="xml">          return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="xml">        &#125;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">    &#125;);</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ol><h3 id="计算属性缓存-vs-方法methods"><a href="#计算属性缓存-vs-方法methods" class="headerlink" title="计算属性缓存 vs 方法methods"></a>计算属性缓存 vs 方法methods</h3><p>你可能已经注意到我们可以通过在表达式中调用方法来达到同样的效果：</p><p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，<strong>不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 full 计算属性会立即返回之前的计算结果，而不必再次执行函数。</strong></p><p>这也同样意味着下面的计算属性将不再更新，因为computed中的return <code>this.firstName + &quot; &quot; + this.lastName;</code> 不是响应式依赖：      </p><p>相比之下，每当触发重新渲染时，调用方法将<strong>总会</strong>再次执行函数。</p><p>我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。</p><h3 id="Vue侦听器"><a href="#Vue侦听器" class="headerlink" title="Vue侦听器"></a>Vue侦听器</h3><p>侦听属性，响应数据（data&amp;computed）的变化，当数据变化时，会立刻执行对应函数。</p><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-comment">&lt;!-- 这里表示被vue控制的区域 --&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">fullName</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">age</span> &#125;&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  const vm = new Vue(&#123;</span><br><span class="xml">    el: &quot;#app&quot;, // 控制id为app的元素</span><br><span class="xml">    data: &#123;</span><br><span class="xml">      firstName: &quot;li&quot;,</span><br><span class="xml">      lastName: &quot;xinxin&quot;,</span><br><span class="xml">      fullName: &quot;li xinxin&quot;,</span><br><span class="xml">      age: 20,</span><br><span class="xml">    &#125;,</span><br><span class="xml">    watch: &#123;</span><br><span class="xml">      firstName() &#123;</span><br><span class="xml">        console.log(&quot;侦听器执行了&quot;);</span><br><span class="xml">        return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="xml">      &#125;,</span><br><span class="xml">      lastName() &#123;</span><br><span class="xml">        console.log(&quot;侦听器执行了&quot;);</span><br><span class="xml">        return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="xml">      &#125;,</span><br><span class="xml">    &#125;,</span><br><span class="xml">  &#125;);</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/image/15.png" alt="如图"></p><h4 id="侦听器-vs-计算属性"><a href="#侦听器-vs-计算属性" class="headerlink" title="侦听器 vs 计算属性"></a>侦听器 vs 计算属性</h4><ol><li>两者都可以观察和响应Vue实例上的数据的变动。</li><li>watch擅长处理的场景是：一个数据影响多个数据。计算属性擅长处理的场景是：多个数据影响一个数据。</li><li>在侦听器中可以执行异步，但是在计算属性中不可以。</li></ol><h3 id="当我们可以使用一个功能，使用计算属性、方法、侦听器都可以时，推荐使用计算属性。计算属性的模板较轻，有利于提高浏览器的性能。"><a href="#当我们可以使用一个功能，使用计算属性、方法、侦听器都可以时，推荐使用计算属性。计算属性的模板较轻，有利于提高浏览器的性能。" class="headerlink" title="当我们可以使用一个功能，使用计算属性、方法、侦听器都可以时，推荐使用计算属性。计算属性的模板较轻，有利于提高浏览器的性能。"></a>当我们可以使用一个功能，使用计算属性、方法、侦听器都可以时，推荐使用计算属性。计算属性的模板较轻，有利于提高浏览器的性能。</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://cn.vuejs.org/v2/guide/computed.html">Vue官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript 关于赋值、浅拷贝、深拷贝</title>
    <link href="/2021/04/17/javascript%20%E5%85%B3%E4%BA%8E%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <url>/2021/04/17/javascript%20%E5%85%B3%E4%BA%8E%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>以下是对关于赋值、浅拷贝、深拷贝的学习</p><hr><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>说这个话题之前，先扯一下JS的基本数据类型。</p><p>大家都知道JS中的数据类型分为：<br>基本类型：string, number, boolean, null, undefined,symbol(ES6新增)<br>引用类型：Object，特殊的有Array, Function, Date, Math, RegExp, Error等((Object类)有常规名值对的无序对象{a:1}，数组[1,2,3]，以及函数等)     </p><p>那什么是引用类型呢？这又得扯上JS的内存机制了。</p><p>JS的内存跟其他的内存差不多，分为堆（heap）和栈（stack）。 </p><ol><li>栈和堆<br>栈：由系统自动分配，自动回收，效率高，但容量小。<br>堆：由程序员手动分配内存，并且手动销毁（高级语言如JS中有垃圾自动回收机制），效率不如栈，但容量大。<br>请注意区分数据结构中所说的堆栈和内存中的堆栈是两回事。</li><li>基本类型和引用类型分配位置(栈，堆)<br>JS的基本类型分配在栈中，而因为引用类型大小的不固定，系统将存储该引用类型的地址存在栈中，并赋值给变量本身，而具体的内容存在堆中。所以当访问一个对象的时候，先访问栈中它的地址，然后按照这个地址去堆中找到它的实际内容。<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4></li></ol><ol><li>a.基本类型–名值存储在栈内存中，例如let a=1;<br><img src="/image/14.1.PNG" alt="如图"><br>当你b=a复制时，栈内存会新开辟一个内存，例如这样：<br><img src="/image/14.2.PNG" alt="如图">   </li></ol><p>所以当复制的时候，对于基本类型的变量，系统会为新的变量在栈中开辟一个新的空间，赋予相同的值，然后这两个变量就各自独立，毫无牵连。所以当你此时修改a=2，对b并不会造成影响，因为此时的b已自食其力，翅膀硬了，不受a的影响了.         </p><ol><li>b.引用数据类型–名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值<br><img src="/image/14.3.PNG" alt="如图"><br>而对于引用类型的变量，新的变量复制的是那个对象在堆中的地址，这两个变量指向的是同一个对象。        </li></ol><p>例子：简单的引用拷贝(浅拷贝)</p><pre><code>var obj = &#123;name: &#39;Yecao&#39;&#125;;var obj2 = obj;console.log(obj2.name); // &#39;Yecao&#39;obj2.name = &#39;Claire&#39;;console.log(obj.name); //&#39;Claire&#39;</code></pre><p>以上是个很简单的例子，obj2复制了obj之后，两个其实指向的是同一个对象。           </p><p>而当我们a[0]=1时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。             </p><p><img src="/image/14.4.PNG" alt="如图">        </p><p>实现简单的深拷贝<br>这么我们封装一个深拷贝的函数(PS：只是一个基本实现的展示，并非最佳实践)</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> deep<span class="hljs-constructor">Clone(<span class="hljs-params">obj</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> objClone = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">obj</span>)</span>?<span class="hljs-literal">[]</span>:&#123;&#125;;<br>    <span class="hljs-keyword">if</span>(obj<span class="hljs-operator"> &amp;&amp; </span>typeof obj===<span class="hljs-string">&quot;object&quot;</span>)&#123;<br>        <span class="hljs-keyword">for</span>(key <span class="hljs-keyword">in</span> obj)&#123;<br>            <span class="hljs-keyword">if</span>(obj.has<span class="hljs-constructor">OwnProperty(<span class="hljs-params">key</span>)</span>)&#123;<br>                <span class="hljs-comment">//判断ojb子元素是否为对象，如果是，递归复制</span><br>                <span class="hljs-keyword">if</span>(obj<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span>&amp;&amp;typeof obj<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> ===<span class="hljs-string">&quot;object&quot;</span>)&#123;<br>                    objClone<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> = deep<span class="hljs-constructor">Clone(<span class="hljs-params">obj</span>[<span class="hljs-params">key</span>])</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//如果不是，简单复制</span><br>                    objClone<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> = obj<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    return objClone;<br>&#125;    <br><span class="hljs-keyword">let</span> a=<span class="hljs-literal">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]</span>,<br>    b=deep<span class="hljs-constructor">Clone(<span class="hljs-params">a</span>)</span>;<br>a<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>=<span class="hljs-number">2</span>;<br>console.log(a,b);<br></code></pre></td></tr></table></figure><p>可以看到<br><img src="/image/14.5.PNG" alt="如图">        </p><p>跟之前想象的一样，现在b脱离了a的控制，不再受a影响了。</p><p>这里再次强调，深拷贝，是拷贝对象各个层级的属性<br><img src="/image/14.6.PNG" alt="如图">   </p><p>第一层的属性确实深拷贝，拥有了独立的内存，但更深的属性却仍然公用了地址，所以才会造成上面的问题。</p><p>同理，concat方法与slice也存在这样的情况，他们都不是真正的深拷贝，这里需要注意。  </p><h4 id="slice-和-concat"><a href="#slice-和-concat" class="headerlink" title="slice 和 concat"></a>slice 和 concat</h4><p>Array 的 slice 和 concat 方法 和 jQuery 中的 extend 复制方法，他们都会复制第一层的值，对于 第一层 的值都是 深拷贝，而到 第二层 的时候 Array 的 slice 和 concat 方法就是 复制引用 ，jQuery 中的 extend 复制方法 则 取决于 你的 第一个参数， 也就是是否进行递归复制。所谓第一层 就是 key 所对应的 value 值是基本数据类型，也就像上面栗子中的name、age，而对于 value 值是引用类型 则为第二层，也就像上面栗子中的 company。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>JS的基本类型不存在浅拷贝还是深拷贝的问题,深拷贝与浅拷贝的概念只存在于引用类型。</li><li>对于仅仅是复制了引用（地址），换句话说，复制了之后，原来的变量和新的变量指向同一个东西，彼此之间的操作会互相影响，为 浅拷贝。<br>而如果是在堆中重新分配内存，拥有不同的地址，但是值是一样的，复制后的对象与原来的对象是完全隔离，互不影响，为 深拷贝。</li><li>深浅拷贝 的主要区别就是：复制的是引用(地址)还是复制的是实例。</li></ol><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.cnblogs.com/echolun/p/7889848.html">博客圆</a></p><p><a href="https://zhuanlan.zhihu.com/p/26282765">知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-promise</title>
    <link href="/2021/04/17/ES6(promise)/"/>
    <url>/2021/04/17/ES6(promise)/</url>
    
    <content type="html"><![CDATA[<p>在JavaScript的世界中，所有代码都是单线程执行的。由于这个“缺陷”，导致 <strong>JavaScript的所有网络操作，浏览器事件</strong>，都必须是异步执行。异步执行可以用回调函数实现。一旦有一连串的ajax请求a,b,c,d….后面的请求依赖前面的请求结果，就需要层层嵌套。这种缩进和层层嵌套的方式，非常容易造成上下文代码混乱，我们不得不非常小心翼翼处理内层函数与外层函数的数据，一旦内层函数使用了上层函数的变量，这种混乱程度就会加剧…总之，这种层叠上下文的层层嵌套方式，着实增加了神经的紧张程度</p><hr><p>先理解一下什么是回调函数</p><h4 id="什么是函数？"><a href="#什么是函数？" class="headerlink" title="什么是函数？"></a>什么是函数？</h4><p>函数是在其中有一组代码的逻辑构件，用来执行特定任务。实际上为了易于调试和维护，函数允许以更有组织的方式去编写代码。函数还允许代码重用。</p><p>你只需定义一次函数，然后在需要时去调用它，而不必一次又一次地编写相同的代码。</p><h2 id="回调函数（callback）"><a href="#回调函数（callback）" class="headerlink" title="回调函数（callback）"></a>回调函数（callback）</h2><p>首先回调函数就是一个函数,形式上和其他函数没有半点区别.<br>举个例子:</p><p>一般函数:function a(int a, String b):接收的参数是一般类型.</p><p>特殊函数:function b(function c):接收的参数是一个函数,c这个函数就叫回调函数.</p><p>你也可以这么理解:本质区别是,一般一个函数调用另一个函数,被调用的函数是出现在方法体当中,而回调函数比较特殊,它是出现在参数列表当中.也就是说,当调用的时候,需要从其他地方拿到这个(回调)函数,以参数的形式传入.<br><img src="/image/12.png" alt="示例"></p><h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><h3 id="同步和异步区别？"><a href="#同步和异步区别？" class="headerlink" title="同步和异步区别？"></a>同步和异步区别？</h3><p>举个栗子，煮开水，同步就是把水放上去烧，得一直等水开，中途不能做其他事情。而异步，则是把水放上去烧，让水在烧，你可以玩手机看电视，等水开了把火关掉。同样的，代码中也是一样，同步是现在发生的，异步是未来某个时刻发生的。</p><h3 id="JS-运行机制"><a href="#JS-运行机制" class="headerlink" title="JS 运行机制"></a>JS 运行机制</h3><p>先介绍下JavaScript运行机制，因为JS 是单线程运行的，所以这意味着两段代码不能同时运行，而是必须一个接一个地运行，所以，在同步代码执行过程中，异步代码是不执行的。只有等同步代码执行结束后，异步代码才会被添加到事件队列中。</p><h3 id="JS-中异步有几种？"><a href="#JS-中异步有几种？" class="headerlink" title="JS 中异步有几种？"></a>JS 中异步有几种？</h3><p>JS 中异步操作还挺多的，常见的分以下几种：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">setTimeout</span> (<span class="hljs-built_in">setInterval</span>)<br>AJAX<br><span class="hljs-built_in">Promise</span><br><span class="hljs-keyword">async</span>/<span class="hljs-keyword">await</span><br></code></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>状态的特点<br>Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。    </p><p>Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。<br>语法：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim">new <span class="hljs-type">Promise</span>( function(resolve, reject) <span class="hljs-meta">&#123;...&#125;</span>);<br></code></pre></td></tr></table></figure><p>Promise 对象是由关键字 new 及其构造函数来创建的。这个“处理器函数”接受两个函数 resolve 和 reject 作为其参数。当异步任务顺利完成且返回结果值时，会调用 resolve 函数；而当异步任务失败且返回失败原因（通常是一个错误对象）时，会调用reject 函数。       </p><p>new Promise 返回一个 promise 对象，在遇到 resolve 或 reject之前，状态一直是pending，如果调用 resolve 方法，状态变为 fulfilled，如果调用了 reject 方法，状态变为 rejected。   </p><p>例子：<br>案例:用户登录，并展示该用户的各科成绩。在页面发送两次请求:<br>1.查询当前用户信息<br>2.按照当前用户的id查出他的课程<br>3.按照当前课程id查出分数<br>分析:此时后台应该提供三个接口，一个提供用户查询接口，一个提供科目的接口，一个提供各科成绩的接口，为了渲染方便，最好响应json数据。在这里就不编写后台接口了，而是提供三个json文件，直接提供json数据，模拟后台接口。<br><img src="/image/12.1.png" alt="数据如图"></p><ol><li>ajax发送请求获取数据方法<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 导入JQuery --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  $.ajax(&#123;</span><br><span class="javascript">    url: <span class="hljs-string">&quot;mock/user.json&quot;</span>,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">success</span>(<span class="hljs-params">data</span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;查询用户：&quot;</span>, data);</span><br><span class="javascript">      $.ajax(&#123;</span><br><span class="javascript">        url: <span class="hljs-string">`mock/user_corse_<span class="hljs-subst">$&#123;data.id&#125;</span>.json`</span>,</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">success</span>(<span class="hljs-params">data</span>)</span> &#123;</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;查询到课程：&quot;</span>, data);</span><br><span class="javascript">          $.ajax(&#123;</span><br><span class="javascript">            url: <span class="hljs-string">`mock/corse_score_<span class="hljs-subst">$&#123;data.id&#125;</span>.json`</span>,</span><br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">success</span>(<span class="hljs-params">data</span>)</span> &#123;</span><br><span class="javascript">              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;查询到分数：&quot;</span>, data);</span><br>            &#125;,<br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">error</span>(<span class="hljs-params">error</span>)</span> &#123;</span><br><span class="javascript">              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;出现异常了：&quot;</span> + error);</span><br>            &#125;,<br>          &#125;);<br>        &#125;,<br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">error</span>(<span class="hljs-params">error</span>)</span> &#123;</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;出现异常了：&quot;</span> + error);</span><br>        &#125;,<br>      &#125;);<br>    &#125;,<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">error</span>(<span class="hljs-params">error</span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;出现异常了：&quot;</span> + error);</span><br>    &#125;,<br>  &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>Promise方法</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.</span>primise可以封装异步操作<br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">//1.异步操作</span><br>  $.ajax(&#123;<br>    url: <span class="hljs-string">&quot;user.json&quot;</span>,<br>    success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;查询用户成功：&quot;</span>, data);<br>      resolve(data); <span class="hljs-comment">//成功了</span><br>    &#125;,<br>    error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>      reject(err); <span class="hljs-comment">//失败了</span><br>    &#125;,<br>  &#125;);<br>&#125;);<br><span class="hljs-comment">//then 方法接收两个函数作为参数，第一个参数是 Promise 执行成功时的回调，</span><br><span class="hljs-comment">//第二个参数是 Promise 执行失败时的回调，两个函数只会有一个被调用。</span><br><span class="hljs-comment">// obj对象是上一步传下来的对象</span><br>p.then(<span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">//p.then调用完以后还会返回一个promise对象</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    $.ajax(&#123;<br>      url: <span class="hljs-string">`usr_corse_<span class="hljs-subst">$&#123;obj.id&#125;</span>.json`</span>,<br>      success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;查询用户课程成功：&quot;</span>, data);<br>        resolve(data);<br>      &#125;,<br>      error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>        reject(err);<br>      &#125;,<br>    &#125;);<br>  &#125;);<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// data是上一步的data</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;上一步的结果&quot;</span>, data);<br>  $.ajax(&#123;<br>    url: <span class="hljs-string">`corse_score_<span class="hljs-subst">$&#123;data.id&#125;</span>.json`</span>,<br>    success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;查询课程得分成功：&quot;</span>, data);<br>    &#125;,<br>    error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;&#125;,<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="3"><li>简化Promise,抽取方法</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">url, data</span>) </span>&#123;<br>  <span class="hljs-comment">// new  Promise封装一个异步操作</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    $.ajax(&#123;<br>      url: url,<br>      data: data,<br>      success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>        resolve(data);<br>      &#125;,<br>      error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>        reject(err);<br>      &#125;,<br>    &#125;);<br>  &#125;);<br>&#125;<br><span class="hljs-comment">// 发送一个get请求，由于get封装的是Promise方法所以可以调用.then方法</span><br>get(<span class="hljs-string">&quot;user.json&quot;</span>)<br>  .then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;用户查询成功:&quot;</span>, data);<br>    <span class="hljs-keyword">return</span> get(<span class="hljs-string">`usr_corse_<span class="hljs-subst">$&#123;data.id&#125;</span>.json`</span>);<br>  &#125;)<br>  .then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;课程查询成功:&quot;</span>, data);<br>    <span class="hljs-keyword">return</span> get(<span class="hljs-string">`corse_score_<span class="hljs-subst">$&#123;data.id&#125;</span>.json`</span>);<br>  &#125;)<br>  .then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;课程成绩查询成功:&quot;</span>, data);<br>  &#125;)<br>  .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;数据异常&quot;</span>, err);<br>  &#125;);<br></code></pre></td></tr></table></figure><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Promise</span>.<span class="hljs-literal">all</span>([promise<span class="hljs-number">1</span>, promise<span class="hljs-number">2</span>]).then(success<span class="hljs-number">1</span>, fail<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>promise1和promise2都成功才会调用success1</p><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p>Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Promise</span>.race([promise<span class="hljs-number">1</span>, promise<span class="hljs-number">2</span>]).then(success<span class="hljs-number">1</span>, fail<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>promise1和promise2只要有一个成功就会调用success1</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.Promise的作用<br>主要用于异步计算<br>可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果<br>可以在对象之间传递和操作promise，帮助我们处理队列  </p><p>2.理解<br>promise是一个对象，对象和函数的区别就是对象可以保存状态，函数不可以（闭包除外）<br>并未剥夺函数return的能力，因此无需层层传递callback，进行回调获取数据<br>代码风格，容易理解，便于维护<br>多个异步等待合并便于解决</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://juejin.cn/post/6844903541543288840">理解 JavaScript 异步操作</a><br><a href="https://www.runoob.com/w3cnote/es6-promise.html">菜鸟教程</a></p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-模块化</title>
    <link href="/2021/04/17/ES6%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2021/04/17/ES6%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>模块化就是把代码进行拆分，方便重复利用，类似java中的导包，需要使用一个包，必须先导包，而js中没有包的概念，换来的是<strong>模块</strong></p><p>ES6 的模块化分为导出（export） @与导入（import）两个模块。</p><hr><h3 id="一个页面需要引入多个js文件引发的问题"><a href="#一个页面需要引入多个js文件引发的问题" class="headerlink" title="一个页面需要引入多个js文件引发的问题"></a>一个页面需要引入多个js文件引发的问题</h3><ol><li>请求过多</li><li>依赖模糊</li><li>难以维护 这些问题可以通过现代模块化编码和项目构建来解决</li></ol><h2 id="模块化优点"><a href="#模块化优点" class="headerlink" title="模块化优点"></a>模块化优点</h2><ol><li>避免命名冲突（减少命名空间污染）</li><li>更好的分类，按需加载</li><li>更高的复用性</li><li>高可维护性</li></ol><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><p>ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 use strict;。</p></li><li><p>模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。</p></li><li><p>每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。</p></li><li><p>每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。</p></li></ol><h3 id="export-与-import"><a href="#export-与-import" class="headerlink" title="export 与 import"></a>export 与 import</h3><p>模块导入导出各种类型的变量，如字符串，数值，函数，类。</p><ol><li>导出的函数声明与类声明必须要有名称（export default 导出了一个对象，没给这个对象起名字，导入的时候可以随意起名字）。</li><li>不仅能导出声明还能导出引用（例如函数）。</li><li>export 命令可以出现在模块的任何位置，但必需处于模块顶层。(如果处于块级作用域内，就会报错)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;bar&#x27;</span> <span class="hljs-comment">// SyntaxError</span><br>&#125;<br>foo()<br></code></pre></td></tr></table></figure><ol start="4"><li>import 命令会提升到整个模块的头部，首先执行。</li></ol><p>代码示例<br>hello.js</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>  export   const  util=&#123;<br><span class="hljs-regexp">//</span>     sum(a,b)&#123;<br><span class="hljs-regexp">//</span>         return  a+b;<br><span class="hljs-regexp">//</span>     &#125;<br><span class="hljs-regexp">//</span> &#125;<br><br><span class="hljs-regexp">//</span> 这两个等效<br><span class="hljs-regexp">//</span> 导出了一个对象，没给这个对象起名字，导入的时候可以随意起名字<br>export  default&#123;<br>        sum(a,b)&#123;<br>            return  a+b;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>user.js</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">var  <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;jack&quot;</span><br>var  <span class="hljs-attribute">age</span>=21<br><br>function  <span class="hljs-builtin-name">add</span>(a,b)&#123;<br>    return  a+b;<br>&#125;<br><br><span class="hljs-builtin-name">export</span>  &#123;name,age,add&#125;<br></code></pre></td></tr></table></figure><p>main.js</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> abc  <span class="hljs-keyword">from</span>  &quot;./hello.js&quot;<br><span class="hljs-keyword">import</span>  &#123;<span class="hljs-type">name</span>,<span class="hljs-keyword">add</span>&#125;  <span class="hljs-keyword">from</span>  &quot;./user.js&quot;<br><br>abc.sum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>console.log(<span class="hljs-type">name</span>);<br><span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>标签导入</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;script <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;./main.js&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>Babel是一个Javascript编译器，有些浏览器 (如 IE) 尚未支持 ES6 模块化部分语法，因此我们需要使用 babel 对其进行转化，变为浏览器可以识别的语法（ES5）。提升其兼容性。</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.runoob.com/w3cnote/es6-module.html">菜鸟教程</a></p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue&amp; axios的基本使用</title>
    <link href="/2021/04/17/Vue&amp;axios(%E4%B8%80)/"/>
    <url>/2021/04/17/Vue&amp;axios(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h3 id="Vue-js-Ajax-axios"><a href="#Vue-js-Ajax-axios" class="headerlink" title="Vue.js Ajax(axios)"></a>Vue.js Ajax(axios)</h3><p>Vue.js 2.0 版本推荐使用 axios 来完成 ajax 请求。</p><p>Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p><p>Github开源地址： <a href="https://github.com/axios/axios">https://github.com/axios/axios</a></p><h4 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h4><ol><li>使用 cdn:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>使用 npm:<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> axios<br></code></pre></td></tr></table></figure></li><li>其他</li></ol><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol><li>axios必须先导入才可以使用</li><li>使用get或post方法即可发送对应的请求</li><li>then方法中的回调函数会在请求成功或失败时触发</li><li>通过回调函数的形参可以获取响应内容，或错误信息</li></ol><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;get请求&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;get&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;post请求&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;post&quot;</span> /&gt;</span><br>  <span class="hljs-comment">&lt;!-- 官网提供的axios在线地址 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    /*<br>        接口1：随机笑话<br><span class="javascript">        请求地址：https:<span class="hljs-comment">//autumnfish.cn/api/joke/list</span></span><br>        请求方法：get<br>        请求参数：num(笑话条数，数字)<br>        响应内容：随机笑话<br>        */<br><span class="javascript">    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.get&quot;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br>      axios<br><span class="javascript">        .get(<span class="hljs-string">&quot;https://autumnfish.cn/api/joke/list?num=6&quot;</span>)</span><br><span class="javascript">        .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(response);</span><br>        &#125;),<br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(err);</span><br>        &#125;;<br>    &#125;;<br>    /*<br>        接口2：用户注册<br><span class="javascript">        请求地址：https:<span class="hljs-comment">//autumnfish.cn/api/user/reg</span></span><br>        请求方法：post<br>        请求参数：username(用户名，字符串)<br>        响应内容：注册成功失败<br>        */<br><span class="javascript">    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;.post&quot;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br>      axios<br><span class="javascript">        .post(<span class="hljs-string">&quot;https://autumnfish.cn/api/user/reg&quot;</span>, &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&quot;jack&quot;</span> &#125;)</span><br><span class="javascript">        .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(response);</span><br>        &#125;),<br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(err);</span><br>        &#125;;<br>    &#125;;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>querySelector() 方法返回文档中匹配指定 CSS 选择器的一个元素。</p><p>注意： querySelector() 方法仅仅返回匹配指定选择器的第一个元素。如果你需要返回所有的元素，请使用 querySelectorAll() 方法替代。</p><h3 id="axios-vue"><a href="#axios-vue" class="headerlink" title="axios+vue"></a>axios+vue</h3><p>例子：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;获取笑话&quot;</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;getJoke&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">joke</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  <span class="hljs-comment">&lt;!-- 官网提供的axios在线地址 --&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">    /*</span><br><span class="xml">        接口1：随机笑话</span><br><span class="xml">        请求地址：https://autumnfish.cn/api/joke/list</span><br><span class="xml">        请求方法：get</span><br><span class="xml">        请求参数：num(笑话条数，数字)</span><br><span class="xml">        响应内容：随机笑话</span><br><span class="xml">        */</span><br><span class="xml">    var app = new Vue(&#123;</span><br><span class="xml">      el: &quot;#app&quot;,</span><br><span class="xml">      data: &#123;</span><br><span class="xml">        joke: &quot;很好笑的笑话&quot;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">      methods: &#123;</span><br><span class="xml">        getJoke: function () &#123;</span><br><span class="xml">          console.log(this.joke);</span><br><span class="xml">          var that = this;</span><br><span class="xml">          axios</span><br><span class="xml">            .get(&quot;https://autumnfish.cn/api/joke&quot;)</span><br><span class="xml">            .then(function (response) &#123;</span><br><span class="xml">              // console.log(response);</span><br><span class="xml">              console.log(response.data);</span><br><span class="xml">              // console.log(this.joke);</span><br><span class="xml">              that.joke = response.data;</span><br><span class="xml">            &#125;),</span><br><span class="xml">            function (err) &#123;&#125;;</span><br><span class="xml">        &#125;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">    &#125;);</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue&amp;v-on&amp;v-show&amp;v-if&amp;v-bind&amp;v-for&amp;v-model</title>
    <link href="/2021/04/16/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
    <url>/2021/04/16/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。</p><p>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。</p><hr><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><ol><li>该指令的作用是：为元素绑定事件</li><li>事件名不需要写on</li><li>指令可以简写为@</li><li>绑定的方法定义在methods属性中</li><li>方法内部通过this关键字可以访问定义在data中的数据</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;v-on指令&quot;</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;doIt&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;v-on简写&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;doIt&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;双击事件&quot;</span> @<span class="hljs-attr">dblclick</span>=<span class="hljs-string">&quot;doIt&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeFood&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">food</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">    var app = new Vue(&#123;</span><br><span class="xml">      el: &quot;#app&quot;,</span><br><span class="xml">      data: &#123;</span><br><span class="xml">        food: &quot;西兰花炒蛋&quot;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">      methods: &#123;</span><br><span class="xml">        doIt: function () &#123;</span><br><span class="xml">          alert(&quot;学Vue&quot;);</span><br><span class="xml">        &#125;,</span><br><span class="xml">        changeFood: function () &#123;</span><br><span class="xml">          // console.log(this.food);</span><br><span class="xml">          this.food += &quot;好好吃！&quot;;</span><br><span class="xml">        &#125;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">    &#125;);</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><img src="/image/11.6.PNG" alt="效果图"></p><h4 id="v-on例子"><a href="#v-on例子" class="headerlink" title="v-on例子"></a>v-on例子</h4><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">  <span class="hljs-comment">&lt;!-- html结构 --&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-num&quot;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">num</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sub&quot;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  <span class="hljs-comment">&lt;!-- 编码 --&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">    // 创建Vue实例</span><br><span class="xml">    var app = new Vue(&#123;</span><br><span class="xml">      el: &quot;#app&quot;,</span><br><span class="xml">      data: &#123;</span><br><span class="xml">        num: 1,</span><br><span class="xml">      &#125;,</span><br><span class="xml">      methods: &#123;</span><br><span class="xml">        add: function () &#123;</span><br><span class="xml">          // console.log(&quot;add&quot;);</span><br><span class="xml">          if (this.num &lt; 10) &#123;</span><br><span class="xml">            this.num++;</span><br><span class="xml">          &#125; else &#123;</span><br><span class="xml">            alert(&quot;别点了，最大了！&quot;);</span><br><span class="xml">          &#125;</span><br><span class="xml">        &#125;,</span><br><span class="xml">        sub: function () &#123;</span><br><span class="xml">          // console.log(&quot;sub&quot;);</span><br><span class="xml">          if (this.num &gt; 0) &#123;</span><br><span class="xml">            this.num--;</span><br><span class="xml">          &#125; else &#123;</span><br><span class="xml">            alert(&quot;别点了，最小了&quot;);</span><br><span class="xml">          &#125;</span><br><span class="xml">        &#125;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">    &#125;);</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><ol><li>该指令的作用是根据真假切换元素的显示状态</li><li>原理是修改元素的display，实现显示隐藏</li><li>指令后面的内容，最终都会解析为<strong>布尔值</strong></li><li>值为<strong>true</strong>元素显示，值为<strong>false</strong>元素隐藏</li><li>数据改变之后，对应元素的显示状态会<strong>同步更新</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;切换显示状态&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeIsShow&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;累加年龄&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addAge&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isshow&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;.//node_modules/vue/img/1.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;age&gt;=18&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;.//node_modules/vue/img/1.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&quot;#app&quot;</span>,</span><br>      data: &#123;<br><span class="javascript">        isshow: <span class="hljs-literal">false</span>,</span><br>        age: 17,<br>      &#125;,<br>      methods: &#123;<br><span class="javascript">        changeIsShow: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.isshow = !<span class="hljs-built_in">this</span>.isshow;</span><br>        &#125;,<br><span class="javascript">        addAge: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.age++;</span><br>        &#125;,<br>      &#125;,<br>    &#125;);<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><ol><li>该指令的作用是根据表达式的真假来切换元素的显示状态</li><li>本质是通过操作<strong>dom</strong>元素来切换显示状态</li><li>表达式的值为<strong>true</strong>,元素存在于<strong>dom</strong>中；为<strong>false</strong>，从<strong>dom</strong>树中移除</li><li>频繁的切换使用<strong>v-show</strong>,反之使用<strong>v-if</strong>,前者的切换消耗小</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;切换显示&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toggleIsShow&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isshow&quot;</span>&gt;</span>学习Vue<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isshow&quot;</span>&gt;</span>学习Vue---v-show修饰<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;temperature&gt;=35&quot;</span>&gt;</span>热死了<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&quot;#app&quot;</span>,</span><br>      data: &#123;<br><span class="javascript">        isshow: <span class="hljs-literal">false</span>,</span><br>        temperature: 20,<br>      &#125;,<br>      methods: &#123;<br><span class="javascript">        toggleIsShow: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.isshow = !<span class="hljs-built_in">this</span>.isshow;</span><br>        &#125;,<br>      &#125;,<br>    &#125;);<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><ol><li>该指令的作用是：为元素绑定属性</li><li>完整写法是 v-bind:属性名</li><li>简写的话可以直接省略v-bind，只保留 :属性名</li><li>需要动态的增删 class 建议使用对象的方式</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>  .active &#123;<br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">&quot;imgSrc&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;imgSrc&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;imgTitle +&#x27;!!!&#x27;&quot;</span>//</span><br><span class="hljs-tag">    <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;isActive?&#x27;active&#x27;:&#x27;&#x27;&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toggleActive&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>    //&#123;&#125;为使用对象的方式<br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;imgSrc&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;imgTitle +&#x27;!!!&#x27;&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;active:isActive&#125;&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toggleActive&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&quot;#app&quot;</span>,</span><br>      data: &#123;<br><span class="javascript">        imgSrc: <span class="hljs-string">&quot;https://www.itheima.com/images/logo.png&quot;</span>,</span><br><span class="javascript">        imgTitle: <span class="hljs-string">&quot;好好学习&quot;</span>,</span><br><span class="javascript">        isActive: <span class="hljs-literal">false</span>,</span><br>      &#125;,<br>      methods: &#123;<br><span class="javascript">        toggleActive: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.isActive = !<span class="hljs-built_in">this</span>.isActive;</span><br>        &#125;,<br>      &#125;,<br>    &#125;);<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><ol><li>该指令的作用是：根据数据生成列表结构</li><li>数组经常和v-for结合使用</li><li>语法是(item,index) in 数据(item可以自己取任意字母代表)</li><li>item 和index 可以结合其他指令一起使用</li><li>数组长度的更新会同步到页面上，是响应式的</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;添加数据&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;移除数据&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;remove&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(it,index)  in arr&quot;</span>&gt;</span></span><br><span class="xml">        </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">index</span>+<span class="hljs-number">1</span>&#125;&#125;</span><span class="xml">我想去旅游的地方有：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">it</span>&#125;&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in vegetables&quot;</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">&quot;item.name&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.name</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">    var app = new Vue(&#123;</span><br><span class="xml">      el: &quot;#app&quot;,</span><br><span class="xml">      data: &#123;</span><br><span class="xml">        arr: [&quot;北京&quot;, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;],</span><br><span class="xml">        vegetables: [&#123; name: &quot;西兰花炒蛋&quot; &#125;, &#123; name: &quot;蛋炒西兰花&quot; &#125;],</span><br><span class="xml">      &#125;,</span><br><span class="xml">      methods: &#123;</span><br><span class="xml">        add: function () &#123;</span><br><span class="xml">          this.vegetables.push(&#123; name: &quot;花菜炒蛋&quot; &#125;);</span><br><span class="xml">        &#125;,</span><br><span class="xml">        remove: function () &#123;</span><br><span class="xml">          this.vegetables.shift();</span><br><span class="xml">        &#125;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">    &#125;);</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="v-on-补充"><a href="#v-on-补充" class="headerlink" title="v-on 补充"></a>v-on 补充</h3><ol><li>事件绑定的方法写成 <strong> 函数调用</strong>  的形式，可以传入自定义参数</li><li>定义方法时需要定义 <strong>形参 </strong>来接收传入的实参</li><li>事件的后面跟上<strong> .修饰符</strong>可以对事件进行限制</li><li><strong> .enter </strong>可以限制触发按键回车</li><li>事件修饰符有多种</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;点击&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;doIt(666,&#x27;老铁&#x27;)&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- @keyup.enter --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">&quot;sayHi&quot;</span> /&gt;</span><br>    <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&quot;#app&quot;</span>,</span><br>      methods: &#123;<br><span class="javascript">        doIt: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">p1, p2</span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;做IT&quot;</span>);</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(p1);</span><br><span class="javascript">          <span class="hljs-built_in">console</span>.log(p2);</span><br>        &#125;,<br><span class="javascript">        sayHi: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">          alert(<span class="hljs-string">&quot;吃了没&quot;</span>);</span><br>        &#125;,<br>      &#125;,<br>    &#125;);<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><ol><li>该指令的作用是便捷的设置和获取表单元素的值</li><li>绑定的数据会和表单元素的<strong>值</strong>相关联</li><li>绑定的数据<strong>&lt;—&gt;</strong>表单元素的值</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;修改message&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;setM&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">&quot;getM&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">message</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./node_modules/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml">    var app = new Vue(&#123;</span><br><span class="xml">      el: &quot;#app&quot;,</span><br><span class="xml">      data: &#123;</span><br><span class="xml">        message: &quot;学习Vue&quot;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">      methods: &#123;</span><br><span class="xml">        getM: function () &#123;</span><br><span class="xml">          alert(this.message);</span><br><span class="xml">        &#125;,</span><br><span class="xml">        setM: function () &#123;</span><br><span class="xml">          this.message = &quot;好好学习&quot;;</span><br><span class="xml">        &#125;,</span><br><span class="xml">      &#125;,</span><br><span class="xml">    &#125;);</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue&amp;MVVM思想&amp;安装&amp;Vue.js目录结构&amp;v-text</title>
    <link href="/2021/04/16/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <url>/2021/04/16/Vue%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<p>以下是对Vue入门的学习(安装Vue,v-text,v-html  )</p><hr><h3 id="MVVM思想-重要"><a href="#MVVM思想-重要" class="headerlink" title="MVVM思想(重要)"></a>MVVM思想(重要)</h3><ol><li>M：即Model模型，包括数据和一些基本操作</li><li>V：即View，视图，页面渲染结果</li><li>VM： 即View-Model，模型于视图间的双向操作(无需开发人员干涉)</li></ol><p>在MVVM之前，开发人员从后端获取需要的数据模型，然后要通过DOM操作Model渲染到View中。而后当用户操作视图，我们还需要通过DOM获取View中的数据，然后同步到Model中。</p><p>而MVVM中的VM要做的事情就是把DOM操作完全封装起来，开发人员不再关心Model和View之间的如何相互影响的</p><h3 id="安装Vue"><a href="#安装Vue" class="headerlink" title="安装Vue"></a>安装Vue</h3><ol><li>方法一 直接<code>&lt;script&gt;</code>引入</li></ol><p>CDN<br>对于制作原型或学习，你可以这样使用最新版本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>方法二  NPM</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm  init -y  <span class="hljs-regexp">//</span>初始化项目，项目路径多了一个package.json文件，代表是一个npm来管理的项目<br>npm install vue  <span class="hljs-regexp">//</span>安装Vue   <br></code></pre></td></tr></table></figure><p>由于 npm 安装速度慢，本教程使用了淘宝的镜像及其命令 cnpm，安装使用介绍参照：使用<a href="https://www.runoob.com/nodejs/nodejs-npm.html#taobaonpm">淘宝 NPM 镜像</a>。</p><p>npm 版本需要大于 3.0，如果低于此版本需要升级它：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 查看版本</span><br>$ npm -v<br><span class="hljs-number">2</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br><br><span class="hljs-comment">#升级 npm</span><br>cnpm <span class="hljs-keyword">install </span>npm -g<br><br><br><span class="hljs-comment"># 升级或安装 cnpm</span><br>npm <span class="hljs-keyword">install </span>cnpm -g<br><br>在用 Vue.<span class="hljs-keyword">js </span>构建大型应用时推荐使用 cnpm 安装：<br><span class="hljs-comment"># 最新稳定版</span><br>$ cnpm <span class="hljs-keyword">install </span>vue<br></code></pre></td></tr></table></figure><ol start="3"><li>命令行工具<br>Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。</li></ol><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 全局安装 vue-cli</span><br>$ cnpm install <span class="hljs-comment">--global vue-cli  //这里是vue cli2.x版本命令</span><br>$ npm install -g @vue/cli@<span class="hljs-number">3.11</span><span class="hljs-number">.0</span>  <span class="hljs-comment"> //这里是vue cli3.x版本命令(使用这个)</span><br><span class="hljs-comment"># 创建一个基于 webpack 模板的新项目</span><br>$ vue init webpack my-project <span class="hljs-comment"> //注：这里是vue cli2.x版本命令</span><br>$ vue  <span class="hljs-built_in">create</span>  my-project <span class="hljs-comment"> //这里是vue cli3.x版本命令</span><br><span class="hljs-comment"># 这里需要进行一些配置，默认回车即可</span><br>This will install Vue <span class="hljs-number">2.</span>x <span class="hljs-built_in">version</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> template.<br><br>For Vue <span class="hljs-number">1.</span>x use: vue init webpack<span class="hljs-comment">#1.0 my-project</span><br><br>? Project name my-project<br>? Project description A Vue.js project<br>? Author runoob &lt;test@runoob.com&gt;<br>? Vue build standalone<br>? Use ESLint <span class="hljs-built_in">to</span> lint your code? Yes<br>? Pick <span class="hljs-keyword">an</span> ESLint preset Standard<br>? Setup unit tests <span class="hljs-keyword">with</span> Karma + Mocha? Yes<br>? Setup e2e tests <span class="hljs-keyword">with</span> Nightwatch? Yes<br><br>   vue-cli · Generated <span class="hljs-string">&quot;my-project&quot;</span>.<br><br>   To <span class="hljs-built_in">get</span> started:<br>   <br>     cd my-project<br>     npm install<br>     npm run dev<br>   <br>   Documentation can be found <span class="hljs-keyword">at</span> <span class="hljs-keyword">https</span>://vuejs-templates.github.io/webpack<br></code></pre></td></tr></table></figure><p>进入项目，安装并运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> my-project</span><br><span class="hljs-meta">$</span><span class="bash"> cnpm install</span><br><span class="hljs-meta">$</span><span class="bash"> cnpm run dev</span><br> DONE  Compiled successfully in 4388ms<br><br><span class="hljs-meta">&gt;</span><span class="bash"> Listening at http://localhost:8080</span><br></code></pre></td></tr></table></figure><p>成功执行以上命令后访问 <a href="http://localhost:8080/">http://localhost:8080/</a>，</p><p><img src="/image/11.1.PNG" alt="运行效果"></p><p>注意：Vue.js 不支持 IE8 及其以下 IE 版本。</p><h3 id="Vue-js-目录结构"><a href="#Vue-js-目录结构" class="headerlink" title="Vue.js 目录结构"></a>Vue.js 目录结构</h3><p>我们使用了 npm安装项目，我们在 IDE(visual code) 中打开该目录，结构如下所示:<br><img src="/image/11.2.png" alt="Vue项目目录结构"></p><h3 id="VUE简介"><a href="#VUE简介" class="headerlink" title="VUE简介"></a>VUE简介</h3><ol><li>JavaScript框架</li><li>简化Dom操作</li><li>响应式数据驱动</li></ol><h3 id="Vue基础-el-挂载点，data-数据对象"><a href="#Vue基础-el-挂载点，data-数据对象" class="headerlink" title="Vue基础(el:挂载点，data:数据对象)"></a>Vue基础(el:挂载点，data:数据对象)</h3><h4 id="el-挂载点—用来设置Vue实例挂载-管理-的元素"><a href="#el-挂载点—用来设置Vue实例挂载-管理-的元素" class="headerlink" title="el:挂载点—用来设置Vue实例挂载(管理)的元素"></a>el:挂载点—用来设置Vue实例挂载(管理)的元素</h4><ol><li>Vue实例的作用范围是什么呢？<br>Vue会管理el选项<strong>命中的元素</strong>及其内部的<strong>后代元素</strong></li><li>是否可以使用其他的选择器？<br>可以使用其他的选择器，但是建议使用<strong>id选择器</strong>(一般建议使用id选择器(唯一)，因为类选择器和标签选择器都可以命中多个元素)</li><li>是否可以设置其他dom元素呢？<br>可以使用其他的双标签，不能使用<strong>HTML</strong>和<strong>Body</strong><br><img src="/image/11.3.png" alt="不能使用body"></li></ol><h4 id="data-数据对象"><a href="#data-数据对象" class="headerlink" title="data:数据对象"></a>data:数据对象</h4><ol><li>Vue中用到的数据定义在data中</li><li>data中可以写复杂类型的数据</li><li>渲染复杂数据类型时，遵守js的语法即可</li></ol><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><ol><li>该指令的作用的：设置标签的内容(textContent)</li><li>默认写法会<strong>替换全部内容</strong>，使用<strong>差值表达式<code>&#123;&#123;&#125;&#125;</code></strong>可以替换指定内容</li><li>内部支持写表达式</li></ol><p><img src="/image/11.4.PNG" alt="效果"></p><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><ol><li>该指令的作用是：设置元素的innerHTML</li><li>内容中有html结构会被解析为标签</li><li>v-text指令无论内容是什么，只会被解析为文本</li><li>解析文本使用v-text,需要解析html结构使用v-html</li></ol><p><img src="/image/11.5.PNG" alt="如图"></p><h4 id="为什么要用指令和插值表达式"><a href="#为什么要用指令和插值表达式" class="headerlink" title="为什么要用指令和插值表达式"></a>为什么要用指令和插值表达式</h4><p>前面我们已经说到过，在Vue中不直接对DOM进行操作，而是通过数据的改变来改变页面的显示状态。但是如果在HTML中直接像这样设置页面内容，那么改变数据时将无法用到Vue提供的便捷方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello&quot;</span> &gt;</span>hello world<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>为了能通过变量来决定显示的内容，用原生JS我们可以这样写</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">var <span class="hljs-attribute">str</span>=<span class="hljs-string">&quot;hello world&quot;</span>;<br>document.getEleMentById(<span class="hljs-string">&#x27;hello&#x27;</span>).<span class="hljs-attribute">innerText</span>=str;<br></code></pre></td></tr></table></figure><p>但此时在控制台中改变str的值，页面并不会改变，因为在页面不刷新的情况下，变量改变页面不会重新渲染。</p><p>因此，我们需要使用Vue提供的方法，来做到在不刷新页面的情况下重新渲染页面。</p><p>Vue实例的数据，要定义在实例中的data内，当某个数据改变时，就会重新渲染页面中用到了该数据的地方。而要达到这个目的，要解决的问题就是：如何使用在Vue实例中定义的数据，这也就用到了标题中的两种方法，指令和插值表达式。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-map&amp;reduce</title>
    <link href="/2021/04/14/Map&amp;&amp;Set&amp;&amp;Weakmap&amp;&amp;Weakset/"/>
    <url>/2021/04/14/Map&amp;&amp;Set&amp;&amp;Weakmap&amp;&amp;Weakset/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="1-传统对象结构"><a href="#1-传统对象结构" class="headerlink" title="1. 传统对象结构"></a>1. 传统对象结构</h4><p>Map本质上是一个键值对的集合。和传统对象结构相比，传统的对象只能用字符串作为键名，这就在使用上造成了很大的限制了。这也是新增 Map 的原因之一。</p><h4 id="2-Map-结构"><a href="#2-Map-结构" class="headerlink" title="2. Map 结构"></a>2. Map 结构</h4><p>Map类似于对象，但是键名不限于字符串，可以说Object结构提供键-值对应，Map结构提供值-值对应因此其实采用map结构会优于传统对象</p><h4 id="3-Map-的特点"><a href="#3-Map-的特点" class="headerlink" title="3. Map 的特点"></a>3. Map 的特点</h4><ol><li><p>Map 默认情况下不包含任何键，所有键都是自己添加进去的。不同于 Object 原型链上有一些默认的键。</p></li><li><p>Map 的键可以是<strong>任意类型数据</strong>，就连函数都可以。</p></li><li><p>Map 的键值对个数可以<strong>轻易</strong>通过size属性获取，Object 需要手动计算。</p></li><li><p>Map 在频繁增删键值对的场景下<strong>性能</strong>要比 Object 好。</p></li></ol><h4 id="4-什么时候用-Map"><a href="#4-什么时候用-Map" class="headerlink" title="4. 什么时候用 Map"></a>4. 什么时候用 Map</h4><ol><li>要添加的键值名和 Object 上的默认键值名冲突，又不想改名时，用 Map</li><li>需要 String 和 Symbol 以外的数据类型做键值时，用 Map</li><li>键值对很多，有需要计算数量时，用 Map</li><li>需要频繁增删键值对时，用 Map</li></ol><h3 id="Map-实例属性和方法"><a href="#Map-实例属性和方法" class="headerlink" title="Map 实例属性和方法"></a>Map 实例属性和方法</h3><h4 id="1-set"><a href="#1-set" class="headerlink" title="1. set"></a>1. set</h4><p>set方法设置键名key对应的键值为value，然后会返回整个Map结构，如果设置的key已经存在，则会更新value值，否则会新生成该键</p><h4 id="2-get"><a href="#2-get" class="headerlink" title="2. get"></a>2. get</h4><p>通过get方法读取key对应的键值，如果传入的键值不存在，则会返回undefined</p><h4 id="3-has"><a href="#3-has" class="headerlink" title="3. has"></a>3. has</h4><p>判断传入的键是否存在当前Map对象中，该方法返回一个布尔值</p><h4 id="4-delete"><a href="#4-delete" class="headerlink" title="4. delete"></a>4. delete</h4><p>删除传入的键，返回true，如果删除失败，则返回false</p><h4 id="5-clear"><a href="#5-clear" class="headerlink" title="5. clear"></a>5. clear</h4><p>清除所有成员，没有返回值</p><h3 id="三、遍历方法"><a href="#三、遍历方法" class="headerlink" title="三、遍历方法"></a>三、遍历方法</h3><p>可以采用for…of循环和forEach两种方法。由于Map实例会维护键值对的插入顺序，因此可以根据插入顺序进行遍历<br>采用for…of</p><p>for…of可以遍历有iterator接口的数据结构</p><p>keys()：返回键名的遍历器<br>values()：返回键值的遍历器<br>entries()：返回键值对的遍历器<br>forEach()：使用回调函数遍历每个成员</p><h4 id="map-entries"><a href="#map-entries" class="headerlink" title="map.entries()"></a>map.entries()</h4><p>在Map实例中有一个迭代器，能以插入顺序生成[key,value]形式的数据。<br>我们可以通过entries方法来获得这个迭代器，从而利用for…of进行遍历操作</p><h4 id="map-values"><a href="#map-values" class="headerlink" title="map.values()"></a>map.values()</h4><p>可以采用遍历map.values()的方式来遍历map容器的属性值</p><h4 id="map-keys"><a href="#map-keys" class="headerlink" title="map.keys()"></a>map.keys()</h4><p>可以采用map.keys()来遍历键名</p><h4 id="采用-forEach-回调遍历"><a href="#采用-forEach-回调遍历" class="headerlink" title="采用 forEach() 回调遍历"></a>采用 forEach() 回调遍历</h4><h3 id="四、Map-类型转化"><a href="#四、Map-类型转化" class="headerlink" title="四、Map 类型转化"></a>四、Map 类型转化</h3><p>几种与map相互类型转化的方法</p><h4 id="Map-转为数组"><a href="#Map-转为数组" class="headerlink" title="Map 转为数组"></a>Map 转为数组</h4><p>通过扩展运算符实现</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">let</span> <span class="hljs-built_in">map</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Map</span>()<br><span class="hljs-keyword">let</span> arr = <span class="hljs-meta">[</span><span class="hljs-params">...</span><span class="hljs-built_in">map</span><span class="hljs-meta">]</span><br></code></pre></td></tr></table></figure><h4 id="数组转为-Map"><a href="#数组转为-Map" class="headerlink" title="数组转为 Map"></a>数组转为 Map</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">let</span> <span class="hljs-built_in">map</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Map</span>(arr)<br></code></pre></td></tr></table></figure><h4 id="Map-转为对象"><a href="#Map-转为对象" class="headerlink" title="Map 转为对象"></a>Map 转为对象</h4><p>通过遍历利用set将键值对加入对象中</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span> = &#123;&#125;<br>for (<span class="hljs-keyword">let</span> [k, v] of <span class="hljs-built_in">map</span>) &#123;<br>  obj[k] = v<br>&#125;<br></code></pre></td></tr></table></figure><p>对象转为 Map</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">( let k of Object.keys(obj)</span></span>)&#123;<br>  map<span class="hljs-selector-class">.set</span>(k,obj<span class="hljs-selector-attr">[k]</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="五、什么是-WeakMap-？"><a href="#五、什么是-WeakMap-？" class="headerlink" title="五、什么是 WeakMap ？"></a>五、什么是 WeakMap ？</h3><p>总所周知，WeakMap是 ES6 中新增的一种集合类型，叫做“弱映射”。它和Map是兄弟关系，与Map的区别就在于这个弱字，API 还是Map的那套（只有set get has delete)<br>那它真正是什么意思呢？</p><blockquote><p>这其实描述的是 JS 中垃圾回收程序对待“弱映射”中键的方式</p></blockquote><h4 id="六、WeakMap-的特性"><a href="#六、WeakMap-的特性" class="headerlink" title="六、WeakMap 的特性"></a>六、WeakMap 的特性</h4><p>我们先从 WeakMap 的特性讲起</p><ol><li>WeakMap 只能将对象作为键名<br>只接受对象作为键名（null 除外），不接受其他类型的值作为键名<br>null 除外</li><li>WeakMap 的键名引用的对象是弱引用<br>这里懵了挺久的，但是这是WeakMap结构的关键所在</li></ol><p>要想读懂这句话，不容易，我们需要先知道强引用和弱引用</p><h6 id="在上面我们谈到强引用数据被删除时，需要手动解除引用，而弱引用则可以等待垃圾回收机制自动清除"><a href="#在上面我们谈到强引用数据被删除时，需要手动解除引用，而弱引用则可以等待垃圾回收机制自动清除" class="headerlink" title="在上面我们谈到强引用数据被删除时，需要手动解除引用，而弱引用则可以等待垃圾回收机制自动清除"></a>在上面我们谈到强引用数据被删除时，需要手动解除引用，而弱引用则可以等待垃圾回收机制自动清除</h6><p>总的来说， WeakMap 保持了对键名所引用的对象的弱引用，即垃圾回收机制不将该引用考虑在内。只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p><h4 id="七、Map-和-WeakMap-的区别"><a href="#七、Map-和-WeakMap-的区别" class="headerlink" title="七、Map 和 WeakMap 的区别"></a>七、Map 和 WeakMap 的区别</h4><p>看到这里相信心中已经有答案了</p><p>1.Map 的键可以是任意类型，WeakMap 只接受对象作为键（null除外），不接受其他类型的值作为键<br>2. Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键； WeakMap 的键是弱引用，键所指向的对象可以被垃圾回收，此时键是无效的<br>3. Map 可以被遍历， WeakMap 不能被遍历</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://juejin.cn/post/6993101968545677319">浅析 Map 和 WeakMap 区别以及使用场景</a></p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS3--flex布局</title>
    <link href="/2021/04/14/CSS3flex%E5%B8%83%E5%B1%80/"/>
    <url>/2021/04/14/CSS3flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>以下是对flex布局的学习(重点)</p><hr><h3 id="flex布局体验"><a href="#flex布局体验" class="headerlink" title="flex布局体验"></a>flex布局体验</h3><p><img src="/image/10.png" alt="flex布局"></p><h3 id="布局原理"><a href="#布局原理" class="headerlink" title="布局原理"></a>布局原理</h3><p>flex  是flexible  Box的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为flex布局。</p><ul><li>当我们为父盒子设为flex布局以后，子元素的float,clear和vertical-align属性将无效</li><li>伸缩布局=弹性布局=伸缩盒布局=弹性盒布局=flex布局            <h4 id="flex布局布局原理：就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式"><a href="#flex布局布局原理：就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式" class="headerlink" title="flex布局布局原理：就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式"></a>flex布局布局原理：就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式</h4></li></ul><h3 id="常见父项属性"><a href="#常见父项属性" class="headerlink" title="常见父项属性"></a>常见父项属性</h3><p>以下由6个属性是对父元素设置的</p><ul><li>flex-direction:  设置主轴的方向</li><li>justify-content:  设置主轴上的子元素排列方式</li><li>flex-warp: 设置子元素是否换行</li><li>align-content:设置侧轴上的子元素排列方式(多行)</li><li>align-items:设置侧轴上的子元素排列方式(单行)</li><li>flex-flow: 符合属性，相当于同时设置了flex-direction和flex-warp</li></ul><h4 id="flex-direction-设置主轴的方向"><a href="#flex-direction-设置主轴的方向" class="headerlink" title="flex-direction:  设置主轴的方向"></a>flex-direction:  设置主轴的方向</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="css">    <span class="hljs-comment">/* 给父级添加flex属性 */</span></span><br><span class="css">    <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    <span class="hljs-comment">/* 默认的主轴是x轴，行 row  那么y轴就是侧轴 */</span></span><br><span class="css">    <span class="hljs-comment">/* 我们的元素是跟着主轴来排列的 */</span></span><br><span class="css">    <span class="hljs-comment">/* flex-direction: row; 默认从左到右*/</span></span><br><span class="css">    <span class="hljs-comment">/* flex-direction: row-reverse; 简单了解  翻转从右到左 */</span></span><br><span class="css">    <span class="hljs-comment">/* flex-direction: column; 从上到下 */</span></span><br><span class="css">    <span class="hljs-comment">/* flex-direction: column-reverse;  从下到上 */</span></span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: red;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="justify-content-设置主轴上的子元素排列方式"><a href="#justify-content-设置主轴上的子元素排列方式" class="headerlink" title="justify-content 设置主轴上的子元素排列方式"></a>justify-content 设置<strong>主轴</strong>上的子元素排列方式</h4><h4 id="注意：使用这个属性之前一定要确定好主轴是哪个"><a href="#注意：使用这个属性之前一定要确定好主轴是哪个" class="headerlink" title="注意：使用这个属性之前一定要确定好主轴是哪个"></a>注意：使用这个属性之前一定要确定好主轴是哪个</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs awk">div &#123;<br>  display: flex;<br>  width: <span class="hljs-number">800</span>px;<br>  height: <span class="hljs-number">300</span>px;<br>  background-color: pink;<br>  <span class="hljs-regexp">/* 默认的主轴是x轴row */</span><br>  flex-direction: row;<br>  <span class="hljs-regexp">/*默认值，从头部开始，如果主轴是x轴，则从左到右  */</span><br>  <span class="hljs-regexp">/* justify-content: flex-start; */</span><br><br>  <span class="hljs-regexp">/* 从尾部开始 */</span><br>  <span class="hljs-regexp">/* justify-content: flex-end; */</span><br><br>  <span class="hljs-regexp">/* 让我们子元素居中对齐 */</span><br>  <span class="hljs-regexp">/* justify-content: center; */</span><br><br>  <span class="hljs-regexp">/* 平分剩余空间 */</span><br>  <span class="hljs-regexp">/* justify-content: space-around; */</span><br><br>  <span class="hljs-regexp">/* 先两边贴边，在分配剩余的空间 */</span><br>  <span class="hljs-regexp">/* justify-content: space-between; */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="flex-wrap-wrap-设置子元素是否换行"><a href="#flex-wrap-wrap-设置子元素是否换行" class="headerlink" title="flex-wrap: wrap  设置子元素是否换行"></a>flex-wrap: wrap  设置子元素是否换行</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-comment">/* flex布局中，默认的子元素是不换行的，如果装不开，会缩小子元素的宽度，放到父元素里面 */</span><br><br>  <span class="hljs-comment">/* flex-wrap: nowrap; nowrap默认值,不换行*/</span><br><br>  <span class="hljs-comment">/* flex-wrap: wrap; 换行 */</span><br>&#125;<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: purple;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="align-items-设置侧轴上的子元素排列方式-单行"><a href="#align-items-设置侧轴上的子元素排列方式-单行" class="headerlink" title="align-items 设置侧轴上的子元素排列方式(单行)"></a>align-items 设置侧轴上的子元素排列方式(单行)</h3><p>该属性是控制子项在侧轴(默认是y轴)上的排列方式，在子项为单项的时候使用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">display: flex;<br><br><span class="hljs-regexp">/* 我们是需要一个侧轴居中 */</span><br>align-items: center;<br><br><span class="hljs-regexp">/* 从上到下 */</span><br><span class="hljs-regexp">/* align-items: flex-start; */</span><br><br><span class="hljs-regexp">/* 从下到上 */</span><br><span class="hljs-regexp">/* align-items: flex-end; */</span><br><br><span class="hljs-regexp">/*拉伸，但是子盒子不要给高度  */</span><br><span class="hljs-regexp">/* align-items: stretch; */</span><br></code></pre></td></tr></table></figure><h3 id="align-content-设置侧轴上的子元素的排列方式-多行"><a href="#align-content-设置侧轴上的子元素的排列方式-多行" class="headerlink" title="align-content 设置侧轴上的子元素的排列方式(多行)"></a>align-content 设置侧轴上的子元素的排列方式(多行)</h3><p><img src="/image/10.1.png" alt="换行"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">800px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br><br>  <span class="hljs-comment">/* 因为有了换行，此时我们侧轴上控制子元素的对齐方式我们用align-content */</span><br><br>  <span class="hljs-comment">/* align-content: flex-start; */</span><br>  <span class="hljs-attribute">align-content</span>: center;<br>  <span class="hljs-comment">/* align-content: space-between; */</span><br>  <span class="hljs-comment">/* align-content: space-around; */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="align-content-和align-items区别"><a href="#align-content-和align-items区别" class="headerlink" title="align-content 和align-items区别"></a>align-content 和align-items区别</h3><p><img src="/image/10.2.png" alt="区别"></p><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p>flex-flow 属性是flex-direction和flex-wrap 属性的复合属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* flex-direction: column;</span><br><span class="hljs-comment">flex-wrap: wrap; */</span><br><span class="hljs-comment">/* 把设置主轴方向和 是否换行(换列)简写*/</span><br><span class="hljs-attribute">flex-flow</span>: column wrap;<br></code></pre></td></tr></table></figure><h3 id="flex布局子项常见属性"><a href="#flex布局子项常见属性" class="headerlink" title="flex布局子项常见属性"></a>flex布局子项常见属性</h3><ol><li>flex子项目占的分数</li></ol><p>flex属性定义子项目<strong>分配剩余空间</strong>，用flex来表示占多少<strong>份数</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-selector-tag">section</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">60%</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">section</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">1</span>) &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: red;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">section</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;</span><br><span class="css">    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><br><span class="css">    <span class="hljs-comment">/* flex:&lt;number&gt; 表示多少份 */</span></span><br><span class="css">    <span class="hljs-attribute">background-color</span>: green;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">section</span> <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: blue;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>align-self 控制子项自己在侧轴上的排列方式(了解)<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    <span class="hljs-comment">/* 让三个子盒子沿着侧轴底侧对齐 */</span></span><br><span class="css">    <span class="hljs-comment">/* align-items: flex-end; */</span></span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: purple;</span><br><span class="css">    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">5px</span>;</span><br>  &#125;<br><span class="css">  <span class="hljs-comment">/* 我们想只让3号盒子下来底侧 */</span></span><br><span class="css">  <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">3</span>) &#123;</span><br><span class="css">    <span class="hljs-attribute">align-self</span>: flex-end;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>order 属性定义项目的排列顺序(了解)</li></ol><p>数值越小，排列越靠前，默认为0<br>注意：和z-index不一样</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">span</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-attribute">order</span>: -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-Object新增的API&amp;声明对象的简写&amp;对象函数的简写</title>
    <link href="/2021/04/13/ES6(%E5%9B%9B)/"/>
    <url>/2021/04/13/ES6(%E5%9B%9B)/</url>
    
    <content type="html"><![CDATA[<p>以下是对新增的API,声明对象的简写,对象函数的简写,对象拓展运算符的学习</p><hr><h3 id="新增的API"><a href="#新增的API" class="headerlink" title="新增的API"></a>新增的API</h3><p>ES6给Object扩展了许多新的方法，如：</p><h4 id="keys-obj-，获取对象的所有key形成的数组"><a href="#keys-obj-，获取对象的所有key形成的数组" class="headerlink" title="-keys(obj)，获取对象的所有key形成的数组"></a>-keys(obj)，获取对象的所有key形成的数组</h4><h4 id="values-obj-获取对象的所有value形成的数组"><a href="#values-obj-获取对象的所有value形成的数组" class="headerlink" title="-values(obj),获取对象的所有value形成的数组"></a>-values(obj),获取对象的所有value形成的数组</h4><h4 id="entries-obj-，获取对象的所有key和value形成的二维数组"><a href="#entries-obj-，获取对象的所有key和value形成的二维数组" class="headerlink" title="-entries(obj)，获取对象的所有key和value形成的二维数组"></a>-entries(obj)，获取对象的所有key和value形成的二维数组</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const person = &#123;<br>   <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>   age: <span class="hljs-number">21</span>,<br>   <span class="hljs-keyword">language</span>: [<span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;js&#x27;</span>, <span class="hljs-string">&#x27;css&#x27;</span>],<br> &#125;;<br> console.log(<span class="hljs-keyword">Object</span>.keys(person)); <br> console.log(<span class="hljs-keyword">Object</span>.<span class="hljs-keyword">values</span>(person)); <br> console.log(<span class="hljs-keyword">Object</span>.entries(person)); <br><br></code></pre></td></tr></table></figure><p><img src="/imageO/Object.jpg" alt="Object"><br>对象的新方法</p><h4 id="Object-assign-dest-···src-将多个src对象的值拷贝到dest中-第一层为深拷贝，第二层为浅拷贝"><a href="#Object-assign-dest-···src-将多个src对象的值拷贝到dest中-第一层为深拷贝，第二层为浅拷贝" class="headerlink" title="Object.assign(dest,  ···src) ,将多个src对象的值拷贝到dest中(第一层为深拷贝，第二层为浅拷贝)"></a>Object.assign(dest,  ···src) ,将多个src对象的值拷贝到dest中(第一层为深拷贝，第二层为浅拷贝)</h4><p>用于将源对象的所有可枚举属性复制到目标对象中。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">const</span> <span class="hljs-keyword">target</span> = &#123; a: 1 &#125;;<br><span class="hljs-keyword">const</span> source1 = &#123; b: 2 &#125;;<br><span class="hljs-keyword">const</span> source2 = &#123; c: 3 &#125;;<br><span class="hljs-comment">// Object.assign方法的第一个参数是目标对象，后面的参数都是源对象</span><br>Object.assign(<span class="hljs-keyword">target</span>, source1, source2);<br>console.log(<span class="hljs-keyword">target</span>); <span class="hljs-comment">//&#123;a: 1, b: 2, c: 3&#125;</span><br></code></pre></td></tr></table></figure><p>Object.assign()方法的第一个参数是目标对象，后面的参数都是源对象。<br>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。<br>如果只有一个参数，Object.assign()会直接返回该参数。<br>如果该参数不是对象，则会先转成对象，然后返回。<br>由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。<br>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。</p><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。<br>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.is</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;foo&#x27;</span>)<br><span class="hljs-comment">// true</span><br><span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.is</span>(&#123;&#125;, &#123;&#125;)<br><span class="hljs-comment">// false</span><br><br></code></pre></td></tr></table></figure><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p>ES5 的Object.getOwnPropertyDescriptor()方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk">const obj = &#123;<br>  foo: <span class="hljs-number">123</span>,<br>  get bar() &#123; return <span class="hljs-string">&#x27;abc&#x27;</span> &#125;<br>&#125;;<br><br>Object.getOwnPropertyDescriptors(obj)<br><span class="hljs-regexp">//</span> &#123; foo:<br><span class="hljs-regexp">//</span>    &#123; value: <span class="hljs-number">123</span>,<br><span class="hljs-regexp">//</span>      writable: true,<br><span class="hljs-regexp">//</span>      enumerable: true,<br><span class="hljs-regexp">//</span>      configurable: true &#125;,<br><span class="hljs-regexp">//</span>   bar:<br><span class="hljs-regexp">//</span>    &#123; get: [Function: get bar],<br><span class="hljs-regexp">//</span>      set: undefined,<br><span class="hljs-regexp">//</span>      enumerable: true,<br><span class="hljs-regexp">//</span>      configurable: true &#125; &#125;<br></code></pre></td></tr></table></figure><p>上面代码中，Object.getOwnPropertyDescriptors()方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p><h3 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__属性"></a>__proto__属性</h3><p>JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。<br>__proto__属性<br>__proto__属性（前后各两个下划线），用来读取或设置当前对象的原型对象（prototype）。目前，所有浏览器（包括 IE11）都部署了这个属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// es5 的写法</span><br><span class="hljs-keyword">const</span> obj = &#123;<br>  method: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; ... &#125;<br>&#125;;<br>obj.__proto__ = someOtherObj;<br><br><span class="hljs-comment">// es6 的写法</span><br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(someOtherObj);<br>obj.method = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; ... &#125;;<br></code></pre></td></tr></table></figure><p>该属性没有写入 ES6 的正文，而是写入了附录，原因是__proto__前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://juejin.cn/post/7000675538310266910#heading-6">es6对象新增的方法</a></p><h3 id="声明对象的简写"><a href="#声明对象的简写" class="headerlink" title="声明对象的简写"></a>声明对象的简写</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">const</span> age = <span class="hljs-number">23</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;张三&#x27;</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">const</span> person1 = &#123; age: age, name: name &#125;<span class="hljs-comment">;</span><br><br><span class="hljs-keyword">const</span> person2 = &#123; age, name &#125;<span class="hljs-comment">;</span><br>console.<span class="hljs-built_in">log</span>(person2)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="对象函数的简写"><a href="#对象函数的简写" class="headerlink" title="对象函数的简写"></a>对象函数的简写</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person3 = &#123;<br>  name: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>  <span class="hljs-comment">//以前</span><br>  eat: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">food</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;在吃&#x27;</span> + food);<br>  &#125;,<br>  <span class="hljs-comment">//箭头函数this不能使用，对象，属性</span><br>  eat2: <span class="hljs-function">(<span class="hljs-params">food</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(person3.name + <span class="hljs-string">&#x27;在吃&#x27;</span> + food),<br>  <span class="hljs-comment">//方法三  使用较多</span><br>  <span class="hljs-function"><span class="hljs-title">eat3</span>(<span class="hljs-params">food</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;在吃&#x27;</span> + food);<br>  &#125;,<br>&#125;;<br>person3.eat(<span class="hljs-string">&#x27;香蕉&#x27;</span>);<br>person3.eat2(<span class="hljs-string">&#x27;苹果&#x27;</span>);<br>person3.eat3(<span class="hljs-string">&#x27;橘子&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="对象拓展运算符"><a href="#对象拓展运算符" class="headerlink" title="对象拓展运算符"></a>对象拓展运算符</h3><ol><li>拷贝对象（深拷贝）</li></ol><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">let</span> p1 = &#123; name: <span class="hljs-string">&#x27;Amy&#x27;</span>, age: <span class="hljs-number">15</span> &#125;;<br><span class="hljs-keyword">let</span> someone = &#123; <span class="hljs-params">...</span>p1 &#125;;<br>console.<span class="hljs-keyword">log</span>(someone); <span class="hljs-comment">//age: 15 name: &quot;Amy&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>合并对象</li></ol><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">let</span> age1 = &#123; age: <span class="hljs-number">15</span> &#125;;<br><span class="hljs-keyword">let</span> name1 = &#123; name: <span class="hljs-string">&#x27;Amy&#x27;</span> &#125;;<br><span class="hljs-comment">//假设之前已经有一个值，但是打印时最后的值还是会覆盖原来的值</span><br><span class="hljs-keyword">let</span> p2 = &#123; name: <span class="hljs-string">&#x27;zhangsan&#x27;</span> &#125;;<br>p2 = &#123; <span class="hljs-params">...</span>age1, <span class="hljs-params">...</span>name1 &#125;;<br>console.<span class="hljs-keyword">log</span>(p2); <span class="hljs-comment">//age: 15 name: &quot;Amy&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-函数优化&amp;箭头函数(使用较多)</title>
    <link href="/2021/04/13/ES6(%E4%B8%89)/"/>
    <url>/2021/04/13/ES6(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<p>以下是对函数,不定参数,箭头函数的学习</p><hr><h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法；</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-comment">//判断是否为空，为空就给默认值；</span><br>  b = b || <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-comment">//传一个参数</span><br><span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">10</span>));<br><span class="hljs-comment">//现在可以这么写，直接给参数写上默认值，没传给会自动使用默认值</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add2</span>(<span class="hljs-params">a, b = <span class="hljs-number">1</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-built_in">console</span>.log(add2(<span class="hljs-number">20</span>));<br></code></pre></td></tr></table></figure><p>注意点：使用函数默认参数时，不允许有同名参数。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs fortran">// 不报错<br><span class="hljs-function"><span class="hljs-keyword">function</span></span> fn(<span class="hljs-keyword">name</span>,<span class="hljs-keyword">name</span>)&#123;<br> console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">name</span>);<br>&#125;<br> <br>// 报错<br>//SyntaxError: Duplicate <span class="hljs-keyword">parameter</span> <span class="hljs-keyword">name</span> not allowed <span class="hljs-keyword">in</span> this context<br><span class="hljs-function"><span class="hljs-keyword">function</span></span> fn(<span class="hljs-keyword">name</span>,<span class="hljs-keyword">name</span>,age=<span class="hljs-number">17</span>)&#123;<br> console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">name</span>+<span class="hljs-string">&quot;,&quot;</span>+age);<br>&#125;<br></code></pre></td></tr></table></figure><p>只有在未传递参数，或者参数为 undefined 时，才会使用默认参数，null 值被认为是有效的值传递。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> fn(<span class="hljs-type">name</span>,age=<span class="hljs-number">17</span>)&#123;<br>    console.log(<span class="hljs-type">name</span>+&quot;,&quot;+age);<br>&#125;<br>fn(&quot;Amy&quot;,<span class="hljs-keyword">null</span>); // Amy,<span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><h3 id="不定参数"><a href="#不定参数" class="headerlink" title="不定参数"></a>不定参数</h3><p>不定参数用来表示不确定参数个数，形如，…变量名，由…加上一个具名参数标识符组成。具名参数只能放在参数组的最后，并且有且只有一个不定参数。</p><p>基本用法</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-rest_arg">...values</span>)</span></span>&#123;<br>    console.log(values.length);<br>&#125;<br>f(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);      <span class="hljs-comment">//2</span><br>f(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);  <span class="hljs-comment">//4</span><br></code></pre></td></tr></table></figure><h3 id="箭头函数-使用较多"><a href="#箭头函数-使用较多" class="headerlink" title="箭头函数(使用较多)"></a>箭头函数(使用较多)</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">      <span class="hljs-comment">//以前声明一个方法</span><br>      <span class="hljs-comment">// var  print=function(obj)&#123;</span><br>      <span class="hljs-comment">//     console.log(obj);</span><br>      <span class="hljs-comment">// &#125;</span><br>      <span class="hljs-keyword">var</span> print = <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> console.log(obj);<br>      print(<span class="hljs-string">&#x27;hello&#x27;</span>);<span class="hljs-comment">//hello</span><br>或<br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v;<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>)</span>&#123;<br> <span class="hljs-keyword">return</span> a;<br>&#125;<br>f(<span class="hljs-number">1</span>);  <span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><p>当箭头函数没有参数或者有多个参数，要用 () 括起来。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> f = <span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> a+b;<br>f(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>);  <span class="hljs-comment">//8</span><br></code></pre></td></tr></table></figure><p>当箭头函数函数体有多行语句，用 {} 包裹起来，表示代码块，当只有一行语句，并且需要返回结果时，可以省略 {} , 结果会自动返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function">(<span class="hljs-params">a,b</span>) =&gt;</span> &#123;<br> <span class="hljs-keyword">let</span> result = a+b;<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br>f(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>);  <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><p>当箭头函数要返回对象的时候，为了区分于代码块，要用 () 将对象包裹起来</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xquery">// 报错<br>var f = <span class="hljs-built_in">(id</span><span class="hljs-built_in">,name</span>) =&gt; <span class="hljs-built_in">&#123;id</span>:<span class="hljs-built_in"> id</span>,<span class="hljs-built_in"> name</span>:<span class="hljs-built_in"> name</span>&#125;;<br>f(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>);  // SyntaxError: Unexpected token :<br> <br>// 不报错<br>var f = <span class="hljs-built_in">(id</span><span class="hljs-built_in">,name</span>) =&gt; (<span class="hljs-built_in">&#123;id</span>:<span class="hljs-built_in"> id</span>,<span class="hljs-built_in"> name</span>:<span class="hljs-built_in"> name</span>&#125;);<br>f(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>);  // <span class="hljs-built_in">&#123;id</span>: <span class="hljs-number">6</span>,<span class="hljs-built_in"> name</span>: <span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><p>注意点：没有 this、super、arguments 和 new.target 绑定。<br>箭头函数体中的 this 对象，是定义函数时的对象，而不是使用函数时的对象。<br>不可以作为构造函数，也就是不能使用 new 命令，否则会报错</p><ul><li>箭头函数+解构</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> person = &#123;<br>  name: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>  age: <span class="hljs-number">21</span>,<br>  language: [<span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;js&#x27;</span>, <span class="hljs-string">&#x27;css&#x27;</span>],<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params">person</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>, person.name);<br>&#125;<br><span class="hljs-comment">//箭头函数+解构</span><br><span class="hljs-keyword">var</span> hello2 = <span class="hljs-function">(<span class="hljs-params">&#123; name &#125;</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>, name);<br>hello2(person);<br></code></pre></td></tr></table></figure><h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><p>本篇我们重点比较一下箭头函数与普通函数。<br>主要区别包括：</p><h4 id="没有-this"><a href="#没有-this" class="headerlink" title="没有 this"></a>没有 this</h4><p>箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。<br>这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this。</p><h4 id="1-箭头函数this为父作用域的this，不是调用时的this"><a href="#1-箭头函数this为父作用域的this，不是调用时的this" class="headerlink" title="1.箭头函数this为父作用域的this，不是调用时的this"></a>1.箭头函数this为父作用域的this，不是调用时的this</h4><p><img src="/imageO/JTHS.jpg" alt="this"><br>箭头函数的this永远指向其父作用域，任何方法都改变不了，包括call，apply，bind。</p><p>普通函数的this指向调用它的那个对象。</p><blockquote><p>上例中，init为箭头函数，其内部的this为全局window，onclick的this也就是init函数的this，也是window，得到的this.name就为undefined。</p></blockquote><h4 id="没有-arguments"><a href="#没有-arguments" class="headerlink" title="没有 arguments"></a>没有 arguments</h4><p>箭头函数没有自己的 arguments 对象，这不一定是件坏事，因为箭头函数可以访问外围函数的 arguments 对象：<br>那如果我们就是要访问箭头函数的参数呢？<br>你可以通过命名参数或者 rest 参数的形式访问参数:<br>let nums = (…nums) =&gt; nums;</p><h4 id="不能通过-new-关键字调用"><a href="#不能通过-new-关键字调用" class="headerlink" title="不能通过 new 关键字调用"></a>不能通过 new 关键字调用</h4><p>JavaScript 函数有两个内部方法：[[Call]] 和 [[Construct]]。</p><p>当通过 new 调用函数时，执行 [[Construct]] 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。</p><p>当直接调用的时候，执行 [[Call]] 方法，直接执行函数体。</p><p>箭头函数并没有 [[Construct]] 方法，不能被用作构造函数，如果通过 new 的方式调用，会报错。</p><p>var Foo = () =&gt; {};<br>var foo = new Foo(); // TypeError: Foo is not a constructor</p><h4 id="没有-new-target"><a href="#没有-new-target" class="headerlink" title="没有 new.target"></a>没有 new.target</h4><p>因为不能使用 new 调用，所以也没有 new.target 值。</p><p>关于 new.target，可以参考 es6.ruanyifeng.com/#docs/class…</p><h4 id="没有原型"><a href="#没有原型" class="headerlink" title="没有原型"></a>没有原型</h4><p>由于不能使用 new 调用箭头函数，所以也没有构建原型的需求，于是箭头函数也不存在 prototype 这个属性。</p><p>var Foo = () =&gt; {};<br>console.log(Foo.prototype); // undefined</p><h4 id="没有-super"><a href="#没有-super" class="headerlink" title="没有 super"></a>没有 super</h4><p>连原型都没有，自然也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的，不过跟 this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。</p><h4 id="箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或-new-target。这些函数表达式最适合用于非方法函数-non-method-functions-，并且它们不能用作构造函数"><a href="#箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或-new-target。这些函数表达式最适合用于非方法函数-non-method-functions-，并且它们不能用作构造函数" class="headerlink" title="箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数(non-method functions)，并且它们不能用作构造函数"></a>箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数(non-method functions)，并且它们不能用作构造函数</h4><p><a href="https://juejin.cn/post/6844903616231260174#heading-4">参考文章</a></p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-解构&amp;字符串</title>
    <link href="/2021/04/12/ES6(%E4%BA%8C)/"/>
    <url>/2021/04/12/ES6(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<p>以下是对解构&amp;字符串的学习</p><hr><p>解构赋值是对赋值运算符的扩展。<br>他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。</p><p>解构的源，解构赋值表达式的右边部分。<br>解构的目标，解构赋值表达式的左边部分。</p><h3 id="数组模型的解构（Array）"><a href="#数组模型的解构（Array）" class="headerlink" title="数组模型的解构（Array）"></a>数组模型的解构（Array）</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">let arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-regexp">//</span>以前我们想获取其中的值，只能通过角标。ES6可以这样。<br><span class="hljs-regexp">//</span>   let a = arr[<span class="hljs-number">0</span>];<br><span class="hljs-regexp">//</span>   let b = arr[<span class="hljs-number">1</span>];<br><span class="hljs-regexp">//</span>   let c = arr[<span class="hljs-number">2</span>];<br>let [a, b, c] = arr; <span class="hljs-regexp">//</span>x,y,z将与arr中的每个位置对应来取值<br>console.log(a, b, c);<br></code></pre></td></tr></table></figure><h3 id="对象模型的解构（Object）"><a href="#对象模型的解构（Object）" class="headerlink" title="对象模型的解构（Object）"></a>对象模型的解构（Object）</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sqf">const person = &#123;<br>  <span class="hljs-built_in">name</span>: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>  age: <span class="hljs-number">21</span>,<br>  <span class="hljs-built_in">language</span>: [<span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;js&#x27;</span>, <span class="hljs-string">&#x27;css&#x27;</span>],<br>&#125;;<br><span class="hljs-comment">// const  name=person.name;</span><br><span class="hljs-comment">// const  age=person.age;</span><br><span class="hljs-comment">// const  language=person.language;</span><br><span class="hljs-comment">//对象结构</span><br>const &#123; <span class="hljs-built_in">name</span>, age, <span class="hljs-built_in">language</span> &#125; = person; <span class="hljs-comment">//方法一</span><br>const &#123; <span class="hljs-built_in">name</span>: abc, age, <span class="hljs-built_in">language</span> &#125; = person; <span class="hljs-comment">//方法二</span><br>console.<span class="hljs-built_in">log</span>(abc, age, <span class="hljs-built_in">language</span>);<br></code></pre></td></tr></table></figure><h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ol><li>扩展的方法，子串的识别<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs processing">let <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;hello.vue&#x27;</span>;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span>.startsWith(<span class="hljs-string">&#x27;hello&#x27;</span>)); <span class="hljs-comment">//true</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span>.endsWith(<span class="hljs-string">&#x27;.vue&#x27;</span>)); <span class="hljs-comment">//true</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span>.includes(<span class="hljs-string">&#x27;e&#x27;</span>)); <span class="hljs-comment">//true</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span>.includes(<span class="hljs-string">&#x27;hello&#x27;</span>)); <span class="hljs-comment">//true</span><br><br></code></pre></td></tr></table></figure></li><li>字符串模板<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts">let ss = `<span class="hljs-params">&lt;div&gt;</span><br>                  <span class="hljs-params">&lt;span&gt;</span>hello world<span class="hljs-params">&lt;span&gt;</span><br>                  <span class="hljs-params">&lt;/div&gt;</span>`;<br>      console.log(ss);<span class="hljs-comment">//空格也能打印</span><br></code></pre></td></tr></table></figure></li></ol><p>控制台效果：</p><p><img src="/image/9.1.png" alt="运行效果"></p><ol><li>符串插入变量和表达式。变量名写在${}中，${}中可以放入javascript表达式。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这是一个函数&#x27;</span>;<br>&#125;<br><br>let info = `我是$&#123;abc&#125;，今年$&#123;age + <span class="hljs-number">10</span>&#125;了，我想说： $&#123;<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#125;`;<br>console.log(info);<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-let&amp;const</title>
    <link href="/2021/04/12/ES6(%E4%B8%80)/"/>
    <url>/2021/04/12/ES6(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<p>以下是对 ES6-let&amp;const的学习</p><hr><p>ECMAScript是浏览器脚本语言的规范，而我们熟知的JS语言，如<strong>JavaScript则是规范的具体实现。</strong></p><h3 id="let与var对比-做项目中习惯用let声明变量"><a href="#let与var对比-做项目中习惯用let声明变量" class="headerlink" title="let与var对比(做项目中习惯用let声明变量)"></a>let与var对比(做项目中习惯用let声明变量)</h3><ul><li>var声明的变量往往会越狱 (let 是在代码块内有效，var 是在全局范围内有效:)</li><li>let声明的变量有严格局部作用域</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>   <span class="hljs-keyword">var</span>  a=<span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">let</span>  b=<span class="hljs-number">2</span>;<br> &#125;<br> <span class="hljs-built_in">console</span>.log(a);  <span class="hljs-comment">//1</span><br> <span class="hljs-built_in">console</span>.log(b);  <span class="hljs-comment">//ReferenceError:b  is  not  defined</span><br></code></pre></td></tr></table></figure><ul><li>var可以声明多次</li><li>let只能声明一次<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span>  m=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span>  m=<span class="hljs-number">2</span>;<br><span class="hljs-keyword">let</span>  n=<span class="hljs-number">3</span>;<br><span class="hljs-keyword">let</span>  n=<span class="hljs-number">4</span>;<br><span class="hljs-built_in">console</span>.log(m);  <span class="hljs-comment">//2</span><br><span class="hljs-built_in">console</span>.log(n);  <span class="hljs-comment">//Identifier &#x27;n&#x27; has already been declared</span><br></code></pre></td></tr></table></figure></li><li> var 会变量提升</li><li> let 不存在变量提升<br>变量 b 用 var 声明存在变量提升，所以当脚本开始运行的时候，b 已经存在了，但是还没有赋值，所以会输出 undefined。<br>变量 a 用 let 声明不存在变量提升，在声明变量 a 之前，a 不存在，所以会报错。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">//  undefined</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">console</span>.log(y); <span class="hljs-comment">//Cannot access &#x27;y&#x27; before initialization</span><br><span class="hljs-keyword">let</span> y = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><h3 id="const声明变量-只读变量"><a href="#const声明变量-只读变量" class="headerlink" title="const声明变量 (只读变量)"></a>const声明变量 (只读变量)</h3></li><li>声明之后不允许改变</li><li>一旦声明必须初始化，否者会报错</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const a = <span class="hljs-number">1</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">a</span> = <span class="hljs-number">3</span><span class="hljs-comment">; //Uncaught TypeError: Assignment to constant variable.</span><br></code></pre></td></tr></table></figure><p>const 如何做到变量在声明初始化之后不允许改变的？其实 const 其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JQuery</title>
    <link href="/2021/04/08/Javascript%E5%85%A5%E9%97%A8(%E4%B8%83)/"/>
    <url>/2021/04/08/Javascript%E5%85%A5%E9%97%A8(%E4%B8%83)/</url>
    
    <content type="html"><![CDATA[<p>以下是对JQuery的学习</p><hr><p>Javascript<br>JQuery库(小型且功能丰富的JavaScript库)，里面存在大量的Javascript函数(通过易于使用的API（可在多种浏览器中使用），它使HTML文档的遍历和操作，事件处理，动画和Ajax等事情变得更加简单。)<br>能够避免重复造轮子。</p><h3 id="获取JQuery"><a href="#获取JQuery" class="headerlink" title="获取JQuery"></a>获取JQuery</h3><p>(CDN jQuery)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  //两种导入方式，一种本地，一种在线方式导入<br>    <span class="hljs-comment">&lt;!-- CDN引入 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;lib/jquery-3.6.0.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test-jquery&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">      <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;id&#x27;</span>);</span><br><span class="javascript">      <span class="hljs-comment">//选择器就是css的选择器</span></span><br><span class="javascript">      $(<span class="hljs-string">&#x27;test-jquery&#x27;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        alert(<span class="hljs-string">&#x27;hello,jQuery&#x27;</span>);</span><br>      &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>选择器</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>原生js,选择器少，麻烦不好记<br><span class="hljs-regexp">//</span>标签<br>document.getElementsByTagName();<br><span class="hljs-regexp">//i</span>d<br>document.getElementById();<br><span class="hljs-regexp">//</span>类<br>document.getElementById();<br><span class="hljs-regexp">//</span>jQuery  css种的选择器都能用<br>$(<span class="hljs-string">&#x27;p&#x27;</span>).click(); <span class="hljs-regexp">//</span>标签选择器<br>$(<span class="hljs-string">&#x27;#id1&#x27;</span>).click(); <span class="hljs-regexp">//i</span>d选择器<br>$(<span class="hljs-string">&#x27;.class1&#x27;</span>).click(); <span class="hljs-regexp">//</span>class选择器<br></code></pre></td></tr></table></figure><p>文档工具站：(<a href="https://jquery.cuishifeng.cn/">https://jquery.cuishifeng.cn/</a>)<br><img src="/image/7.1.PNG" alt="文档工具"></p><blockquote><p>事件</p></blockquote><p>鼠标事件，键盘事件，其他事件<br><img src="/image/7.3.png" alt="鼠标点击"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;lib/jquery-3.6.0.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>//导入JQuery<br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>  #divMove &#123;<br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;</span><br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 事件：获取鼠标当前的一个坐标 --&gt;</span><br>  mouse:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mouseMove&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;divMove&quot;</span>&gt;</span>在这里移动鼠标试试<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">//当网页元素加载完毕之后，响应事件</span></span><br><span class="javascript">    <span class="hljs-comment">// $(document).ready(function () &#123;&#125;);</span></span><br><span class="javascript">    <span class="hljs-comment">//简写</span></span><br><span class="javascript">    $(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">      $(<span class="hljs-string">&#x27;#divMove&#x27;</span>).mousemove(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-comment">//e代表获取的参数</span></span><br><span class="javascript">        $(<span class="hljs-string">&#x27;#mouseMove&#x27;</span>).text(<span class="hljs-string">&#x27;x:&#x27;</span> + e.pageX + <span class="hljs-string">&#x27;y&#x27;</span> + e.pageY);</span><br>      &#125;);<br>    &#125;);<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>操作DOM</p></blockquote><p>节点文本操作</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(&#x27;#<span class="hljs-params">test</span>-<span class="hljs-params">ul</span>  <span class="hljs-params">li</span>[<span class="hljs-params">name</span>=<span class="hljs-params">python</span>]&#x27;)</span>.text<span class="hljs-literal">()</span>; <span class="hljs-comment">//获得值</span><br><span class="hljs-constructor">$(&#x27;#<span class="hljs-params">test</span>-<span class="hljs-params">ul</span>  <span class="hljs-params">li</span>[<span class="hljs-params">name</span>=<span class="hljs-params">python</span>]&#x27;)</span>.text(&#x27;设置值&#x27;); <span class="hljs-comment">//设置值</span><br><span class="hljs-constructor">$(&#x27;#<span class="hljs-params">test</span>-<span class="hljs-params">ul</span>&#x27;)</span>.html<span class="hljs-literal">()</span>; <span class="hljs-comment">//获得值</span><br><span class="hljs-constructor">$(&#x27;#<span class="hljs-params">test</span>-<span class="hljs-params">ul</span>&#x27;)</span>.html(&#x27;&lt;strong&gt;<span class="hljs-number">123</span>&lt;/strong&gt;&#x27;); <span class="hljs-comment">//设置值</span><br></code></pre></td></tr></table></figure><p>css的操作</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(&#x27;#<span class="hljs-params">test</span>-<span class="hljs-params">ul</span>  <span class="hljs-params">li</span>[<span class="hljs-params">name</span>=<span class="hljs-params">python</span>]&#x27;)</span>.css(&#x27;color&#x27;, &#x27;red&#x27;);<br></code></pre></td></tr></table></figure><p>元素的显示和隐藏，本质<code>display:none</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">$(&#x27;#<span class="hljs-params">test</span>-<span class="hljs-params">ul</span>  <span class="hljs-params">li</span>[<span class="hljs-params">name</span>=<span class="hljs-params">python</span>]&#x27;)</span>.show<span class="hljs-literal">()</span><br><span class="hljs-constructor">$(&#x27;#<span class="hljs-params">test</span>-<span class="hljs-params">ul</span>  <span class="hljs-params">li</span>[<span class="hljs-params">name</span>=<span class="hljs-params">python</span>]&#x27;)</span>.hide<span class="hljs-literal">()</span><br></code></pre></td></tr></table></figure><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1JJ41177di?p=1">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
      <tag>JQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript操作表单(验证)(六)</title>
    <link href="/2021/04/08/Javascript%E5%85%A5%E9%97%A8(%E5%85%AD)/"/>
    <url>/2021/04/08/Javascript%E5%85%A5%E9%97%A8(%E5%85%AD)/</url>
    
    <content type="html"><![CDATA[<p>以下是对Javascript操作表单(验证)的学习</p><hr><h2 id="操作表单-验证"><a href="#操作表单-验证" class="headerlink" title="操作表单(验证)"></a>操作表单(验证)</h2><blockquote><p>表单是什么 form 本身也是DOM树</p></blockquote><ul><li>文本框 text</li><li>下拉框 select</li><li>单选框 radio</li><li>多选框 checkbox</li><li>隐藏域 hidden</li><li>密码框 password</li><li>….</li></ul><blockquote><p>获得要提交的信息</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>用户名：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 单，多选框的值，就是定义好的value --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>性别：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;man&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;boy&quot;</span> /&gt;</span>男<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;woman&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;girl&quot;</span> /&gt;</span>女<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> input_text = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;username&#x27;</span>);</span><br><span class="javascript">  <span class="hljs-keyword">var</span> boy_radio = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;boy&#x27;</span>);</span><br><span class="javascript">  <span class="hljs-keyword">var</span> girl_radio = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;girl&#x27;</span>);</span><br><span class="javascript">  <span class="hljs-comment">//得到输入框的值</span></span><br>  input_text.value;<br><span class="javascript">  <span class="hljs-comment">//修改输入框的值</span></span><br><span class="javascript">  <span class="hljs-comment">//对于单，多选框等等固定的值，boy_radio，value只能取到当前的值</span></span><br><span class="javascript">  boy_radio.checked; <span class="hljs-comment">//查看返回的结果，是否为true,如果为true,则被选中~</span></span><br><span class="javascript">  girl_radio.checked = <span class="hljs-literal">true</span>; <span class="hljs-comment">//赋值</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>提交表单。md5加密密码，表单优化</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>   <span class="hljs-comment">&lt;!-- 表单绑定提交事件</span><br><span class="hljs-comment">   onsubmit= 绑定一个提交检测的函数：true,fale</span><br><span class="hljs-comment">   将这个结果返回给表单，使用onsubmit接受！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   --&gt;</span><br>   &lt;form<br>     action=&quot;https://wwww.baidu.com/&quot;<br>     method=&quot;post&quot;<br>     onsubmit=&quot;return  aaa()&quot;<br>   &gt;<br>     <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>用户名：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> /&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>密码 ：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input-password&quot;</span> /&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;md5-password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> /&gt;</span>//隐藏密码<br>     <span class="hljs-comment">&lt;!--绑定事件onclick 被点击   onclick=&quot;aaa()&quot; --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">     <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aaa</span>(<span class="hljs-params"></span>) </span>&#123;</span><br>       alert(1);<br><span class="javascript">       <span class="hljs-keyword">var</span> uname = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;username&#x27;</span>);</span><br><span class="javascript">       <span class="hljs-keyword">var</span> pwd = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;input-password&#x27;</span>);</span><br><span class="javascript">       <span class="hljs-keyword">var</span> md5pwd = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;md5-password&#x27;</span>);</span><br>       md5pwd.value = md5(pwd.value);<br><span class="javascript">       <span class="hljs-comment">//可以校验判断表单内容，true就是通过提交，false,阻止提交</span></span><br><span class="javascript">       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="javascript">       <span class="hljs-comment">// console.log(uname.value);</span></span><br><span class="javascript">       <span class="hljs-comment">// //MD5  算法</span></span><br><span class="javascript">       <span class="hljs-comment">// pwd.value = md5(pwd);//密码隐藏</span></span><br><span class="javascript">       <span class="hljs-comment">// console.log(pwd.value);</span></span><br>     &#125;<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1JJ41177di?p=1">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript操作BOM对象与DOM(五)</title>
    <link href="/2021/04/06/Javascript%E5%85%A5%E9%97%A8(%E4%BA%94)/"/>
    <url>/2021/04/06/Javascript%E5%85%A5%E9%97%A8(%E4%BA%94)/</url>
    
    <content type="html"><![CDATA[<p>以下是对Javascript操作BOM对象与DOM的学习</p><hr><h2 id="操作BOM对象-重点"><a href="#操作BOM对象-重点" class="headerlink" title="操作BOM对象(重点)"></a>操作BOM对象(重点)</h2><blockquote><p>浏览器介绍<br>JavaScript 和浏览器关系？<br>JavaScript诞生就是伪类能够让他在浏览器中运行！<br><strong>BOM：浏览器对象模型</strong>      </p></blockquote><p>内核</p><ul><li>IE 6-11</li><li>Chrome</li><li>Safari</li><li>FireFox</li><li>Opera</li></ul><blockquote><p>window(重要)</p></blockquote><p>window代表浏览器窗口</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">window</span>.alert(<span class="hljs-number">1</span>)<br><span class="hljs-literal">undefined</span><br><span class="hljs-built_in">window</span>.innerHeight<br><span class="hljs-number">271</span><br><span class="hljs-built_in">window</span>.innerWidth<br><span class="hljs-number">1088</span><br><span class="hljs-built_in">window</span>.outerHeight<br><span class="hljs-number">805</span><br><span class="hljs-built_in">window</span>.outerWidth<br><span class="hljs-number">1104</span><br></code></pre></td></tr></table></figure><blockquote><p>Navigator(不建议使用)</p></blockquote><p>navigator,封装了浏览器的信息</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">navigator.appVersion<br><span class="hljs-string">&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36&quot;</span><br>navigator.userAgent<br><span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36&quot;</span><br>navigator.platform<br><span class="hljs-string">&quot;Win32&quot;</span><br></code></pre></td></tr></table></figure><p>大多数时候，我们不会使用navigator对象，因为会被人为修改！<br>不建议使用这些属性来判断和编写代码</p><blockquote><p>screen<br>代表屏幕尺寸</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">screen.width<br><span class="hljs-number">1536</span><br>screen.height<br><span class="hljs-number">864</span><br></code></pre></td></tr></table></figure><blockquote><p>location  (重要)</p></blockquote><p>location代表当前页面的URL信息</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">host:<span class="hljs-string">&quot;www.baidu.com&quot;</span><br>href: <span class="hljs-string">&quot; https://www.baidu.com/&quot;</span><br>protocol: <span class="hljs-string">&quot;https:&quot;</span><br>reload: ƒ reload()  <span class="hljs-regexp">//</span>刷新网页<br>location.assign(<span class="hljs-string">&#x27;https://pengzhenglong.github.io/&#x27;</span>)<span class="hljs-regexp">//</span>设置新的地址<br></code></pre></td></tr></table></figure><blockquote><p>document(内容)</p></blockquote><p>document代表当前的页面，HTML DOM文档树</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">document</span>.title<br><span class="hljs-string">&quot;百度一下，你就知道&quot;</span><br><span class="hljs-built_in">document</span>.title=<span class="hljs-string">&#x27;DragonPeng&#x27;</span><br><span class="hljs-string">&quot;DragonPeng&quot;</span><br></code></pre></td></tr></table></figure><p>获取具体的文档树节点</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>javase<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>javaEE<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> dl = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;app&#x27;</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>获取cookie</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">document</span>.cookie<br></code></pre></td></tr></table></figure><p>劫持cookie原理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;aa.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 恶意人员；获取你的cookie上传到他的服务器 --&gt;</span><br></code></pre></td></tr></table></figure><p>服务端可以设置cookie:httpOnly</p><blockquote><p>history(不建议使用)</p></blockquote><p>history代表浏览器的历史记录</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">history.back() <span class="hljs-regexp">//</span>后退<br>history.forward()<span class="hljs-regexp">//</span>前进<br></code></pre></td></tr></table></figure><h2 id="操作DOM对象-重点"><a href="#操作DOM对象-重点" class="headerlink" title="操作DOM对象(重点)"></a>操作DOM对象(重点)</h2><blockquote><p>核心</p></blockquote><p>浏览器网页就是一个Dom树形结构！    </p><ul><li>更新：更新Dom节点</li><li>遍历Dom节点：得到Dom节点</li><li>删除：删除一个Dom节点</li><li>添加：添加一个新的节点<br>要操作一个Dom节点，就必须要先获得这个Dom节点</li></ul><blockquote><p>获取dom节点</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 对应css选择器</span><br><span class="hljs-keyword">var</span> h1 = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;h1&#x27;</span>);<br><span class="hljs-keyword">var</span> h1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;p1&#x27;</span>);<br><span class="hljs-keyword">var</span> p2 = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&#x27;p2&#x27;</span>);<br><span class="hljs-keyword">var</span> father = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;father&#x27;</span>);<br><span class="hljs-keyword">var</span> childrens = father.children[index]; <span class="hljs-comment">//获取父节点下的所有子节点</span><br><span class="hljs-comment">//   father.firstChild;</span><br><span class="hljs-comment">//   father.lastChild;</span><br></code></pre></td></tr></table></figure><p>这是原生代码，之后我们尽量都使用JQuery();</p><blockquote><p>更新节点</p></blockquote><p>操作文本</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">id1.innerText=<span class="hljs-string">&#x27;456&#x27;</span>  <span class="hljs-regexp">//</span>修改文本的值<br>id1.innerHTML=<span class="hljs-string">&#x27;&lt;strong&gt;123&lt;/strong&gt;&#x27;</span><span class="hljs-regexp">//</span>可以解析HTML文本标签<br></code></pre></td></tr></table></figure><p>操作css</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">id1.style.color</span>=<span class="hljs-string">&#x27;red&#x27;</span><span class="hljs-comment">;  //属性使用  字符串</span><br><span class="hljs-attr">id1.style.fontSize</span>=<span class="hljs-string">&#x27;20px&#x27;</span><span class="hljs-comment">; //_转驼峰命名问题</span><br><span class="hljs-attr">id1.style.padding</span>  =<span class="hljs-string">&#x27;2em&#x27;</span>  <br><br></code></pre></td></tr></table></figure><blockquote><p>删除节点</p></blockquote><p>删除节点的步骤：先获取父节点，再通过父节点删除自己</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>标题1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p2&quot;</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> self = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;p1&#x27;</span>);</span><br><span class="javascript"><span class="hljs-keyword">var</span>  father = p1.parentElement;</span><br>father.removeChild(self);<br><br><span class="javascript"><span class="hljs-comment">//删除是一个动态的过程</span></span><br>father.removeChild(father.children[0])<br>father.removeChild(father.children[1])<br>father.removeChild(father.children[2])<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong>删除多个节点的时候，children是再时刻变化的，删除节点的时候一定要注意！</p><blockquote><p>插入节点</p></blockquote><p>我们获得了某个Dom节点，假设这个dom节点是空的，我们通过innerHTML就可以增加一个元素了，但是这个DOM节点已经存在元素了，我们就不能这么干了！会产生覆盖</p><p>追加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;js&quot;</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;se&quot;</span>&gt;</span>JavaSE<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ee&quot;</span>&gt;</span>JavaEE<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;me&quot;</span>&gt;</span>JavaMe<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> js = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;js&#x27;</span>);</span><br><span class="javascript">  <span class="hljs-keyword">var</span> list = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;list&#x27;</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果:<br><img src="/image/6.2.png" alt="追加到后面了"></p><blockquote><p>创建一个新的标签，实现插入</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> js = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;js&#x27;</span>); <span class="hljs-comment">//已经存在的节点</span></span><br><span class="javascript">  <span class="hljs-keyword">var</span> list = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;list&#x27;</span>);</span><br><span class="javascript">  <span class="hljs-comment">//通过JS创建一个新的节点</span></span><br><span class="javascript">  <span class="hljs-keyword">var</span> newP = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;p&#x27;</span>); <span class="hljs-comment">//创建一个P标签</span></span><br><span class="javascript">  newP.id = <span class="hljs-string">&#x27;newP&#x27;</span>;</span><br><br><span class="javascript">  newP.innerText = <span class="hljs-string">&#x27;hello.DragonPeng&#x27;</span>;</span><br><span class="javascript">  <span class="hljs-comment">//创建一个标签节点</span></span><br><span class="javascript">  <span class="hljs-keyword">var</span> myScript = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);</span><br><span class="javascript">  myScript.setAttribute(<span class="hljs-string">&#x27;type&#x27;</span>, <span class="hljs-string">&#x27;text/javascript&#x27;</span>);</span><br><br><span class="javascript">  <span class="hljs-comment">//可以创建一个Style标签</span></span><br><span class="javascript">  <span class="hljs-keyword">var</span> myStyle = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;style&#x27;</span>); <span class="hljs-comment">//创建了一个空style标签</span></span><br><span class="javascript">  myStyle.setAttribute(<span class="hljs-string">&#x27;type&#x27;</span>, <span class="hljs-string">&#x27;text/css&#x27;</span>);</span><br><span class="javascript">  myStyle.innerHTML = <span class="hljs-string">&#x27;body&#123;background-color: blue;&#125;&#x27;</span>; <span class="hljs-comment">//设置标签内容</span></span><br><span class="javascript">  <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;head&#x27;</span>)[<span class="hljs-number">0</span>].appendChild(myStyle);</span><br><span class="javascript">  <span class="hljs-comment">//   list.appendChild(js);</span></span><br><span class="javascript">  <span class="hljs-comment">//   list.append(newP);</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>insert</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> ee = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;ee&#x27;</span>);<br><span class="hljs-keyword">var</span> js = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;js&#x27;</span>);<br><span class="hljs-keyword">var</span> list = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;list&#x27;</span>);<br><span class="hljs-comment">// 要包含的节点，insertBefore(newNode, targetNode);</span><br>list.insertBefore(js, ee);<br></code></pre></td></tr></table></figure><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1JJ41177di?p=1">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript面向对象&amp;json(四)</title>
    <link href="/2021/04/05/Javascript%E5%85%A5%E9%97%A8(%E5%9B%9B)/"/>
    <url>/2021/04/05/Javascript%E5%85%A5%E9%97%A8(%E5%9B%9B)/</url>
    
    <content type="html"><![CDATA[<p>以下是对JavaScript函数与面向对象的学习</p><hr><h2 id="内部对象"><a href="#内部对象" class="headerlink" title="内部对象"></a>内部对象</h2><p>标准对象</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">typeof</span> <span class="hljs-number">123</span>o<br><span class="hljs-string">&quot;number&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;123&#x27;</span><br><span class="hljs-string">&quot;string&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span><br><span class="hljs-string">&quot;boolean&quot;</span><br><span class="hljs-keyword">typeof</span>  <span class="hljs-literal">NaN</span><br><span class="hljs-string">&quot;number&quot;</span><br><span class="hljs-keyword">typeof</span> []<br><span class="hljs-string">&quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> &#123;&#125;<br><span class="hljs-string">&quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Math</span>.abs<br><span class="hljs-string">&quot;function&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span><br><span class="hljs-string">&quot;undefined&quot;</span><br></code></pre></td></tr></table></figure><ol><li>Date<br>基本使用<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var now = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>; <span class="hljs-comment">//Mon Apr 12 2021 18:27:49 GMT+0800 (中国标准时间)</span><br>now.get<span class="hljs-constructor">FullYear()</span>; <span class="hljs-comment">//年</span><br>now.get<span class="hljs-constructor">Month()</span>; <span class="hljs-comment">//月  0~11月</span><br>now.get<span class="hljs-constructor">Date()</span>; <span class="hljs-comment">//日</span><br>now.get<span class="hljs-constructor">Day()</span>; <span class="hljs-comment">//星期几</span><br>now.get<span class="hljs-constructor">Hours()</span>; <span class="hljs-comment">//时</span><br>now.get<span class="hljs-constructor">Minutes()</span>; <span class="hljs-comment">//分</span><br>now.get<span class="hljs-constructor">Seconds()</span>; <span class="hljs-comment">//秒</span><br>now.get<span class="hljs-constructor">Time()</span>; <span class="hljs-comment">//时间戳  全世界统一 1970  1.1 0：00：00</span><br>console.log(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Date(1618223269100)</span>); <span class="hljs-comment">//时间戳转为时间</span><br></code></pre></td></tr></table></figure>转换<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">now = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Date(1618223269100)</span><br>Mon Apr <span class="hljs-number">12</span> <span class="hljs-number">2021</span> <span class="hljs-number">18</span>:<span class="hljs-number">27</span>:<span class="hljs-number">49</span> GMT+<span class="hljs-number">0800</span> (中国标准时间)<br>now.toLocaleDateString <span class="hljs-comment">//注意，调用的是一个方式，不是一个属性;</span><br>ƒ <span class="hljs-keyword">to</span><span class="hljs-constructor">LocaleDateString()</span> &#123; <span class="hljs-literal">[<span class="hljs-identifier">native</span> <span class="hljs-identifier">code</span>]</span> &#125;<br>now.toLocaleString<br>ƒ <span class="hljs-keyword">to</span><span class="hljs-constructor">LocaleString()</span> &#123; <span class="hljs-literal">[<span class="hljs-identifier">native</span> <span class="hljs-identifier">code</span>]</span> &#125;<br>now.<span class="hljs-keyword">to</span><span class="hljs-constructor">LocaleString()</span><br><span class="hljs-string">&quot;2021/4/12 下午6:27:49&quot;</span><br>now.<span class="hljs-keyword">to</span><span class="hljs-constructor">GMTString()</span><br><span class="hljs-string">&quot;Mon, 12 Apr 2021 10:27:49 GMT&quot;</span><br></code></pre></td></tr></table></figure></li><li>json是什么<br>早期，所有数据传输习惯使用XML文件</li></ol><ul><li> JSON是一种轻量级的数据交互格式。</li><li> 简洁和清晰的<strong>层次结构</strong>使得JSON成为理想的数据交互语言。</li><li> 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。<br>在JavaScript一切皆为对象，任何js支持的类型都可以用JSON来表示; number, string…     </li></ul><p>格式：</p><ul><li>对象都用{}</li><li>数组都用[]</li><li>所有的键值对都是用key:value</li></ul><ol start="3"><li>JSON字符串和JS对象的转化<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">var</span> student = &#123;<br>  <span class="hljs-built_in">na</span><span class="hljs-symbol">me:</span> &#x27;zhansan&#x27;,<br>  a<span class="hljs-symbol">ge:</span> <span class="hljs-number">3</span>,<br>  s<span class="hljs-symbol">ex:</span> &#x27;男&#x27;,<br>&#125;; //&#123;<span class="hljs-built_in">na</span><span class="hljs-symbol">me:</span> <span class="hljs-string">&quot;zhansan&quot;</span>, a<span class="hljs-symbol">ge:</span> <span class="hljs-number">3</span>, s<span class="hljs-symbol">ex:</span> <span class="hljs-string">&quot;男&quot;</span>&#125;<br>//对象转化为JSON字符串 &#123;<span class="hljs-string">&quot;name&quot;</span><span class="hljs-symbol">:</span><span class="hljs-string">&quot;zhansan&quot;</span>,<span class="hljs-string">&quot;age&quot;</span><span class="hljs-symbol">:3</span>,<span class="hljs-string">&quot;sex&quot;</span><span class="hljs-symbol">:</span><span class="hljs-string">&quot;男&quot;</span>&#125;<br><span class="hljs-built_in">var</span> jasonStudent = JSON.stringify(student);<br><br>//json字符串转化为对象，参数为json字符串<br><span class="hljs-built_in">var</span> obj = JSON.parse(&#x27;&#123;<span class="hljs-string">&quot;name&quot;</span><span class="hljs-symbol">:</span><span class="hljs-string">&quot;zhansan&quot;</span>,<span class="hljs-string">&quot;age&quot;</span><span class="hljs-symbol">:3</span>,<span class="hljs-string">&quot;sex&quot;</span><span class="hljs-symbol">:</span><span class="hljs-string">&quot;男&quot;</span>&#125;&#x27;);<br></code></pre></td></tr></table></figure>JSON和js对象的区别<br>JSON是一种格式化的字符串，而对象是键值对形式的<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">var</span> obj = &#123; a: <span class="hljs-symbol">&#x27;hell</span>o&#x27;, b: <span class="hljs-symbol">&#x27;hello</span>b&#x27; &#125;;<br><span class="hljs-keyword">var</span> json = &#x27;&#123;<span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>:<span class="hljs-string">&quot;hellob&quot;</span>&#125;&#x27;;<br></code></pre></td></tr></table></figure><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3></li><li>什么是面向对象<br>JavaScript，java,c#….面向对象;JavaScript有些区别！</li></ol><ul><li>类：模板</li><li>对象；具体的实例<br>在JavaScript中这个需要大家换一下思维方式！<br>原型：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> student = &#123;<br>  name: <span class="hljs-string">&#x27;zhansan&#x27;</span>,<br>  age: <span class="hljs-number">3</span>,<br>  sex: <span class="hljs-string">&#x27;男&#x27;</span>,<br>  run: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;run...&#x27;</span>);<br>  &#125;,<br>&#125;;<br><span class="hljs-keyword">var</span> xiaoming = &#123;<br>  name: <span class="hljs-string">&#x27;xiaoming&#x27;</span>,<br>&#125;;<br><span class="hljs-comment">//原型对象</span><br>xiaoming.__proto__ = student;<br><span class="hljs-keyword">var</span> Bird = &#123;<br>  fly: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;fly....&#x27;</span>);<br>  &#125;,<br>&#125;;<br><span class="hljs-comment">//小明的原型是Student</span><br>xiaoming.__proto__ = Bird;<br></code></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span><span class="hljs-params">(name)</span> </span>&#123;<br>  <span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><span class="hljs-comment">//给student新增一个方法</span><br>Student.prototype.hello = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;<br>  alert(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>class继承<br>class关键字，是在ES6引入的</li><li>定义一个类，属性，方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//定义一个学生类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> &#123;<br>    alert(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;hello&#x27;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> xiaoming = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;小明&#x27;</span>);<br><span class="hljs-keyword">var</span> xioahong = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;小红&#x27;</span>);<br>xiaoming.hello();<br></code></pre></td></tr></table></figure></li><li>继承<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span> &#123;<br>    alert(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XiaoStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, grade</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name); <span class="hljs-comment">//记得用super调用父类的构造方法!</span><br>    <span class="hljs-built_in">this</span>.grade = grade;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">myGrade</span>(<span class="hljs-params"></span>)</span> &#123;<br>    alert(<span class="hljs-string">&#x27;我是一名小学生&#x27;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> xiaoming = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;小明&#x27;</span>);<br><span class="hljs-keyword">var</span> xiaohong = <span class="hljs-keyword">new</span> XiaoStudent(<span class="hljs-string">&#x27;小红&#x27;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>本质：查看对象原型         </li></ol><p><img src="/image/6.png" alt="查看对象原型"></p><ol start="3"><li>原型链         </li></ol><p><img src="/image/6.1.png" alt="原型链"></p><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1JJ41177di?p=1">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript函数&amp;变量的作用域&amp;&amp;方法(三)</title>
    <link href="/2021/04/04/Javascript%E5%85%A5%E9%97%A8(%E4%B8%89)/"/>
    <url>/2021/04/04/Javascript%E5%85%A5%E9%97%A8(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<p>以下是对JavaScript函数的学习</p><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><ol><li>定义方式一</li></ol><p>绝对值函数</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sas">function<span class="hljs-meta"> abs(</span><span class="hljs-meta">x</span>) &#123;<br>  <span class="hljs-meta">if</span> (<span class="hljs-meta">x</span> &gt;= 0) &#123;<br>    <span class="hljs-meta">return</span> <span class="hljs-meta">x</span>;<br>  &#125; <span class="hljs-meta">else</span> &#123;<br>    <span class="hljs-meta">return</span> -<span class="hljs-meta">x</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦执行到return代表函数结束，返回结果！<br>如果没有执行return，函数执行完也会返回结果，结果就是undefined</p><ol start="2"><li><p>定义方式二</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada">var <span class="hljs-keyword">abs</span> = <span class="hljs-keyword">function</span> <span class="hljs-title"></span>(x) &#123;<br>  if (x &gt;= 0) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">x</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> -x;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>function(x){….}这是一个匿名函数，但是可以把结果赋值给abs，通过abs就可以调用函数！<br>方式一和方式二等价！</p></li><li><p>调用函数</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">abs</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>  <span class="hljs-comment">//10</span><br><span class="hljs-function"><span class="hljs-title">abs</span><span class="hljs-params">(-<span class="hljs-number">10</span>)</span></span>  <span class="hljs-comment">//10</span><br></code></pre></td></tr></table></figure><p>参数问题： JavaScript可以传任意个参数，也可以不传递参数~<br>参数尽量是否存在的问题？<br>假设不存在参数，如何规避？</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> abs = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x)</span> </span>&#123;<br>  <span class="hljs-comment">//   手动抛出异常来判断</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;Not  a Number&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> x;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> -x;          <br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>arguments<br>arguments是一个JS免费赠送的关键字：<br>代表，传递进来的所有的参数，是一个数组！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> abs = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x=&gt;&#x27;</span> + x);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[i]);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> x;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> -x;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>问题： arguments包含所有的参数，我们有时候使用多余的参数来进行附加操作。需要排除已有参数~     </p></li><li><p>rest<br>ES6引入的新特性，获取除了已经定义的参数之外的所有参数~<br>以前  </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">arguments</span>.<span class="hljs-built_in">length</span>&gt;<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">for</span>(var  <span class="hljs-built_in">i</span>=<span class="hljs-number">2</span>;<span class="hljs-built_in">i</span>&lt;<span class="hljs-keyword">arguments</span>.<span class="hljs-built_in">length</span>;<span class="hljs-built_in">i</span>++)&#123;<br>            <br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>ES6引入的新特性，获取除了已经定义的参数之外的所有参数~    </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aaa</span><span class="hljs-params">(a, b, <span class="hljs-rest_arg">...rest</span>)</span> </span>&#123;<br>  console.log(<span class="hljs-string">&#x27;a=&gt;&#x27;</span> + a);<br>  console.log(<span class="hljs-string">&#x27;b=&gt;&#x27;</span> + b);<br>  console.log(rest);<br>&#125;<br></code></pre></td></tr></table></figure><p>rest 参数只能写在最后面，必须用…标识。</p></li></ol><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><ol><li><p>在JavaScript中，var定义的变量实际是有作用域的。<br>假设在函数体中声明，则在函数体外不可以使用~(非要想实现的话后面可以研究以下闭包)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qj</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;<br>  x = x + <span class="hljs-number">1</span>;<br>&#125;<br>x = x + <span class="hljs-number">2</span>; <span class="hljs-comment">//Uncaught ReferenceError: x is not defined</span><br></code></pre></td></tr></table></figure></li><li><p>如果两个函数使用了相同的变量名，只要在函数内部，就不冲突</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qj</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;<br>  x = x + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qj2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-string">&#x27;a&#x27;</span>;<br>  X = X + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>假设，内部函数变量和外部函数的变量，重名！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qj</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qj2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-string">&#x27;A&#x27;</span>;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;inner&#x27;</span> + x); <span class="hljs-comment">//innerA</span><br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;outer&#x27;</span> + x); <span class="hljs-comment">//outer1</span><br>  qj2();<br>&#125;<br>  qj();<br></code></pre></td></tr></table></figure><p>假设在JavaScript中函数查找变量从自身函数开始~，由“内”向“外”查找，假设外部存在这个同名的函数变量，则内部函数会屏蔽外部函数的变量。</p></li><li><p>提升变量的作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qj</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-string">&#x27;x&#x27;</span> + y;<br>  <span class="hljs-built_in">console</span>.log(x);<br>  <span class="hljs-keyword">var</span> y = <span class="hljs-string">&#x27;y&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果： xundefined<br>说明：js执行引擎，自动提升了y的声明，但是不会提升变量y的赋值；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qj2</span>(<span class="hljs-params"></span>) </span>&#123;<br> <span class="hljs-keyword">var</span>  y;<br> <span class="hljs-keyword">var</span> x = <span class="hljs-string">&#x27;x&#x27;</span> + y;<br>  <span class="hljs-built_in">console</span>.log(x);<br>  y = <span class="hljs-string">&#x27;y&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个是在JavaScript建立之初就存在的特性。养成规范：所有的变量定义都放在函数的头部，不要乱放，便于代码维护。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qj2</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>  y = x + <span class="hljs-number">1</span>;<br>  z, i, a; <span class="hljs-comment">//undefined</span><br><br>  <span class="hljs-comment">//之后随意用</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>全局函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//全局变量</span><br> <span class="hljs-keyword">var</span>  x=<span class="hljs-number">1</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-built_in">console</span>.log(x);<br>  &#125;<br>  f();<br>  <span class="hljs-built_in">console</span>.log(x);<br></code></pre></td></tr></table></figure></li><li><p><strong>全局对象window</strong></p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sas">var <span class="hljs-meta">x</span> = <span class="hljs-string">&#x27;xxx&#x27;</span>;<br><span class="hljs-meta">window</span>.alert(<span class="hljs-meta">x</span>);<br><span class="hljs-meta">window</span>.alert(<span class="hljs-meta">window</span>.<span class="hljs-meta">x</span>); //默认所有的全局变量，都会自动绑定在<span class="hljs-meta">window</span>对象下<br></code></pre></td></tr></table></figure></li></ol><p>alter()这个函数本身也是一个window变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-string">&#x27;xxx&#x27;</span>;<br><span class="hljs-built_in">window</span>.alert(x);<br><span class="hljs-comment">//   window.alert(window.x); //默认所有的全局变量，都会自动绑定在window对象下</span><br><span class="hljs-keyword">var</span> old_alter = <span class="hljs-built_in">window</span>.alert;<br><span class="hljs-comment">//   old_alter(x);</span><br><span class="hljs-built_in">window</span>.alert = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-comment">//发现alter()失效了</span><br><span class="hljs-built_in">window</span>.alert(<span class="hljs-number">123</span>);<br><span class="hljs-comment">//恢复</span><br><span class="hljs-built_in">window</span>.alert = old_alter;<br><span class="hljs-built_in">window</span>.alert(<span class="hljs-number">456</span>);<br></code></pre></td></tr></table></figure><p>JavaScript实际上只有一个全局作用域，任何变量(函数也可以视为变量)，假如没有在函数作用范围内找到，就会向外查找。如果在全局作用域都没有找到，报错ReferenceError.<br>7. 规范<br>由于我们所有的全局变量都会绑定在我们的window上，如果不同的js文件，使用了相同的全局变量，冲突-&gt;如何能够减少冲突？</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada">//唯一全局变量<br>var <span class="hljs-keyword">all</span> = &#123;&#125;;<br>//定义全局变量<br><span class="hljs-keyword">all</span>.name = <span class="hljs-symbol">&#x27;DragonPeng</span>&#x27;;<br><span class="hljs-keyword">all</span>.add = <span class="hljs-keyword">function</span> <span class="hljs-title"></span>(a, b) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">a</span> + b;<br>&#125;;<br></code></pre></td></tr></table></figure><p>把自己的代码全部放入自己定义的唯一空间命名中，降低全局命名冲突的问题~</p><ol start="8"><li><p><strong>局部作用域let</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aaa</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>    <span class="hljs-built_in">console</span>.log(i);<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(i + <span class="hljs-number">1</span>); <span class="hljs-comment">//问题？i出了这个作用域还可以使用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ES6  let关键字，解决局部作用域冲突问题！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aaa</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>    <span class="hljs-built_in">console</span>.log(i);<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(i + <span class="hljs-number">1</span>); <span class="hljs-comment">//Uncaught ReferenceError: i is not defined</span><br>&#125;<br></code></pre></td></tr></table></figure><p>建议大家都用let去定义局部作用域的变量</p></li><li><p>常量const<br>在ES6之前，怎么定义常量，只有用全部大写字母命名的变量就是常量；建议不要修改这样的值</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams">var <span class="hljs-built_in">PI</span> = <span class="hljs-string">&#x27;3.14&#x27;</span>;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">PI</span>);<br><span class="hljs-built_in">PI</span> = <span class="hljs-string">&#x27;214&#x27;</span>;<span class="hljs-comment">//可以改变这个值</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">PI</span>);<br></code></pre></td></tr></table></figure><p>在ES6引入了常量关键字 const</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">const</span> <span class="hljs-literal">PI</span> = <span class="hljs-string">&#x27;3.14&#x27;</span>;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-literal">PI</span>);<br><span class="hljs-literal">PI</span> = <span class="hljs-string">&#x27;123&#x27;</span>;<span class="hljs-comment">//Uncaught TypeError: Assignment to constant variable.</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-literal">PI</span>); <br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>定义方法：<br>方法就是把函数放在对象的里面，对象只有两个东西:属性和方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">      <span class="hljs-keyword">var</span> student = &#123;<br>        name: <span class="hljs-string">&#x27;haha&#x27;</span>,<br>        birth: <span class="hljs-number">2000</span>,<br>        <span class="hljs-comment">//方法</span><br>        age: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-comment">//今年-出生的年</span><br>          <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getFullYear();<br>          <span class="hljs-keyword">return</span> now - <span class="hljs-built_in">this</span>.birth;<br>        &#125;,<br>      &#125;;<br><span class="hljs-comment">//属性</span><br>student.name<br><span class="hljs-comment">//方法，一定要带()</span><br>student.age()<br></code></pre></td></tr></table></figure><p>this代表什么？拆开上面的代码看看~</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">//今年-出生的年</span><br>  <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getFullYear();<br>  <span class="hljs-keyword">return</span> now - <span class="hljs-built_in">this</span>.birth;<br>&#125;<br><span class="hljs-keyword">var</span> student = &#123;<br>  name: <span class="hljs-string">&#x27;haha&#x27;</span>,<br>  birth: <span class="hljs-number">2000</span>,<br>  age: getAge,<br>&#125;;<br><span class="hljs-comment">//student.age() //ok</span><br><span class="hljs-comment">//   getAge()   NaN  window</span><br></code></pre></td></tr></table></figure><p>this是无法指向的，是默认指向调用它的那个对象；      </p></li></ol><blockquote><p>applay</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">//今年-出生的年</span><br>  <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getFullYear();<br>  <span class="hljs-keyword">return</span> now - <span class="hljs-built_in">this</span>.birth;<br>&#125;<br><span class="hljs-keyword">var</span> student = &#123;<br>  name: <span class="hljs-string">&#x27;haha&#x27;</span>,<br>  birth: <span class="hljs-number">2000</span>,<br>  age: getAge,<br>&#125;;<br><span class="hljs-comment">//student.age() //ok</span><br><span class="hljs-comment">//   getAge()   NaN</span><br>getAge.apply(student, []); <span class="hljs-comment">//this,指向了student，参数为空</span><br></code></pre></td></tr></table></figure><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1JJ41177di?p=1">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript&amp;字符串类型&amp;数组类型&amp;对象类型(二)</title>
    <link href="/2021/04/02/Javascript%E5%85%A5%E9%97%A8(%E4%BA%8C)/"/>
    <url>/2021/04/02/Javascript%E5%85%A5%E9%97%A8(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h2 id="字符串类型，数组类型，对象类型-详讲"><a href="#字符串类型，数组类型，对象类型-详讲" class="headerlink" title="字符串类型，数组类型，对象类型(详讲)"></a>字符串类型，数组类型，对象类型(详讲)</h2><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol><li>正常字符串我们使用 单引号，或者双引号包裹</li><li>注意转义字符\</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\&#x27;</span>   代表字符串<br><span class="hljs-string">\n</span>   换行<br><span class="hljs-string">\t</span>   tab<br><span class="hljs-string">\u4e2d</span>  <span class="hljs-string">\u###</span>  Unicode字符<br><span class="hljs-string">\x41</span>  Ascll字符<br></code></pre></td></tr></table></figure><ol start="3"><li>多行字符串编写</li></ol><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-comment">//  tab上面esc下面</span><br><span class="hljs-keyword">var</span>  msg= <br>    <span class="hljs-string">&#x27;hello </span><br><span class="hljs-string">    world</span><br><span class="hljs-string">    你好ya</span><br><span class="hljs-string">    你好&#x27;</span><br></code></pre></td></tr></table></figure><ol start="4"><li><strong>模板字符串</strong> (掌握es6的新特性)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//tab上面esc下面</span><br><span class="hljs-keyword">let</span>  name = <span class="hljs-string">&quot;xm&quot;</span>;<br><span class="hljs-keyword">let</span>  age=<span class="hljs-number">3</span>;<br><span class="hljs-keyword">let</span>  msg= <span class="hljs-string">&#x27;你好呀，$&#123;name&#125;&#x27;</span><br><span class="hljs-built_in">console</span>.log(msg)<br>你好呀，$&#123;name&#125;<br><br></code></pre></td></tr></table></figure><ol start="5"><li>字符串长度</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">str.<span class="hljs-built_in">length</span><br></code></pre></td></tr></table></figure><ol start="6"><li><strong>字符串的不可变性</strong>(掌握)</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">console.<span class="hljs-built_in">log</span>(student[<span class="hljs-number">0</span>])<br>s<br>student[<span class="hljs-number">0</span>]<span class="hljs-operator">=</span><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br>console.<span class="hljs-built_in">log</span>(student)<br>student<br></code></pre></td></tr></table></figure><ol start="7"><li>大小写转换</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//注意，这里是方法，不是属性</span><br>student.<span class="hljs-keyword">to</span><span class="hljs-constructor">UpperCase()</span>  <span class="hljs-comment">//大写</span><br><span class="hljs-string">&quot;STUDENT&quot;</span><br>student.<span class="hljs-keyword">to</span><span class="hljs-constructor">LowerCase()</span>  <span class="hljs-comment">//小写</span><br><span class="hljs-string">&quot;student&quot;</span><br></code></pre></td></tr></table></figure><ol start="8"><li>获取指定的下标</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">console.<span class="hljs-built_in">log</span>(student.indexOf(<span class="hljs-string">&#x27;t&#x27;</span>))<br> <span class="hljs-number">1</span><br>console.<span class="hljs-built_in">log</span>(student.indexOf(<span class="hljs-string">&#x27;s&#x27;</span>))<br> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ol start="9"><li><strong>substring</strong>(掌握)</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">[)<br>student.substring(<span class="hljs-number">1</span>)  <span class="hljs-regexp">//</span>从第一个字符串截取到最后一个字符串<br><span class="hljs-string">&quot;tudent&quot;</span><br>student.substring(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>) <span class="hljs-regexp">//</span>[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<br><span class="hljs-string">&quot;tu&quot;</span><br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Array 可以包含任意的数据类型</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var</span>  arr =<span class="hljs-meta"> [1,2,3,4,5,6]  //通过下标取值和赋值</span><br><span class="hljs-meta">arr[0]</span><br><span class="hljs-attribute">arr</span>[<span class="hljs-number">0</span>] =<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><ol><li>长度</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">arr.<span class="hljs-built_in">length</span><br></code></pre></td></tr></table></figure><p><strong>注意：假如给arr.length，数组大小就会发生变化。如果赋值过小，元素就会丢失。</strong></p><ol start="2"><li>indexOf,通过元素获得下标索引<br>indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。</li></ol><p>如果没有找到匹配的字符串则返回 -1。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">arr</span>.indexOf(<span class="hljs-number">2</span>)<br><span class="hljs-attribute">1</span><br></code></pre></td></tr></table></figure><p>字符串的”1”和数字1是不同的<br>3. slice()  截取Array的一部分，返回一个新数组，类似于String中的substring</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs"><span class="hljs-attribute">arr</span>.slice(<span class="hljs-number">3</span>)<br>[4, 5, 6]<br></code></pre></td></tr></table></figure><ol start="4"><li>push,pop  尾部(掌握)</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">push</span>:  压入到尾部<br><span class="hljs-keyword">pop</span>:  弹出尾部的一个元素<br>arr.<span class="hljs-keyword">push</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;a&quot;</span>)<br>arr.<span class="hljs-keyword">pop</span>()<br></code></pre></td></tr></table></figure><ol start="5"><li>unshift(),shift()头部  (掌握)</li></ol><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">unshift</span>  压入到头部<br><span class="hljs-keyword">shift</span>    弹出头部的一个元素 <br></code></pre></td></tr></table></figure><ol start="6"><li>排序  sort()</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">arr</span><br>(<span class="hljs-number">3</span>) <span class="hljs-selector-attr">[<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>]</span><br><span class="hljs-selector-tag">arr</span><span class="hljs-selector-class">.sort</span>()<br>(<span class="hljs-number">3</span>) <span class="hljs-selector-attr">[<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>]</span><br></code></pre></td></tr></table></figure><ol start="7"><li>元素反转  reverse()</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">(<span class="hljs-number">3</span>) <span class="hljs-selector-attr">[<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>]</span><br>arr<span class="hljs-selector-class">.reverse</span>()<br>(<span class="hljs-number">3</span>) <span class="hljs-selector-attr">[<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>]</span><br></code></pre></td></tr></table></figure><ol start="8"><li>concat()     (掌握)</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">(<span class="hljs-number">3</span>) <span class="hljs-selector-attr">[<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>]</span><br>arr<span class="hljs-selector-class">.concat</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br>(<span class="hljs-number">6</span>) <span class="hljs-selector-attr">[<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, 1, 2, 3]</span><br>arr<br>(<span class="hljs-number">3</span>) <span class="hljs-selector-attr">[<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><strong>注意： concat()并没有修改数组，只是会返回一个新的数组</strong></p><ol start="9"><li>连接符join<br>打印拼接数组，使用特定的字符串连接</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">(<span class="hljs-number">3</span>) <span class="hljs-selector-attr">[<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>]</span><br>arr<span class="hljs-selector-class">.join</span>(<span class="hljs-string">&#x27;-&#x27;</span>)<br><span class="hljs-string">&quot;C-B-A&quot;</span><br></code></pre></td></tr></table></figure><ol start="10"><li>多维数组</li></ol><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">arr= [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>]];<br>arr[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>总结： 数组:存储数据(如何存，如何取，方法都可以自己实现！)</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>是若干个键值对<br><strong>Js中所有的键都是字符串，值是任意对象！</strong></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dts">var 对象名=&#123;<br>    属性名: 属性值;<br>    属性名: 属性值;<br>    属性名: 属性值;<br>&#125;<br><span class="hljs-comment">//定义了一个student对象，它有四个属性！</span><br>var student=&#123;<br>    name :<span class="hljs-string">&quot;zhangsan&quot;</span>,<br><span class="hljs-symbol">    age:</span><span class="hljs-number">10</span>,<br><span class="hljs-symbol">    email:</span>  <span class="hljs-string">&quot;24132413241@qq.com&quot;</span>,<br><span class="hljs-symbol">    score:</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Js中对象，{…}表示一个对象，键值对描述属性xxxx:xxxx,多个属性之间使用逗号隔开，最后一个属性不加逗号！</p><ol><li>对象赋值</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">student.<span class="hljs-built_in">name</span><br><span class="hljs-string">&quot;zhangsan&quot;</span><br>student.<span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;lishi&quot;</span><br><span class="hljs-string">&quot;lishi&quot;</span><br>student.<span class="hljs-built_in">name</span><br><span class="hljs-string">&quot;lishi&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>使用一个不存在的对象属性，不会报错！ undefined</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">student.hahah<br><span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><ol start="3"><li>动态的删减属性，通过delete删除对象的属性</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">delete</span> student.name<br><span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><ol start="4"><li>动态添加,直接给新属性添加值即可</li></ol><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">student.<span class="hljs-attr">haha=</span> <span class="hljs-string">&quot;haha&quot;</span><br><span class="hljs-string">&quot;haha&quot;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>判断属性值是否在这个对象中！ xx in xxx!</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-string">&#x27;age&#x27;</span> <span class="hljs-keyword">in</span> student<br><span class="hljs-literal">true</span>   <br><span class="hljs-comment">//继承</span><br><span class="hljs-string">&#x27;toString&#x27;</span>  <span class="hljs-keyword">in</span> student<br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ol start="6"><li>判断一个属性是否是这个对象自身拥有的hasOwnProperty()</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">student.has<span class="hljs-constructor">OwnProperty(&#x27;<span class="hljs-params">toString</span>&#x27;)</span><br><span class="hljs-literal">false</span><br>student.has<span class="hljs-constructor">OwnProperty(&#x27;<span class="hljs-params">age</span>&#x27;)</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ol><li>if判断 else</li><li>while循环 ，避免程序死循环</li><li>for循环</li><li><strong>forEach循环</strong>(5.1引入的)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span>  age=[<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">31</span>,<span class="hljs-number">23</span>,<span class="hljs-number">123</span>]<br><span class="hljs-comment">//函数</span><br>age.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(value)<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="5"><li>for…in(age 不知道是数组大小的情况用)</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs maxima">//<span class="hljs-keyword">for</span>(<span class="hljs-built_in">var</span>  index  <span class="hljs-keyword">in</span> object)&#123;&#125;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-built_in">var</span> <span class="hljs-built_in">num</span> <span class="hljs-keyword">in</span> age) &#123;<br>        <span class="hljs-keyword">if</span> (age.hasOwnProperty(<span class="hljs-built_in">num</span>)) &#123;<br>          console.<span class="hljs-built_in">log</span>(&#x27;存在&#x27;);<br>          console.<span class="hljs-built_in">log</span>(age[<span class="hljs-built_in">num</span>]);<br>        &#125;<br>      &#125;<br></code></pre></td></tr></table></figure><h2 id="Map和Set-ES6的新特性"><a href="#Map和Set-ES6的新特性" class="headerlink" title="Map和Set (ES6的新特性)"></a>Map和Set (ES6的新特性)</h2><p>Map：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>ES6   Map<br><span class="hljs-regexp">//</span>学生的成绩，学生的名字<br><span class="hljs-regexp">//</span> var  names  =[<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-string">&quot;haha&quot;</span>] ;<br><span class="hljs-regexp">//</span> var  scores= [<span class="hljs-number">100</span>,<span class="hljs-number">90</span>,<span class="hljs-number">80</span>];<br>var map = new Map([<br>  [<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-number">100</span>],<br>  [<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">90</span>],<br>  [<span class="hljs-string">&#x27;haha&#x27;</span>, <span class="hljs-number">80</span>],<br>]);<br>var name = map.get(<span class="hljs-string">&#x27;tom&#x27;</span>);<br>map.set(<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-number">1223456</span>); <span class="hljs-regexp">//</span>添加<br>console.log(name); <span class="hljs-regexp">//</span>通过Key获得value<br>map.<span class="hljs-keyword">delete</span>(<span class="hljs-string">&#x27;tom&#x27;</span>);<span class="hljs-regexp">//</span>删除<br></code></pre></td></tr></table></figure><p>Set:无序不重复的集合</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">var <span class="hljs-built_in">set</span> = <span class="hljs-built_in">new</span> Set([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]);<span class="hljs-comment"> //Set可以去重</span><br>     <span class="hljs-built_in">set</span>.<span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>); <span class="hljs-comment"> //添加</span><br>     <span class="hljs-built_in">set</span>.<span class="hljs-built_in">delete</span>(<span class="hljs-number">1</span>);<span class="hljs-comment"> // 删除</span><br>     console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">set</span>.has(<span class="hljs-number">3</span>)); <span class="hljs-comment"> //是否包含某个元素</span><br></code></pre></td></tr></table></figure><h2 id="iterator-es6新特性"><a href="#iterator-es6新特性" class="headerlink" title="iterator(es6新特性)"></a>iterator(es6新特性)</h2><p>遍历数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> arr) &#123;<br>  <span class="hljs-built_in">console</span>.log(x);<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历map</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">var</span> <span class="hljs-keyword">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([<br>  [<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-number">100</span>],<br>  [<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">90</span>],<br>  [<span class="hljs-string">&#x27;haha&#x27;</span>, <span class="hljs-number">70</span>],<br>]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> <span class="hljs-keyword">map</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(x);<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历set</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">var <span class="hljs-meta">set</span> = new <span class="hljs-meta">Set</span>([5, 6, 7]);<br>for (let <span class="hljs-meta">x</span> of <span class="hljs-meta">set</span>) &#123;<br>  console<span class="hljs-meta">.log(</span><span class="hljs-meta">x</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024358748480">参考链接</a></p><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1JJ41177di?p=1">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript入门&amp;数据类型(一)</title>
    <link href="/2021/04/02/Javascript%E5%85%A5%E9%97%A8(%E4%B8%80)/"/>
    <url>/2021/04/02/Javascript%E5%85%A5%E9%97%A8(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<p>有句话叫，假设能够重新来过，我就只愿意学Javascript。为什么：因为它足够的简单，而且应用量极其强大，不仅在前端用的多，而且在后端用的也足够的多，整个nodejs不需要java也能够搭建起来服务器。但是支撑不了高并发，还是有个弊端。以下是对JavaScript基础学习总结。</p><hr><h3 id="入门-Javascript代码放置"><a href="#入门-Javascript代码放置" class="headerlink" title="入门(Javascript代码放置)"></a>入门(Javascript代码放置)</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- script标签内，写Javascript代码 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- &lt;script&gt;</span><br><span class="hljs-comment">    alert(&#x27;hello,world&#x27;)</span><br><span class="hljs-comment">  &lt;/script&gt; --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 外部引入 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- 注意：script:必须成对出现 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/p1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 不用显示定义type,也默认就是javascript --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 这里也可以存放 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span> <br></code></pre></td></tr></table></figure><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>ECMAScript它可以理解是JavaScript的一个标准，最新版本已经到了es6版本~。但是大部分浏览器还只停留在支持es5代码上！开发环境–线上环境，版本不一致。<br><strong>javascript更简单了，只要你按照java的语法写javascript就一定不会出错。javascript可以不写分号结尾，但是有个问题，它编译打包会把多行变成一行。有个东西是eslink专门检查JavaScript语法的。有很多强语法的检查工具。</strong></p><h3 id="浏览器的使用-5个常用功能"><a href="#浏览器的使用-5个常用功能" class="headerlink" title="浏览器的使用(5个常用功能)"></a>浏览器的使用(5个常用功能)</h3><p>Elements  元素（爬网站用，把网站复刻一遍）<br>Console      调试js<br>Source   打断点<br>Network   抓包<br>Application   查看网站的cookie<br><img src="/image/4.1.png" alt="浏览器控制台"></p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Javascript严格区分大小写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-comment">//1.定义变量  变量类型  变量名= 变量值</span></span><br><span class="javascript">  <span class="hljs-keyword">var</span> score = <span class="hljs-number">71</span>;</span><br><span class="javascript">  <span class="hljs-comment">// var num = 1;</span></span><br><span class="javascript">  <span class="hljs-comment">//   alert(num);</span></span><br><span class="javascript">  <span class="hljs-comment">//2.条件控制</span></span><br>  if (1 &lt; 2) &#123;<br><span class="javascript">    alert(<span class="hljs-string">&quot;true&quot;</span>);</span><br>  &#125;<br><span class="javascript">  <span class="hljs-comment">// console.log(score) //在浏览器的控制台打印变量！</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="数据类型略讲"><a href="#数据类型略讲" class="headerlink" title="数据类型略讲"></a>数据类型略讲</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span>  王者荣耀=<span class="hljs-string">&#x27;永恒砖石&#x27;</span>(可以使用中文定义，但最好不要使用)<br></code></pre></td></tr></table></figure><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>js不区分小数和整数，Number</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">123</span>    <span class="hljs-regexp">//</span>整数<span class="hljs-number">123</span><br><span class="hljs-number">123.1</span>   <span class="hljs-regexp">//</span>浮点数<span class="hljs-number">123.1</span><br><span class="hljs-number">1.123</span>e3   <span class="hljs-regexp">//</span>科学计数法<br>-<span class="hljs-number">99</span>   <span class="hljs-regexp">//</span>复数<br>NaN   <span class="hljs-regexp">//</span>not  a number<br>Infinity   <span class="hljs-regexp">//</span>表示无限大<br></code></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scheme"><span class="hljs-symbol">&#x27;abc</span>&#x27;  <span class="hljs-string">&quot;abc&quot;</span><br></code></pre></td></tr></table></figure><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>true,   false</p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">&amp;&amp;  两个都为真，结果为真</span><br><span class="hljs-string">||  一个为真，一个为假</span><br>！  真即假，假即真<br></code></pre></td></tr></table></figure><h3 id="比较运算符！！！重要！"><a href="#比较运算符！！！重要！" class="headerlink" title="比较运算符！！！重要！"></a>比较运算符！！！<strong>重要！</strong></h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">=  </span><br><span class="hljs-section">==   等于(类型不一样，值一样，也会判断为true)</span><br><span class="hljs-section">===   绝对等于 (类型一样，值一样，结果为true)</span><br></code></pre></td></tr></table></figure><p><strong>这是JS的缺陷，坚持不要使用 == 比较</strong><br>须知：</p><ul><li>NaN === NaN,这个与所有的数值都不相等，包括自己</li><li>只能通过isNaN(NaN)来判断这个数是否是NaN</li></ul><p>浮点数问题:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">console</span>.log((<span class="hljs-number">1</span>/<span class="hljs-number">3</span>)   ==== (<span class="hljs-number">1</span>-<span class="hljs-number">1</span>/<span class="hljs-number">3</span>))  (false)<br></code></pre></td></tr></table></figure><p>尽量避免使用浮点数进行运算，存在精度问题！</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Math</span>.abs(<span class="hljs-number">1</span>/<span class="hljs-number">3</span>-(<span class="hljs-number">1</span>-<span class="hljs-number">2</span>/<span class="hljs-number">3</span>))&lt;<span class="hljs-number">0</span>.<span class="hljs-number">00000001</span>  (true)<br></code></pre></td></tr></table></figure><h3 id="null-和undefined"><a href="#null-和undefined" class="headerlink" title="null 和undefined"></a>null 和undefined</h3><ul><li>null  空</li><li>undefined  未定义</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>Java的数值必须是相同类型的对象~，JS中不需要这样！</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//  保证代码的可读性，尽量使用[]</span><br><span class="hljs-keyword">var</span>  arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Hello&#x27;</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">true</span>];<br><br><span class="hljs-keyword">new</span>  <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Hello&#x27;</span>)<br></code></pre></td></tr></table></figure><p>去数组下标：如果越界了，就会</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象的大括号，数组是中括号</p><blockquote><p>每个属性之间使用都好隔开，最好一个不需要添加</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> person= &#123;<br>    name:<span class="hljs-string">&quot;hh&quot;</span>,<br>    age: <span class="hljs-number">3</span>,<br>    tags:<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;js&#x27;</span>,<span class="hljs-string">&#x27;java&#x27;</span>,<span class="hljs-string">&#x27;web&#x27;</span>,<span class="hljs-string">&#x27;...&#x27;</span>]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>取对象的值</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">person.age<br>&gt;<span class="hljs-number">3</span><br>person.tags<br>&gt;<span class="hljs-selector-attr">[<span class="hljs-string">&quot;js&quot;</span>, <span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;web&quot;</span>, <span class="hljs-string">&quot;...&quot;</span>]</span><br></code></pre></td></tr></table></figure><h2 id="严格检查模式strict"><a href="#严格检查模式strict" class="headerlink" title="严格检查模式strict"></a>严格检查模式strict</h2><p>前提：IDEA 需要设置支持ES6语法’use  strict’;严格检查模式，预防Javascript的随意性导致产生的一些问题,必须写在Javascript的第一行,局部变量建议使用let去定义~</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-string">&#x27;use  strict&#x27;</span>;</span><br><span class="javascript">  <span class="hljs-comment">// 全局变量</span></span><br>    i = 1;<br><span class="javascript">  <span class="hljs-comment">//   ES6 let</span></span><br><span class="javascript">  <span class="hljs-comment">//   let i = 1;</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1JJ41177di?p=1">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS浮动&amp;父级边框塌陷问题&amp;定位</title>
    <link href="/2021/04/02/CSS%E5%AD%A6%E4%B9%A0(%E4%B8%89)/"/>
    <url>/2021/04/02/CSS%E5%AD%A6%E4%B9%A0(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<p>以下是对CSS(浮动，父级边框塌陷问题，定位)的学习(重点)</p><hr><h2 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h2><p>边框的粗细，样式，颜色( border: 1px solid red;)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-comment">/* body 总有以一个默认的外边距margin:0 常见操作 */</span></span><br><span class="css"><span class="hljs-selector-tag">h1</span>, <span class="hljs-selector-tag">ul</span>, <span class="hljs-selector-tag">li</span>, <span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="css">    <span class="hljs-attribute">text-decoration</span>: none;</span><br>  &#125;<br><span class="css">  <span class="hljs-comment">/* border: 粗细，样式，颜色 */</span></span><br>  #box &#123;<br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">h2</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#3cbda6</span>;</span><br><span class="css">    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">30px</span>;</span><br><span class="css">    <span class="hljs-attribute">color</span>: white;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">form</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">background</span>: <span class="hljs-number">#3cbda6</span>;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">1</span>) <span class="hljs-selector-tag">input</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid black;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">div</span>:<span class="hljs-built_in">neh-of-type</span>(<span class="hljs-number">2</span>) iniput &#123;</span><br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> dashed <span class="hljs-number">#4d0b8c</span>;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">div</span>:<span class="hljs-built_in">neh-of-type</span>(<span class="hljs-number">3</span>) iniput &#123;</span><br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> dashed <span class="hljs-number">#008c27</span>;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="内外边距及边框居中"><a href="#内外边距及边框居中" class="headerlink" title="内外边距及边框居中"></a>内外边距及边框居中</h2>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;外边距的妙用，居中元素<br><span class="hljs-attribute">margin</span>:<span class="hljs-number">10</span>px <span class="hljs-number">5</span>px <span class="hljs-number">15</span>px <span class="hljs-number">20</span>px;(上右下左)--顺时针<br><span class="hljs-attribute">margin</span>:<span class="hljs-number">10</span>px <span class="hljs-number">5</span>px;上下<span class="hljs-number">10</span>px,左右 <span class="hljs-number">5</span>px <br><span class="hljs-attribute">margin</span>:<span class="hljs-number">10</span>px <span class="hljs-number">5</span>px <span class="hljs-number">15</span>px;上外边距是<span class="hljs-number">10</span>px，左右<span class="hljs-number">5</span>px，下外边距是<span class="hljs-number">15</span>px<br><span class="hljs-attribute">margin</span>:<span class="hljs-number">10</span>px;所有 <span class="hljs-number">4</span> 个外边距都是 <span class="hljs-number">10</span>px<br></code></pre></td></tr></table></figure><p>盒子大小计算方式<br><img src="/image/5.1.PNG" alt="盒子大小"></p><h2 id="圆角边框"><a href="#圆角边框" class="headerlink" title="圆角边框"></a>圆角边框</h2><p>4个角</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  border-radius  左上  右上  右下  左下 ，顺时针方向 --&gt;</span><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">  圆圈  = 半径+边距!</span><br><span class="hljs-comment"> --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid red;</span><br><span class="css">    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">100px</span>;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="盒子阴影-box-shadow"><a href="#盒子阴影-box-shadow" class="headerlink" title="盒子阴影(box-shadow)"></a>盒子阴影(box-shadow)</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">    <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><br><span class="css">      <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50px</span>;</span><br><span class="css">      <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">10px</span> <span class="hljs-number">10px</span> <span class="hljs-number">1px</span> yellow;</span><br>    &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>box-shadow: h-shadow v-shadow blur spread color inset;<br>h-shadow必需。水平阴影的位置。允许负值。<br>v-shadow必需。垂直阴影的位置。允许负值。<br>blur    可选。模糊距离。<br>spread    可选。阴影的尺寸。<br>color    可选。阴影的颜色。请参阅 CSS 颜色值。<br>inset    可选。将外部阴影 (outset) 改为内部阴影。<br></code></pre></td></tr></table></figure><h2 id="模仿网站思路"><a href="#模仿网站思路" class="headerlink" title="模仿网站思路"></a>模仿网站思路</h2><p><a href="https://www.bilibili.com/video/BV1YJ411a7dy?p=16">网页链接</a><br>视频后半部分讲解</p><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><h3 id="标准文档流"><a href="#标准文档流" class="headerlink" title="标准文档流"></a>标准文档流</h3><p>块级元素: 独占一行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span>~<span class="hljs-selector-tag">h6</span>   <span class="hljs-selector-tag">p</span>  <span class="hljs-selector-tag">div</span>  列表...<br></code></pre></td></tr></table></figure><p>行内元素: 不占一行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">span</span>  <span class="hljs-selector-tag">a</span>  <span class="hljs-selector-tag">img</span>  <span class="hljs-selector-tag">strong</span>....<br></code></pre></td></tr></table></figure><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>这个也是一种实现行内元素排列的方式，但是我们很多情况都是float</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">    block 块元素</span><br><span class="hljs-comment">    inline  行内元素</span><br><span class="hljs-comment">    inline-block 是块元素，但是可以内联在一行！</span><br><span class="hljs-comment">    none</span><br><span class="hljs-comment"> --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;</span><br><span class="css">    <span class="hljs-attribute">display</span>: none;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">span</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;</span><br><span class="css">    <span class="hljs-attribute">display</span>: inline-block;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><p>左右浮动 float </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>;<br>&#125;<br><span class="hljs-selector-id">#father</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-number">#000</span> solid;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br><span class="hljs-selector-id">#father</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br><span class="hljs-selector-class">.layer01</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-number">#00f</span> dashed;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">float</span>: left;<br>&#125;<br><span class="hljs-selector-class">.layer02</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-number">#00f</span> dashed;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">float</span>: left;<br>&#125;<br><br><span class="hljs-selector-class">.layer03</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-number">#00f</span> dashed;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">float</span>: right;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li>display 方向不可以控制</li><li>float    浮动起来的话会脱离标准文档流，所以要解决父级边框塌陷的问题<h2 id="父级边框塌陷问题"><a href="#父级边框塌陷问题" class="headerlink" title="父级边框塌陷问题"></a>父级边框塌陷问题</h2>clear<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq">/*  <span class="hljs-built_in">clear</span>: <span class="hljs-built_in">right</span>;  右侧不允许有浮动元素<br>    <span class="hljs-built_in">clear</span>: <span class="hljs-built_in">left</span>;  左侧不允许有浮动元素<br>    <span class="hljs-built_in">clear</span>: both;  两侧不允许有浮动元素<br>     <span class="hljs-built_in">clear</span>: none默认值。允许浮动元素出现在两侧。<br>*/<br></code></pre></td></tr></table></figure>解决方案：</li></ul><ol><li>增加父级元素的高度~<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#father</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> <span class="hljs-number">#000</span> solid;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">800px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>增加一个空的div标签，清除浮动<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;div class=&quot;clear&quot;&gt;</span><span class="hljs-params">&lt;/div&gt;</span><br>.<span class="hljs-class">clear </span>&#123;<br><span class="hljs-symbol">  clear:</span> both;<br><span class="hljs-symbol">  margin:</span> <span class="hljs-number">0</span>;<br><span class="hljs-symbol">  padding:</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>overflow<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">在父级元素中添加一个  <span class="hljs-attribute">overflow</span>:hidden;<br></code></pre></td></tr></table></figure></li><li>父类添加一个伪元素  ::after<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#father</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><h3 id="1-相对定位-position-relative"><a href="#1-相对定位-position-relative" class="headerlink" title="1.相对定位 position: relative;"></a>1.相对定位 position: relative;</h3><p> 相对原来自己的位置，进行指定的偏移，相对定位的话，它仍然在标准文档流中，原来的位置会被保留。<br> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">top</span>: -<span class="hljs-number">20px</span>;上<br><span class="hljs-attribute">left</span>:<span class="hljs-number">20px</span>;左<br><span class="hljs-attribute">bottom</span>:-<span class="hljs-number">10px</span>;下<br><span class="hljs-attribute">right</span>: <span class="hljs-number">20px</span>;右<br></code></pre></td></tr></table></figure></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 相对定位</span><br><span class="hljs-comment">相对自己原来的位置进行偏移 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;</span><br><span class="css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>;</span><br><span class="css">    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;</span><br><span class="css">    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">25px</span>;</span><br>  &#125;<br>  #father &#123;<br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#666</span>;</span><br><span class="css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br>  &#125;<br>  #first &#123;<br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> dashed <span class="hljs-built_in">rgb</span>(<span class="hljs-number">35</span>, <span class="hljs-number">204</span>, <span class="hljs-number">50</span>);</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: cyan;</span><br><span class="css">    <span class="hljs-attribute">position</span>: relative; <span class="hljs-comment">/* 相对定位，上下左右  */</span></span><br><span class="css">    <span class="hljs-attribute">top</span>: -<span class="hljs-number">20px</span>;</span><br><span class="css">    <span class="hljs-attribute">left</span>: <span class="hljs-number">20px</span>;</span><br>  &#125;<br>  #second &#123;<br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> dashed <span class="hljs-built_in">rgb</span>(<span class="hljs-number">16</span>, <span class="hljs-number">58</span>, <span class="hljs-number">194</span>);</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="css">    <span class="hljs-attribute">position</span>: relative;</span><br><span class="css">    <span class="hljs-attribute">bottom</span>: -<span class="hljs-number">10px</span>; <span class="hljs-comment">/* 向下 */</span></span><br>  &#125;<br>  #third &#123;<br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> dashed <span class="hljs-built_in">rgb</span>(<span class="hljs-number">167</span>, <span class="hljs-number">46</span>, <span class="hljs-number">92</span>);</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: chartreuse;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-绝对定位-position-absolute"><a href="#2-绝对定位-position-absolute" class="headerlink" title="2. 绝对定位 position: absolute;"></a>2. 绝对定位 position: absolute;</h3><p>定位: 基于xxx定位，上下左右~</p><ol><li>没有父级元素定位的前提下，相对于浏览器定位</li><li>假如父级元素存在定位，我们通常会相对于父级元素进行偏移</li><li>在父级元素范围内移动</li></ol><p>相对于父级或浏览器的位置，进行指定的偏移，绝对定位的话，它不在标准文档流中，原来的位置不会被保留。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;</span><br><span class="css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>;</span><br><span class="css">    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;</span><br><span class="css">    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">25px</span>;</span><br>  &#125;<br>  #father &#123;<br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#666</span>;</span><br><span class="css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="css">    <span class="hljs-attribute">position</span>: relative;</span><br>  &#125;<br>  #first &#123;<br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> dashed <span class="hljs-built_in">rgb</span>(<span class="hljs-number">35</span>, <span class="hljs-number">204</span>, <span class="hljs-number">50</span>);</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: cyan;</span><br>  &#125;<br>  #second &#123;<br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> dashed <span class="hljs-built_in">rgb</span>(<span class="hljs-number">16</span>, <span class="hljs-number">58</span>, <span class="hljs-number">194</span>);</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="css">    <span class="hljs-attribute">position</span>: absolute;</span><br><span class="css">    <span class="hljs-attribute">right</span>: <span class="hljs-number">30px</span>;</span><br>  &#125;<br>  #third &#123;<br><span class="css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> dashed <span class="hljs-built_in">rgb</span>(<span class="hljs-number">167</span>, <span class="hljs-number">46</span>, <span class="hljs-number">92</span>);</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: chartreuse;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;first&quot;</span>&gt;</span>第一个盒子<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;second&quot;</span>&gt;</span>第二个盒子<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;third&quot;</span>&gt;</span>第三个盒子<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-固定定位-position-fixed"><a href="#3-固定定位-position-fixed" class="headerlink" title="3.固定定位      position: fixed;"></a>3.固定定位      position: fixed;</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">1000px</span>;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">1</span>) &#123;</span><br><span class="css">    <span class="hljs-comment">/*绝对定位，相对于浏览器*/</span></span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">background</span>: red;</span><br><span class="css">    <span class="hljs-attribute">position</span>: absolute;</span><br><span class="css">    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><br><span class="css">    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span><br>  &#125;<br><span class="css">  <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">2</span>) &#123;</span><br><span class="css">    <span class="hljs-comment">/*fixed  固定定位*/</span></span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;</span><br><span class="css">    <span class="hljs-attribute">background</span>: yellow;</span><br><span class="css">    <span class="hljs-attribute">position</span>: fixed;</span><br><span class="css">    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><br><span class="css">    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-z-index"><a href="#4-z-index" class="headerlink" title="4. z-index"></a>4. z-index</h3><p>图层~<br>z-index:  默认是0，最高~999(z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。)<br>注释：元素可拥有负的 z-index 属性值。<br>注释：Z-index 仅能在定位元素上奏效（例如 position:absolute;）！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;style/style.css&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;images/1.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tipText&quot;</span>&gt;</span>学习CSS<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tipBg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>时间:2021-1-23<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>地点：月球一号基地<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>opacity: 0.5;背景透明度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#content</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">304px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">25px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> black solid;<br>&#125;<br><span class="hljs-selector-tag">ul</span>,<br><span class="hljs-selector-tag">li</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span>;<br>  <span class="hljs-attribute">list-style</span>: none;<br>&#125;<br><span class="hljs-comment">/* 父级元素相对定位 */</span><br><span class="hljs-selector-id">#content</span> <span class="hljs-selector-tag">ul</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.tipText</span>,<br><span class="hljs-selector-class">.tipBg</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">304px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">25px</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">164px</span>;<br>&#125;<br><span class="hljs-selector-class">.tipText</span> &#123;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">z-index</span>: <span class="hljs-number">999</span>;<br>&#125;<br><span class="hljs-selector-class">.tipBg</span> &#123;<br>  <span class="hljs-attribute">background</span>: black;<br>  <span class="hljs-comment">/* 背景透明度  */</span><br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动画及视野拓展"><a href="#动画及视野拓展" class="headerlink" title="动画及视野拓展"></a>动画及视野拓展</h2><p><a href="https://www.bilibili.com/video/BV1YJ411a7dy?p=23">学习视频地址</a></p><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1YJ411a7dy?p=1">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS&amp;结构伪类选择器&amp;属性选择器(重要)&amp;美化网页元素</title>
    <link href="/2021/04/01/CSS%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
    <url>/2021/04/01/CSS%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<p>以下是对CSS(结构伪类选择器(避免使用，class,id选择器),属性选择器(重要)等)的学习</p><hr><h2 id="结构伪类选择器-避免使用，class-id选择器"><a href="#结构伪类选择器-避免使用，class-id选择器" class="headerlink" title="结构伪类选择器(避免使用，class,id选择器)"></a>结构伪类选择器(避免使用，class,id选择器)</h2><p>带冒号都是伪类选择器<br>1 ul li:first-child</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* ul的第一个子元素 */</span><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-comment">/* ul的最后一个元素 */</span><br><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span> &#123;<br>  <span class="hljs-attribute">background</span>: turquoise;<br>&#125;<br></code></pre></td></tr></table></figure><p>2  p:nth-child(1) (nth父元素)</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">    <span class="hljs-comment">/* 选中p1: 定位到父元素，选择当前的第一个元素 </span><br><span class="hljs-comment">选择当前p元素的父级元素，选择父级元素的第一个,并且是当前元素才生效</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-comment">/* p:nth-child(1)&#123;</span><br><span class="hljs-comment">      background: violet;</span><br><span class="hljs-comment">  &#125; */</span><br></code></pre></td></tr></table></figure><p>3 p:nth-of-type(1) </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">/*  选中父元素，下的p元素的第一个，按类型选类型  */</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-attribute">background</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><p>4 a:hover(鼠标悬浮的颜色 (重要))</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">background</span>: yellow;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="属性选择器-重要"><a href="#属性选择器-重要" class="headerlink" title="属性选择器(重要)"></a>属性选择器(重要)</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">    <span class="hljs-selector-class">.demo</span> <span class="hljs-selector-tag">a</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">float</span>: left;</span><br><span class="css">      <span class="hljs-attribute">display</span>: block;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;</span><br><span class="css">      <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;</span><br><span class="css">      <span class="hljs-attribute">background</span>: lightgreen;</span><br><span class="css">      <span class="hljs-attribute">text-align</span>: center;</span><br><span class="css">      <span class="hljs-attribute">color</span>: gainsboro;</span><br><span class="css">      <span class="hljs-attribute">text-decoration</span>: none;</span><br><span class="css">      <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">5px</span>;</span><br><span class="css">      <span class="hljs-attribute">font</span>: bold <span class="hljs-number">20px</span>/<span class="hljs-number">50px</span> Arial;</span><br><span class="css">      <span class="hljs-attribute">line-height</span>: <span class="hljs-number">50px</span>;</span><br>    &#125;<br>    /* 属性名， 属性名= 属性值（正则）<br>=绝对等于<br>*=包含这个元素<br>^= 以这个开头<br>$= 以这个结尾<br> */<br><br><span class="css">    <span class="hljs-comment">/* 存在id属性的元素   a[]&#123;&#125; */</span></span><br><span class="css">    <span class="hljs-comment">/* a[id]&#123;</span></span><br><span class="css">    <span class="hljs-attribute">background</span>: yellow;</span><br>&#125; */<br><span class="css">    <span class="hljs-comment">/*id=first的元素  */</span></span><br><span class="css">    <span class="hljs-comment">/* a[id=first]&#123;</span></span><br><span class="css">    <span class="hljs-attribute">background</span>: violet;</span><br>&#125; */<br><span class="css">    <span class="hljs-comment">/* class 中有links的元素 */</span></span><br><span class="css">    <span class="hljs-comment">/* a[class*=&quot;links&quot;]&#123;</span></span><br><span class="css">    <span class="hljs-attribute">background</span>: yellow;</span><br>&#125; */<br><br><span class="css">    <span class="hljs-comment">/* 选中href中以http开头的元素 */</span></span><br><span class="css">    <span class="hljs-comment">/* a[href^=http]&#123;</span></span><br><span class="css"><span class="hljs-attribute">background</span>: yellow;</span><br>    &#125; */<br><span class="css">    <span class="hljs-comment">/* 选中href中以doc结尾的元素 */</span></span><br><span class="css">    <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href$=<span class="hljs-string">&#x27;doc&#x27;</span>]</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">background</span>: yellow;</span><br>    &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links item first&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;first&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links item active&quot;</span><span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;test&quot;</span> &gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;images/123.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links item&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;images/123.png&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links item&quot;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;images/123.jpg&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links item&quot;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;abc&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links item&quot;</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/a.pdf&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links item&quot;</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/a.pdf&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links item&quot;</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;abc.doc&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links item&quot;</span>&gt;</span>9<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;abcd.doc&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;links item&quot;</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="美化网页元素"><a href="#美化网页元素" class="headerlink" title="美化网页元素"></a>美化网页元素</h2><ol><li>有效的传递页面信息</li><li>美化页面，页面漂亮，才能吸引用户</li><li>凸显页面的主题</li><li>提高用户的体验</li></ol><h3 id="span标签：重点要突出的字，使用span套起来"><a href="#span标签：重点要突出的字，使用span套起来" class="headerlink" title="span标签：重点要突出的字，使用span套起来"></a>span标签：重点要突出的字，使用span套起来</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!-- font-family:字体</span><br><span class="hljs-comment">   font-size:字体大小</span><br><span class="hljs-comment">   font-weight:字体粗细</span><br><span class="hljs-comment">   color:字体颜色</span><br><span class="hljs-comment">--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">   <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">     <span class="hljs-attribute">font-family</span>: Impact, Haettenschweiler, <span class="hljs-string">&#x27;Arial Narrow Bold&#x27;</span>, sans-serif;</span><br><span class="css">     <span class="hljs-attribute">color</span>: blue;</span><br>   &#125;<br><span class="css">   <span class="hljs-selector-tag">h1</span> &#123;</span><br><span class="css">     <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50px</span>;</span><br>   &#125;<br>   .p1 &#123;<br><span class="css">     <span class="hljs-attribute">font-weight</span>: lighter;</span><br>   &#125;<br> <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><ol><li>颜色 color rgb rgba</li><li>文本对齐的方式  text-align(重要)</li><li>首行缩进  text-indent: 2em; (重要)</li><li>行高    line-height(单行文字上下居中)(重要)</li><li>装饰   text-decoration</li><li>文本图片水平对齐  vertical-align: middle;<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">   颜色：</span><br><span class="hljs-comment">           单词</span><br><span class="hljs-comment">           RGB  0~F</span><br><span class="hljs-comment">           RGBA  A :0~1</span><br><span class="hljs-comment">           text-align:  排版，居中</span><br><span class="hljs-comment">           text-indent: 2em;  段落首行缩进</span><br><span class="hljs-comment">       line-height: 300px;  </span><br><span class="hljs-comment">       行高，和块的高度一致，就可以上下居中  </span><br><span class="hljs-comment">--&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">   <span class="hljs-selector-tag">h1</span> &#123;</span><br><span class="css">     <span class="hljs-attribute">color</span>: red;</span><br><span class="css">     <span class="hljs-attribute">text-align</span>: center;</span><br>   &#125;<br>   .p1 &#123;<br><span class="css">     <span class="hljs-attribute">text-indent</span>: <span class="hljs-number">2em</span>;</span><br>   &#125;<br><br>   .p3 &#123;<br><span class="css">     <span class="hljs-attribute">background</span>: chartreuse;</span><br><span class="css">     <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">     <span class="hljs-attribute">line-height</span>: <span class="hljs-number">300px</span>;</span><br>   &#125;<br><span class="css">   <span class="hljs-comment">/* 下划线 */</span></span><br>   .l1 &#123;<br><span class="css">     <span class="hljs-attribute">text-decoration</span>: underline;</span><br>   &#125;<br><span class="css">   <span class="hljs-comment">/* 中划线 */</span></span><br>   .l2 &#123;<br><span class="css">     <span class="hljs-attribute">text-decoration</span>: line-through;</span><br>   &#125;<br><span class="css">   <span class="hljs-comment">/*上划线  */</span></span><br>   .l3 &#123;<br><span class="css">     <span class="hljs-attribute">text-decoration</span>: overline;</span><br>   &#125;<br><span class="css">   <span class="hljs-selector-tag">img</span>,</span><br><span class="css">   <span class="hljs-selector-tag">span</span> &#123;</span><br><span class="css">     <span class="hljs-attribute">vertical-align</span>: middle;</span><br>   &#125;<br> <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;l1&quot;</span>&gt;</span>123123<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;l2&quot;</span>&gt;</span>123123<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;l3&quot;</span>&gt;</span>123123<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>故事介绍<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span><br>     平静安详的元泱境界，每隔333年，总会有一个神秘而恐怖的异常生物重生，它就是魁拔！魁拔的每一次出现，都会给元泱境界带来巨大的灾难！<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>     在偏远的兽国窝窝乡，蛮大人和蛮吉每天为取得象征成功和光荣的妖侠纹耀而刻苦修炼，却把他们生活的村庄搅得鸡犬不宁。村民们绞尽脑汁把他们赶走。<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;p3&quot;</span>&gt;</span><br>     I have searched a thousand years,And I have cried a thousand tears.<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="超链接伪类"><a href="#超链接伪类" class="headerlink" title="超链接伪类"></a>超链接伪类</h3>正常情况下， a:hover<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css">    <span class="hljs-comment">/* 默认的颜色 */</span><br>  <span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">text-decoration</span>: none;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;<br>  &#125;<br>  <span class="hljs-comment">/* 鼠标悬浮的颜色 (重要)*/</span><br>  <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">color</span>: orange;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">50px</span>;<br>  &#125;<br>  <span class="hljs-comment">/* 鼠标按住未释放的状态 */</span><br>  <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>    <span class="hljs-attribute">color</span>: green;<br>  &#125;<br><br>  <span class="hljs-comment">/*  text-shadow   阴影颜色，水平偏移，垂直偏移，阴影半径*/</span><br>  <span class="hljs-selector-id">#price</span> &#123;<br>    <span class="hljs-attribute">text-shadow</span>: blue <span class="hljs-number">10px</span> <span class="hljs-number">10px</span> <span class="hljs-number">2px</span>;<br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h3 id="列表样式"><a href="#列表样式" class="headerlink" title="列表样式"></a>列表样式</h3><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">/* <span class="hljs-string">ul</span>  <span class="hljs-string">li</span> */<br>/* <br><span class="hljs-built_in">list-style::</span><br><span class="hljs-built_in">none</span>  去掉原点<br><span class="hljs-string">circle</span>  空心圆<br><span class="hljs-string">decimal</span>  数字<br><span class="hljs-string">square</span>  正方形<br>*/<br><span class="hljs-string">ul</span>  <span class="hljs-string">li</span>&#123;<br>    <span class="hljs-string">height</span>: <span class="hljs-string">30px</span>;<br>    <span class="hljs-built_in">list-style:</span> <span class="hljs-string">none</span>;<br>    <span class="hljs-string">text-indent</span>: <span class="hljs-string">1em</span>;<br>      &#125;<br></code></pre></td></tr></table></figure><h3 id="图片平铺方式渐变-background-repeat"><a href="#图片平铺方式渐变-background-repeat" class="headerlink" title="图片平铺方式渐变(background-repeat)"></a>图片平铺方式渐变(background-repeat)</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span></span><br><span class="xml">  div </span><span class="xquery">&#123;</span><br><span class="xquery">    width: <span class="hljs-number">1000</span>px;</span><br><span class="xquery">    height: <span class="hljs-number">700</span>px;</span><br><span class="xquery">    border: <span class="hljs-number">1</span>px solid red;</span><br><span class="xquery">    background-image: url(<span class="hljs-string">&#x27;image/1.jpg&#x27;</span>);</span><br><span class="xquery">    /* 默认是全部平铺的 */</span><br><span class="xquery">  &#125;</span><br><span class="xml">  <span class="hljs-comment">&lt;!-- 沿x轴平铺 --&gt;</span></span><br><span class="xml">  .div1 </span><span class="xquery">&#123;</span><br><span class="xquery">    background-repeat: repeat-x;</span><br><span class="xquery">  &#125;</span><br><span class="xml">      <span class="hljs-comment">&lt;!-- 沿y轴平铺 --&gt;</span></span><br><span class="xml">  .div2 </span><span class="xquery">&#123;</span><br><span class="xquery">    background-repeat: repeat-y;</span><br><span class="xquery">  &#125;</span><br><span class="xml">  .div3 </span><span class="xquery">&#123;</span><br><span class="xquery">    background-repeat: no-repeat;</span><br><span class="xquery">  &#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="背景渐变"><a href="#背景渐变" class="headerlink" title="背景渐变"></a>背景渐变</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--径向渐变，圆形渐变  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">  <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#00dbde</span>;</span><br><span class="css">    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">45deg</span>, <span class="hljs-number">#00dbde</span> <span class="hljs-number">0%</span>, <span class="hljs-number">#fc00ff</span> <span class="hljs-number">100%</span>);</span><br>  &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><a href="https://www.grabient.com/">开源项目网址</a></li></ol><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1YJ411a7dy?p=1">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS导入方式&amp;三种基本选择器&amp;层次选择器</title>
    <link href="/2021/04/01/Css%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <url>/2021/04/01/Css%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">css的优势：<br><span class="hljs-number">1</span>.内容和表现分离<br><span class="hljs-number">2</span>.网页结构表现统一，可以实现复用。<br><span class="hljs-number">3</span>.样式十分丰富。<br><span class="hljs-number">4</span>.建议使用独立于<span class="hljs-selector-tag">html</span>的css文件。<br><span class="hljs-number">5</span>.利用SEO,容易被搜索引擎收录。<br></code></pre></td></tr></table></figure><p>以下是对CSS(CSS导入方式(三种),三种基本选择器,层次选择器)的学习</p><hr><h2 id="CSS导入方式-三种"><a href="#CSS导入方式-三种" class="headerlink" title="CSS导入方式(三种)"></a>CSS导入方式(三种)</h2><ol><li>行内样式<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 行内样式：在标签元素中，编写一个style属性，编写样式即可 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;&quot;</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>内部样式<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 内部样式 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">        <span class="hljs-selector-tag">h1</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">color</span>:green;</span><br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>外部样式–1.链接式<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 外部样式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/css/style.css&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>外部样式–2.导入式(不常用，以前网页先加载框架Html，后渲染出页面)<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">@import是CSS2.1特有的<br><span class="hljs-comment">&lt;!-- 导入式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css"><span class="hljs-keyword">@import</span> url(css/style.css);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><strong>优先级:就近原则</strong><br><strong>优先级:行内样式&gt;内部样式&gt;外部样式</strong></li></ol><h2 id="三种基本选择器"><a href="#三种基本选择器" class="headerlink" title="三种基本选择器"></a>三种基本选择器</h2><ol><li>标签选择器<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">    <span class="hljs-comment">/* 标签选择器，会选择到页面所有的这个标签的元素 */</span></span><br><span class="css">    <span class="hljs-selector-tag">h1</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">background</span>: blue;</span><br><span class="css">        <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">24px</span>;</span><br><span class="css">        <span class="hljs-attribute">color</span>: hotpink;</span><br>    &#125;<br><span class="css">    <span class="hljs-selector-tag">p</span>&#123;</span><br><span class="css">        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">80px</span>;</span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>类选择器<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    /*  类选择器的格式，.class的名称&#123;&#125;<br>    好处，可以多个标签归类，是同一个class,可以复用<br>      */<br>    .aa.cc&#123;<br><span class="css">        <span class="hljs-attribute">color</span>:hotpink;</span><br>    &#125;<br>    .bb&#123;<br><span class="css">        <span class="hljs-attribute">color</span>: indianred;</span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>id选择器(全局唯一)<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>/*   id选择器  ：id必须保证全局唯一<br>  #id名称&#123;&#125;*/<br>#aa&#123;<br><span class="css">   <span class="hljs-attribute">color</span>: lawngreen; </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h3>优先级:不遵循就近原则，固定的<br><strong>id选择器&gt;class选择器&gt;标签选择器</strong></li></ol><h2 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h2><ol><li>后代选择器：在某个元素的后面(都会作用)<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">    <span class="hljs-comment">/* body  p&#123;</span><br><span class="hljs-comment">        background: red;</span><br><span class="hljs-comment">    &#125; */</span><br>例：<span class="hljs-selector-tag">body</span>后的所有<span class="hljs-selector-tag">p</span>标签背景都会变为红色<br></code></pre></td></tr></table></figure></li><li>子选择器：(就作用一代)<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">   <span class="hljs-comment">/* body&gt;p&#123;</span><br><span class="hljs-comment">       background:blue;</span><br><span class="hljs-comment">   &#125; */</span><br>例：<span class="hljs-selector-tag">body</span>后面的第一代<span class="hljs-selector-tag">p</span>标签才有效果，其他嵌套的没有<br></code></pre></td></tr></table></figure></li><li>相邻兄弟选择器：只有一个，相邻(向下)<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">    <span class="hljs-comment">/* .active+p&#123;</span><br><span class="hljs-comment">        background:blue;</span><br><span class="hljs-comment">    &#125; */</span><br>例：类active标签的向下的一个<span class="hljs-selector-tag">P</span>标签才会作用<br></code></pre></td></tr></table></figure></li><li>通用兄弟选择器<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">当前选中元素的向下的所有兄弟元素 */<br>    <span class="hljs-selector-class">.active</span> ~ <span class="hljs-selector-tag">p</span> &#123;<br>      <span class="hljs-attribute">background</span>: tomato;<br>    &#125;<br>例：类active后面向下的所有<span class="hljs-selector-tag">P</span>标签都会作用<br></code></pre></td></tr></table></figure></li></ol><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1YJ411a7dy?p=1">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端基础</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git的使用--如何将本地项目上传到Github&amp;Git创建新分支</title>
    <link href="/2021/03/31/Git%E7%9A%84%E4%BD%BF%E7%94%A8--%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0Github&amp;Git%E5%88%9B%E5%BB%BA%E6%96%B0%E5%88%86%E6%94%AF/"/>
    <url>/2021/03/31/Git%E7%9A%84%E4%BD%BF%E7%94%A8--%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0Github&amp;Git%E5%88%9B%E5%BB%BA%E6%96%B0%E5%88%86%E6%94%AF/</url>
    
    <content type="html"><![CDATA[<p>如何将本地项目上传到Github（两种简单、方便的方法）</p><hr><h3 id="第一种-已尝试"><a href="#第一种-已尝试" class="headerlink" title="第一种(已尝试)"></a>第一种(已尝试)</h3><ol><li><p>Github上新建一个仓库<br><img src="/image/8.png" alt="新建一个仓库"></p></li><li><p>复制仓库地址先(两个都行)<br><img src="/image/8.1.png" alt="仓库地址"></p></li><li><p>桌面右键Git进入文件夹目录<br><img src="/image/8.2.png" alt="Git"></p></li><li><p>接下来输入如下代码（关键步骤），把github上面的仓库克隆到本地</p></li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">git</span>  <span class="hljs-selector-tag">clone</span>  <span class="hljs-selector-tag">git</span>@<span class="hljs-selector-tag">github</span><span class="hljs-selector-class">.com</span>:<span class="hljs-selector-tag">Pengzhenglong</span>/<span class="hljs-selector-tag">html</span><span class="hljs-selector-tag">-css-js</span><span class="hljs-selector-class">.git</span><br>(git<span class="hljs-variable">@github</span>.<span class="hljs-attribute">com</span>:Pengzhenglong/html-css-js.git换成你第二步复制的地址链接)<br></code></pre></td></tr></table></figure><p><img src="/image/8.3.png" alt="克隆仓库"><br> 这个步骤以后你的本地项目文件夹下面就会多出个文件夹，该文件夹名即为你github上面的项目名，如图我多出了个html-css-js文件夹，我们把本地项目文件夹下的所有文件（除了新多出的那个文件夹不用），其余都复制到那个新多出的文件夹下。</p><p><img src="/image/8.4.png" alt="文件图片"></p><ol start="5"><li><p>接着继续输入命令 cd html-css-js，进入html-css-js文件夹</p></li><li><p>接下来依次输入以下代码即可完成其他剩余操作</p></li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git add . （注：别忘记后面的.，此操作是把html-css-js文件夹下面的文件都添加进来）           <br><br>git commit  -m  ”提交信息”  （注：“提交信息”里面换成你需要，如“<span class="hljs-built_in">first</span> commit”）       <br><br>git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> master   （注：此操作目的是把本地仓库<span class="hljs-built_in">push</span>到github上面，此步骤需要你输入帐号和密码）(由于我之前设置了免密操作所以我这台电脑不需要输入账号密码)<br></code></pre></td></tr></table></figure><p><img src="/image/8.5.png" alt="Git操作"></p><p><img src="/image/8.6.png" alt="上传成功"></p><h3 id="第二种-未尝试"><a href="#第二种-未尝试" class="headerlink" title="第二种(未尝试)"></a>第二种(未尝试)</h3><blockquote><p>参考链接:<br><code>https://blog.csdn.net/u014135752/article/details/79951802</code></p></blockquote><h3 id="Git创建新分支并提交到github"><a href="#Git创建新分支并提交到github" class="headerlink" title="Git创建新分支并提交到github"></a>Git创建新分支并提交到github</h3><p>因为需求的变更，需要把原来的代码做一下备份，再进行下一步的开发，所以 这是就将原来的代码创建一个新的分支来保存原来的代码，以防后面需要回滚，这里记录一下操作的步骤</p><ol><li>可以先查看一下当前所在分支</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span><br></code></pre></td></tr></table></figure><ol start="2"><li>创建本地分支并切换到新创建的分支</li></ol><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">git</span> <span class="hljs-variable">checkout</span> -<span class="hljs-variable">b</span> <span class="hljs-function"><span class="hljs-title">dev</span>(<span class="hljs-variable">dev</span> 可以命名为自己想取的名字)</span><br></code></pre></td></tr></table></figure><ol start="3"><li>已经创建成功了，可以看一下</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span><br></code></pre></td></tr></table></figure><ol start="4"><li>将新创建的分支信息推送到github</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> HEAD -u<br></code></pre></td></tr></table></figure><ol start="5"><li><p>可以到github看一下<br><img src="/image/8.8.png" alt="Github"></p></li><li><p>git checkout branchname   //切换分支  branchname为你的分支名字</p></li><li><p>分支操作</p></li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">然后切换到主分支<br>$ git checkout <span class="hljs-keyword">master</span> <span class="hljs-title"></span><br><span class="hljs-title"></span><br><span class="hljs-title">然后将新分支提交的改动合并到主分支上</span><br><span class="hljs-title">$</span> git merge newbranch  <br><br>然后就可以push代码了<br>$ git push -u origin <span class="hljs-literal">master</span><br><br>最后还可以删除这个分支<br>$ git branch -D newbranch<br></code></pre></td></tr></table></figure><h4 id="删除分支操作"><a href="#删除分支操作" class="headerlink" title="删除分支操作"></a>删除分支操作</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">删除本地分支：<br>git branch  <span class="hljs-regexp">//</span><span class="hljs-number">1</span>.查看本地分支列表<br>git branch -d 分支名称   <span class="hljs-regexp">//</span><span class="hljs-number">2</span>.删除本地分支<br><br><br>删除远程分支：<br>git branch -a    <span class="hljs-regexp">//</span><span class="hljs-number">1</span>.查看远程分支列表<br>git push origin --<span class="hljs-keyword">delete</span> 远程分支名称   <span class="hljs-regexp">//</span><span class="hljs-number">2</span>.删除远程分支<br></code></pre></td></tr></table></figure><h3 id="Git的基本操作指令"><a href="#Git的基本操作指令" class="headerlink" title="Git的基本操作指令"></a>Git的基本操作指令</h3><p><img src="/image/8.9.png" alt="Git"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">切换分支命令:<br><br>git checkout (branchname)   <span class="hljs-regexp">//</span>切换分支<br>$ git init    <span class="hljs-regexp">//</span> 初始化仓库。<br>$ git add .    <span class="hljs-regexp">//</span>添加文件到暂存区。<br>$ git commit  <span class="hljs-regexp">//</span>将暂存区内容添加到仓库中。<br>$ git push   <span class="hljs-regexp">//</span>上传远程代码并合并<br>$ git pull   <span class="hljs-regexp">//</span>下载远程代码并合并<br><br><br></code></pre></td></tr></table></figure><h3 id="开发项目码云与Git分支的使用"><a href="#开发项目码云与Git分支的使用" class="headerlink" title="开发项目码云与Git分支的使用"></a>开发项目码云与Git分支的使用</h3><ol><li>在码云上你的项目中新建分支</li></ol><p><img src="/image/4.2.png" alt="创建分支">  </p><ol start="2"><li>本地项目文件右键Git  Bash Here</li></ol><p>命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">git  pull  <span class="hljs-regexp">//</span>将线上的分支拉到本地<br><br>git  checkout  index <span class="hljs-regexp">//i</span>ndex为你自己建的分支名字，现在你所在的分支就在index分支上，本地开发的代码都在这个分支上<br><br><span class="hljs-regexp">//</span>开发完成后<br><br>git  add .  <span class="hljs-regexp">//</span>添加文件到暂存区<br>git  commit -m <span class="hljs-string">&#x27;name&#x27;</span>  <span class="hljs-regexp">//</span>name可以你自己起<br>git  push <span class="hljs-regexp">//</span>本地分支的内容提交到线上了<br>git  checkout  master  <span class="hljs-regexp">//</span>切换为主分支<br>git  merge  index  <span class="hljs-regexp">//</span>将新增的内容合并到主分支上<br>git  push  <span class="hljs-regexp">//</span>将master分支代码提交到线上<br><br></code></pre></td></tr></table></figure><ol start="3"><li>查看所有分支</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git branch -a<br>* br-<span class="hljs-number">2.1</span>.<span class="hljs-number">2.2</span><br>  master<br>  remotes<span class="hljs-regexp">/origin/</span>HEAD -&gt; origin/master<br>  remotes<span class="hljs-regexp">/origin/</span>br-<span class="hljs-number">2.1</span>.<span class="hljs-number">2.1</span><br>  remotes<span class="hljs-regexp">/origin/</span>br-<span class="hljs-number">2.1</span>.<span class="hljs-number">2.2</span><br>  remotes<span class="hljs-regexp">/origin/</span>br-<span class="hljs-number">2.1</span>.<span class="hljs-number">3</span><br>  remotes<span class="hljs-regexp">/origin/m</span>aster<br></code></pre></td></tr></table></figure><h3 id="git-stash暂存开发分支，拉去合并线上分支"><a href="#git-stash暂存开发分支，拉去合并线上分支" class="headerlink" title="git  stash暂存开发分支，拉去合并线上分支"></a>git  stash暂存开发分支，拉去合并线上分支</h3><h4 id="git-pull-和-git-fetch-的区别"><a href="#git-pull-和-git-fetch-的区别" class="headerlink" title="git pull 和 git fetch 的区别"></a>git pull 和 git fetch 的区别</h4><ol><li><p>git fetch 只是将远程仓库的变化下载下来，并没有和本地分支合并。（fetch  只是下拉远程分支，怎么合并，可以自己再做选择）</p></li><li><p>git pull 会将远程仓库的变化下载下来，并和当前分支合并。pull=fetch+merge</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">git  stash  <br>git  status<br>git  <span class="hljs-keyword">add</span> .<br>git  <span class="hljs-keyword">fetch</span>  <span class="hljs-operator">-</span><span class="hljs-keyword">all</span> <br>git  <span class="hljs-keyword">merge</span>  origin<span class="hljs-operator">/</span>分支名<br>git  stash  pop<br></code></pre></td></tr></table></figure><h3 id="Git默认拉取的是master分支，拉取指定分支代码命令"><a href="#Git默认拉取的是master分支，拉取指定分支代码命令" class="headerlink" title="Git默认拉取的是master分支，拉取指定分支代码命令"></a>Git默认拉取的是master分支，拉取指定分支代码命令</h3><p>拉取指定分支代码解决方案：</p><p>以拉取1.0分支的代码为例， 要拉取其余分支代码类似操作</p><ol><li>使用git命令拉取<br>命令：git clone -b 1.o XXX</li></ol><p>其中1.0就是分支的名称<br><img src="/image/56.png" alt="拉取指定分支">  </p><h3 id="git-tag标签的使用"><a href="#git-tag标签的使用" class="headerlink" title="git  tag标签的使用"></a>git  tag标签的使用</h3><p>tag是git版本库的一个标记，指向某个commit的指针。</p><p>tag主要用于发布版本的管理，一个版本发布之后，我们可以为git打上 v.1.0.1 v.1.0.2 …这样的标签。</p><p>tag感觉跟branch有点相似，但是本质上和分工上是不同的：</p><p>tag 对应某次commit, 是一个点，是不可移动的。<br>branch 对应一系列commit，是很多点连成的一根线，有一个HEAD 指针，是可以依靠 HEAD 指针移动的。<br>所以，两者的区别决定了使用方式，改动代码用 branch ,不改动只查看用 tag。<br>tag 和 branch 的相互配合使用，有时候起到非常方便的效果，例如：已经发布了 v1.0 v2.0 v3.0 三个版本，这个时候，我突然想不改现有代码的前提下，在 v2.0 的基础上加个新功能，作为 v4.0 发布。就可以检出 v2.0 的代码作为一个 branch ，然后作为开发分支。</p><h4 id="tag的简单使用"><a href="#tag的简单使用" class="headerlink" title="tag的简单使用"></a>tag的简单使用</h4><p>创建 tag 是基于本地分支的 commit，而且与分支的推送是两回事，就是说分支已经推送到远程了，但是你的 tag 并没有，如果把 tag 推送到远程分支上，需要另外执行 tag 的推送命令。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">//本地新增无备注的<span class="hljs-keyword">tag</span>（默认在当前分支最后一个commit上添加<span class="hljs-keyword">tag</span>）<br>git <span class="hljs-keyword">tag</span>   <span class="hljs-title">//git</span>查询本地所有<span class="hljs-keyword">tag</span><br>git <span class="hljs-keyword">tag</span> <span class="hljs-title">标签名   //后面是标签命名</span><br><span class="hljs-title">git</span> <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span>.<span class="hljs-number">1.0</span>  <br><br>//本地新增有备注的<span class="hljs-keyword">tag</span>（默认在当前分支最后一个commit上添加<span class="hljs-keyword">tag</span>）<br>git <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> 标签名 -m “备注内容”<br>git <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> v1.<span class="hljs-number">1.1</span> -m <span class="hljs-string">&quot;测试&quot;</span>   <br><br>// //在指定commit上新增<span class="hljs-keyword">tag</span><br>git <span class="hljs-keyword">tag</span> <span class="hljs-title">标签名 commit</span>（前几位也可以，尝试过最低<span class="hljs-number">3</span>位报错，最好<span class="hljs-number">5</span>位以上）<br>git <span class="hljs-keyword">tag</span> <span class="hljs-title">v1</span>.<span class="hljs-number">1.0</span>  <span class="hljs-number">105851905</span>c8a0f9cc040cf845b35c1ced1963fcc    <br><br><br><br> // 将<span class="hljs-keyword">tag</span>推送到远程分支<br>git push origin 标签名<br>git push origin v1.<span class="hljs-number">1.0</span>   <br><br><br>//删除本地分支标签<br>git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> 标签名<br>git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> v1.<span class="hljs-number">1.0</span>  <br><br><br>//删除远程分支标签<br>git push origin :refs/tags/标签名<br>git push origin :refs/tags/v1.<span class="hljs-number">1.0</span>   <br></code></pre></td></tr></table></figure><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>git rebase相对来说是比较复杂的一个命令了,但只要掌握了使用方式,你会深深地喜欢上他,如果有时间我也许会细细地讲一下,现将git rebase的正确使用步骤总结如下:</p><h5 id="Git-操作"><a href="#Git-操作" class="headerlink" title="Git 操作"></a>Git 操作</h5><p>假设Git目前只有一个分支master。开发人员的工作流程是</p><ul><li>git clone master branch</li><li>在自己本地checkout -b local创建一个本地开发分支</li><li>在本地的开发分支上开发和测试</li><li>阶段性开发完成后（包含功能代码和单元测试），可以准备提交代码</li><li>首先切换到master分支，git pull拉取最新的分支状态</li><li>然后切回local分支</li><li>通过git rebase -i 将本地的多次提交合并为一个，以简化提交历史。本地有多个提交时,如果不进行这一步,在git rebase master时会多次解决冲突(最坏情况下,每一个提交都会相应解决一个冲突)</li><li>git rebase master 将master最新的分支同步到本地，这个过程可能需要手动解决冲突(如果进行了上一步的话,只用解决一次冲突)</li><li>然后切换到master分支，git merge将本地的local分支内容合并到master分支</li><li>git push将master分支的提交上传</li><li>本地开发分支可以灵活管理</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git checkout <span class="hljs-literal">master</span><br>git pull<br>git checkout local<br>git rebase -i HEAD~<span class="hljs-number">2</span>  //合并提交 --- <span class="hljs-number">2</span>表示合并两个<br>git rebase <span class="hljs-literal">master</span>----&gt;解决冲突---&gt;git rebase --continue<br>git checkout <span class="hljs-literal">master</span><br>git merge local<br>git push<br><br></code></pre></td></tr></table></figure><h3 id="git-diff命令的使用"><a href="#git-diff命令的使用" class="headerlink" title="git diff命令的使用"></a>git diff命令的使用</h3><p>git diff是一个git提供的一个非常有用的命令，使用git diff可清晰的显示出文件被修改的内容。</p><h4 id="工作区、版本库"><a href="#工作区、版本库" class="headerlink" title="工作区、版本库"></a>工作区、版本库</h4><p>要理解git diff命令，就必须先理解工作区、暂存区与版本库的概念。</p><p>工作区就是所在目录，比如我的TestGit文件夹：<br><img src="/imageO/34.png" alt="TestGit"></p><p>在上图的.git文件中，存放的就是版本库，版本库中存储了很多东西，最重要的就是stage（或者叫index）暂存区、git自动创建的一个分支master，以及指向master的一个指针HEAD。</p><p>添加修改到版本库的过程如图所示：<br><img src="/imageO/35.png" alt="添加修改版本库"></p><ol><li><p>工作区 –&gt; 暂存区<br>使用git add命令将工作区文件添加到缓存区。</p></li><li><p>暂存区 –&gt; 仓库<br>使用git commit命令将暂存区中的文件提交到仓库。</p></li><li><p>git diff命令<br>根据所要对比区域不同，git diff有如下几种用法。</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">命令             作用<br>git diff       <span class="hljs-regexp">//</span>查看工作区与暂存区的差异<br>git diff --cached     <span class="hljs-regexp">//</span>查看暂存区与仓库的差异<br>git diff HEAD <span class="hljs-regexp">//</span>查看工作区与仓库的差异<br></code></pre></td></tr></table></figure><blockquote><p>参考链接<br><a href="https://www.runoob.com/git/git-basic-operations.html">菜鸟教程</a><br><a href="https://www.cnblogs.com/jmhwsrr/p/14085463.html">git diff命令的使用</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git(SSH本地免密)+Github迁移到Gitee</title>
    <link href="/2021/03/31/Git(SSH%E6%9C%AC%E5%9C%B0%E5%85%8D%E5%AF%86)+Github%E8%BF%81%E7%A7%BB%E5%88%B0Gitee/"/>
    <url>/2021/03/31/Git(SSH%E6%9C%AC%E5%9C%B0%E5%85%8D%E5%AF%86)+Github%E8%BF%81%E7%A7%BB%E5%88%B0Gitee/</url>
    
    <content type="html"><![CDATA[<p>Git上传到Github每次都要密码验证，很麻烦，想一下可以使用SSH免密操作，同时上传到Github和Gitee,也可以将项目迁移至Gitee.</p><hr><h2 id="Github配置-SSH-key"><a href="#Github配置-SSH-key" class="headerlink" title="Github配置 SSH key"></a>Github配置 SSH key</h2><p>window10系统桌面右键<code>Git Bash Here</code></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>注：<strong>后面的 <code>your_email@youremail.com</code> 改为你在 Github 上注册的邮箱</strong>，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。<br>成功的话会在C:\Users\ASUS下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。<br>之后进入Github中自己的设置中，左边选择 SSH and GPG keys，然后点击 New SSH key 按钮,title 设置标题，可以随便填，粘贴在你电脑上生成的 key。<br>验证：为了验证是否成功，输入以下命令：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">$ ssh -T git@github.com<br>The authenticity <span class="hljs-keyword">of</span> host <span class="hljs-symbol">&#x27;github</span>.com (<span class="hljs-number">52.74</span>.<span class="hljs-number">223.119</span>)&#x27; can<span class="hljs-symbol">&#x27;t</span> be established.<br>RSA key fingerprint <span class="hljs-keyword">is</span> SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.<br>Are you sure you want <span class="hljs-keyword">to</span> continue connecting (yes/no/[fingerprint])? yes                   # 输入 yes<br><span class="hljs-literal">Warning</span>: Permanently added <span class="hljs-symbol">&#x27;github</span>.com,<span class="hljs-number">52.74</span>.<span class="hljs-number">223.119</span>&#x27; (RSA) <span class="hljs-keyword">to</span> the list <span class="hljs-keyword">of</span> known hosts.<br>Hi tianqixin! You<span class="hljs-symbol">&#x27;ve</span> successfully authenticated, but GitHub does <span class="hljs-keyword">not</span> provide shell <span class="hljs-keyword">access</span>. # 成功信息<br></code></pre></td></tr></table></figure><h2 id="Gitee-配置-SSH-key"><a href="#Gitee-配置-SSH-key" class="headerlink" title="Gitee 配置 SSH key"></a>Gitee 配置 SSH key</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">登陆Gitee的账号：<br>点击用户头像-&gt;进入个人设置<br>选择安全设置-&gt;SSH公钥<br>选择新增公钥<br>填写标题：公钥标题key<br>填写公钥：把我们刚刚复制的公钥粘贴到这里(刚刚Github生成的密钥)<br>添加后输入输入账号密码进行确认<br></code></pre></td></tr></table></figure><p>验证：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">使用Git Bash输入：<br>ssh -T git@github.com<br>第一次连接时会问你是否继续连接，输入 <span class="hljs-literal">yes</span> 即可；<br>接下来验证Gitee的ssh连接：<br>ssh -T git@gitee.com<br>同样输入 <span class="hljs-literal">yes</span> 即可。<br></code></pre></td></tr></table></figure><p>参考链接：</p><blockquote><p><a href="https://www.runoob.com/git/git-remote-repo.html">https://www.runoob.com/git/git-remote-repo.html</a><br><a href="https://blog.csdn.net/pilihaotian/article/details/103337959">https://blog.csdn.net/pilihaotian/article/details/103337959</a></p></blockquote><h2 id="Github迁移到Gitee"><a href="#Github迁移到Gitee" class="headerlink" title="Github迁移到Gitee"></a>Github迁移到Gitee</h2><h3 id="1-直接从Github中导入到Gitee"><a href="#1-直接从Github中导入到Gitee" class="headerlink" title="1.直接从Github中导入到Gitee"></a>1.直接从Github中导入到Gitee</h3><p><img src="/image/3.png" alt="Gitee迁移"></p><h3 id="2-Gitee上新建一个项目将本地项目上传。"><a href="#2-Gitee上新建一个项目将本地项目上传。" class="headerlink" title="2.Gitee上新建一个项目将本地项目上传。"></a>2.Gitee上新建一个项目将本地项目上传。</h3><p>修改配置文件：<br>在站点根目录下找到_config.yml文件，将里边的deploy节点修改成下边的形式，其中repository等于username ，即</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">deploy:<br>  type: git<br>  repo: <br>    github: git@github<span class="hljs-selector-class">.com</span>:<span class="hljs-selector-attr">[username]</span>/<span class="hljs-selector-attr">[username]</span><span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.git</span>,master<br>    gitee: git@gitee<span class="hljs-selector-class">.com</span>:<span class="hljs-selector-attr">[username]</span>/<span class="hljs-selector-attr">[username]</span><span class="hljs-selector-class">.git</span>,master<br></code></pre></td></tr></table></figure><p>配置了这后免密了能同时上传到Github和Gitee</p><h3 id="1-注：配置文件的缩进很重要"><a href="#1-注：配置文件的缩进很重要" class="headerlink" title="1.注：配置文件的缩进很重要"></a>1.注：配置文件的缩进很重要</h3><p><img src="/image/3.1.png" alt="配置文件">  </p><h3 id="2-名字一样很重要！！！不然页面渲染加载不出来。"><a href="#2-名字一样很重要！！！不然页面渲染加载不出来。" class="headerlink" title="2.名字一样很重要！！！不然页面渲染加载不出来。"></a>2.名字一样很重要！！！不然页面渲染加载不出来。</h3><p>对于 Gitee，你可以选择建立一个私人仓库来部署自己的Hexo博客，不过和 Github 不同的地方在于：<br>Github 的仓库名要命名为： {username}.github.io<br>而 Coding.net 的仓库名要命名为：{username}<br>这里的 username 指的是你在这两个网站上的用户名，只有以这种命名形式的仓库，才能够不通过子域名的形式来访问我们的博客。<br>比如说，我的 Github 和Gitee 的账号都是jack，那么在部署博客成功后，我就可以通过下边的url来访问我的Hexo博客：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>jack.github.io/<br>https:<span class="hljs-regexp">//</span>jack.gitee.io<br></code></pre></td></tr></table></figure><ol><li>一开始我的个人空间地址与username不一样，导致网页加载不出来  </li></ol><p><img src="/image/3.2.png" alt="网站加载页面"><br>2. 最终将Gitee个人中心修改和username一致才成功加载页面 </p><p><img src="/image/3.3.png" alt="修改地址"></p><ol start="3"><li>Git上传更新到Gitee和Github上发现Github博客更新了，但是Gitee页面没有更新。<br>解决方法：<br>打开博客的仓库 -&gt; 服务 -&gt; 点击 Gitee Pages-&gt; 点击【更新】即可    </li></ol><p><img src="/image/3.5.png" alt="修改地址"></p><h3 id="总结：配置文件格式很重要，缩进及编码要注意，否者项目启动不了。博客命名和Github-Gitee的命名一致很重要，不然也会报错。"><a href="#总结：配置文件格式很重要，缩进及编码要注意，否者项目启动不了。博客命名和Github-Gitee的命名一致很重要，不然也会报错。" class="headerlink" title="总结：配置文件格式很重要，缩进及编码要注意，否者项目启动不了。博客命名和Github,Gitee的命名一致很重要，不然也会报错。"></a>总结：配置文件格式很重要，缩进及编码要注意，否者项目启动不了。博客命名和Github,Gitee的命名一致很重要，不然也会报错。</h3>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Html&amp;表格&amp;表单(重点)</title>
    <link href="/2021/03/30/%E9%87%8D%E5%AD%A6Html(%E4%BA%8C)/"/>
    <url>/2021/03/30/%E9%87%8D%E5%AD%A6Html(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ol><li>表格table    行  tr  rows( rowspan  跨行) </li><li>列  td(colspan  跨列)  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1px&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- colspan  跨列 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span>1-4<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- rowspan  跨行 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>2-1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2-4<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="媒体元素"><a href="#媒体元素" class="headerlink" title="媒体元素"></a>媒体元素</h2>音频和视频(src :资源路径,constrols: 控制条,autuplay: 自动播放)<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../html/audio/FN=告白气球_周杰伦_128K.mp3&quot;</span>  <span class="hljs-attr">controls</span>  <span class="hljs-attr">autoplay</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span>    <br><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../html/audio/BLACKPINK - &#x27;Lovesick Girls&#x27; M_V MAKING FILM.mp4&quot;</span>  <span class="hljs-attr">controls</span>  <span class="hljs-attr">autoplay</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>页面头部<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>网页主体<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>网页脚部<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="内联框架"><a href="#内联框架" class="headerlink" title="内联框架"></a>内联框架</h2>iframe:内联框架，src :地址,w- h :宽度高度   <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;iframe <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;http:www.baidu.com&quot;</span>  <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attribute">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span>  <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;800px&quot;</span>  <span class="hljs-attribute">height</span>=<span class="hljs-string">&quot;800px&quot;</span>&gt;&lt;/iframe&gt;<br></code></pre></td></tr></table></figure><h2 id="学习表单-重点"><a href="#学习表单-重点" class="headerlink" title="学习表单(重点)"></a>学习表单(重点)</h2></li></ol><ol><li><p>表单form(post和get提交)<br> action:表单提交的位置，可以是网站，也可以是一个请求处理地址<br> method: post,get提交方式<br> get方式提交：我们可以在url中看到我们的提交信息，不安全，高效<br> post: 比较安全，传输大文件.<br> <img src="/image/2.2.PNG" alt="表单语法"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;1.我的第一个网页.html&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;GET&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>名字：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> , <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>   <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入用户名&quot;</span> <span class="hljs-attr">required</span>  <span class="hljs-attr">maxlength</span>=<span class="hljs-string">&quot;8&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 密码值：input  type=&quot;password&quot; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pwd&quot;</span> <span class="hljs-attr">hidden</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span> <br></code></pre></td></tr></table></figure></li><li><p>文本框和单选框<br>文本输入框:</p><pre><code>     input  type = &quot;text&quot;         value =&quot;我好帅&quot;  默认初始值        maxlength=&quot;8 &quot;   最长能写几个字符            size = &quot;30&quot;      文本框的长度    </code></pre><blockquote><p>单选标签: input  type= “radio”</p></blockquote></li><li><p>按钮和多选框<br>按钮: </p><pre><code>     input type=&quot;button&quot;  普通按钮      input type=&quot;image&quot;   图像按钮         input type=&quot;submit&quot;  提示按钮        input type=&quot;reset&quot;   重置按钮    </code></pre><blockquote><p>多选框:   input type=”checkbox”</p></blockquote></li><li><p> 列表框文本域和文件域</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--文本域 cols=&quot;30&quot; rows=&quot;10&quot;--&gt;</span> <br>         <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>反馈<br>            <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;textarea&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span>文本内容<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 文件域 input type=&quot;file&quot; name=&quot;files&quot;--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;files&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;上传&quot;</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;upload&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>              <br></code></pre></td></tr></table></figure></li><li><p>搜索框和滑块验证</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!--滑块input type=&quot;range&quot; --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>滑块；<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;range&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;voice&quot;</span> <span class="hljs-attr">min</span>=<span class="hljs-string">&quot;0&quot;</span>  <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;100&quot;</span>  <span class="hljs-attr">step</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 搜索框 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>搜索：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;search&quot;</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;search&quot;</span>  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mark&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <br></code></pre></td></tr></table></figure></li><li><p>表单的应用和元素<br>readonly只读<br>disabled 禁用<br>hidden   隐藏<br><img src="/image/2.1.PNG" alt="表单元素"></p></li><li><p>表单的初级验证<br>优点：数据安全，减轻压力</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">常用方式<br>placeeholder 提示信息(文本框中有提示信息)<br><span class="hljs-built_in">require</span> 非空判断<br>pattern  正则表达式<br></code></pre></td></tr></table></figure></li><li><p>其他</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 增强鼠标可用性   了解--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;mark&quot;</span>&gt;</span>你点我试试<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>  &gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>//正则验证<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>自定义邮箱：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;diymail&quot;</span>  <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1x4411V75C">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4></li></ol>]]></content>
    
    
    <categories>
      
      <category>Html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Html</tag>
      
      <tag>前端基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Html&amp;基本标签&amp;列表</title>
    <link href="/2021/03/30/%E9%87%8D%E5%AD%A6Html(%E4%B8%80)/"/>
    <url>/2021/03/30/%E9%87%8D%E5%AD%A6Html(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<p>之前对Html有过学习和了解，但没有系统学习，基础还是很重要的所以现在重新学习，一起共勉。</p><hr><h2 id="Html基础"><a href="#Html基础" class="headerlink" title="Html基础"></a>Html基础</h2><h3 id="1-基本信息"><a href="#1-基本信息" class="headerlink" title="1.基本信息"></a>1.基本信息</h3><ol><li>DOCTYPE 告诉浏览器，我们要使用什么规范</li><li>head标签代表网页头部</li><li>meta描述性标签，它用来描述我们网站的一些信息</li><li>meta一般用来做SEO</li><li>title标签代表网页的主体<h3 id="2-基本标签"><a href="#2-基本标签" class="headerlink" title="2.基本标签"></a>2.基本标签</h3></li><li>h1-h6 一级-六级标签</li><li>p 段落标签</li><li>hr 水平标签</li><li>br 换行标签</li><li>strong 粗体标签</li><li>em 斜体</li><li>&amp;nbsp(空格)  @copy(版权所)有 &amp;gt(大于号) &amp;lt(小于号)—-特殊标签<h3 id="3-图像标签"><a href="#3-图像标签" class="headerlink" title="3.图像标签"></a>3.图像标签</h3></li><li> <code>&lt;img  src=&quot;../html/img/1.png&quot;  alt=&quot;女孩&quot;  title=&quot;悬停文字&quot; width=&quot;500px&quot; height=&quot;500px&quot;  &gt;  </code> (src:图片地址(必填)相对地址（推荐使用）;绝对地址../  –上一级目录 alt:  图片名字（必填）)<h3 id="4-链接标签"><a href="#4-链接标签" class="headerlink" title="4.链接标签"></a>4.链接标签</h3></li><li><code>&lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_self&quot;&gt;点击我跳转到百度&lt;/a&gt;</code>a 标签,href : 必填，表示要跳转到那个页面,_blank  在新标签中打开,_self  在自己的的网页打开.</li><li>锚链接1.需要一个锚标记2.跳转到标记<br><code> &lt;a  href=&quot;#top&quot;&gt;回到顶部&lt;/a&gt;  &lt;a  name=&quot;down&quot;&gt;down&lt;/a&gt;</code>   </li><li>功能性链接 邮箱链接：mailto<br><code>&lt;a  href=&quot;mailto:232324265@qq.com&quot;&gt;点击联系我&lt;/a&gt;</code> <h3 id="5-列表学习"><a href="#5-列表学习" class="headerlink" title="5.列表学习"></a>5.列表学习</h3></li><li>有序列表<br>应用范围:  试卷，问答…. <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>python<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>运维<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>前端<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>c<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>无序列表<br>应用范围：导航，侧边栏….     <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>python<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>运维<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>前端<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>c<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>自定义列表<br>dl:列表 dt: 列表名称 dd: 列表内容<br>运用在 公司网页底部  <pre><code>&lt;dl&gt;&lt;dt&gt;学科&lt;/dt&gt;&lt;dd&gt;java&lt;/dd&gt;&lt;dd&gt;python&lt;/dd&gt;&lt;dd&gt;位置&lt;/dd&gt;   &lt;dd&gt;西安&lt;/dd&gt;&lt;/dl&gt;</code></pre></li></ol><h4 id="基于B站视频学习-特别感谢up主-遇见狂神说"><a href="#基于B站视频学习-特别感谢up主-遇见狂神说" class="headerlink" title="基于B站视频学习 特别感谢up主 遇见狂神说"></a>基于<a href="https://www.bilibili.com/video/BV1x4411V75C">B站视频</a>学习 特别感谢up主 <a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.1">遇见狂神说</a></h4>]]></content>
    
    
    <categories>
      
      <category>Html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Html</tag>
      
      <tag>前端基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo+fluid搭建博客个人总结</title>
    <link href="/2021/03/30/hexo+fluid%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <url>/2021/03/30/hexo+fluid%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>大一大二学习了前端和后端的知识，在B站和各种网站上一通乱学，都没学精，现在发现学习了什么都记不得了。最近看了一位老师的视频学习到了你学进去的知识更重要的是输出，因为你输出了才真正是你学到的。今天开始用博客记录我学习的知识，一起共勉。</p><hr><h2 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1.安装node.js"></a>1.安装node.js</h2><p><a href="https://nodejs.org/en/">官方网站</a>安装即可,安装步骤非常简单，一直next，下一步就可以了，默认安装就行。</p><h2 id="验证安装-命令"><a href="#验证安装-命令" class="headerlink" title="验证安装  命令:"></a>验证安装  命令:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">node -v <span class="hljs-comment">#查看node版本  </span><br>npm -v <span class="hljs-comment">#查看npm版本</span><br></code></pre></td></tr></table></figure><h2 id="安装淘宝cnpm"><a href="#安装淘宝cnpm" class="headerlink" title="安装淘宝cnpm"></a>安装淘宝cnpm</h2><p>为了速度更快些，使用淘宝cnpm管理器  </p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tcl">命令：npm install -g cnpm --<span class="hljs-keyword">registry</span>=<span class="hljs-keyword">http</span>://<span class="hljs-keyword">registry</span>.npm.taobao.org  <br>安装完成查看cnpm是否成功，查看版本信息 cnpm -v<br></code></pre></td></tr></table></figure><h2 id="2-安装hexo框架"><a href="#2-安装hexo框架" class="headerlink" title="2.安装hexo框架"></a>2.安装hexo框架</h2><p>命令：<code>cnpm install -g hexo-cli</code></p><p>安装完成查看版本: <code>hexo -v</code></p><h2 id="使用Hexo创建博客"><a href="#使用Hexo创建博客" class="headerlink" title="使用Hexo创建博客"></a>使用Hexo创建博客</h2><h3 id="Linux系统命令"><a href="#Linux系统命令" class="headerlink" title="Linux系统命令"></a>Linux系统命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir blog <span class="hljs-comment">#创建blog目录  </span><br><span class="hljs-built_in">cd</span> blog  <span class="hljs-comment">#进入blog目录  </span><br>sudo hexo init  <span class="hljs-comment">#生成博客 初始化博客  </span><br>hexo s <span class="hljs-comment">#启动本地博客服务  </span><br>http://localhost:4000/ <span class="hljs-comment">#本地访问地址  </span><br>hexo n <span class="hljs-string">&quot;我的第一篇文章&quot;</span> <span class="hljs-comment">#创建新的文章</span><br></code></pre></td></tr></table></figure><h3 id="Window系统"><a href="#Window系统" class="headerlink" title="Window系统"></a>Window系统</h3><p>博客目录下/source/_posts下直接新建.md文件</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><blockquote><p>官方文档地址  <a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p></blockquote><h2 id="3-主题Fluid的更换"><a href="#3-主题Fluid的更换" class="headerlink" title="3.主题Fluid的更换"></a>3.主题Fluid的更换</h2><h3 id="获取主题最新版本"><a href="#获取主题最新版本" class="headerlink" title="获取主题最新版本"></a>获取主题最新版本</h3><h3 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h3><p>Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-theme-fluid  </span><br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 _config.fluid.yml，将主题的 _config.yml 内容复制进去。</p><h3 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h3><p>下载最新release版本解压到 themes 目录，并将解压出的文件夹重命名为 fluid。<br>指定主题<br>如下修改 Hexo 博客目录中的 _config.yml：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">theme:</span> fluid  <span class="hljs-meta"># 指定主题   </span><br><span class="hljs-symbol">language:</span> <span class="hljs-built_in">zh</span>-CN  <span class="hljs-meta"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><h3 id="创建「关于页」"><a href="#创建「关于页」" class="headerlink" title="创建「关于页」"></a>创建「关于页」</h3><p>首次使用主题的「关于页」需要手动创建：(注：此处必须创建，否则about页面无)</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> about   <br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 /source/about/index.md，添加 layout 属性。<br>修改后的文件示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">about</span>   <br><span class="hljs-attr">date:</span> <span class="hljs-number">2021-03-23 19:20:33</span>   <br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span>   <br><span class="hljs-string">这里写关于页的正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><h3 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h3><p>修改hexo根目录下的 _config.yml 文件 ： theme: fluid<br>百度了很多更改Fluid背景图片和文字的方法没有找到，官方文档一开始看的有点看不懂，没有静下心看，导致耽误了很久。   </p><h3 id="官方文档-https-hexo-fluid-dev-com-docs-start"><a href="#官方文档-https-hexo-fluid-dev-com-docs-start" class="headerlink" title="官方文档  https://hexo.fluid-dev.com/docs/start/"></a>官方文档  <code>https://hexo.fluid-dev.com/docs/start/</code></h3><p>更改地址在theme/fluid/_config.yml 或者 _config.fluid.yml中修改全局配置。</p><h2 id="4-使用Git上传至Github"><a href="#4-使用Git上传至Github" class="headerlink" title="4. 使用Git上传至Github"></a>4. 使用Git上传至Github</h2><p><a href="https://git-scm.com/">Git官网</a>  下载直接安装，一直点下一步<br>使用教程 参考链接<code>https://www.runoob.com/git/git-tutorial.html</code>(推荐使用免密SSH公钥)</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">hexo</span> c<span class="hljs-comment">#清理一下</span><br>hexo g<span class="hljs-comment">#生成</span><br>hexo d<span class="hljs-comment">#部署到远程Github仓库</span><br></code></pre></td></tr></table></figure><h2 id="5-部署到Github上"><a href="#5-部署到Github上" class="headerlink" title="5.部署到Github上"></a>5.部署到Github上</h2><p>Github创建一个新的仓库 <code>YourGithubName.github.io</code><br>#在blog目录下安装git部署插件<code>cnpm install --save hexo-deployer-git</code><br>#配置_config.yml   </p><pre><code># Deployment   ## Docs: https://hexo.io/docs/deployment.html    deploy:         type: git         repo: https://github.com/YourGithubName/   YourGithubName.github.io.git      branch: master   </code></pre><p>#部署到Github仓库里<code>hexo d</code><br>#访问这个地址可以查看博客<code>https://YourGithubName.github.io/</code></p><h3 id="注-YourGithubName必须与你的Github名字一模一样，否者页面打不开。"><a href="#注-YourGithubName必须与你的Github名字一模一样，否者页面打不开。" class="headerlink" title="注:YourGithubName必须与你的Github名字一模一样，否者页面打不开。"></a>注:YourGithubName必须与你的Github名字一模一样，否者页面打不开。</h3><h2 id="总结：看官方文档是学习最快最好的方式，一开始看不懂没关系，一个字慢慢看，一定会有收获的。切勿囫囵吞枣。"><a href="#总结：看官方文档是学习最快最好的方式，一开始看不懂没关系，一个字慢慢看，一定会有收获的。切勿囫囵吞枣。" class="headerlink" title="总结：看官方文档是学习最快最好的方式，一开始看不懂没关系，一个字慢慢看，一定会有收获的。切勿囫囵吞枣。"></a>总结：看官方文档是学习最快最好的方式，一开始看不懂没关系，一个字慢慢看，一定会有收获的。切勿囫囵吞枣。</h2><h4 id="基于B站视频搭建-特别感谢up主-CodeSheep"><a href="#基于B站视频搭建-特别感谢up主-CodeSheep" class="headerlink" title="基于B站视频搭建 特别感谢up主 CodeSheep"></a>基于<a href="https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.788.recommend_more_video.-1">B站视频</a>搭建 特别感谢up主 <a href="https://space.bilibili.com/384068749?spm_id_from=333.788.b_765f7570696e666f.1">CodeSheep</a></h4>]]></content>
    
    
    <categories>
      
      <category>Myblog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Myblog</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

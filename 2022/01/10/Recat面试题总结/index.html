

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/2.jpg">
  <link rel="icon" href="/img/2.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="DragonPeng">
  <meta name="keywords" content="">
  
  <title>React面试题总结 - DragonPeng的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.9","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>DragonPeng' blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/page1.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="React面试题总结">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-01-10 20:15" pubdate>
        January 10, 2022 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      30.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      366
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">React面试题总结</h1>
            
            <div class="markdown-body">
              <p>总结了最近的一些面试题和之前的知识点(4.26)</p>
<hr>
<h2 id="较重要（加强）"><a href="#较重要（加强）" class="headerlink" title="较重要（加强）"></a>较重要（加强）</h2><h3 id="一、组件基础"><a href="#一、组件基础" class="headerlink" title="一、组件基础"></a>一、组件基础</h3><h4 id="1-React-事件机制"><a href="#1-React-事件机制" class="headerlink" title="1. React 事件机制"></a>1. React 事件机制</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">&lt;<span class="hljs-keyword">div</span> onClick=&#123;<span class="hljs-keyword">this</span>.handleClick.bind(<span class="hljs-keyword">this</span>)&#125;&gt;点我&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>
<p>React并不是将click事件绑定到了div的真实DOM上，而是在document处监听了所有的事件，当事件发生并且冒泡到document处的时候，<strong>React将事件内容封装并交由真正的处理函数运行。这样的方式不仅仅减少了内存的消耗，还能在组件挂在销毁时统一订阅和移除事件。</strong></p>
<p>除此之外，冒泡到document上的事件也不是原生的浏览器事件，而是由react自己实现的合成事件（SyntheticEvent）。因此如果不想要是事件冒泡的话应该调用event.preventDefault()方法，而不是调用event.stopProppagation()方法。<br><img src="/imageO/react10.png" srcset="/img/loading.gif" lazyload alt="冒泡捕获"></p>
<p>JSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 document 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。</p>
<p>另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 <strong>event.preventDefault</strong>。</p>
<p>实现合成事件的目的如下：<br>●合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力；<br>●对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。</p>
<h4 id="2-React的事件和普通的HTML事件有什么不同？"><a href="#2-React的事件和普通的HTML事件有什么不同？" class="headerlink" title="2. React的事件和普通的HTML事件有什么不同？"></a>2. React的事件和普通的HTML事件有什么不同？</h4><p>区别：<br>●对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；<br>●对于事件函数处理语法，原生事件为字符串，react 事件为函数；<br>●react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。</p>
<p>合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：<br>●兼容所有浏览器，更好的跨平台；<br>●将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。<br>●方便 react 统一管理和事务机制。</p>
<p>事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。</p>
<h4 id="3-React-组件中怎么做事件代理？它的原理是什么？"><a href="#3-React-组件中怎么做事件代理？它的原理是什么？" class="headerlink" title="3. React 组件中怎么做事件代理？它的原理是什么？"></a>3. React 组件中怎么做事件代理？它的原理是什么？</h4><p>React基于Virtual DOM实现了一个SyntheticEvent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。</p>
<p>在React底层，主要对合成事件做了两件事：<br>●事件委派：React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。<br>●自动绑定：React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。</p>
<h4 id="4-React-高阶组件、Render-props、hooks-有什么区别，为什么要不断迭代"><a href="#4-React-高阶组件、Render-props、hooks-有什么区别，为什么要不断迭代" class="headerlink" title="4. React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代"></a>4. React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代</h4><p>这三者是目前react解决代码复用的主要方式：<br>●高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。<br>●render props是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术，更具体的说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。<br>●通常，render props 和高阶组件只渲染一个子节点。让 Hook 来服务这个使用场景更加简单。这两种模式仍有用武之地，（例如，一个虚拟滚动条组件或许会有一个 renderltem 属性，或是一个可见的容器组件或许会有它自己的 DOM 结构）。但在大部分场景下，Hook 足够了，并且能够帮助减少嵌套。</p>
<h5 id="（1）HOC"><a href="#（1）HOC" class="headerlink" title="（1）HOC"></a>（1）HOC</h5><p>官方解释∶ </p>
<blockquote>
<p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。<br>简言之，HOC是一种组件的设计模式，HOC接受一个组件和额外的参数（如果需要），返回一个新的组件。HOC 是纯函数，没有副作用。</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// hoc的定义</span><br>function withSubscription(<span class="hljs-type">WrappedComponent</span>, selectData) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    constructor(props) &#123;<br>      <span class="hljs-keyword">super</span>(props);<br>      <span class="hljs-keyword">this</span>.state = &#123;<br>        data: selectData(<span class="hljs-type">DataSource</span>, props)<br>      &#125;;<br>    &#125;<br>    <span class="hljs-comment">// 一些通用的逻辑处理</span><br>    render() &#123;<br>      <span class="hljs-comment">// ... 并使用新数据渲染被包装的组件!</span><br>      <span class="hljs-keyword">return</span> &lt;<span class="hljs-type">WrappedComponent</span> data=&#123;<span class="hljs-keyword">this</span>.state.data&#125; &#123;...<span class="hljs-keyword">this</span>.props&#125; /&gt;;<br>    &#125;<br>  &#125;;<br><br><span class="hljs-comment">// 使用</span><br>const <span class="hljs-type">BlogPostWithSubscription</span> = withSubscription(<span class="hljs-type">BlogPost</span>,<br>  (<span class="hljs-type">DataSource</span>, props) =&gt; <span class="hljs-type">DataSource</span>.getBlogPost(props.id));<br></code></pre></td></tr></table></figure>
<h5 id="（2）Render-props"><a href="#（2）Render-props" class="headerlink" title="（2）Render props"></a>（2）Render props</h5><p>官方解释∶</p>
<blockquote>
<p>“render prop”是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术<br>具有render prop 的组件接受一个返回React元素的函数，将render的渲染逻辑注入到组件内部。在这里，”render”的命名可以是任何其他有效的标识符。</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// DataProvider组件内部的渲染逻辑如下</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Components</span> </span>&#123;<br>     state = &#123;<br>    name: <span class="hljs-symbol">&#x27;To</span>m&#x27;<br>  &#125;<br><br>    render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;div&gt;<br>          &lt;p&gt;共享数据组件自己内部的渲染逻辑&lt;/p&gt;<br>          &#123; <span class="hljs-keyword">this</span>.props.render(<span class="hljs-keyword">this</span>.state) &#125;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用方式</span><br>&lt;<span class="hljs-type">DataProvider</span> render=&#123;data =&gt; (<br>  &lt;h1&gt;<span class="hljs-type">Hello</span> &#123;data.name&#125;&lt;/h1&gt;<br>)&#125;/&gt;<br></code></pre></td></tr></table></figure>
<p>由此可以看到，render props的优缺点也很明显∶<br>●优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。<br>●缺点：无法在 return 语句外访问数据、嵌套写法不够优雅</p>
<h5 id="（3）Hooks"><a href="#（3）Hooks" class="headerlink" title="（3）Hooks"></a>（3）Hooks</h5><p>官方解释∶</p>
<blockquote>
<p>Hook是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。通过自定义hook，可以复用代码逻辑。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 自定义一个获取订阅数据的hook</span><br>function useSubscription() &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">data</span> = DataSource.getComments();<br>  <span class="hljs-keyword">return</span> [<span class="hljs-keyword">data</span>];<br>&#125;<br><span class="hljs-comment">// </span><br>function CommentList(props) &#123;<br>  <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">data</span>&#125; = props;<br>  <span class="hljs-keyword">const</span> [subData] = useSubscription();<br>    ...<br>&#125;<br><span class="hljs-comment">// 使用</span><br>&lt;CommentList <span class="hljs-keyword">data</span>=<span class="hljs-string">&#x27;hello&#x27;</span> /&gt;<br></code></pre></td></tr></table></figure>
<p>以上可以看出，hook解决了hoc的prop覆盖的问题，同时使用的方式解决了render props的嵌套地狱的问题。hook的优点如下∶<br>●使用直观；<br>●解决hoc的prop 重名问题；<br>●解决render props 因共享数据 而出现嵌套地狱的问题；<br>●能在return之外使用数据的问题。</p>
<p>需要注意的是：hook只能在组件顶层使用，不可在分支语句中使用。</p>
<h5 id="总结∶"><a href="#总结∶" class="headerlink" title="总结∶"></a>总结∶</h5><p>Hoc、render props和hook都是为了解决代码复用的问题，但是hoc和render props都有特定的使用场景和明显的缺点。hook是react16.8更新的新的API，让组件逻辑复用更简洁明了，同时也解决了hoc和render props的一些缺点。</p>
<h4 id="6-React-Component-和-React-PureComponent-的区别"><a href="#6-React-Component-和-React-PureComponent-的区别" class="headerlink" title="6. React.Component 和 React.PureComponent 的区别"></a>6. React.Component 和 React.PureComponent 的区别</h4><p>PureComponent表示一个纯组件，可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。</p>
<p>在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。</p>
<p>不过，pureComponent中的 shouldComponentUpdate() 进行的是浅比较，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。</p>
<p>使用pureComponent的好处：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。</p>
<h4 id="7-Component-Element-Instance-之间有什么区别和联系？"><a href="#7-Component-Element-Instance-之间有什么区别和联系？" class="headerlink" title="7. Component, Element, Instance 之间有什么区别和联系？"></a>7. Component, Element, Instance 之间有什么区别和联系？</h4><p>●元素：一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。<br>●组件：一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。<br>●实例：一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。</p>
<p>函数式组件(Functional component)根本没有实例instance。类组件(Class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。</p>
<h4 id="8-React-createClass和extends-Component的区别有哪些？"><a href="#8-React-createClass和extends-Component的区别有哪些？" class="headerlink" title="8. React.createClass和extends Component的区别有哪些？"></a>8. React.createClass和extends Component的区别有哪些？</h4><p>React.createClass和extends Component的bai区别主要在于：<br>（1）语法区别<br>●createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。<br>●createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。</p>
<p>（2）propType 和 getDefaultProps<br>●React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.<br>●React.Component：通过设置两个属性propTypes和defaultProps</p>
<p>（3）状态的区别<br>●React.createClass：通过getInitialState()方法返回一个包含初始值的对象<br>●React.Component：通过constructor设置初始状态</p>
<p>（4）this区别<br>●React.createClass：会正确绑定this<br>●React.Component：由于使用了 ES6，这里会有些微不同，属性并不会自动绑定到 React 类的实例上。</p>
<p>（5）Mixins<br>●React.createClass：使用 React.createClass 的话，可以在创建组件时添加一个叫做 mixins 的属性，并将可供混合的类的集合以数组的形式赋给 mixins。<br>●如果使用 ES6 的方式来创建组件，那么 React mixins 的特性将不能被使用了。</p>
<h4 id="11-哪些方法会触发-React-重新渲染？重新渲染-render-会做些什么？"><a href="#11-哪些方法会触发-React-重新渲染？重新渲染-render-会做些什么？" class="headerlink" title="11. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？"></a>11. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</h4><p><strong>（1）哪些方法会触发 react 重新渲染?</strong><br><strong>●setState（）方法被调用</strong><br>setState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候不一定会重新渲染。<strong>当 setState 传入 null 时，并不会触发 render。</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  state = &#123;<br>    a: <span class="hljs-number">1</span><br>  &#125;;<br><br>  render() &#123;<br>    console.log(<span class="hljs-string">&quot;render&quot;</span>);<br>    <span class="hljs-keyword">return</span> (<br>      &lt;<span class="hljs-type">React</span>.<span class="hljs-type">Fragement</span>&gt;<br>        &lt;p&gt;&#123;<span class="hljs-keyword">this</span>.state.a&#125;&lt;/p&gt;<br>        &lt;button<br>          onClick=&#123;() =&gt; &#123;<br>            <span class="hljs-keyword">this</span>.setState(&#123; a: <span class="hljs-number">1</span> &#125;); <span class="hljs-comment">// 这里并没有改变 a 的值</span><br>          &#125;&#125;<br>        &gt;<br>          <span class="hljs-type">Click</span> me<br>        &lt;/button&gt;<br>        &lt;button onClick=&#123;() =&gt; <span class="hljs-keyword">this</span>.setState(<span class="hljs-literal">null</span>)&#125;&gt;setState <span class="hljs-literal">null</span>&lt;/button&gt;<br>        &lt;<span class="hljs-type">Child</span> /&gt;<br>      &lt;/<span class="hljs-type">React</span>.<span class="hljs-type">Fragement</span>&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>●父组件重新渲染</strong><br>只要父组件重新渲染了，即使传入子组件的 props 未发生变化，那么子组件也会重新渲染，进而触发 render</p>
<p><strong>（2）重新渲染 render 会做些什么?</strong><br>●会对新旧 VNode 进行对比，也就是我们所说的Diff算法。<br>●对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面<br>●遍历差异对象，根据差异的类型，根据对应对规则更新VNode</p>
<p>React 的处理 render 的基本思维模式是每次一有变动就会去重新渲染整个应用。在 Virtual DOM 没有出现之前，最简单的方法就是直接调用 innerHTML。Virtual DOM厉害的地方并不是说它比直接操作 DOM 快，而是说不管数据怎么变，都会尽量以最小的代价去更新 DOM。React 将 render 函数返回的虚拟 DOM 树与老的进行比较，从而确定 DOM 要不要更新、怎么更新。当 DOM 树很大时，遍历两棵树进行各种比对还是相当耗性能的，特别是在顶层 setState 一个微小的修改，默认会去遍历整棵树。尽管 React 使用高度优化的 Diff 算法，但是这个过程仍然会损耗性能.</p>
<h4 id="13-React声明组件有哪几种方法，有什么不同？"><a href="#13-React声明组件有哪几种方法，有什么不同？" class="headerlink" title="13. React声明组件有哪几种方法，有什么不同？"></a>13. React声明组件有哪几种方法，有什么不同？</h4><p>React 声明组件的三种方式：<br>●函数式定义的无状态组件<br>●ES5原生方式React.createClass定义的组件<br>●ES6形式的extends React.Component定义的组件</p>
<p><strong>（1）无状态函数式组件</strong><br>它是为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到state状态的操作<br>组件不会被实例化，整体渲染性能得到提升，不能访问this对象，不能访问生命周期的方法</p>
<p><strong>（2）ES5 原生方式 React.createClass // RFC</strong><br>React.createClass会自绑定函数方法，导致不必要的性能开销，增加代码过时的可能性。</p>
<p><strong>（3）E6继承形式 React.Component // RCC</strong><br>目前极为推荐的创建有状态组件的方式，最终会取代React.createClass形式；相对于 React.createClass可以更好实现代码复用。</p>
<p>无状态组件相对于于后者的区别：<br>与无状态组件相比，React.createClass和React.Component都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。</p>
<p>React.createClass与React.Component区别：<br>① 函数this自绑定<br>●React.createClass创建的组件，其每一个成员函数的this都有React自动绑定，函数中的this会被正确设置。<br>●React.Component创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。<br>② 组件属性类型propTypes及其默认props属性defaultProps配置不同<br>●React.createClass在创建组件时，有关组件props的属性类型及组件默认的属性会作为组件实例的属性来配置，其中defaultProps是使用getDefaultProps的方法来获取默认组件属性的<br>●React.Component在创建组件时配置这两个对应信息时，他们是作为组件类的属性，不是组件实例的属性，也就是所谓的类的静态属性来配置的。<br>③ 组件初始状态state的配置不同<br>●React.createClass创建的组件，其状态state是通过getInitialState方法来配置组件相关的状态；<br>●React.Component创建的组件，其状态state是在constructor中像初始化组件属性一样声明的。</p>
<h4 id="14-对有状态组件和无状态组件的理解及使用场景"><a href="#14-对有状态组件和无状态组件的理解及使用场景" class="headerlink" title="14. 对有状态组件和无状态组件的理解及使用场景"></a>14. 对有状态组件和无状态组件的理解及使用场景</h4><p>**（1）有状态组件 **<br><strong>特点：</strong><br>●是类组件<br>●有继承<br>●可以使用this<br>●可以使用react的生命周期<br>●使用较多，容易频繁触发生命周期钩子函数，影响性能<br>●内部使用 state，维护自身状态的变化，有状态组件根据外部组件传入的 props 和自身的 state进行渲染。</p>
<p><strong>使用场景：</strong><br>●需要使用到状态的。<br>●需要使用状态操作组件的（无状态组件的也可以实现新版本react hooks也可实现）</p>
<p><strong>总结：</strong><br>类组件可以维护自身的状态变量，即组件的 state ，类组件还有不同的生命周期方法，可以让开发者能够在组件的不同阶段（挂载、更新、卸载），对组件做更多的控制。类组件则既可以充当无状态组件，也可以充当有状态组件。当一个类组件不需要管理自身状态时，也可称为无状态组件。</p>
<p><strong>（2）无状态组件</strong><br>特点：<br>●不依赖自身的状态state<br>●可以是类组件或者函数组件。<br>●可以完全避免使用 this 关键字。（由于使用的是箭头函数事件无需绑定）<br>●有更高的性能。当不需要使用生命周期钩子时，应该首先使用无状态函数组件<br>●组件内部不维护 state ，只根据外部组件传入的 props 进行渲染的组件，当 props 改变时，组件重新渲染。</p>
<p><strong>使用场景：</strong><br>●组件不需要管理 state，纯展示 </p>
<p><strong>优点：</strong><br>●简化代码、专注于 render<br>●组件不需要被实例化，无生命周期，提升性能。 输出（渲染）只取决于输入（属性），无副作用<br>●视图和数据的解耦分离</p>
<p><strong>缺点：</strong><br>●无法使用 ref<br>●无生命周期方法<br>●无法控制组件的重渲染，因为无法使用shouldComponentUpdate 方法，当组件接受到新的属性时则会重渲染</p>
<p>总结：<br>组件内部状态且与外部无关的组件，可以考虑用状态组件，这样状态树就不会过于复杂，易于理解和管理。当一个组件不需要管理自身状态时，也就是无状态组件，应该优先设计为函数组件。比如自定义的 <code>&lt;Button/&gt;、 &lt;Input /&gt; </code>等组件。</p>
<h4 id="15-对React中Fragment的理解，它的使用场景是什么？"><a href="#15-对React中Fragment的理解，它的使用场景是什么？" class="headerlink" title="15. 对React中Fragment的理解，它的使用场景是什么？"></a>15. 对React中Fragment的理解，它的使用场景是什么？</h4><p>在React中，组件返回的元素只能有一个根元素。为了不添加多余的DOM节点，我们可以使用Fragment标签来包裹所有的元素，Fragment标签不会渲染出任何元素。React官方对Fragment的解释：</p>
<blockquote>
<p>React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component, Fragment &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-comment">// 一般形式</span><br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;React.Fragment&gt;<br>      &lt;ChildA /&gt;<br>      &lt;ChildB /&gt;<br>      &lt;ChildC /&gt;<br>    &lt;/React.Fragment&gt;<br>  );<br>&#125;<br><span class="hljs-comment">// 也可以写成以下形式</span><br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;&gt;<br>      &lt;ChildA /&gt;<br>      &lt;ChildB /&gt;<br>      &lt;ChildC /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="16-React如何获取组件对应的DOM元素？"><a href="#16-React如何获取组件对应的DOM元素？" class="headerlink" title="16. React如何获取组件对应的DOM元素？"></a>16. React如何获取组件对应的DOM元素？</h4><p>可以用ref来获取某个子节点的实例，然后通过当前class组件实例的一些特定属性来直接获取子节点实例。ref有三种实现方法:<br>●<strong>字符串格式</strong>：字符串格式，这是React16版本之前用得最多的，例如：<code>&lt;p ref=&quot;info&quot;&gt;span&lt;/p&gt;</code><br>●<strong>函数格式</strong>：ref对应一个方法，该方法有一个参数，也就是对应的节点实例，例如：<code>&lt;p ref=&#123;ele =&gt; this.info = ele&#125;&gt;&lt;/p&gt;</code><br>●<strong>createRef方法</strong>：React 16提供的一个API，使用React.createRef()来实现 　</p>
<h4 id="17-React中可以在render访问refs吗？为什么？"><a href="#17-React中可以在render访问refs吗？为什么？" class="headerlink" title="17. React中可以在render访问refs吗？为什么？"></a>17. React中可以在render访问refs吗？为什么？</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">ref</span>=</span></span><span class="hljs-template-variable">&#123;this.spanRef&#125;</span><span class="xml"><span class="hljs-tag">&gt;</span></span><span class="hljs-template-variable">&#123;this.state.title&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">     this.spanRef.current ? &#x27;有值&#x27; : &#x27;无值&#x27;</span><br><span class="hljs-template-variable">  &#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/&gt;</span></span><br></code></pre></td></tr></table></figure>
<p><strong>不可以，render 阶段 DOM 还没有生成，无法获取 DOM</strong>。DOM 的获取需要在 pre-commit 阶段和 commit 阶段：<br><img src="/imageO/react11s.png" srcset="/img/loading.gif" lazyload alt="生命周期"></p>
<h4 id="18-对React的插槽-Portals-的理解，如何使用，有哪些使用场景"><a href="#18-对React的插槽-Portals-的理解，如何使用，有哪些使用场景" class="headerlink" title="18. 对React的插槽(Portals)的理解，如何使用，有哪些使用场景"></a>18. 对React的插槽(Portals)的理解，如何使用，有哪些使用场景</h4><p>React 官方对 Portals 的定义：</p>
<blockquote>
<p>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案<br>Portals 是React 16提供的官方解决方案，使得组件可以脱离父组件层级挂载在DOM树的任何位置。通俗来讲，就是我们 render 一个组件，但这个组件的 DOM 结构并不在本组件内。</p>
</blockquote>
<p>Portals语法如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ReactDOM</span>.</span></span>create<span class="hljs-constructor">Portal(<span class="hljs-params">child</span>, <span class="hljs-params">container</span>)</span>;<br></code></pre></td></tr></table></figure>
<p>●第一个参数 child 是可渲染的 React 子项，比如元素，字符串或者片段等;<br>●第二个参数 container 是一个 DOM 元素。</p>
<p>一般情况下，组件的render函数返回的元素会被挂载在它的父级组件上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> DemoComponent <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./DemoComponent&#x27;</span>;<br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">// DemoComponent元素会被挂载在id为parent的div的元素上</span><br>  <span class="hljs-keyword">return</span> (<br>    &lt;div id=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>        &lt;DemoComponent /&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然而，有些元素需要被挂载在更高层级的位置。最典型的应用场景：当父组件具有overflow: hidden或者z-index的样式设置时，组件有可能被其他元素遮挡，这时就可以考虑要不要使用Portal使组件的挂载脱离父组件。例如：对话框，模态窗。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> DemoComponent <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./DemoComponent&#x27;</span>;<br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">// react会将DemoComponent组件直接挂载在真实的 dom 节点 domNode 上，生命周期还和16版本之前相同。</span><br>  <span class="hljs-keyword">return</span> ReactDOM.createPortal(<br>    &lt;DemoComponent /&gt;,<br>    domNode,<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="19-在React中如何避免不必要的render？"><a href="#19-在React中如何避免不必要的render？" class="headerlink" title="19. 在React中如何避免不必要的render？"></a>19. 在React中如何避免不必要的render？</h4><p>React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点：<br><strong>●shouldComponentUpdate 和 PureComponent</strong><br>在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。<br><strong>●利用高阶组件</strong><br>在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能<br><strong>●使用 React.memo</strong><br>React.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。</p>
<h4 id="21-对-React-context-的理解"><a href="#21-对-React-context-的理解" class="headerlink" title="21. 对 React context 的理解"></a>21. 对 React context 的理解</h4><p>在React中，数据传递一般使用props传递数据，维持单向数据流，这样可以让组件之间的关系变得简单且可预测，但是单项数据流在某些场景中并不适用。单纯一对的父子组件传递并无问题，但要是组件之间层层依赖深入，props就需要层层传递显然，这样做太繁琐了。</p>
<p>Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。</p>
<p>可以把context当做是特定一个组件树内共享的store，用来做数据传递。<strong>简单说就是，当你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。</strong></p>
<p>JS的代码块在执行期间，会创建一个相应的作用域链，这个作用域链记录着运行时JS代码块执行期间所能访问的活动对象，包括变量和函数，JS程序通过作用域链访问到代码块内部或者外部的变量和函数。</p>
<p>假如以JS的作用域链作为类比，React组件提供的Context对象其实就好比一个提供给子组件访问的作用域，而 Context对象的属性可以看成作用域上的活动对象。由于组件 的 Context 由其父节点链上所有组件通 过 getChildContext（）返回的Context对象组合而成，所以，组件通过Context是可以访问到其父组件链上所有节点组件提供的Context的属性。</p>
<h4 id="22-为什么React并不推荐优先考虑使用Context？"><a href="#22-为什么React并不推荐优先考虑使用Context？" class="headerlink" title="22. 为什么React并不推荐优先考虑使用Context？"></a>22. 为什么React并不推荐优先考虑使用Context？</h4><p>●Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。<br>●尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context<br>●对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。<br>●context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注</p>
<h4 id="23-React中什么是受控组件和非控组件？"><a href="#23-React中什么是受控组件和非控组件？" class="headerlink" title="23. React中什么是受控组件和非控组件？"></a>23. React中什么是受控组件和非控组件？</h4><p>（1）受控组件<br>在使用表单来收集用户输入时，例如<code>&lt;input&gt;&lt;select&gt;&lt;textearea&gt;</code>等元素都要绑定一个change事件，当表单的状态发生变化，就会触发onChange事件，更新组件的state。这种组件在React中被称为受控组件，在受控组件中，组件渲染出的状态与它的value或checked属性相对应，react通过这种方式消除了组件的局部状态，使整个状态可控。react官方推荐使用受控表单组件。</p>
<p>受控组件更新state的流程：<br>●可以通过初始state中设置表单的默认值<br>●每当表单的值发生变化时，调用onChange事件处理器<br>●事件处理器通过事件对象e拿到改变后的状态，并更新组件的state<br>●一旦通过setState方法更新state，就会触发视图的重新渲染，完成表单组件的更新</p>
<p><strong>受控组件缺陷：</strong><br>表单元素的值都是由React组件进行管理，当有多个输入框，或者多个这种组件时，如果想同时获取到全部的值就必须每个都要编写事件处理函数，这会让代码看着很臃肿，所以为了解决这种情况，出现了非受控组件。</p>
<p>（2）非受控组件<br>如果一个表单组件没有value props（单选和复选按钮对应的是checked props）时，就可以称为非受控组件。在非受控组件中，可以使用一个ref来从DOM获得表单值。而不是为每个状态更新编写一个事件处理程序。</p>
<p>React官方的解释：</p>
<blockquote>
<p>要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以使用 ref来从 DOM 节点中获取表单数据。</p>
</blockquote>
<blockquote>
<p>因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。</p>
</blockquote>
<p>例如，下面的代码在非受控组件中接收单个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(props);<br>    <span class="hljs-built_in">this</span>.handleSubmit = <span class="hljs-built_in">this</span>.handleSubmit.bind(<span class="hljs-built_in">this</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">handleSubmit</span>(<span class="hljs-params">event</span>)</span> &#123;<br>    alert(<span class="hljs-string">&#x27;A name was submitted: &#x27;</span> + <span class="hljs-built_in">this</span>.input.value);<br>    event.preventDefault();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;form onSubmit=&#123;<span class="hljs-built_in">this</span>.handleSubmit&#125;&gt;<br>        &lt;label&gt;<br>          Name:<br>          &lt;input type=<span class="hljs-string">&quot;text&quot;</span> ref=&#123;<span class="hljs-function">(<span class="hljs-params">input</span>) =&gt;</span> <span class="hljs-built_in">this</span>.input = input&#125; /&gt;<br>        &lt;/label&gt;<br>        &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;Submit&quot;</span> /&gt;<br>      &lt;/form&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：页面中所有输入类的DOM如果是现用现取的称为非受控组件，而通过setState将输入的值维护到了state中，需要时再从state中取出，这里的数据就受到了state的控制，称为受控组件。</p>
<h4 id="24-React中refs的作用是什么？有哪些应用场景？"><a href="#24-React中refs的作用是什么？有哪些应用场景？" class="headerlink" title="24. React中refs的作用是什么？有哪些应用场景？"></a>24. React中refs的作用是什么？有哪些应用场景？</h4><p>Refs 提供了一种方式，用于访问在 render 方法中创建的 React 元素或 DOM 节点。Refs 应该谨慎使用，如下场景使用 Refs 比较适合：<br>●处理焦点、文本选择或者媒体的控制<br>●触发必要的动画<br>●集成第三方 DOM 库</p>
<p>Refs 是使用 React.createRef() 方法创建的，他通过 ref 属性附加到 React 元素上。要在整个组件中使用 Refs，需要将 ref 在构造函数中分配给其实例属性：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props)<br>    <span class="hljs-keyword">this</span>.myRef = <span class="hljs-type">React</span>.createRef()<br>  &#125;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> &lt;div ref=&#123;<span class="hljs-keyword">this</span>.myRef&#125; /&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于函数组件没有实例，因此不能在函数组件上直接使用 ref：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala">function <span class="hljs-type">MyFunctionalComponent</span>() &#123;<br>  <span class="hljs-keyword">return</span> &lt;input /&gt;;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-keyword">this</span>.textInput = <span class="hljs-type">React</span>.createRef();<br>  &#125;<br>  render() &#123;<br>    <span class="hljs-comment">// 这将不会工作！</span><br>    <span class="hljs-keyword">return</span> (<br>      &lt;<span class="hljs-type">MyFunctionalComponent</span> ref=&#123;<span class="hljs-keyword">this</span>.textInput&#125; /&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但可以通过闭合的帮助在函数组件内部进行使用 Refs：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CustomTextInput</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-comment">// 这里必须声明 textInput，这样 ref 回调才可以引用它</span><br>  <span class="hljs-keyword">let</span> textInput = <span class="hljs-literal">null</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleClick</span>(<span class="hljs-params"></span>) </span>&#123;<br>    textInput.focus();<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div&gt;<br>      &lt;input<br>        type=<span class="hljs-string">&quot;text&quot;</span><br>        ref=&#123;<span class="hljs-function">(<span class="hljs-params">input</span>) =&gt;</span> &#123; textInput = input; &#125;&#125; /&gt;<br>      &lt;input<br>        type=<span class="hljs-string">&quot;button&quot;</span><br>        value=<span class="hljs-string">&quot;Focus the text input&quot;</span><br>        onClick=&#123;handleClick&#125;<br>      /&gt;<br>    &lt;/div&gt;<br>  );  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意：<br>●不应该过度的使用 Refs<br>●ref 的返回值取决于节点的类型：<br>○当 ref 属性被用于一个普通的 HTML 元素时，React.createRef() 将接收底层 DOM 元素作为他的 current 属性以创建 ref。<br>○当 ref 属性被用于一个自定义的类组件时，ref 对象将接收该组件已挂载的实例作为他的 current。<br>●当在父组件中需要访问子组件中的 ref 时可使用传递 Refs 或回调 Refs。</p>
<h4 id="25-React中除了在构造函数中绑定this，还有别的方式吗？"><a href="#25-React中除了在构造函数中绑定this，还有别的方式吗？" class="headerlink" title="25. React中除了在构造函数中绑定this，还有别的方式吗？"></a>25. React中除了在构造函数中绑定this，还有别的方式吗？</h4><p>●在构造函数中绑定this</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(props)</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">      super(props); </span></span><br><span class="hljs-function"><span class="hljs-comment">       this.state=&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">           msg:&#x27;hello world&#x27;,</span></span><br><span class="hljs-function"><span class="hljs-comment">       &#125;</span></span><br><span class="hljs-function">       <span class="hljs-title">this</span>.<span class="hljs-title">getMsg</span> = <span class="hljs-title">this</span>.<span class="hljs-title">getMsg</span>.<span class="hljs-title">bind</span><span class="hljs-params">(this)</span></span><br><span class="hljs-function">   &#125;</span><br></code></pre></td></tr></table></figure>
<p>●函数定义的时候使用箭头函数</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(props)</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">    super(props);</span></span><br><span class="hljs-function"><span class="hljs-comment">    this.state=&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">           msg:&#x27;hello world&#x27;,</span></span><br><span class="hljs-function"><span class="hljs-comment">    &#125;</span></span><br><span class="hljs-function">    <span class="hljs-title">render</span><span class="hljs-params">()</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">      &lt;button onClcik=&#123;()=&gt;&#123;alert(this.state.msg)&#125;</span>&#125;&gt;点我&lt;/<span class="hljs-title">button</span>&gt;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>
<p>●函数调用是使用bind绑定this</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&lt;button onClick=&#123;<span class="hljs-keyword">this</span>.getMsg.bind(<span class="hljs-keyword">this</span>)&#125;&gt;点我&lt;/button&gt;<br></code></pre></td></tr></table></figure>
<h4 id="26-React组件的构造函数有什么作用？它是必须的吗？"><a href="#26-React组件的构造函数有什么作用？它是必须的吗？" class="headerlink" title="26. React组件的构造函数有什么作用？它是必须的吗？"></a>26. React组件的构造函数有什么作用？它是必须的吗？</h4><p>构造函数主要用于两个目的：<br>●通过将对象分配给this.state来初始化本地状态<br>●将事件处理程序方法绑定到实例上<br>所以，当在React class中需要设置state的初始值或者绑定事件时，需要加上构造函数，官方Demo：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LikeButton</span> <span class="hljs-title">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>() &#123;<br>    <span class="hljs-keyword">super</span>();<br>    <span class="hljs-keyword">this</span>.state = &#123;<br>      liked: <span class="hljs-literal">false</span><br>    &#125;;<br>    <span class="hljs-keyword">this</span>.handleClick = <span class="hljs-keyword">this</span>.handleClick.bind(<span class="hljs-keyword">this</span>);<br>  &#125;<br>  handleClick() &#123;<br>    <span class="hljs-keyword">this</span>.setState(&#123;liked: !<span class="hljs-keyword">this</span>.state.liked&#125;);<br>  &#125;<br>  render() &#123;<br>    <span class="hljs-keyword">const</span> text = <span class="hljs-keyword">this</span>.state.liked ? <span class="hljs-string">&#x27;liked&#x27;</span> : <span class="hljs-string">&#x27;haven\&#x27;t liked&#x27;</span>;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div onClick=&#123;<span class="hljs-keyword">this</span>.handleClick&#125;&gt;<br>        You &#123;text&#125; <span class="hljs-keyword">this</span>. Click to toggle.<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br>ReactDOM.render(<br>  &lt;LikeButton /&gt;,<br>  document.getElementById(<span class="hljs-string">&#x27;example&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure>
<p>构造函数用来新建父类的this对象；子类必须在constructor方法中调用super方法；否则新建实例时会报错；因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法；子类就得不到this对象。</p>
<p>注意：<br>●constructor () 必须配上 super(), 如果要在constructor 内部使用 this.props 就要 传入props , 否则不用<br>●JavaScript中的 bind 每次都会返回一个新的函数, 为了性能等考虑, 尽量在constructor中绑定事件</p>
<h4 id="27-React-forwardRef是什么？它有什么作用？"><a href="#27-React-forwardRef是什么？它有什么作用？" class="headerlink" title="27. React.forwardRef是什么？它有什么作用？"></a>27. React.forwardRef是什么？它有什么作用？</h4><p>React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。这种技术并不常见，但在以下两种场景中特别有用：<br>●转发 refs 到 DOM 组件<br>●在高阶组件中转发 refs</p>
<h4 id="28-类组件与函数组件有什么异同？"><a href="#28-类组件与函数组件有什么异同？" class="headerlink" title="28. 类组件与函数组件有什么异同？"></a>28. 类组件与函数组件有什么异同？</h4><p><strong>相同点：</strong><br>组件是 React 可复用的最小代码片段，它们会返回要在页面中渲染的 React 元素。也正因为组件是 React 的最小编码单位，所以无论是函数组件还是类组件，在使用方式和最终呈现效果上都是完全一致的。</p>
<p>我们甚至可以将一个类组件改写成函数组件，或者把函数组件改写成一个类组件（虽然并不推荐这种重构行为）。从使用者的角度而言，很难从使用体验上区分两者，而且在现代浏览器中，闭包和类的性能只在极端场景下才会有明显的差别。所以，基本可认为两者作为组件是完全一致的。</p>
<p><strong>不同点：</strong><br>●它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。<br>●之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。<br>●性能优化上，类组件主要依靠 shouldComponentUpdate 阻断渲染来提升性能，而函数组件依靠 React.memo 缓存渲染结果来提升性能。<br>●从上手程度而言，类组件更容易上手，从未来趋势上看，由于React Hooks 的推出，函数组件成了社区未来主推的方案。<br>●类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展。</p>
<h3 id="二、数据管理"><a href="#二、数据管理" class="headerlink" title="二、数据管理"></a>二、数据管理</h3><h4 id="1-React-setState-调用的原理"><a href="#1-React-setState-调用的原理" class="headerlink" title="1. React setState 调用的原理"></a>1. React setState 调用的原理</h4><p><img src="/imageO/react11.png" srcset="/img/loading.gif" lazyload alt="setState"><br>具体的执行过程如下（源码级解析）：<br>●首先调用了setState 入口函数，入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去；</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ReactComponent</span>.</span></span>prototype.setState = <span class="hljs-keyword">function</span> (partialState, callback) &#123;<br>  this.updater.enqueue<span class="hljs-constructor">SetState(<span class="hljs-params">this</span>, <span class="hljs-params">partialState</span>)</span>;<br>  <span class="hljs-keyword">if</span> (callback) &#123;<br>    this.updater.enqueue<span class="hljs-constructor">Callback(<span class="hljs-params">this</span>, <span class="hljs-params">callback</span>, &#x27;<span class="hljs-params">setState</span>&#x27;)</span>;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>●enqueueSetState 方法将新的 state 放进组件的状态队列里，并调用 enqueueUpdate 来处理将要更新的实例对象；</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pf">enqueueSetState: function (publicInstance, partialState) &#123;<br>  // 根据 this 拿到对应的组件实例<br>  var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, &#x27;<span class="hljs-built_in">set</span>State&#x27;);<br>  // 这个 <span class="hljs-keyword">queue</span> 对应的就是一个组件实例的 <span class="hljs-keyword">state</span> 数组<br>  var <span class="hljs-keyword">queue</span> = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);<br>  <span class="hljs-keyword">queue</span>.push(partialState);<br>  //  enqueueUpdate 用来处理当前的组件实例<br>  enqueueUpdate(internalInstance);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>●在 enqueueUpdate 方法中引出了一个关键的对象——batchingStrategy，该对象所具备的isBatchingUpdates 属性直接决定了当下是要走更新流程，还是应该排队等待；如果轮到执行，就调用 batchedUpdates 方法来直接发起更新流程。由此可以推测，batchingStrategy 或许正是 React 内部专门用于管控批量更新的对象。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> enqueue<span class="hljs-constructor">Update(<span class="hljs-params">component</span>)</span> &#123;<br>  ensure<span class="hljs-constructor">Injected()</span>;<br>  <span class="hljs-comment">// 注意这一句是问题的关键，isBatchingUpdates标识着当前是否处于批量创建/更新组件的阶段</span><br>  <span class="hljs-keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123;<br>    <span class="hljs-comment">// 若当前没有处于批量创建/更新组件的阶段，则立即更新组件</span><br>    batchingStrategy.batched<span class="hljs-constructor">Updates(<span class="hljs-params">enqueueUpdate</span>, <span class="hljs-params">component</span>)</span>;<br>    return;<br>  &#125;<br>  <span class="hljs-comment">// 否则，先把组件塞入 dirtyComponents 队列里，让它“再等等”</span><br>  dirtyComponents.push(component);<br>  <span class="hljs-keyword">if</span> (component._updateBatchNumber<span class="hljs-operator"> == </span>null) &#123;<br>    component._updateBatchNumber = updateBatchNumber + <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>注意</strong>：batchingStrategy 对象可以理解为“锁管理器”。这里的“锁”，是指 React 全局唯一的 isBatchingUpdates 变量，isBatchingUpdates 的初始值是 false，意味着“当前并未进行任何批量更新操作”。每当 React 调用 batchedUpdate 去执行更新动作时，会先把这个锁给“锁上”（置为 true），表明“现在正处于批量更新过程中”。当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入 dirtyComponents 里排队等候下一次的批量更新，而不能随意“插队”。此处体现的“任务锁”的思想，是 React 面对大量状态仍然能够实现有序分批处理的基石。</p>
<h4 id="2-React-setState-调用之后发生了什么？是同步还是异步？"><a href="#2-React-setState-调用之后发生了什么？是同步还是异步？" class="headerlink" title="2. React setState 调用之后发生了什么？是同步还是异步？"></a>2. React setState 调用之后发生了什么？是同步还是异步？</h4><p><strong>（1）React中setState后发生了什么</strong><br>在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发调和过程(Reconciliation)。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。</p>
<p>在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p>
<p>如果在短时间内频繁setState。React会将state的改变压入栈中，在合适的时机，批量更新state和视图，达到提高性能的效果。</p>
<p><strong>（2）setState 是同步还是异步的</strong><br>假如所有setState是同步的，意味着每执行一次setState时（有可能一个同步代码中，多次setState），都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异步，则可以把一个同步代码中的多个setState合并成一次组件更新。所以默认是异步的，但是在一些情况下是同步的。</p>
<p>setState 并不是单纯同步/异步的，它的表现会因调用场景的不同而不同。在源码中，通过 isBatchingUpdates 来判断setState 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。<br><strong>●异步</strong>：在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。<br><strong>●同步</strong>：在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。</p>
<p>一般认为，做异步设计是为了性能优化、减少渲染次数：<br>●setState设计为异步，可以显著的提升性能。如果每次调用 setState都进行一次更新，那么意味着render函数会被频繁调用，界面重新渲染，这样效率是很低的；最好的办法应该是获取到多个更新，之后进行批量更新；<br>●如果同步更新了state，但是还没有执行render函数，那么state和props不能保持同步。state和props不能保持一致性，会在开发中产生很多的问题；</p>
<h4 id="3-React中的setState批量更新的过程是什么？"><a href="#3-React中的setState批量更新的过程是什么？" class="headerlink" title="3. React中的setState批量更新的过程是什么？"></a>3. React中的setState批量更新的过程是什么？</h4><p>调用 setState 时，组件的 state 并不会立即改变， setState 只是把要修改的 state 放入一个队列， React 会优化真正的执行时机，并出于性能原因，会将 React 事件处理程序中的多次React 事件处理程序中的多次 setState 的状态修改合并成一次状态修改。 最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pf">this.<span class="hljs-built_in">set</span>State(&#123;<br>  count: this.<span class="hljs-keyword">state</span>.count + <span class="hljs-number">1</span>    ===&gt;    入队，[count+<span class="hljs-number">1</span>的任务]<br>&#125;);<br>this.<span class="hljs-built_in">set</span>State(&#123;<br>  count: this.<span class="hljs-keyword">state</span>.count + <span class="hljs-number">1</span>    ===&gt;    入队，[count+<span class="hljs-number">1</span>的任务，count+<span class="hljs-number">1</span>的任务]<br>&#125;);<br>                                          ↓<br>                                         合并 <span class="hljs-keyword">state</span>，[count+<span class="hljs-number">1</span>的任务]<br>                                          ↓<br>                                         执行 count+<span class="hljs-number">1</span>的任务<br></code></pre></td></tr></table></figure>
<p>需要注意的是，只要同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。</p>
<h4 id="4-React中有使用过getDefaultProps吗？它有什么作用？"><a href="#4-React中有使用过getDefaultProps吗？它有什么作用？" class="headerlink" title="4.  React中有使用过getDefaultProps吗？它有什么作用？"></a>4.  React中有使用过getDefaultProps吗？它有什么作用？</h4><p>通过实现组件的getDefaultProps，对属性设置默认值（ES5的写法）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ShowTitle = React.createClass(&#123;<br>  getDefaultProps:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>      title : <span class="hljs-string">&quot;React&quot;</span><br>    &#125;<br>  &#125;,<br>  render : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;this.props.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="5-React中setState的第二个参数作用是什么？"><a href="#5-React中setState的第二个参数作用是什么？" class="headerlink" title="5. React中setState的第二个参数作用是什么？"></a>5. React中setState的第二个参数作用是什么？</h4><p>setState 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 componentDidUpdate 生命周期内执行。通常建议使用 componentDidUpdate 来代替此方式。在这个回调函数中你可以拿到更新后 state 的值：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">this.<span class="hljs-built_in">set</span>State(&#123;<br>    key1: newState1,<br>    key2: newState2,<br>    ...<br>&#125;, callback) // 第二个参数是 <span class="hljs-keyword">state</span> 更新完成后的回调函数<br></code></pre></td></tr></table></figure>
<h4 id="6-React中的setState和replaceState的区别是什么？"><a href="#6-React中的setState和replaceState的区别是什么？" class="headerlink" title="6. React中的setState和replaceState的区别是什么？"></a>6. React中的setState和replaceState的区别是什么？</h4><p><strong>（1）setState()</strong><br>setState()用于设置状态对象，其语法如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">set<span class="hljs-constructor">State(<span class="hljs-params">object</span> <span class="hljs-params">nextState</span>[, <span class="hljs-params">function</span> <span class="hljs-params">callback</span>])</span><br></code></pre></td></tr></table></figure>
<p>●nextState，将要设置的新状态，该状态会和当前的state合并<br>●callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。</p>
<p>合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。<br><strong>（2）replaceState()</strong><br>replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">replace<span class="hljs-constructor">State(<span class="hljs-params">object</span> <span class="hljs-params">nextState</span>[, <span class="hljs-params">function</span> <span class="hljs-params">callback</span>])</span><br></code></pre></td></tr></table></figure>
<p>●nextState，将要设置的新状态，该状态会替换当前的state。<br>●callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。</p>
<p><strong>总结：</strong>setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。</p>
<h4 id="7-在React中组件的this-state和setState有什么区别？"><a href="#7-在React中组件的this-state和setState有什么区别？" class="headerlink" title="7. 在React中组件的this.state和setState有什么区别？"></a>7. 在React中组件的this.state和setState有什么区别？</h4><p>this.state通常是用来初始化state的，this.setState是用来修改state值的。如果初始化了state之后再使用this.state，之前的state会被覆盖掉，如果使用this.setState，只会替换掉相应的state值。所以，如果想要修改state的值，就需要使用setState，而不能直接修改state，直接修改state之后页面是不会更新的。</p>
<h4 id="8-state-是怎么注入到组件的，从-reducer-到组件经历了什么样的过程"><a href="#8-state-是怎么注入到组件的，从-reducer-到组件经历了什么样的过程" class="headerlink" title="8. state 是怎么注入到组件的，从 reducer 到组件经历了什么样的过程"></a>8. state 是怎么注入到组件的，从 reducer 到组件经历了什么样的过程</h4><p>通过connect和mapStateToProps将state注入到组件中：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span><br><span class="hljs-keyword">import</span> &#123; setVisibilityFilter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/reducers/Todo/actions&#x27;</span><br><span class="hljs-keyword">import</span> Link <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/containers/Todo/components/Link&#x27;</span><br><br>const mapStateToProps = <span class="hljs-function"><span class="hljs-params">(state, ownProps)</span> =&gt;</span> (&#123;<br>    active: ownProps.filter === state.visibilityFilter<br>&#125;)<br><br>const mapDispatchToProps = <span class="hljs-function"><span class="hljs-params">(dispatch, ownProps)</span> =&gt;</span> (&#123;<br>    setFilter: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        dispatch(setVisibilityFilter(ownProps.filter))<br>    &#125;<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> connect(<br>    mapStateToProps,<br>    mapDispatchToProps<br>)(Link)<br></code></pre></td></tr></table></figure>
<p>上面代码中，active就是注入到Link组件中的状态。 mapStateToProps（state，ownProps）中带有两个参数，含义是∶<br>●state-store管理的全局状态对象，所有都组件状态数据都存储在该对象中。<br>●ownProps 组件通过props传入的参数。 </p>
<p><strong>reducer 到组件经历的过程：</strong><br>●reducer对action对象处理，更新组件状态，并将新的状态值返回store。<br>●通过connect（mapStateToProps，mapDispatchToProps）（Component）对组件 Component进行升级，此时将状态值从store取出并作为props参数传递到组件。<br><strong>高阶组件实现源码∶</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;prop-types&#x27;</span><br><br><span class="hljs-comment">// 高阶组件 contect </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> connect = <span class="hljs-function">(<span class="hljs-params">mapStateToProps, mapDispatchToProps</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connect</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>        <span class="hljs-comment">// 通过对context调用获取store</span><br>        <span class="hljs-keyword">static</span> contextTypes = &#123;<br>            store: PropTypes.object<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-built_in">super</span>()<br>            <span class="hljs-built_in">this</span>.state = &#123;<br>                allProps: &#123;&#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 第一遍需初始化所有组件初始状态</span><br>        <span class="hljs-function"><span class="hljs-title">componentWillMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-keyword">const</span> store = <span class="hljs-built_in">this</span>.context.store<br>            <span class="hljs-built_in">this</span>._updateProps()<br>            store.subscribe(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>._updateProps()); <span class="hljs-comment">// 加入_updateProps()至store里的监听事件列表</span><br>        &#125;<br><br>        <span class="hljs-comment">// 执行action后更新props，使组件可以更新至最新状态（类似于setState）</span><br>        <span class="hljs-function"><span class="hljs-title">_updateProps</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-keyword">const</span> store = <span class="hljs-built_in">this</span>.context.store;<br>            <span class="hljs-keyword">let</span> stateProps = mapStateToProps ?<br>                mapStateToProps(store.getState(), <span class="hljs-built_in">this</span>.props) : &#123;&#125; <span class="hljs-comment">// 防止 mapStateToProps 没有传入</span><br>            <span class="hljs-keyword">let</span> dispatchProps = mapDispatchToProps ?<br>                mapDispatchToProps(store.dispatch, <span class="hljs-built_in">this</span>.props) : &#123;<br>                                    dispatch: store.dispatch<br>                                &#125; <span class="hljs-comment">// 防止 mapDispatchToProps 没有传入</span><br>            <span class="hljs-built_in">this</span>.setState(&#123;<br>                allProps: &#123;<br>                    ...stateProps,<br>                    ...dispatchProps,<br>                    ...this.props<br>                &#125;<br>            &#125;)<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...this.state.allProps</span>&#125; /&gt;</span></span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Connect<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="9-React组件的state和props有什么区别？"><a href="#9-React组件的state和props有什么区别？" class="headerlink" title="9. React组件的state和props有什么区别？"></a>9. React组件的state和props有什么区别？</h4><p><strong>（1）props</strong><br>props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。<br><strong>（2）state</strong><br>state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。<br><strong>（3）区别</strong><br>●props 是传递给组件的（类似于函数的形参），而state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。<br>●props 是不可修改的，所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。<br>●state 是在组件中创建的，一般在 constructor中初始化 state。state 是多变的、可以修改，每次setState都异步更新的。</p>
<h4 id="10-React中的props为什么是只读的？"><a href="#10-React中的props为什么是只读的？" class="headerlink" title="10. React中的props为什么是只读的？"></a>10. React中的props为什么是只读的？</h4><p>this.props是组件之间沟通的一个接口，原则上来讲，它只能从父组件流向子组件。React具有浓重的函数式编程的思想。</p>
<p>提到函数式编程就要提一个概念：纯函数。它有几个特点：<br>●给定相同的输入，总是返回相同的输出。<br>●过程没有副作用。<br>●不依赖外部状态。</p>
<p>this.props就是汲取了纯函数的思想。props的不可以变性就保证的相同的输入，页面显示的内容是一样的，并且不会产生副作用</p>
<h4 id="11-在React中组件的props改变时更新组件的有哪些方法？"><a href="#11-在React中组件的props改变时更新组件的有哪些方法？" class="headerlink" title="11. 在React中组件的props改变时更新组件的有哪些方法？"></a>11. 在React中组件的props改变时更新组件的有哪些方法？</h4><p>在一个组件传入的props更新时重新渲染该组件常用的方法是在componentWillReceiveProps中将新的props更新到组件的state中（这种state被成为派生状态（Derived State）），从而实现重新渲染。React 16.3中还引入了一个新的钩子函数getDerivedStateFromProps来专门实现这一需求。</p>
<p><strong>（1）componentWillReceiveProps（已废弃）</strong><br>在react的componentWillReceiveProps(nextProps)生命周期中，可以在子组件的render函数执行前，通过this.props获取旧的属性，通过nextProps获取新的props，对比两次props是否相同，从而更新子组件自己的state。</p>
<p>这样的好处是，可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。<br><strong>（2）getDerivedStateFromProps（16.3引入）</strong><br>这个生命周期函数是为了替代componentWillReceiveProps存在的，所以在需要使用componentWillReceiveProps时，就可以考虑使用getDerivedStateFromProps来进行替代。</p>
<p>两者的参数是不相同的，而getDerivedStateFromProps是一个静态函数，也就是这个函数不能通过this访问到class的属性，也并不推荐直接访问属性。而是应该通过参数提供的nextProps以及prevState来进行判断，根据新传入的props来映射到state。</p>
<p>需要注意的是，<strong>如果props传入的内容不需要影响到你的state，那么就需要返回一个null</strong>，这个返回值是必须的，所以尽量将其写到函数的末尾：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getDerivedStateFromProps</span>(<span class="hljs-params">nextProps, prevState</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">type</span>&#125; = nextProps;<br>    <span class="hljs-comment">// 当传入的type发生变化的时候，更新state</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> !== prevState.type) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-keyword">type</span>,<br>        &#125;;<br>    &#125;<br>    <span class="hljs-comment">// 否则，对于state不进行任何操作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="12-React中怎么检验props？验证props的目的是什么？"><a href="#12-React中怎么检验props？验证props的目的是什么？" class="headerlink" title="12. React中怎么检验props？验证props的目的是什么？"></a>12. React中怎么检验props？验证props的目的是什么？</h4><p>React为我们提供了<strong>PropTypes</strong>以供验证使用。当我们向Props传入的数据无效（向Props传入的数据类型和验证的数据类型不符）就会在控制台发出警告信息。它可以避免随着应用越来越复杂从而出现的问题。并且，它还可以让程序变得更易读。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> <span class="hljs-type">PropTypes</span> from <span class="hljs-symbol">&#x27;prop</span>-types&#x27;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;h1&gt;<span class="hljs-type">Hello</span>, &#123;<span class="hljs-keyword">this</span>.props.name&#125;&lt;/h1&gt;<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-type">Greeting</span>.propTypes = &#123;<br>  name: <span class="hljs-type">PropTypes</span>.string<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>当然，如果项目汇中使用了TypeScript，那么就可以不用PropTypes来校验，而使用TypeScript定义接口来校验props。</p>
<h3 id="三、生命周期"><a href="#三、生命周期" class="headerlink" title="三、生命周期"></a>三、生命周期</h3><h4 id="1-React的生命周期有哪些？"><a href="#1-React的生命周期有哪些？" class="headerlink" title="1. React的生命周期有哪些？"></a>1. React的生命周期有哪些？</h4><p> React 通常将组件生命周期分为三个阶段：<br>●装载阶段（Mount），组件第一次在DOM树中被渲染的过程；<br>●更新过程（Update），组件状态发生变化，重新更新渲染的过程；<br>●卸载过程（Unmount），组件从DOM树中被移除的过程；<br><img src="/imageO/react11.png" srcset="/img/loading.gif" lazyload alt="生命周期"></p>
<h5 id="1）组件挂载阶段"><a href="#1）组件挂载阶段" class="headerlink" title="1）组件挂载阶段"></a><strong>1）组件挂载阶段</strong></h5><p>挂载阶段组件被创建，然后组件实例插入到 DOM 中，完成组件的第一次渲染，该过程只会发生一次，在此阶段会依次调用以下这些方法：<br>●constructor<br>●getDerivedStateFromProps<br>●render<br>●componentDidMount<br><strong>（1）constructor</strong><br>组件的构造函数，第一个被执行，若没有显式定义它，会有一个默认的构造函数，但是若显式定义了构造函数，我们必须在构造函数中执行 super(props)，否则无法在构造函数中拿到this。</p>
<p>如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数<strong>Constructor</strong>。</p>
<p>constructor中通常只做两件事：<br>●初始化组件的 state<br>●给事件处理方法绑定 this</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(props)</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">  super(props);</span></span><br><span class="hljs-function"><span class="hljs-comment">  // 不要在构造函数中调用 setState，可以直接给 state 设置初始值</span></span><br><span class="hljs-function"><span class="hljs-comment">  this.state = &#123; counter: 0 &#125;</span></span><br><span class="hljs-function">  <span class="hljs-title">this</span>.<span class="hljs-title">handleClick</span> = <span class="hljs-title">this</span>.<span class="hljs-title">handleClick</span>.<span class="hljs-title">bind</span><span class="hljs-params">(this)</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>
<p><strong>（2）getDerivedStateFromProps</strong></p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">static getDerivedStateFromProps(props, <span class="hljs-keyword">state</span>)<br></code></pre></td></tr></table></figure>
<p>这是个静态方法，所以不能在这个函数里使用 this，有两个参数 props 和 state，分别指接收到的新参数和当前组件的 state 对象，这个函数会返回一个对象用来更新当前的 state 对象，如果不需要更新可以返回 null。</p>
<p>该函数会在装载时，接收到新的 props 或者调用了 setState 和 forceUpdate 时被调用。如当接收到新的属性想修改 state ，就可以使用。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs pf">// 当 props.counter 变化时，赋值给 <span class="hljs-keyword">state</span> <br>class App extends React.Component &#123;<br>  constructor(props) &#123;<br>    super(props)<br>    this.<span class="hljs-keyword">state</span> = &#123;<br>      counter: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>  static getDerivedStateFromProps(props, <span class="hljs-keyword">state</span>) &#123;<br>    if (props.counter !== <span class="hljs-keyword">state</span>.counter) &#123;<br>      return &#123;<br>        counter: props.counter<br>      &#125;<br>    &#125;<br>    return null<br>  &#125;<br>  <br>  handleClick = () =&gt; &#123;<br>    this.<span class="hljs-built_in">set</span>State(&#123;<br>      counter: this.<span class="hljs-keyword">state</span>.counter + <span class="hljs-number">1</span><br>    &#125;)<br>  &#125;<br>  render() &#123;<br>    return (<br>      <span class="hljs-variable">&lt;div&gt;</span><br>        <span class="hljs-variable">&lt;h1 onClick=&#123;this.handleClick&#125;&gt;</span>Hello, world!&#123;this.<span class="hljs-keyword">state</span>.counter&#125;&lt;/h1&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在可以显式传入 counter ，但是这里有个问题，如果想要通过点击实现 state.counter 的增加，但这时会发现值不会发生任何变化，一直保持 props 传进来的值。这是由于在 React 16.4^ 的版本中 setState 和 forceUpdate 也会触发这个生命周期，所以当组件内部 state 变化后，就会重新走这个方法，同时会把 state 值赋值为 props 的值。因此需要多加一个字段来记录之前的 props 值，这样就会解决上述问题。具体如下：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs pf">// 这里只列出需要变化的地方<br>class App extends React.Component &#123;<br>  constructor(props) &#123;<br>    super(props)<br>    this.<span class="hljs-keyword">state</span> = &#123;<br>      // 增加一个 preCounter 来记录之前的 props 传来的值<br>      preCounter: <span class="hljs-number">0</span>,<br>      counter: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>  static getDerivedStateFromProps(props, <span class="hljs-keyword">state</span>) &#123;<br>    // 跟 <span class="hljs-keyword">state</span>.preCounter 进行比较<br>    if (props.counter !== <span class="hljs-keyword">state</span>.preCounter) &#123;<br>      return &#123;<br>        counter: props.counter,<br>        preCounter: props.counter<br>      &#125;<br>    &#125;<br>    return null<br>  &#125;<br>  handleClick = () =&gt; &#123;<br>    this.<span class="hljs-built_in">set</span>State(&#123;<br>      counter: this.<span class="hljs-keyword">state</span>.counter + <span class="hljs-number">1</span><br>    &#125;)<br>  &#125;<br>  render() &#123;<br>    return (<br>      <span class="hljs-variable">&lt;div&gt;</span><br>        <span class="hljs-variable">&lt;h1 onClick=&#123;this.handleClick&#125;&gt;</span>Hello, world!&#123;this.<span class="hljs-keyword">state</span>.counter&#125;&lt;/h1&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>（3）render</strong><br>render是React 中最核心的方法，一个组件中必须要有这个方法，它会根据状态 state 和属性 props 渲染组件。这个函数只做一件事，就是返回需要渲染的内容，所以不要在这个函数内做其他业务逻辑，通常调用该方法会返回以下类型中一个：<br>●<strong>React 元素</strong>：这里包括原生的 DOM 以及 React 组件；<br>●<strong>数组和 Fragment（片段）</strong>：可以返回多个元素；<br>●<strong>Portals（插槽）</strong>：可以将子元素渲染到不同的 DOM 子树种；<br>●<strong>字符串和数字</strong>：被渲染成 DOM 中的 text 节点；<br>●<strong>布尔值或 null</strong>：不渲染任何内容。<br><strong>（4）componentDidMount()</strong><br>componentDidMount()会在组件挂载后（插入 DOM 树中）立即调。该阶段通常进行以下操作：<br>●执行依赖于DOM的操作；<br>●发送网络请求；（官方建议）<br>●添加订阅消息（会在componentWillUnmount取消订阅）；</p>
<p>如果在 componentDidMount 中调用 setState ，就会触发一次额外的渲染，多调用了一次 render 函数，由于它是在浏览器刷新屏幕前执行的，所以用户对此是没有感知的，但是我应当避免这样使用，这样会带来一定的性能问题，尽量是在 constructor 中初始化 state 对象。</p>
<p>在组件装载之后，将计数数字变为1：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>  </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props)<br>    <span class="hljs-keyword">this</span>.state = &#123;<br>      counter: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>  componentDidMount () &#123;<br>    <span class="hljs-keyword">this</span>.setState(&#123;<br>      counter: <span class="hljs-number">1</span><br>    &#125;)<br>  &#125;<br>  render ()  &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div className=<span class="hljs-string">&quot;counter&quot;</span>&gt;<br>        counter值: &#123; <span class="hljs-keyword">this</span>.state.counter &#125;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>2）组件更新阶段</strong><br>当组件的 props 改变了，或组件内部调用了 setState/forceUpdate，会触发更新重新渲染，这个过程可能会发生多次。这个阶段会依次调用下面这些方法：<br>●getDerivedStateFromProps<br>●shouldComponentUpdate<br>●render<br>●getSnapshotBeforeUpdate<br>●componentDidUpdate<br><strong>（1）shouldComponentUpdate</strong></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">should<span class="hljs-constructor">ComponentUpdate(<span class="hljs-params">nextProps</span>, <span class="hljs-params">nextState</span>)</span><br></code></pre></td></tr></table></figure>
<p>在说这个生命周期函数之前，来看两个问题：<br><strong>●setState 函数在任何情况下都会导致组件重新渲染吗？例如下面这种情况：</strong></p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">this.<span class="hljs-built_in">set</span>State(&#123;number: this.<span class="hljs-keyword">state</span>.number&#125;)<br></code></pre></td></tr></table></figure>
<p><strong>●如果没有调用 setState，props 值也没有变化，是不是组件就不会重新渲染？</strong></p>
<p>第一个问题答案是 <strong>会</strong> ，第二个问题如果是父组件重新渲染时，不管传入的 props 有没有变化，都会引起子组件的重新渲染。</p>
<p>那么有没有什么方法解决在这两个场景下不让组件重新渲染进而提升性能呢？这个时候 shouldComponentUpdate 登场了，这个生命周期函数是用来提升速度的，它是在重新渲染组件开始前触发的，默认返回 true，可以比较 this.props 和 nextProps ，this.state 和 nextState 值是否变化，来确认返回 true 或者 false。当返回 false 时，组件的更新过程停止，后续的 render、componentDidUpdate 也不会被调用。</p>
<p>注意：添加 shouldComponentUpdate 方法时，不建议使用深度相等检查（如使用 JSON.stringify()），因为深比较效率很低，可能会比重新渲染组件效率还低。而且该方法维护比较困难，建议使用该方法会产生明显的性能提升时使用。<br><strong>（2）getSnapshotBeforeUpdate</strong></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">get<span class="hljs-constructor">SnapshotBeforeUpdate(<span class="hljs-params">prevProps</span>, <span class="hljs-params">prevState</span>)</span><br></code></pre></td></tr></table></figure>
<p>这个方法在 render 之后，componentDidUpdate 之前调用，有两个参数 prevProps 和 prevState，表示更新之前的 props 和 state，这个函数必须要和 componentDidUpdate 一起使用，并且要有一个返回值，默认是 null，这个返回值作为第三个参数传给 componentDidUpdate。<br><strong>（3）componentDidUpdate</strong><br>componentDidUpdate() 会在更新后会被立即调用，首次渲染不会执行此方法。 该阶段通常进行以下操作：<br>●当组件更新后，对 DOM 进行操作；<br>●如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求；（例如，当 props 未发生变化时，则不会执行网络请求）。 </p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">component<span class="hljs-constructor">DidUpdate(<span class="hljs-params">prevProps</span>, <span class="hljs-params">prevState</span>, <span class="hljs-params">snapshot</span>)</span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>该方法有三个参数：<br>●prevProps: 更新前的props<br>●prevState: 更新前的state<br>●snapshot: getSnapshotBeforeUpdate()生命周期的返回值<br><strong>3）组件卸载阶段</strong><br>卸载阶段只有一个生命周期函数，componentWillUnmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作：<br>●清除 timer，取消网络请求或清除<br>●取消在 componentDidMount() 中创建的订阅等；<br>这个生命周期在一个组件被卸载和销毁之前被调用，因此你不应该再这个方法中使用 setState，因为组件一旦被卸载，就不会再装载，也就不会重新渲染。<br><strong>4）错误处理阶段</strong><br>componentDidCatch(error, info)，此生命周期在后代组件抛出错误后被调用。 它接收两个参数∶<br>●error：抛出的错误。<br>●info：带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息</p>
<p>React常见的生命周期如下：<br><img src="/imageO/react5.png" srcset="/img/loading.gif" lazyload alt="生命周期"><br><strong>React常见生命周期的过程大致如下：</strong><br>●挂载阶段，首先执行constructor构造方法，来创建组件<br>●创建完成之后，就会执行render方法，该方法会返回需要渲染的内容<br>●随后，React会将需要渲染的内容挂载到DOM树上<br><strong>●挂载完成之后就会执行componentDidMount生命周期函数</strong><br>●如果我们给组件创建一个props（用于组件通信）、调用setState（更改state中的数据）、调用forceUpdate（强制更新组件）时，都会重新调用render函数<br>●render函数重新执行之后，就会重新进行DOM树的挂载<br><strong>●挂载完成之后就会执行componentDidUpdate生命周期函数</strong><br><strong>●当移除组件时，就会执行componentWillUnmount生命周期函数</strong></p>
<p><strong>React主要生命周期总结：</strong><br><strong>1.getDefaultProps</strong>：这个函数会在组件创建之前被调用一次（有且仅有一次），它被用来初始化组件的 Props；<br><strong>2.getInitialState</strong>：用于初始化组件的 state 值；<br><strong>3.componentWillMount</strong>：在组件创建后、render 之前，会走到 componentWillMount 阶段。这个阶段我个人一直没用过、非常鸡肋。后来React 官方已经不推荐大家在 componentWillMount 里做任何事情、到现在 React16 直接废弃了这个生命周期，足见其鸡肋程度了；<br><strong>4.render</strong>：这是所有生命周期中唯一一个你必须要实现的方法。一般来说需要返回一个 jsx 元素，这时 React 会根据 props 和 state 来把组件渲染到界面上；不过有时，你可能不想渲染任何东西，这种情况下让它返回 null 或者 false 即可；<br><strong>5.componentDidMount</strong>：会在组件挂载后（插入 DOM 树中后）立即调用，标志着组件挂载完成。一些操作如果依赖获取到 DOM 节点信息，我们就会放在这个阶段来做。此外，这还是 React 官方推荐的发起 ajax 请求的时机。该方法和 componentWillMount 一样，有且仅有一次调用。</p>
<h4 id="2-React-废弃了哪些生命周期？为什么？"><a href="#2-React-废弃了哪些生命周期？为什么？" class="headerlink" title="2. React 废弃了哪些生命周期？为什么？"></a>2. React 废弃了哪些生命周期？为什么？</h4><h4 id="3-React-16-X-中-props-改变后在哪个生命周期中处理"><a href="#3-React-16-X-中-props-改变后在哪个生命周期中处理" class="headerlink" title="3. React 16.X 中 props 改变后在哪个生命周期中处理"></a>3. React 16.X 中 props 改变后在哪个生命周期中处理</h4><h4 id="4-React-性能优化在哪个生命周期？它优化的原理是什么？"><a href="#4-React-性能优化在哪个生命周期？它优化的原理是什么？" class="headerlink" title="4. React 性能优化在哪个生命周期？它优化的原理是什么？"></a>4. React 性能优化在哪个生命周期？它优化的原理是什么？</h4><h4 id="5-state-和-props-触发更新的生命周期分别有什么区别？"><a href="#5-state-和-props-触发更新的生命周期分别有什么区别？" class="headerlink" title="5. state 和 props 触发更新的生命周期分别有什么区别？"></a>5. state 和 props 触发更新的生命周期分别有什么区别？</h4><h4 id="6-React中发起网络请求应该在哪个生命周期中进行？为什么？"><a href="#6-React中发起网络请求应该在哪个生命周期中进行？为什么？" class="headerlink" title="6. React中发起网络请求应该在哪个生命周期中进行？为什么？"></a>6. React中发起网络请求应该在哪个生命周期中进行？为什么？</h4><h4 id="7-React-16中新生命周期有哪些"><a href="#7-React-16中新生命周期有哪些" class="headerlink" title="7. React 16中新生命周期有哪些"></a>7. React 16中新生命周期有哪些</h4><p><a target="_blank" rel="noopener" href="https://www.yuque.com/cuggz/interview/pgw8v4#b75bdbe861c53e813f8f288f1fec6115">参考</a></p>
<h3 id="四、组件通信"><a href="#四、组件通信" class="headerlink" title="四、组件通信"></a>四、组件通信</h3><p>React组件间通信常见的几种情况:<br>●父组件向子组件通信<br>●子组件向父组件通信<br>●跨级组件通信<br>●非嵌套关系的组件通信</p>
<h4 id="1-父子组件的通信方式？"><a href="#1-父子组件的通信方式？" class="headerlink" title="1. 父子组件的通信方式？"></a>1. 父子组件的通信方式？</h4><p>父组件向子组件通信：父组件通过 props 向子组件传递需要的信息</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 子组件: Child</span><br><span class="hljs-keyword">const</span> Child = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>&#125;<br><span class="hljs-comment">// 父组件 Parent</span><br><span class="hljs-keyword">const</span> Parent = <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;react&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>子组件向父组件通信：: props+回调的方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 子组件: Child</span><br><span class="hljs-keyword">const</span> Child = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span>&#123;<br>  <span class="hljs-keyword">const</span> cb = <span class="hljs-function"><span class="hljs-params">msg</span> =&gt;</span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">()=&gt;</span>&#123;<br>          props.callback(msg)<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>      &lt;button onClick=&#123;cb(<span class="hljs-string">&quot;你好!&quot;</span>)&#125;&gt;你好&lt;/button&gt;<br>  )<br>&#125;<br><span class="hljs-comment">// 父组件 Parent</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">callback</span>(<span class="hljs-params">msg</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(msg)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">callback</span>=<span class="hljs-string">&#123;this.callback.bind(this)&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="2-跨级组件的通信方式？"><a href="#2-跨级组件的通信方式？" class="headerlink" title="2. 跨级组件的通信方式？"></a>2. 跨级组件的通信方式？</h4><p>父组件向子组件的子组件通信，向更深层子组件通信：<br>●使用props，利用中间组件层层传递,但是如果父组件结构较深，那么中间每一层组件都要去传递props，增加了复杂度，并且这些props并不是中间组件自己需要的。<br>●使用context，context相当于一个大容器，可以把要通信的内容放在这个容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用context实现。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// context方式实现跨级组件通信 </span><br><span class="hljs-comment">// Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据</span><br>const <span class="hljs-type">BatteryContext</span> = createContext();<br><span class="hljs-comment">//  子组件的子组件 </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GrandChild</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>    render()&#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;<span class="hljs-type">BatteryContext</span>.<span class="hljs-type">Consumer</span>&gt;<br>                &#123;<br>                    color =&gt; &lt;h1 style=&#123;&#123;<span class="hljs-string">&quot;color&quot;</span>:color&#125;&#125;&gt;我是红色的:&#123;color&#125;&lt;/h1&gt;<br>                &#125;<br>            &lt;/<span class="hljs-type">BatteryContext</span>.<span class="hljs-type">Consumer</span>&gt;<br>        )<br>    &#125;<br>&#125;<br><span class="hljs-comment">//  子组件</span><br>const <span class="hljs-type">Child</span> = () =&gt;&#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;<span class="hljs-type">GrandChild</span>/&gt;<br>    )<br>&#125;<br><span class="hljs-comment">// 父组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>      state = &#123;<br>          color:<span class="hljs-string">&quot;red&quot;</span><br>      &#125;<br>      render()&#123;<br>          const &#123;color&#125; = <span class="hljs-keyword">this</span>.state<br>          <span class="hljs-keyword">return</span> (<br>          &lt;<span class="hljs-type">BatteryContext</span>.<span class="hljs-type">Provider</span> value=&#123;color&#125;&gt;<br>              &lt;<span class="hljs-type">Child</span>&gt;&lt;/<span class="hljs-type">Child</span>&gt;<br>          &lt;/<span class="hljs-type">BatteryContext</span>.<span class="hljs-type">Provider</span>&gt;<br>          )<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-非嵌套关系组件的通信方式？"><a href="#3-非嵌套关系组件的通信方式？" class="headerlink" title="3. 非嵌套关系组件的通信方式？"></a>3. 非嵌套关系组件的通信方式？</h4><p>即没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。<br>●可以使用自定义事件通信（发布订阅模式）<br>●可以通过redux等进行全局状态管理<br>●如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点, 结合父子间通信方式进行通信。</p>
<h4 id="4-如何解决-props-层级过深的问题"><a href="#4-如何解决-props-层级过深的问题" class="headerlink" title="4. 如何解决 props 层级过深的问题"></a>4. 如何解决 props 层级过深的问题</h4><p>●使用Context API：提供一种组件之间的状态共享，而不必通过显式组件树逐层传递props；<br>●使用Redux等状态库。</p>
<h4 id="5-组件通信的方式有哪些"><a href="#5-组件通信的方式有哪些" class="headerlink" title="5. 组件通信的方式有哪些"></a>5. 组件通信的方式有哪些</h4><p><strong>●⽗组件向⼦组件通讯</strong>: ⽗组件可以向⼦组件通过传 props 的⽅式，向⼦组件进⾏通讯<br><strong>●⼦组件向⽗组件通讯</strong>: props+回调的⽅式，⽗组件向⼦组件传递props进⾏通讯，此props为作⽤域为⽗组件⾃身的函 数，⼦组件调⽤该函数，将⼦组件想要传递的信息，作为参数，传递到⽗组件的作⽤域中<br>●兄弟组件通信: 找到这两个兄弟节点共同的⽗节点,结合上⾯两种⽅式由⽗节点转发信息进⾏通信<br><strong>●跨层级通信</strong>: Context 设计⽬的是为了共享那些对于⼀个组件树⽽⾔是“全局”的数据，例如当前认证的⽤户、主题或⾸选语⾔，对于跨越多层的全局数据通过 Context 通信再适合不过<br><strong>●发布订阅模式</strong>: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引⼊event模块进⾏通信<br><strong>●全局状态管理⼯具</strong>: 借助Redux或者Mobx等全局状态管理⼯具进⾏通信,这种⼯具会维护⼀个全局状态中⼼Store,并根据不同的事件产⽣新的状态</p>
<h3 id="五、路由"><a href="#五、路由" class="headerlink" title="五、路由"></a>五、路由</h3><h4 id="1-React-Router的实现原理是什么？"><a href="#1-React-Router的实现原理是什么？" class="headerlink" title="1. React-Router的实现原理是什么？"></a>1. React-Router的实现原理是什么？</h4><p>客户端路由实现的思想：<br>●基于 hash 的路由：通过监听hashchange事件，感知 hash 的变化<br>○改变 hash 可以直接通过 location.hash=xxx<br>●基于 H5 history 路由：<br>○改变 url 可以通过 history.pushState 和 resplaceState 等，会将URL压入堆栈，同时能够应用 history.go() 等 API<br>○监听 url 的变化可以通过自定义事件触发实现</p>
<p><strong>react-router 实现的思想：</strong><br>●基于 history 库来实现上述不同的客户端路由实现思想，并且能够保存历史记录等，磨平浏览器差异，上层无感知<br>●通过维护的列表，在每次 URL 发生变化的回收，通过配置的 路由路径，匹配到对应的 Component，并且 render</p>
<h4 id="2-如何配置-React-Router-实现路由切换"><a href="#2-如何配置-React-Router-实现路由切换" class="headerlink" title="2. 如何配置 React-Router 实现路由切换"></a>2. 如何配置 React-Router 实现路由切换</h4><p><strong>（1）使用<code>&lt;Route&gt;</code>组件</strong><br>路由匹配是通过比较<code> &lt;Route&gt;</code> 的 path 属性和当前地址的 pathname 来实现的。当一个<code> &lt;Route&gt;</code> 匹配成功时，它将渲染其内容，当它不匹配时就会渲染 null。没有路径的 <code>&lt;Route&gt; </code>将始终被匹配。</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">// when location = </span><span class="hljs-template-variable">&#123; pathname: &#x27;/about&#x27; &#125;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#x27;/about&#x27;</span> <span class="hljs-attr">component</span>=</span></span><span class="hljs-template-variable">&#123;About&#125;</span><span class="xml"><span class="hljs-tag">/&gt;</span> // renders <span class="hljs-tag">&lt;<span class="hljs-name">About</span>/&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#x27;/contact&#x27;</span> <span class="hljs-attr">component</span>=</span></span><span class="hljs-template-variable">&#123;Contact&#125;</span><span class="xml"><span class="hljs-tag">/&gt;</span> // renders null</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">component</span>=</span></span><span class="hljs-template-variable">&#123;Always&#125;</span><span class="xml"><span class="hljs-tag">/&gt;</span> // renders <span class="hljs-tag">&lt;<span class="hljs-name">Always</span>/&gt;</span></span><br></code></pre></td></tr></table></figure>
<p><strong>（2）结合使用 <code>&lt;Switch&gt;</code> 组件和 <code>&lt;Route&gt;</code> 组件</strong><br><code>&lt;Switch&gt;</code> 用于将 <code>&lt;Route&gt;</code> 分组。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Home&#125;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/about&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;About&#125;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/contact&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Contact&#125;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>&lt;Switch&gt;</code> 不是分组<code>&lt;Route&gt;</code>所必须的，但他通常很有用。 一个 <code>&lt;Switch&gt; </code>会遍历其所有的子 <code>&lt;Route&gt;</code>元素，并仅渲染与当前地址匹配的第一个元素。<br><strong>（3）使用<code> &lt;Link&gt;、 &lt;NavLink&gt;、&lt;Redirect&gt;</code> 组件</strong><br><code>&lt;Link&gt; </code>组件来在你的应用程序中创建链接。无论你在何处渲染一个<code> &lt;Link&gt;</code> ，都会在应用程序的 HTML 中渲染锚（<code>&lt;a&gt;</code>）。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&lt;<span class="hljs-keyword">Link</span> <span class="hljs-keyword">to</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;Home&lt;/<span class="hljs-keyword">Link</span>&gt;   <br><span class="hljs-comment">// &lt;a href=&#x27;/&#x27;&gt;Home&lt;/a&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>&lt;NavLink&gt; </code>是一种特殊类型的 <code>&lt;Link&gt;</code> 当它的 to属性与当前地址匹配时，可以将其定义为”活跃的”。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> location = &#123; pathname: <span class="hljs-string">&#x27;/react&#x27;</span> &#125;<br>&lt;NavLink to=<span class="hljs-string">&quot;/react&quot;</span> activeClassName=<span class="hljs-string">&quot;hurray&quot;</span>&gt;<br>    React<br>&lt;/NavLink&gt;<br><span class="hljs-regexp">//</span> &lt;a href=<span class="hljs-string">&#x27;/react&#x27;</span> className=<span class="hljs-string">&#x27;hurray&#x27;</span>&gt;React&lt;/a&gt;<br></code></pre></td></tr></table></figure>
<p>当我们想强制导航时，可以渲染一个<code>&lt;Redirect&gt;</code>，当一个<code>&lt;Redirect&gt;</code>渲染时，它将使用它的to属性进行定向</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">from</span>=<span class="hljs-string">&#x27;/users/:id&#x27;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#x27;/users/profile/:id&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#x27;/users/profile/:id&#x27;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Profile&#125;/</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>当我们想强制导航时，可以渲染一个<code>&lt;Redirect&gt;</code>，当一个<code>&lt;Redirect&gt;</code>渲染时，它将使用它的to属性进行定向。</p>
<h4 id="3-React-Router怎么设置重定向？"><a href="#3-React-Router怎么设置重定向？" class="headerlink" title="3. React-Router怎么设置重定向？"></a>3. React-Router怎么设置重定向？</h4><p>使用<code>&lt;Redirect&gt;</code>组件实现路由的重定向：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Redirect</span> <span class="hljs-attr">from</span>=<span class="hljs-string">&#x27;/users/:id&#x27;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#x27;/users/profile/:id&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#x27;/users/profile/:id&#x27;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Profile&#125;/</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>当请求 /users/:id 被重定向去 ‘/users/profile/:id’：<br>●属性 from: string：需要匹配的将要被重定向路径。<br>●属性 to: string：重定向的 URL 字符串<br>●属性 to: object：重定向的 location 对象<br>●属性 push: bool：若为真，重定向操作将会把新地址加入到访问历史记录里面，并且无法回退到前面的页面。</p>
<h4 id="4-react-router-里的-Link-标签和-a-标签的区别"><a href="#4-react-router-里的-Link-标签和-a-标签的区别" class="headerlink" title="4. react-router 里的 Link 标签和 a 标签的区别"></a>4. react-router 里的 Link 标签和 a 标签的区别</h4><p>从最终渲染的 DOM 来看，这两者都是链接，都是 标签，区别是∶<br><code>&lt;Link&gt;</code>是react-router 里实现路由跳转的链接，一般配合<code>&lt;Route&gt; </code>使用，react-router接管了其默认的链接跳转行为，区别于传统的页面跳转，<code>&lt;Link&gt;</code> 的“跳转”行为只会触发相匹配的<code>&lt;Route&gt;</code>对应的页面内容更新，而不会刷新整个页面。</p>
<p><code>&lt;Link&gt;</code>做了3件事情:<br>●有onclick那就执行onclick<br>●click的时候阻止a标签默认事件<br>●根据跳转href(即是to)，用history (web前端路由两种方式之一，history &amp; hash)跳转，此时只是链接变了，并没有刷新页面而<code>&lt;a&gt;</code>标签就是普通的超链接了，用于从当前页面跳转到href指向的另一 个页面(非锚点情况)。</p>
<p>a标签默认事件禁掉之后做了什么才实现了跳转?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> domArr = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;a&#x27;</span>)<br>[...domArr].forEach(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>    item.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        location.href = <span class="hljs-built_in">this</span>.href<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>
<h4 id="5-React-Router如何获取URL的参数和历史对象？"><a href="#5-React-Router如何获取URL的参数和历史对象？" class="headerlink" title="5. React-Router如何获取URL的参数和历史对象？"></a>5. React-Router如何获取URL的参数和历史对象？</h4><p>（1）获取URL的参数<br><strong>●get传值</strong><br>路由配置还是普通的配置，如：’admin’，传参方式如：’admin?id=’1111’’。通过this.props.location.search获取url获取到一个字符串’?id=’1111’<br>可以用url，qs，querystring，浏览器提供的api URLSearchParams对象或者自己封装的方法去解析出id的值。<br><strong>●动态路由传值</strong><br>路由需要配置成动态路由：如path=’/admin/:id’，传参方式，如’admin/111’。通过this.props.match.params.id 取得url中的动态路由id部分的值，除此之外还可以通过useParams（Hooks）来获取<br><strong>●通过query或state传值</strong><br>传参方式如：在Link组件的to属性中可以传递对象{pathname:’/admin’,query:’111’,state:’111’};。通过this.props.location.state或this.props.location.query来获取即可，传递的参数可以是对象、数组等，但是存在缺点就是只要刷新页面，参数就会丢失。<br><strong>（2）获取历史对象</strong><br>●如果React &gt;= 16.8 时可以使用 React Router中提供的Hooks</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123; useHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;<br><span class="hljs-keyword">let</span> history = useHistory();<br></code></pre></td></tr></table></figure>
<p>2.使用this.props.history获取历史对象</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> <span class="hljs-built_in">history</span> = this.props.history;<br></code></pre></td></tr></table></figure>
<h4 id="6-React-Router-4怎样在路由变化时重新渲染同一个组件？"><a href="#6-React-Router-4怎样在路由变化时重新渲染同一个组件？" class="headerlink" title="6. React-Router 4怎样在路由变化时重新渲染同一个组件？"></a>6. React-Router 4怎样在路由变化时重新渲染同一个组件？</h4><p>当路由变化时，即组件的props发生了变化，会调用componentWillReceiveProps等生命周期钩子。那需要做的只是： 当路由改变时，根据路由，也去请求数据：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewsList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  componentDidMount () &#123;<br>     <span class="hljs-keyword">this</span>.fetchData(<span class="hljs-keyword">this</span>.props.location);<br>  &#125;<br>  <br>  fetchData(location) &#123;<br>    const <span class="hljs-class"><span class="hljs-keyword">type</span> </span>= location.pathname.replace(&#x27;/&#x27;, &#x27;&#x27;) || <span class="hljs-symbol">&#x27;to</span>p&#x27;<br>    <span class="hljs-keyword">this</span>.props.dispatch(fetchListData(<span class="hljs-class"><span class="hljs-keyword">type</span>))</span><br><span class="hljs-class">  &#125;</span><br><span class="hljs-class">  <span class="hljs-title">componentWillReceiveProps</span>(<span class="hljs-params">nextProps</span>) </span>&#123;<br>     <span class="hljs-keyword">if</span> (nextProps.location.pathname != <span class="hljs-keyword">this</span>.props.location.pathname) &#123;<br>         <span class="hljs-keyword">this</span>.fetchData(nextProps.location);<br>     &#125; <br>  &#125;<br>  render () &#123;<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>利用生命周期componentWillReceiveProps，进行重新render的预处理操作。</p>
<h4 id="7-React-Router的路由有几种模式？"><a href="#7-React-Router的路由有几种模式？" class="headerlink" title="7. React-Router的路由有几种模式？"></a>7. React-Router的路由有几种模式？</h4><p>React-Router 支持使用 hash（对应 HashRouter）和 browser（对应 BrowserRouter） 两种路由规则， react-router-dom 提供了 BrowserRouter 和 HashRouter 两个组件来实现应用的 UI 和 URL 同步：<br>●BrowserRouter 创建的 URL 格式：<a target="_blank" rel="noopener" href="http://xxx.com/path">http://xxx.com/path</a><br>●HashRouter 创建的 URL 格式：<a target="_blank" rel="noopener" href="http://xxx.com/#/path">http://xxx.com/#/path</a></p>
<p><strong>（1）BrowserRouter</strong><br>它使用 HTML5 提供的 history API（pushState、replaceState 和 popstate 事件）来保持 UI 和 URL 的同步。由此可以看出，<strong>BrowserRouter 是使用 HTML 5 的 history API 来控制路由跳转的</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;BrowserRouter<br>    basename=&#123;string&#125;<br>    forceRefresh=&#123;bool&#125;<br>    getUserConfirmation=&#123;func&#125;<br>    keyLength=&#123;number&#125;<br>/&gt;<br></code></pre></td></tr></table></figure>
<p>其中的属性如下：<br>●basename 所有路由的基准 URL。basename 的正确格式是前面有一个前导斜杠，但不能有尾部斜杠；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span> <span class="hljs-attr">basename</span>=<span class="hljs-string">&quot;/calendar&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/today&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/calendar/today&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<p>●forceRefresh 如果为 true，在导航的过程中整个页面将会刷新。一般情况下，只有在不支持 HTML5 history API 的浏览器中使用此功能；<br>●getUserConfirmation 用于确认导航的函数，默认使用 window.confirm。例如，当从 /a 导航至 /b 时，会使用默认的 confirm 函数弹出一个提示，用户点击确定后才进行导航，否则不做任何处理；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这是默认的确认函数</span><br><span class="hljs-keyword">const</span> getConfirmation = <span class="hljs-function">(<span class="hljs-params">message, callback</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> allowTransition = <span class="hljs-built_in">window</span>.confirm(message);<br>  callback(allowTransition);<br>&#125;<br>&lt;BrowserRouter getUserConfirmation=&#123;getConfirmation&#125; /&gt;<br></code></pre></td></tr></table></figure>
<p>需要配合<code>&lt;Prompt&gt;</code> 一起使用。<br>●KeyLength 用来设置 Location.Key 的长度。</p>
<p><strong>（2）HashRouter</strong><br>使用 URL 的 hash 部分（即 window.location.hash）来保持 UI 和 URL 的同步。由此可以看出，<strong>HashRouter 是通过 URL 的 hash 属性来控制路由跳转的：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;HashRouter<br>    basename=&#123;string&#125;<br>    getUserConfirmation=&#123;func&#125;<br>    hashType=&#123;string&#125;  <br>/&gt;<br></code></pre></td></tr></table></figure>
<p>其中的参数如下：<br>●basename, getUserConfirmation 和 BrowserRouter 功能一样；<br>●hashType window.location.hash 使用的 hash 类型，有如下几种：<br>  ○ slash - 后面跟一个斜杠，例如 #/ 和 #/sunshine/lollipops；<br>  ○ noslash - 后面没有斜杠，例如 # 和 #sunshine/lollipops；<br>  ○ hashbang - Google 风格的 ajax crawlable，例如 #!/ 和 #!/sunshine/lollipops。</p>
<h4 id="8-React-Router-4的Switch有什么用？"><a href="#8-React-Router-4的Switch有什么用？" class="headerlink" title="8. React-Router 4的Switch有什么用？"></a>8. React-Router 4的Switch有什么用？</h4><p>Switch 通常被用来包裹 Route，用于渲染与路径匹配的第一个子 <code>&lt;Route&gt;</code> 或 <code>&lt;Redirect&gt;</code>，它里面不能放其他元素。</p>
<p>假如不加<code>&lt;Switch&gt;</code>：</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">import </span><span class="hljs-template-variable">&#123; Route &#125;</span><span class="xml"> from &#x27;react-router-dom&#x27;</span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">component</span>=</span></span><span class="hljs-template-variable">&#123;Home&#125;</span><span class="xml"><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">component</span>=</span></span><span class="hljs-template-variable">&#123;Login&#125;</span><span class="xml"><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br></code></pre></td></tr></table></figure>
<p>Route 组件的 path 属性用于匹配路径，因为需要匹配 / 到 Home，匹配 /login 到 Login，所以需要两个 Route，但是不能这么写。这样写的话，当 URL 的 path 为 “/login” 时，<code>&lt;Route path=&quot;/&quot; /&gt;和&lt;Route path=&quot;/login&quot; /&gt; </code>都会被匹配，因此页面会展示 Home 和 Login 两个组件。这时就需要借助 <code>&lt;Switch&gt;</code> 来做到只显示一个匹配组件：</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">import </span><span class="hljs-template-variable">&#123; Switch, Route&#125;</span><span class="xml"> from &#x27;react-router-dom&#x27;</span><br><span class="xml">    </span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">component</span>=</span></span><span class="hljs-template-variable">&#123;Home&#125;</span><span class="xml"><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">component</span>=</span></span><span class="hljs-template-variable">&#123;Login&#125;</span><span class="xml"><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span></span><br></code></pre></td></tr></table></figure>
<h3 id="六、Redux"><a href="#六、Redux" class="headerlink" title="六、Redux"></a>六、Redux</h3><h4 id="1-对-Redux-的理解，主要解决什么问题"><a href="#1-对-Redux-的理解，主要解决什么问题" class="headerlink" title="1. 对 Redux 的理解，主要解决什么问题"></a>1. 对 Redux 的理解，主要解决什么问题</h4><p>React是视图层框架。Redux是一个用来管理数据状态和UI状态的JavaScript应用工具。随着JavaScript单页应用（SPA）开发日趋复杂， JavaScript需要管理比任何时候都要多的state（状态）， Redux就是降低管理难度的。（Redux支持React、Angular、jQuery甚至纯JavaScript）。</p>
<p>在 React 中，UI 以组件的形式来搭建，组件之间可以嵌套组合。但 React 中组件间通信的数据流是单向的，顶层组件可以通过 props 属性向下层组件传递数据，而下层组件不能向上层组件传递数据，兄弟组件之间同样不能。这样简单的单向数据流支撑起了 React 中的数据可控性。</p>
<p>当项目越来越大的时候，管理数据的事件或回调函数将越来越多，也将越来越不好管理。管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等。state 的管理在大项目中相当复杂。</p>
<p>Redux 提供了一个叫 store 的统一仓储库，组件通过 dispatch 将 state 直接传入store，不用通过其他的组件。并且组件通过 subscribe 从 store获取到 state 的改变。使用了 Redux，所有的组件都可以从 store 中获取到所需的 state，他们也能从store 获取到 state 的改变。这比组件之间互相传递数据清晰明朗的多。</p>
<p><strong>主要解决的问题：</strong><br>单纯的Redux只是一个状态机，是没有UI呈现的，react- redux作用是将Redux的状态机和React的UI呈现绑定在一起，当你dispatch action改变state的时候，会自动更新页面。</p>
<h4 id="2-Redux-原理及工作流程"><a href="#2-Redux-原理及工作流程" class="headerlink" title="2. Redux 原理及工作流程"></a>2. Redux 原理及工作流程</h4><p><strong>（1）原理</strong><br>Redux源码主要分为以下几个模块文件<br>●compose.js 提供从右到左进行函数式编程<br>●createStore.js 提供作为生成唯一store的函数<br>●combineReducers.js 提供合并多个reducer的函数，保证store的唯一性<br>●bindActionCreators.js 可以让开发者在不直接接触dispacth的前提下进行更改state的操作<br>●applyMiddleware.js 这个方法通过中间件来增强dispatch的功能</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> actionTypes = &#123;<br>    ADD: <span class="hljs-string">&#x27;ADD&#x27;</span>,<br>    CHANGEINFO: <span class="hljs-string">&#x27;CHANGEINFO&#x27;</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> initState = &#123;<br>    info: <span class="hljs-string">&#x27;初始化&#x27;</span>,<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initReducer</span>(<span class="hljs-params">state=initState, action</span>) </span>&#123;<br>    <span class="hljs-keyword">switch</span>(action.type) &#123;<br>        <span class="hljs-keyword">case</span> actionTypes.CHANGEINFO:<br>            <span class="hljs-keyword">return</span> &#123;<br>                ...state,<br>                info: action.preload.info || <span class="hljs-string">&#x27;&#x27;</span>,<br>            &#125;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> &#123; ...state &#125;;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createStore</span>(<span class="hljs-params">reducer, initialState, middleFunc</span>) </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (initialState &amp;&amp; <span class="hljs-keyword">typeof</span> initialState === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        middleFunc = initialState;<br>        initialState = <span class="hljs-literal">undefined</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> currentState = initialState;<br><br>    <span class="hljs-keyword">const</span> listeners = [];<br><br>    <span class="hljs-keyword">if</span> (middleFunc &amp;&amp; <span class="hljs-keyword">typeof</span> middleFunc === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 封装dispatch </span><br>        <span class="hljs-keyword">return</span> middleFunc(createStore)(reducer, initialState);<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> getState = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> currentState;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> dispatch = <span class="hljs-function">(<span class="hljs-params">action</span>) =&gt;</span> &#123;<br>        currentState = reducer(currentState, action);<br><br>        listeners.forEach(<span class="hljs-function"><span class="hljs-params">listener</span> =&gt;</span> &#123;<br>            listener();<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> subscribe = <span class="hljs-function">(<span class="hljs-params">listener</span>) =&gt;</span> &#123;<br>        listeners.push(listener);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &#123;<br>        getState,<br>        dispatch,<br>        subscribe<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>（2）工作流程</strong><br>●const store= createStore（fn）生成数据;<br>●action: {type: Symble(‘action01), payload:’payload’ }定义行为;<br>●dispatch发起action：store.dispatch(doSomething(‘action001’));<br>●reducer：处理action，返回新的state;</p>
<p>通俗点解释：<br>●首先，用户（通过View）发出Action，发出方式就用到了dispatch方法<br>●然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State<br>●State—旦有变化，Store就会调用监听函数，来更新View</p>
<p>以 store 为核心，可以把它看成数据存储中心，但是他要更改数据的时候不能直接修改，数据修改更新的角色由Reducers来担任，store只做存储，中间人，当Reducers的更新完成以后会通过store的订阅来通知react component，组件把新的状态重新获取渲染，组件中也能主动发送action，创建action后这个动作是不会执行的，所以要dispatch这个action，让store通过reducers去做更新React Component 就是react的每个组件。</p>
<h4 id="3-Redux-中异步的请求怎么处理"><a href="#3-Redux-中异步的请求怎么处理" class="headerlink" title="3. Redux 中异步的请求怎么处理"></a>3. Redux 中异步的请求怎么处理</h4><p>可以在 componentDidmount 中直接进⾏请求⽆须借助redux。但是在⼀定规模的项⽬中,上述⽅法很难进⾏异步流的管理,通常情况下我们会借助redux的异步中间件进⾏异步处理。redux异步流中间件其实有很多，当下主流的异步中间件有两种redux-thunk、redux-saga。<br><strong>（1）使用react-thunk中间件</strong><br><strong>redux-thunk</strong>优点:<br>●体积⼩: redux-thunk的实现⽅式很简单,只有不到20⾏代码<br>●使⽤简单: redux-thunk没有引⼊像redux-saga或者redux-observable额外的范式,上⼿简单<br><strong>redux-thunk</strong>缺陷:<br>●样板代码过多: 与redux本身⼀样,通常⼀个请求需要⼤量的代码,⽽且很多都是重复性质的<br>●耦合严重: 异步操作与redux的action偶合在⼀起,不⽅便管理<br>●功能孱弱: 有⼀些实际开发中常⽤的功能需要⾃⼰进⾏封装 </p>
<p>使用步骤：<br>●配置中间件，在store的创建中配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;createStore, applyMiddleware, compose&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducer&#x27;</span>;<br><span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span><br><br><span class="hljs-comment">// 设置调试工具</span><br><span class="hljs-keyword">const</span> composeEnhancers = <span class="hljs-built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? <span class="hljs-built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;) : compose;<br><span class="hljs-comment">// 设置中间件</span><br><span class="hljs-keyword">const</span> enhancer = composeEnhancers(<br>  applyMiddleware(thunk)<br>);<br><br><span class="hljs-keyword">const</span> store = createStore(reducer, enhancer);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure>
<p>●添加一个返回函数的actionCreator，将异步请求逻辑放在里面</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  发送get请求，并生成相应action，更新store的函数</span><br><span class="hljs-comment">  <span class="hljs-doctag">@param </span>url &#123;string&#125; 请求地址</span><br><span class="hljs-comment">  <span class="hljs-doctag">@param </span>func &#123;function&#125; 真正需要生成的action对应的actionCreator</span><br><span class="hljs-comment">  <span class="hljs-doctag">@return <span class="hljs-type">&#123;function&#125;</span> </span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// dispatch为自动接收的store.dispatch函数 </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getHttpAction = <span class="hljs-function">(<span class="hljs-params">url, func</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span> &#123;<br>    axios.get(url).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)</span>&#123;<br>        <span class="hljs-keyword">const</span> action = func(res.data)<br>        dispatch(action)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>●生成action，并发送action</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">componentDidMount</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-selector-tag">var</span> action = getHttpAction(<span class="hljs-string">&#x27;/getData&#x27;</span>, getInitTodoItemAction)<br>    <span class="hljs-comment">// 发送函数类型的action时，该action的函数体会自动执行</span><br>    store<span class="hljs-selector-class">.dispatch</span>(action)<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>（2）使用redux-saga中间件</strong><br><strong>redux-saga优点:</strong><br>●异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js 中<br>●action摆脱thunk function: dispatch 的参数依然是⼀个纯粹的 action (FSA)，⽽不是充满 “⿊魔法” thunk function<br>●异常处理: 受益于 generator function 的 saga 实现，代码异常/请求失败 都可以直接通过 try/catch 语法直接捕获处理<br>●功能强⼤: redux-saga提供了⼤量的Saga 辅助函数和Effect 创建器供开发者使⽤,开发者⽆须封装或者简单封装即可使⽤<br>●灵活: redux-saga可以将多个Saga可以串⾏/并⾏组合起来,形成⼀个⾮常实⽤的异步flow<br>●易测试，提供了各种case的测试⽅案，包括mock task，分⽀覆盖等等 </p>
<p><strong>redux-saga缺陷:</strong><br>●额外的学习成本: redux-saga不仅在使⽤难以理解的 generator function,⽽且有数⼗个API,学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和⼀整套思想<br>●体积庞⼤: 体积略⼤,代码近2000⾏，min版25KB左右<br>●功能过剩: 实际上并发控制等功能很难⽤到,但是我们依然需要引⼊这些代码<br>●ts⽀持不友好: yield⽆法返回TS类型 </p>
<p>redux-saga可以捕获action，然后执行一个函数，那么可以把异步代码放在这个函数中，使用步骤如下：<br>●配置中间件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;createStore, applyMiddleware, compose&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducer&#x27;</span>;<br><span class="hljs-keyword">import</span> createSagaMiddleware <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-saga&#x27;</span><br><span class="hljs-keyword">import</span> TodoListSaga <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./sagas&#x27;</span><br><br><span class="hljs-keyword">const</span> composeEnhancers = <span class="hljs-built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? <span class="hljs-built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;) : compose;<br><span class="hljs-keyword">const</span> sagaMiddleware = createSagaMiddleware()<br><br><span class="hljs-keyword">const</span> enhancer = composeEnhancers(<br>  applyMiddleware(sagaMiddleware)<br>);<br><br><span class="hljs-keyword">const</span> store = createStore(reducer, enhancer);<br>sagaMiddleware.run(TodoListSaga)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure>
<p>●将异步请求放在sagas.js中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;takeEvery, put&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-saga/effects&#x27;</span><br><span class="hljs-keyword">import</span> &#123;initTodoList&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./actionCreator&#x27;</span><br><span class="hljs-keyword">import</span> &#123;GET_INIT_ITEM&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./actionTypes&#x27;</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">func</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-comment">// 可以获取异步返回数据</span><br>        <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> axios.get(<span class="hljs-string">&#x27;/getData&#x27;</span>)<br>        <span class="hljs-keyword">const</span> action = initTodoList(res.data)<br>        <span class="hljs-comment">// 将action发送到reducer</span><br>        <span class="hljs-keyword">yield</span> put(action)<br>    &#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;网络请求失败&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">mySaga</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// 自动捕获GET_INIT_ITEM类型的action，并执行func</span><br>    <span class="hljs-keyword">yield</span> takeEvery(GET_INIT_ITEM, func)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> mySaga<br></code></pre></td></tr></table></figure>
<p>●发送action</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">componentDidMount</span><span class="hljs-params">()</span></span>&#123;<br>  const action = getInitTodoItemAction()<br>  store<span class="hljs-selector-class">.dispatch</span>(action)<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="4-Redux-怎么实现属性传递，介绍下原理"><a href="#4-Redux-怎么实现属性传递，介绍下原理" class="headerlink" title="4. Redux 怎么实现属性传递，介绍下原理"></a>4. Redux 怎么实现属性传递，介绍下原理</h4><p>react-redux 数据传输∶ view–&gt;action–&gt;reducer–&gt;store–&gt;view。看下点击事件的数据是如何通过redux传到view上：<br>●view 上的AddClick 事件通过mapDispatchToProps 把数据传到action —&gt; click:()=&gt;dispatch(ADD)<br>●action 的ADD 传到reducer上<br>●reducer传到store上 const store = createStore(reducer);<br>●store再通过 mapStateToProps 映射穿到view上text:State.text</p>
<p>代码示例∶</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Provider, connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-redux&#x27;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">let</span> &#123; text, click, clickR &#125; = <span class="hljs-built_in">this</span>.props;<br>        <span class="hljs-keyword">return</span>(<br>            &lt;div&gt;<br>                &lt;div&gt;数据:已有人&#123;text&#125;&lt;/div&gt;<br>                &lt;div onClick=&#123;click&#125;&gt;加人&lt;/div&gt;<br>                &lt;div onClick=&#123;clickR&#125;&gt;减人&lt;/div&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> initialState = &#123;<br>    text:<span class="hljs-number">5</span><br>&#125;<br><span class="hljs-keyword">const</span> reducer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">state,action</span>)</span>&#123;<br>    <span class="hljs-keyword">switch</span>(action.type)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ADD&#x27;</span>:<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">text</span>:state.text+<span class="hljs-number">1</span>&#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;REMOVE&#x27;</span>:<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">text</span>:state.text-<span class="hljs-number">1</span>&#125;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> initialState;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ADD = &#123;<br>    type:<span class="hljs-string">&#x27;ADD&#x27;</span><br>&#125;<br><span class="hljs-keyword">let</span> Remove = &#123;<br>    type:<span class="hljs-string">&#x27;REMOVE&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> store = createStore(reducer);<br><br><span class="hljs-keyword">let</span> mapStateToProps = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        text:state.text<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> mapDispatchToProps = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">dispatch</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span>&#123;<br>        click:<span class="hljs-function">()=&gt;</span>dispatch(ADD),<br>        clickR:<span class="hljs-function">()=&gt;</span>dispatch(Remove)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> App1 = connect(mapStateToProps,mapDispatchToProps)(App);<br><br>ReactDOM.render(<br>    &lt;Provider store = &#123;store&#125;&gt;<br>        &lt;App1&gt;&lt;/App1&gt;<br>    &lt;/Provider&gt;,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>
<h4 id="5-Redux-中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？"><a href="#5-Redux-中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？" class="headerlink" title="5. Redux 中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？"></a>5. Redux 中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？</h4><p>Redux 的中间件提供的是位于 action 被发起之后，到达 reducer 之前的扩展点，换而言之，原本 view -→&gt; action -&gt; reducer -&gt; store 的数据流加上中间件后变成了 view -&gt; action -&gt; middleware -&gt; reducer -&gt; store ，在这一环节可以做一些”副作用”的操作，如异步请求、打印日志等。</p>
<p>applyMiddleware源码：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">export <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyMiddleware</span><span class="hljs-params">(<span class="hljs-rest_arg">...middlewares</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> createStore =&gt; (...args) =&gt; &#123;<br>        <span class="hljs-comment">// 利用传入的createStore和reducer和创建一个store</span><br>        <span class="hljs-keyword">const</span> store = createStore(...args)<br>        let dispatch = () =&gt; &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error()<br>        &#125;<br>        <span class="hljs-keyword">const</span> middlewareAPI = &#123;<br>            getState: store.getState,<br>            dispatch: (...args) =&gt; dispatch(...args)<br>        &#125;<br>        <span class="hljs-comment">// 让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍</span><br>        <span class="hljs-keyword">const</span> chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))<br>        <span class="hljs-comment">// 接着 compose 将 chain 中的所有匿名函数，组装成一个新的函数，即新的 dispatch</span><br>        dispatch = compose(...chain)(store.dispatch)<br>        <span class="hljs-keyword">return</span> &#123;<br>            ...store,<br>            dispatch<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从applyMiddleware中可以看出∶<br>●redux中间件接受一个对象作为参数，对象的参数上有两个字段 dispatch 和 getState，分别代表着 Redux Store 上的两个同名函数。<br>●柯里化函数两端一个是 middewares，一个是store.dispatch</p>
<h4 id="6-Redux-请求中间件如何处理并发"><a href="#6-Redux-请求中间件如何处理并发" class="headerlink" title="6. Redux 请求中间件如何处理并发"></a>6. Redux 请求中间件如何处理并发</h4><p>使用redux-Saga<br>redux-saga是一个管理redux应用异步操作的中间件，用于代替 redux-thunk 的。它通过创建 Sagas 将所有异步操作逻辑存放在一个地方进行集中处理，以此将react中的同步操作与异步操作区分开来，以便于后期的管理与维护。 redux-saga如何处理并发：<br><strong>●takeEvery</strong><br>可以让多个 saga 任务并行被 fork 执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;<br>    fork,<br>    take<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux-saga/effects&quot;</span><br><br><span class="hljs-keyword">const</span> takeEvery = <span class="hljs-function">(<span class="hljs-params">pattern, saga, ...args</span>) =&gt;</span> fork(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">const</span> action = <span class="hljs-keyword">yield</span> take(pattern)<br>        <span class="hljs-keyword">yield</span> fork(saga, ...args.concat(action))<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p><strong>●takeLatest</strong><br>takeLatest 不允许多个 saga 任务并行地执行。一旦接收到新的发起的 action，它就会取消前面所有 fork 过的任务（如果这些任务还在执行的话）。<br>在处理 AJAX 请求的时候，如果只希望获取最后那个请求的响应， takeLatest 就会非常有用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;<br>    cancel,<br>    fork,<br>    take<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux-saga/effects&quot;</span><br><br><span class="hljs-keyword">const</span> takeLatest = <span class="hljs-function">(<span class="hljs-params">pattern, saga, ...args</span>) =&gt;</span> fork(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> lastTask<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">const</span> action = <span class="hljs-keyword">yield</span> take(pattern)<br>        <span class="hljs-keyword">if</span> (lastTask) &#123;<br>            <span class="hljs-keyword">yield</span> cancel(lastTask) <span class="hljs-comment">// 如果任务已经结束，则 cancel 为空操作</span><br>        &#125;<br>        lastTask = <span class="hljs-keyword">yield</span> fork(saga, ...args.concat(action))<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<h4 id="7-Redux-状态管理器和变量挂载到-window-中有什么区别"><a href="#7-Redux-状态管理器和变量挂载到-window-中有什么区别" class="headerlink" title="7. Redux 状态管理器和变量挂载到 window 中有什么区别"></a>7. Redux 状态管理器和变量挂载到 window 中有什么区别</h4><p>两者都是存储数据以供后期使用。但是Redux状态更改可回溯——Time travel，数据多了的时候可以很清晰的知道改动在哪里发生，完整的提供了一套状态管理模式。</p>
<p>随着 JavaScript 单页应用开发日趋复杂，JavaScript 需要管理比任何时候都要多的 state （状态）。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。</p>
<p>管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。<br>如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等等。前端开发者正在经受前所未有的复杂性，难道就这么放弃了吗?当然不是。</p>
<p>这里的复杂性很大程度上来自于：我们总是将两个难以理清的概念混淆在一起：变化和异步。 可以称它们为曼妥思和可乐。如果把二者分开，能做的很好，但混到一起，就变得一团糟。一些库如 React 视图在视图层禁止异步和直接操作 DOM来解决这个问题。美中不足的是，React 依旧把处理 state 中数据的问题留给了你。Redux就是为了帮你解决这个问题。</p>
<h4 id="8-mobox-和-redux-有什么区别？"><a href="#8-mobox-和-redux-有什么区别？" class="headerlink" title="8. mobox 和 redux 有什么区别？"></a>8. mobox 和 redux 有什么区别？</h4><p><strong>（1）共同点</strong><br>●为了解决状态管理混乱，无法有效同步的问题统一维护管理应用状态;<br>●某一状态只有一个可信数据来源（通常命名为store，指状态容器）;<br>●操作更新状态方式统一，并且可控（通常以action方式提供更新状态的途径）;<br>●支持将store与React组件连接，如react-redux，mobx- react;<br><strong>（2）区别</strong><br>Redux更多的是遵循Flux模式的一种实现，是一个 JavaScript库，它关注点主要是以下几方面∶<br>●Action∶ 一个JavaScript对象，描述动作相关信息，主要包含type属性和payload属性∶<br>         o type∶ action 类型;<br>         o payload∶ 负载数据;<br>●Reducer∶ 定义应用状态如何响应不同动作（action），如何更新状态;<br>●Store∶ 管理action和reducer及其关系的对象，主要提供以下功能∶<br>         o 维护应用状态并支持访问状态(getState());<br>         o 支持监听action的分发，更新状态(dispatch(action));<br>         o 支持订阅store的变更(subscribe(listener));<br>●异步流∶ 由于Redux所有对store状态的变更，都应该通过action触发，异步任务（通常都是业务或获取数据任务）也不例外，而为了不将业务或数据相关的任务混入React组件中，就需要使用其他框架配合管理异步任务流程，如redux-thunk，redux-saga等; </p>
<p>Mobx是一个透明函数响应式编程的状态管理库，它使得状态管理简单可伸缩∶<br>●Action∶定义改变状态的动作函数，包括如何变更状态;<br>●Store∶ 集中管理模块状态（State）和动作(action)<br>●Derivation（衍生）∶ 从应用状态中派生而出，且没有任何其他影响的数据</p>
<p>对比总结：<br>●redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中<br>●redux使用plain object保存数据，需要手动处理变化后的操作;mobx适用observable保存数据，数据变化后自动处理响应的操作<br>●redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数;mobx中的状态是可变的，可以直接对其进行修改<br>●mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维;redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用<br>●mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测;而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易</p>
<h4 id="9-Redux-和-Vuex-有什么区别，它们的共同思想"><a href="#9-Redux-和-Vuex-有什么区别，它们的共同思想" class="headerlink" title="9. Redux 和 Vuex 有什么区别，它们的共同思想"></a>9. Redux 和 Vuex 有什么区别，它们的共同思想</h4><p><strong>（1）Redux 和 Vuex区别</strong><br>●Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可<br>●Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可<br>●Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数-&gt;store改变（vue检测到数据变化自动渲染）</p>
<p>通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变；取消了action概念，不必传入特定的 action形式进行指定变更；弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易; </p>
<p><strong>（2）共同思想</strong><br>●单—的数据源<br>●变化可以预测</p>
<p>本质上∶ redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案。</p>
<h4 id="10-Redux-中间件是怎么拿到store-和-action-然后怎么处理"><a href="#10-Redux-中间件是怎么拿到store-和-action-然后怎么处理" class="headerlink" title="10. Redux 中间件是怎么拿到store 和 action? 然后怎么处理?"></a>10. Redux 中间件是怎么拿到store 和 action? 然后怎么处理?</h4><p>redux中间件本质就是一个函数柯里化。redux applyMiddleware Api 源码中每个middleware 接受2个参数， Store 的getState 函数和dispatch 函数，分别获得store和action，最终返回一个函数。该函数会被传入 next 的下一个 middleware 的 dispatch 方法，并返回一个接收 action 的新函数，这个函数可以直接调用 next（action），或者在其他需要的时刻调用，甚至根本不去调用它。调用链中最后一个 middleware 会接受真实的 store的 dispatch 方法作为 next 参数，并借此结束调用链。所以，middleware 的函数签名是（{ getState，dispatch })=&gt; next =&gt; action。</p>
<h4 id="11-Redux中的connect有什么作用"><a href="#11-Redux中的connect有什么作用" class="headerlink" title="11. Redux中的connect有什么作用"></a>11. Redux中的connect有什么作用</h4><p>connect负责连接React和Redux<br><strong>（1）获取state</strong><br>connect 通过 context获取 Provider 中的 store，通过 store.getState() 获取整个store tree 上所有state<br><strong>（2）包装原组件</strong><br>将state和action通过props的方式传入到原组件内部 wrapWithConnect 返回—个 ReactComponent 对 象 Connect，Connect 重 新 render 外部传入的原组件 WrappedComponent ，并把 connect 中传入的 mapStateToProps，mapDispatchToProps与组件上原有的 props合并后，通过属性的方式传给WrappedComponent<br><strong>（3）监听store tree变化</strong><br>connect缓存了store tree中state的状态，通过当前state状态 和变更前 state 状态进行比较，从而确定是否调用 this.setState()方法触发Connect及其子组件的重新渲染</p>
<h3 id="七、Hooks"><a href="#七、Hooks" class="headerlink" title="七、Hooks"></a>七、Hooks</h3><h4 id="1-对-React-Hook-的理解，它的实现原理是什么"><a href="#1-对-React-Hook-的理解，它的实现原理是什么" class="headerlink" title="1. 对 React Hook 的理解，它的实现原理是什么"></a>1. 对 React Hook 的理解，它的实现原理是什么</h4><p>React-Hooks 是 React 团队在 React 组件开发实践中，逐渐认知到的一个改进点，这背后其实涉及对<strong>类组件和函数组件</strong>两种组件形式的思考和侧重。</p>
<p><strong>（1）类组件</strong>：所谓类组件，就是基于 ES6 Class 这种写法，通过继承 React.Component 得来的 React 组件。以下是一个类组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  state = &#123;<br>    text: <span class="hljs-string">&quot;&quot;</span><br>  &#125;;<br>  <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>  changeText = <span class="hljs-function">(<span class="hljs-params">newText</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>      text: newText<br>    &#125;);<br>  &#125;;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div className=<span class="hljs-string">&quot;demoClass&quot;</span>&gt;<br>        &lt;p&gt;&#123;<span class="hljs-built_in">this</span>.state.text&#125;&lt;/p&gt;<br>        &lt;button onClick=&#123;<span class="hljs-built_in">this</span>.changeText&#125;&gt;修改&lt;/button&gt;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看出，React 类组件内部预置了相当多的“现成的东西”等着我们去调度/定制，state 和生命周期就是这些“现成东西”中的典型。要想得到这些东西，难度也不大，只需要继承一个 React.Component 即可。</p>
<p>当然，这也是类组件的一个不便，它太繁杂了，对于解决许多问题来说，编写一个类组件实在是一个过于复杂的姿势。复杂的姿势必然带来高昂的理解成本，这也是我们所不想看到的。除此之外，由于开发者编写的逻辑在封装后是和组件粘在一起的，这就使得<strong>类组件内部的逻辑难以实现拆分和复用。</strong></p>
<p>（2）<strong>函数组件</strong>：函数组件就是以函数的形态存在的 React 组件。早期并没有 React-Hooks，函数组件内部无法定义和维护 state，因此它还有一个别名叫“无状态组件”。以下是一个函数组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DemoFunction</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123; text &#125; = props<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div className=<span class="hljs-string">&quot;demoFunction&quot;</span>&gt;<br>      &lt;p&gt;&#123;<span class="hljs-string">`函数组件接收的内容：[<span class="hljs-subst">$&#123;text&#125;</span>]`</span>&#125;&lt;/p&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>
<p>相比于类组件，函数组件肉眼可见的特质自然包括轻量、灵活、易于组织和维护、较低的学习成本等。</p>
<p>通过对比，从形态上可以对两种组件做区分，它们之间的区别如下：<br>●类组件需要继承 class，函数组件不需要；<br>●类组件可以访问生命周期方法，函数组件不能；<br>●类组件中可以获取到实例化后的 this，并基于这个 this 做各种各样的事情，而函数组件不可以；<br>●类组件中可以定义并维护 state（状态），而函数组件不可以；</p>
<p>除此之外，还有一些其他的不同。通过上面的区别，我们不能说谁好谁坏，它们各有自己的优势。在 React-Hooks 出现之前，类组件的能力边界明显强于函数组件。</p>
<p>实际上，类组件和函数组件之间，是面向对象和函数式编程这两套不同的设计思想之间的差异。而函数组件更加契合 React 框架的设计理念：<br>React 组件本身的定位就是函数，一个输入数据、输出 UI 的函数。作为开发者，我们编写的是声明式的代码，而 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用户可见的 UI 变化中去。这就意味着从原则上来讲，React 的数据应该总是紧紧地和渲染绑定在一起的，而类组件做不到这一点。<strong>函数组件就真正地将数据和渲染绑定到了一起。函数组件是一个更加匹配其设计理念、也更有利于逻辑拆分与重用的组件表达形式。</strong></p>
<p>为了能让开发者更好的的去编写函数式组件。于是，React-Hooks 便应运而生。</p>
<p>React-Hooks 是一套能够使函数组件更强大、更灵活的“钩子”。</p>
<p>函数组件比起类组件少了很多东西，比如生命周期、对 state 的管理等。这就给函数组件的使用带来了非常多的局限性，导致我们并不能使用函数这种形式，写出一个真正的全功能的组件。而React-Hooks 的出现，就是为了帮助函数组件补齐这些（相对于类组件来说）缺失的能力。</p>
<p>如果说函数组件是一台轻巧的快艇，那么 React-Hooks 就是一个内容丰富的零部件箱。“重装战舰”所预置的那些设备，这个箱子里基本全都有，同时它还不强制你全都要，而是允许你自由地选择和使用你需要的那些能力，然后将这些能力以 Hook（钩子）的形式“钩”进你的组件里，从而定制出一个最适合你的“专属战舰”。</p>
<h4 id="2-为什么-useState-要使用数组而不是对象"><a href="#2-为什么-useState-要使用数组而不是对象" class="headerlink" title="2. 为什么 useState 要使用数组而不是对象"></a>2. 为什么 useState 要使用数组而不是对象</h4><p>useState 的用法：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">count</span>, setCount] = useState(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>
<p>可以看到 useState 返回的是一个数组，那么为什么是返回数组而不是返回对象呢？</p>
<p>这里用到了解构赋值，所以先来看一下ES6 的解构赋值：<br><strong>数组的解构赋值</strong></p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> foo = [1, 2, 3];<br><span class="hljs-keyword">const</span> [<span class="hljs-keyword">one</span>, <span class="hljs-keyword">two</span>, three] = foo;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">one</span>);	<span class="hljs-comment">// 1</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">two</span>);	<span class="hljs-comment">// 2</span><br>console.<span class="hljs-built_in">log</span>(three);	<span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>
<p><strong>对象的解构赋值</strong></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const <span class="hljs-keyword">user</span> = &#123;<br>  id: <span class="hljs-number">888</span>,<br>  <span class="hljs-type">name</span>: &quot;xiaoxin&quot;<br>&#125;;<br>const &#123; id, <span class="hljs-type">name</span> &#125; = <span class="hljs-keyword">user</span>;<br>console.log(id);	// <span class="hljs-number">888</span><br>console.log(<span class="hljs-type">name</span>);	// &quot;xiaoxin&quot;<br></code></pre></td></tr></table></figure>
<p>看完这两个例子，答案应该就出来了：<br>●如果 useState 返回的是数组，那么使用者可以对数组中的元素命名，代码看起来也比较干净<br>●如果 useState 返回的是对象，在解构对象的时候必须要和 useState 内部实现返回的对象同名，想要使用多次的话，必须得设置别名才能使用返回值</p>
<p>下面来看看如果 useState 返回对象的情况：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">// 第一次使用<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">state</span>, <span class="hljs-built_in">set</span>State &#125; = useState(false);<br>// 第二次使用<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">state</span>: counter, <span class="hljs-built_in">set</span>State: <span class="hljs-built_in">set</span>Counter &#125; = useState(<span class="hljs-number">0</span>) <br></code></pre></td></tr></table></figure>
<p>这里可以看到，返回对象的使用方式还是挺麻烦的，更何况实际项目中会使用的更频繁。<br><strong>总结</strong>：useState 返回的是 array 而不是 object 的原因就是为了<strong>降低使用的复杂度</strong>，返回数组的话可以直接根据顺序解构，而返回对象的话要想使用多次就需要定义别名了。</p>
<h4 id="3-React-Hooks-解决了哪些问题？"><a href="#3-React-Hooks-解决了哪些问题？" class="headerlink" title="3. React Hooks 解决了哪些问题？"></a>3. React Hooks 解决了哪些问题？</h4><p>React Hooks 主要解决了以下问题：<br><strong>（1）在组件之间复用状态逻辑很难</strong><br>React 没有提供将可复用性行为“附加”到组件的途径（例如，把组件连接到 store）解决此类问题可以使用 render props 和 高阶组件。但是这类方案需要重新组织组件结构，这可能会很麻烦，并且会使代码难以理解。由 providers，consumers，高阶组件，render props 等其他抽象层组成的组件会形成“嵌套地狱”。尽管可以在 DevTools 过滤掉它们，但这说明了一个更深层次的问题：React 需要为共享状态逻辑提供更好的原生途径。</p>
<p>可以使用 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook 使我们在无需修改组件结构的情况下复用状态逻辑。 这使得在组件间或社区内共享 Hook 变得更便捷。<br><strong>（2）复杂组件变得难以理解</strong><br>在组件中，每个生命周期常常包含一些不相关的逻辑。例如，组件常常在 componentDidMount 和 componentDidUpdate 中获取数据。但是，同一个 componentDidMount 中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount 中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。</p>
<p>在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 React 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。</p>
<p>为了解决这个问题，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。<br><strong>（3）难以理解的 class</strong><br>除了代码复用和代码管理会遇到困难外，class 是学习 React 的一大屏障。我们必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。没有稳定的语法提案，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。即便在有经验的 React 开发者之间，对于函数组件与 class 组件的差异也存在分歧，甚至还要区分两种组件的使用场景。</p>
<p>为了解决这些问题，Hook 使你在非 class 的情况下可以使用更多的 React 特性。 从概念上讲，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术</p>
<h4 id="4-React-Hook-的使用限制有哪些？"><a href="#4-React-Hook-的使用限制有哪些？" class="headerlink" title="4. React Hook 的使用限制有哪些？"></a>4. React Hook 的使用限制有哪些？</h4><p>React Hooks 的限制主要有两条：<br>●不要在循环、条件或嵌套函数中调用 Hook；<br>●在 React 的函数组件中调用 Hook。</p>
<p>那为什么会有这样的限制呢？Hooks 的设计初衷是为了改进 React 组件的开发模式。在旧有的开发模式下遇到了三个问题。<br>●组件之间难以复用状态逻辑。过去常见的解决方案是高阶组件、render props 及状态管理框架。<br>●复杂的组件变得难以理解。生命周期函数与业务逻辑耦合太深，导致关联部分难以拆分。<br>●人和机器都很容易混淆类。常见的有 this 的问题，但在 React 团队中还有类难以优化的问题，希望在编译优化层面做出一些改进。</p>
<p>这三个问题在一定程度上阻碍了 React 的后续发展，所以为了解决这三个问题，Hooks 基于函数组件开始设计。然而第三个问题决定了 Hooks 只支持函数组件。</p>
<p>那为什么不要在循环、条件或嵌套函数中调用 Hook 呢？因为 Hooks 的设计是基于数组实现。在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的 Hook。当然，实质上 React 的源码里不是数组，是链表。</p>
<p>这些限制会在编码上造成一定程度的心智负担，新手可能会写错，为了避免这样的情况，可以引入 ESLint 的 Hooks 检查插件进行预防。</p>
<h4 id="5-useEffect-与-useLayoutEffect-的区别"><a href="#5-useEffect-与-useLayoutEffect-的区别" class="headerlink" title="5. useEffect 与 useLayoutEffect 的区别"></a>5. useEffect 与 useLayoutEffect 的区别</h4><p><strong>（1）共同点</strong><br><strong>●运用效果</strong>：useEffect 与 useLayoutEffect 两者都是用于处理副作用，这些副作用包括改变 DOM、设置订阅、操作定时器等。在函数组件内部操作副作用是不被允许的，所以需要使用这两个函数去处理。<br><strong>●使用方式：</strong>useEffect 与 useLayoutEffect 两者底层的函数签名是完全一致的，都是调用的 mountEffectImpl方法，在使用上也没什么差异，基本可以直接替换。</p>
<p><strong>（2）不同点</strong><br><strong>●使用场景：</strong>useEffect 在 React 的渲染过程中是被异步调用的，用于绝大多数场景；而 useLayoutEffect 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 useLayoutEffect 做计算量较大的耗时任务从而造成阻塞。<br><strong>●使用效果</strong>：useEffect是按照顺序执行代码的，改变屏幕像素之后执行（先渲染，后改变DOM），当改变屏幕内容时可能会产生闪烁；useLayoutEffect是改变屏幕像素之前就执行了（会推迟页面显示的事件，先改变DOM后渲染），不会产生闪烁。<strong>useLayoutEffect总是比useEffect先执行。</strong></p>
<p>在未来的趋势上，两个 API 是会长期共存的，暂时没有删减合并的计划，需要开发者根据场景去自行选择。React 团队的建议非常实用，如果实在分不清，先用 useEffect，一般问题不大；如果页面有异常，再直接替换为 useLayoutEffect 即可。</p>
<h4 id="6-React-Hooks在平时开发中需要注意的问题和原因"><a href="#6-React-Hooks在平时开发中需要注意的问题和原因" class="headerlink" title="6. React Hooks在平时开发中需要注意的问题和原因"></a>6. React Hooks在平时开发中需要注意的问题和原因</h4><p><strong>（1）不要在循环，条件或嵌套函数中调用Hook，必须始终在 React函数的顶层使用Hook</strong><br>这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性，从而产生难以预料到的后果。<br><strong>（2）使用useState时候，使用push，pop，splice等直接更改数组对象的坑</strong><br>使用push直接更改数组无法获取到新值，应该采用析构方式，但是在class里面不会有这个问题。代码示例：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Indicatorfilter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> [num,setNums] = useState([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br>  <span class="hljs-keyword">const</span> test = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 这里坑是直接采用push去更新num</span><br>    <span class="hljs-comment">// setNums(num)是无法更新num的</span><br>    <span class="hljs-comment">// 必须使用num = [...num ,1]</span><br>    num.push(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// num = [...num ,1]</span><br>    setNums(num)<br>  &#125;<br><span class="hljs-keyword">return</span> (<br>    &lt;div className=<span class="hljs-string">&#x27;filter&#x27;</span>&gt;<br>      &lt;div onClick=&#123;test&#125;&gt;测试&lt;/div&gt;<br>        &lt;div&gt;<br>          &#123;num.map(<span class="hljs-function">(<span class="hljs-params">item,index</span>) =&gt;</span> (<br>              &lt;div key=&#123;index&#125;&gt;&#123;item&#125;&lt;/div&gt;<br>          ))&#125;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Indicatorfilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;<span class="hljs-title">any</span>,<span class="hljs-title">any</span>&gt;</span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props:<span class="hljs-built_in">any</span></span>)</span>&#123;<br>      <span class="hljs-built_in">super</span>(props)<br>      <span class="hljs-built_in">this</span>.state = &#123;<br>          nums:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>      &#125;<br>      <span class="hljs-built_in">this</span>.test = <span class="hljs-built_in">this</span>.test.bind(<span class="hljs-built_in">this</span>)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-comment">// class采用同样的方式是没有问题的</span><br>      <span class="hljs-built_in">this</span>.state.nums.push(<span class="hljs-number">1</span>)<br>      <span class="hljs-built_in">this</span>.setState(&#123;<br>          nums: <span class="hljs-built_in">this</span>.state.nums<br>      &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-keyword">let</span> &#123;nums&#125; = <span class="hljs-built_in">this</span>.state<br>      <span class="hljs-keyword">return</span>(<br>          &lt;div&gt;<br>              &lt;div onClick=&#123;<span class="hljs-built_in">this</span>.test&#125;&gt;测试&lt;/div&gt;<br>                  &lt;div&gt;<br>                      &#123;nums.map(<span class="hljs-function">(<span class="hljs-params">item:<span class="hljs-built_in">any</span>,index:<span class="hljs-built_in">number</span></span>) =&gt;</span> (<br>                          &lt;div key=&#123;index&#125;&gt;&#123;item&#125;&lt;/div&gt;<br>                      ))&#125;<br>                  &lt;/div&gt;<br>          &lt;/div&gt;<br><br>      )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>3）useState设置状态的时候，只有第一次生效，后期需要更新状态，必须通过useEffect</strong><br>TableDeail是一个公共组件，在调用它的父组件里面，我们通过set改变columns的值，以为传递给TableDeail 的 columns是最新的值，所以tabColumn每次也是最新的值，但是实际tabColumn是最开始的值，不会随着columns的更新而更新：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> TableDeail = (&#123;<br>    columns,<br>&#125;:TableData) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> [tabColumn, setTabColumn] = useState(columns) <br>&#125;<br><br><span class="hljs-comment">// 正确的做法是通过useEffect改变这个值</span><br><span class="hljs-keyword">const</span> TableDeail = (&#123;<br>    columns,<br>&#125;:TableData) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> [tabColumn, setTabColumn] = useState(columns) <br>    useEffect(<span class="hljs-function">() =&gt;</span>&#123;setTabColumn(columns)&#125;,[columns])<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>（4）善用useCallback</strong><br>父组件传递给子组件事件句柄时，如果我们没有任何参数变动可能会选用useMemo。但是每一次父组件渲染子组件即使没变化也会跟着渲染一次。<br><strong>（5）不要滥用useContext</strong><br>可以使用基于 useContext 封装的状态管理工具。</p>
<h4 id="7-React-Hooks-和生命周期的关系？"><a href="#7-React-Hooks-和生命周期的关系？" class="headerlink" title="7. React Hooks 和生命周期的关系？"></a>7. React Hooks 和生命周期的关系？</h4><p><strong>函数组件</strong> 的本质是函数，没有 state 的概念的，因此<strong>不存在生命周期</strong>一说，仅仅是一个 <strong>render 函数</strong>而已。<br>但是引入 <strong>Hooks</strong>之后就变得不同了，它能让组件在不使用 class 的情况下拥有 state，所以就有了生命周期的概念，所谓的生命周期其实就是 <strong>useState、 useEffect() 和 useLayoutEffect() 。</strong></p>
<p>即：<strong>Hooks 组件（使用了Hooks的函数组件）有生命周期，而函数组件（未使用Hooks的函数组件）是没有生命周期的。</strong><br>下面是具体的 class 与 Hooks 的<strong>生命周期对应关系</strong>：<br><strong>●constructor</strong>：函数组件不需要构造函数，可以通过调用 useState 来初始化 state。如果计算的代价比较昂贵，也可以传一个函数给 useState。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> [<span class="hljs-built_in">num</span>, UpdateNum] = useState(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>
<p><strong>●getDerivedStateFromProps</strong>：一般情况下，我们不需要使用它，可以在渲染过程中更新 state，以达到实现 getDerivedStateFromProps 的目的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ScrollView</span>(<span class="hljs-params">&#123;row&#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> [isScrollingDown, setIsScrollingDown] = useState(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">let</span> [prevRow, setPrevRow] = useState(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">if</span> (row !== prevRow) &#123;<br>    <span class="hljs-comment">// Row 自上次渲染以来发生过改变。更新 isScrollingDown。</span><br>    setIsScrollingDown(prevRow !== <span class="hljs-literal">null</span> &amp;&amp; row &gt; prevRow);<br>    setPrevRow(row);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Scrolling down: <span class="hljs-subst">$&#123;isScrollingDown&#125;</span>`</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>React 会立即退出第一次渲染并用更新后的 state 重新运行组件以避免耗费太多性能。<br>●shouldComponentUpdate：可以用 React.memo 包裹一个组件来对它的 props 进行浅比较</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Button = React.memo(<span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 具体的组件</span><br>&#125;);<br></code></pre></td></tr></table></figure>
<p>注意：React.memo 等效于 PureComponent，它只浅比较 props。这里也可以使用 useMemo 优化每一个节点。<br>●render：这是函数组件体本身。<br>●componentDidMount, componentDidUpdate： useLayoutEffect 与它们两的调用阶段是一样的。但是，我们推荐<strong>你一开始先用 useEffect</strong>，只有当它出问题的时候再尝试使用 useLayoutEffect。useEffect 可以表达所有这些的组合。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// componentDidMount</span><br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>  <span class="hljs-comment">// 需要在 componentDidMount 执行的内容</span><br>&#125;, [])<br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <br>  <span class="hljs-comment">// 在 componentDidMount，以及 count 更改时 componentDidUpdate 执行的内容</span><br>  document.title = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span>; <br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 需要在 count 更改时 componentDidUpdate（先于 document.title = ... 执行，遵守先清理后更新）</span><br>    <span class="hljs-comment">// 以及 componentWillUnmount 执行的内容       </span><br>  &#125; <span class="hljs-comment">// 当函数中 Cleanup 函数会按照在代码中定义的顺序先后执行，与函数本身的特性无关</span><br>&#125;, [count]); <span class="hljs-comment">// 仅在 count 更改时更新</span><br></code></pre></td></tr></table></figure>
<p><strong>请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 ，因此会使得额外操作很方便</strong><br>●componentWillUnmount：相当于 useEffect 里面返回的 cleanup 函数</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// componentDidMount/componentWillUnmount</span><br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>  <span class="hljs-comment">// 需要在 componentDidMount 执行的内容</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanup</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 需要在 componentWillUnmount 执行的内容      </span><br>  &#125;<br>&#125;, [])<br></code></pre></td></tr></table></figure>
<p>●componentDidCatch and getDerivedStateFromError：目前还没有这些方法的 Hook 等价写法，但很快会加上。<br><img src="/imageO/react12.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="八、虚拟DOM"><a href="#八、虚拟DOM" class="headerlink" title="八、虚拟DOM"></a>八、虚拟DOM</h3><p><a target="_blank" rel="noopener" href="https://www.yuque.com/cuggz/interview/pgw8v4#bf7c58762878b0c5101b22e7fdce9b85">参考</a></p>
<h3 id="九、其他"><a href="#九、其他" class="headerlink" title="九、其他"></a>九、其他</h3><p><a target="_blank" rel="noopener" href="https://www.yuque.com/cuggz/interview/pgw8v4#c7e1632a1282e9f715f629812a8c5c44">参考</a></p>
<h2 id="还未被问到（加强）"><a href="#还未被问到（加强）" class="headerlink" title="还未被问到（加强）"></a>还未被问到（加强）</h2><h2 id="被问到了掌握了以及-较简单"><a href="#被问到了掌握了以及-较简单" class="headerlink" title="被问到了掌握了以及(较简单)"></a>被问到了掌握了以及(较简单)</h2><h2 id="其他待整理-（掘金）"><a href="#其他待整理-（掘金）" class="headerlink" title="其他待整理 （掘金）"></a>其他待整理 （掘金）</h2><h3 id="hooks用过吗？聊聊react中class组件和函数组件的区别"><a href="#hooks用过吗？聊聊react中class组件和函数组件的区别" class="headerlink" title="hooks用过吗？聊聊react中class组件和函数组件的区别"></a>hooks用过吗？聊聊react中class组件和函数组件的区别</h3><p>类组件是使用ES6 的 class 来定义的组件。 函数组件是接收一个单一的 <strong>props</strong> 对象并返回一个React元素。</p>
<p>关于React的两套API（类（class）API 和基于函数的钩子（hooks） API）。官方推荐使用钩子（函数），而不是类。因为钩子更简洁，代码量少，用起来比较”轻”，而类比较”重”。而且，钩子是函数，更符合 React 函数式的本质。</p>
<p>函数一般来说，只应该做一件事，就是返回一个值。 如果你有多个操作，每个操作应该写成一个单独的函数。而且，数据的状态应该与操作方法分离。根据函数这种理念，React 的函数组件只应该做一件事情：返回组件的 HTML 代码，而没有其他的功能。函数的返回结果只依赖于它的参数。不改变函数体外部数据、函数执行过程里面没有副作用。</p>
<p>类（class）是数据和逻辑的封装。 也就是说，组件的状态和操作方法是封装在一起的。如果选择了类的写法，就应该把相关的数据和操作，都写在同一个 class 里面。</p>
<h3 id="类组件的缺点"><a href="#类组件的缺点" class="headerlink" title="类组件的缺点 :"></a>类组件的缺点 :</h3><p>大型组件很难拆分和重构，也很难测试。<br>业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。<br>组件类引入了复杂的编程模式，比如 render props 和高阶组件。<br>难以理解的 class，理解 JavaScript 中 this 的工作方式。</p>
<h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><p>函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。<br>1.状态的有无<br>hooks出现之前，函数组件<strong>没有实例，没有生命周期，没有state，没有this</strong>，所以我们称函数组件为无状态组件。 hooks出现之前，react中的函数组件通常只考虑负责UI的渲染，没有自身的状态没有业务逻辑代码，是一个纯函数。它的输出只由参数props决定，不受其他任何因素影响。</p>
<p>2.调用方式的不同<br>函数组件重新渲染，将重新调用组件方法返回新的react元素。类组件重新渲染将new一个新的组件实例，然后调用render类方法返回react元素，这也说明为什么类组件中this是可变的。</p>
<p>3.因为调用方式不同，在函数组件使用中会出现问题<br>在操作中改变状态值，类组件可以获取最新的状态值，而函数组件则会按照顺序返回状态值</p>
<h3 id="React-Hooks（钩子的作用）"><a href="#React-Hooks（钩子的作用）" class="headerlink" title="React Hooks（钩子的作用）"></a>React Hooks（钩子的作用）</h3><p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。<br>React Hooks的几个常用钩子:</p>
<ol>
<li>useState() //状态钩子</li>
<li>useContext() //共享状态钩子</li>
<li>useReducer() //action 钩子</li>
<li>useEffect() //副作用钩子</li>
</ol>
<p>还有几个不常见的大概的说下</p>
<p>1.useCallback 记忆函数 一般把<strong>函数式组件理解为class组件render函数的语法糖</strong>，所以每次重新渲染的时候，函数式组件内部所有的代码都会重新执行一遍。而有了 useCallback 就不一样了，你可以通过 useCallback 获得一个记忆后的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> memoizedHandleClick = useCallback(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Click happened&#x27;</span>)<br>  &#125;, []); <span class="hljs-comment">// 空数组代表无论什么情况下该函数都不会发生改变</span><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">SomeComponent</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;memoizedHandleClick&#125;</span>&gt;</span>Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">SomeComponent</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第二个参数传入一个数组，数组中的每一项一旦值或者引用发生改变，useCallback 就会重新返回一个新的记忆函数提供给后面进行渲染。</p>
<p>2.useMemo 记忆组件 useCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。 唯一的区别是：<strong>useCallback 不会执行第一个参数函数，而是将它返回给你，而 useMemo 会执行第一个函数并且将函数执行结果返回给你。</strong><br>所以 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。</p>
<p>3.useRef 保存引用值<br>useRef 跟 createRef 类似，都可以用来生成对 DOM 对象的引用。useRef 返回的值传递给组件或者 DOM 的 ref 属性，就可以通过 ref.current 值<strong>访问组件或真实的 DOM 节点，重点是组件也是可以访问到的</strong>，从而可以对 DOM 进行一些操作，比如监听事件等等。</p>
<p>4.useImperativeHandle 穿透 Ref<br>通过 useImperativeHandle 用于让父组件获取子组件内的索引</p>
<p>5.useLayoutEffect 同步执行副作用<br>大部分情况下，使用 useEffect 就可以帮我们处理组件的副作用，但是如果想要同步调用一些副作用，比如对 DOM 的操作，就需要使用 useLayoutEffect，useLayoutEffect 中的副作用会在 DOM 更新之后同步执行。<br><strong>useEffect和useLayoutEffect有什么区别</strong>：简单来说就是调用时机不同，useLayoutEffect和原来componentDidMount&amp;componentDidUpdate一致，在react完成DOM更新后马上同步调用的代码，会阻塞页面渲染。而useEffect是会在整个页面渲染完才会调用的代码。官方建议优先使用useEffect</p>
<h3 id="setState-既存在异步情况也存在同步情况"><a href="#setState-既存在异步情况也存在同步情况" class="headerlink" title="setState 既存在异步情况也存在同步情况"></a>setState 既存在异步情况也存在同步情况</h3><p>1.异步情况 <strong>在React事件当中是异步操作</strong><br>2.同步情况 如果是在<strong>setTimeout事件或者自定义的dom事件</strong>中，都是同步的</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pf">//<span class="hljs-built_in">set</span>Timeout事件<br>import React,&#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br>class Count extends Component&#123;<br>    constructor(props)&#123;<br>        super(props);<br>        this.<span class="hljs-keyword">state</span> = &#123;<br>            count:<span class="hljs-number">0</span><br>        &#125;<br>    &#125;<br><br>    render()&#123;<br>        return (<br>            <span class="hljs-variable">&lt;&gt;</span><br>                <span class="hljs-variable">&lt;p&gt;</span>count:&#123;this.<span class="hljs-keyword">state</span>.count&#125;&lt;/p&gt;<br>                <span class="hljs-variable">&lt;button onClick=&#123;this.btnAction&#125;&gt;</span>增加&lt;/button&gt;<br>            &lt;/&gt;<br>        )<br>    &#125;<br>    <br>    btnAction = ()=&gt;&#123;<br>        //不能直接修改<span class="hljs-keyword">state</span>，需要通过<span class="hljs-built_in">set</span>State进行修改<br>        //同步<br>        <span class="hljs-built_in">set</span>Timeout(()=&gt;&#123;<br>            this.<span class="hljs-built_in">set</span>State(&#123;<br>                count: this.<span class="hljs-keyword">state</span>.count + <span class="hljs-number">1</span><br>            &#125;);<br>            console.<span class="hljs-keyword">log</span>(this.<span class="hljs-keyword">state</span>.count);<br>        &#125;)<br>    &#125;<br>&#125;<br><br>export <span class="hljs-keyword">default</span> Count;<br></code></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//自定义dom事件</span><br><span class="hljs-keyword">import</span> React,&#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Count</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            count:<span class="hljs-number">0</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;&gt;<br>                &lt;p&gt;count:&#123;<span class="hljs-built_in">this</span>.state.count&#125;&lt;/p&gt;<br>                &lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;绑定点击事件&lt;/button&gt;<br>            &lt;/&gt;<br>        )<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">//自定义dom事件，也是同步修改</span><br>        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#btn&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-built_in">this</span>.setState(&#123;<br>                count: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span><br>            &#125;);<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count);<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Count;<br></code></pre></td></tr></table></figure>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/imageO/react5.png" srcset="/img/loading.gif" lazyload alt="生命周期"></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs stylus">安装<br>当组件的实例被创建并插入到 DOM 中时，这些方法按以下顺序调用：<br><br><span class="hljs-function"><span class="hljs-title">constructor</span><span class="hljs-params">()</span></span><br>static getDerivedStateFromProps()<br><span class="hljs-function"><span class="hljs-title">render</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">componentDidMount</span><span class="hljs-params">()</span></span><br><br>更新中<br>更新可能由道具或状态的更改引起。当重新渲染组件时，这些方法按以下顺序调用：<br><br>static getDerivedStateFromProps()<br><span class="hljs-function"><span class="hljs-title">shouldComponentUpdate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">render</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">getSnapshotBeforeUpdate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">componentDidUpdate</span><span class="hljs-params">()</span></span><br><br>卸载<br>当组件从 DOM 中移除时调用此方法：<br><br><span class="hljs-function"><span class="hljs-title">componentWillUnmount</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>
<h3 id="说一下-react-fiber"><a href="#说一下-react-fiber" class="headerlink" title="说一下 react-fiber"></a>说一下 react-fiber</h3><h4 id="1）背景"><a href="#1）背景" class="headerlink" title="1）背景"></a>1）背景</h4><p>react-fiber 产生的根本原因，是<strong>大量的同步计算任务阻塞了浏览器的 UI 渲染</strong>。默认情况下，JS 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。如果 JS 运算持续占用主线程，页面就没法得到及时的更新。当我们调用setState更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI。如果页面元素很多，整个过程占用的时机就可能超过 16 毫秒，就容易出现掉帧的现象。</p>
<h4 id="2）实现原理"><a href="#2）实现原理" class="headerlink" title="2）实现原理"></a>2）实现原理</h4><p>react内部运转分三层：</p>
<ol>
<li>Virtual DOM 层，描述页面长什么样。</li>
<li>Reconciler 层，负责调用组件生命周期方法，进行 Diff 运算等。</li>
<li>Renderer 层，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。</li>
</ol>
<p><strong>Fiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示：</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">const fiber = &#123;<br>    stateNode,    <span class="hljs-regexp">//</span> 节点实例<br>    child,        <span class="hljs-regexp">//</span> 子节点<br>    sibling,      <span class="hljs-regexp">//</span> 兄弟节点<br>    return,       <span class="hljs-regexp">//</span> 父节点<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了实现不卡顿，就需要有一个调度器 (Scheduler) 来进行任务分配。优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效。任务的优先级有六种：</p>
<ol>
<li>synchronous，与之前的Stack Reconciler操作一样，同步执行</li>
<li>task，在next tick之前执行</li>
<li>animation，下一帧之前执行</li>
<li>high，在不久的将来立即执行</li>
<li>low，稍微延迟执行也没关系</li>
<li>offscreen，下一次render时或scroll时才执行</li>
</ol>
<p>Fiber Reconciler（react ）执行过程分为2个阶段：</p>
<ol>
<li>阶段一，生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率。</li>
<li>阶段二，将需要更新的节点一次过批量更新，这个过程不能被打断。</li>
</ol>
<p>Fiber树：React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 Virtual DOM Tree，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 Fiber Tree。Fiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复。</p>
<p>从Stack Reconciler到Fiber Reconciler，源码层面其实就是干了一件递归改循环的事情<br>传送门 ☞# <a target="_blank" rel="noopener" href="https://juejin.cn/post/7002250258826657799">深入了解 Fiber</a></p>
<h3 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a>Portals</h3><p>Portals 提供了一种一流的方式来将子组件渲染到存在于父组件的 DOM 层次结构之外的 DOM 节点中。结构不受外界的控制的情况下就可以使用portals进行创建</p>
<h3 id="何时要使用异步组件？如和使用异步组件"><a href="#何时要使用异步组件？如和使用异步组件" class="headerlink" title="何时要使用异步组件？如和使用异步组件"></a>何时要使用异步组件？如和使用异步组件</h3><p>加载大组件的时候<br>路由异步加载的时候</p>
<p>react 中要配合 Suspense 使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 异步懒加载</span><br><span class="hljs-keyword">const</span> Box = lazy(<span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./components/Box&#x27;</span>));<br><span class="hljs-comment">// 使用组件的时候要用suspense进行包裹</span><br>&lt;Suspense fallback=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;&gt;<br>    &#123;show &amp;&amp; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Box</span>/&gt;</span></span>&#125;<br>&lt;/Suspense&gt;<br></code></pre></td></tr></table></figure>
<h3 id="React-事件绑定原理"><a href="#React-事件绑定原理" class="headerlink" title="React 事件绑定原理"></a>React 事件绑定原理</h3><p>React并不是将click事件绑在该div的真实DOM上，而是<strong>在document处监听所有支持的事件</strong>，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。<br>另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 <strong>event.preventDefault</strong>。<br><img src="/imageO/react10.png" srcset="/img/loading.gif" lazyload alt="绑定事件"></p>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7016593221815910408#heading-83">连八股文都不懂还指望在前端混下去么</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/">前端基础</a>
                    
                      <a class="hover-with-bg" href="/tags/React/">React</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/01/10/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Vue面试题总结</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/07/%E8%AE%A1%E7%BD%91+%E6%B5%8F%E8%A7%88%E5%99%A8+http+%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/">
                        <span class="hidden-mobile">计网+HTTP+浏览器+网络安全面试题总结</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>

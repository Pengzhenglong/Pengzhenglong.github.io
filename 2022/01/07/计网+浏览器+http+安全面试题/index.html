

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/2.jpg">
  <link rel="icon" href="/img/2.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="DragonPeng">
  <meta name="keywords" content="">
  
  <title>计网+HTTP+浏览器+网络安全面试题总结 - DragonPeng的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.9","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>DragonPeng' blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/page1.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="计网+HTTP+浏览器+网络安全面试题总结">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-01-07 20:15" pubdate>
        January 7, 2022 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      144
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">计网+HTTP+浏览器+网络安全面试题总结</h1>
            
            <div class="markdown-body">
              <p>总结了最近的一些面试题和之前的知识点</p>
<hr>
<h2 id="计网-HTTP"><a href="#计网-HTTP" class="headerlink" title="计网+HTTP"></a>计网+HTTP</h2><h3 id="从输入URL到浏览器显示页面过程中都发生了什么"><a href="#从输入URL到浏览器显示页面过程中都发生了什么" class="headerlink" title="从输入URL到浏览器显示页面过程中都发生了什么"></a>从输入URL到浏览器显示页面过程中都发生了什么</h3><p>  <a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2021/05/27/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E8%BF%87%E7%A8%8B%E9%9D%A2%E8%AF%95/#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">从输入URL到浏览器显示页面过程中都发生了什么</a></p>
<h3 id="1-http-和-https-的基本概念"><a href="#1-http-和-https-的基本概念" class="headerlink" title="1.http 和 https 的基本概念"></a>1.http 和 https 的基本概念</h3><p>HTTP 是一种 超文本传输协议(Hypertext Transfer Protocol)，HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范<br><img src="/imageO/Http.jpg" srcset="/img/loading.gif" lazyload alt="Http"><br>HTTP 主要内容分为三部分，<strong>超文本（Hypertext）、传输（Transfer）、协议（Protocol）</strong>。</p>
<ol>
<li>超文本就是不单单只是本文，它还可以传输图片、音频、视频，甚至点击文字或图片能够进行超链接的跳转。</li>
<li>上面这些概念可以统称为数据，传输就是数据需要经过一系列的物理介质从一个端系统传送到另外一个端系统的过程。通常我们2把传输数据包的一方称为请求方，把接到二进制数据包的一方称为应答方。</li>
<li>而协议指的就是是网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为协议，只不过是网络协议。<br>说到 HTTP，不得不提的就是 TCP/IP 网络模型，一般是五层模型。如下图所示<br>但是也可以分为四层，就是把链路层和物理层都表示为网络接口层<br><img src="/imageO/WC.jpg" srcset="/img/loading.gif" lazyload alt="TCP/IP网络模型"><br>还有一种就是 OSI 七层网络模型，它就是在五层协议之上加了表示层和会话层<br><img src="/imageO/QC.jpg" srcset="/img/loading.gif" lazyload alt="TCP/IP网络模型"></li>
</ol>
<h4 id="那么，HTTP-和-HTTPS-的主要区别是什么呢？"><a href="#那么，HTTP-和-HTTPS-的主要区别是什么呢？" class="headerlink" title="那么，HTTP 和 HTTPS 的主要区别是什么呢？"></a>那么，HTTP 和 HTTPS 的主要区别是什么呢？</h4><ol>
<li>最简单的，HTTP 在地址栏上的协议是以 http:// 开头，而 HTTPS 在地址栏上的协议是以 https:// 开头</li>
</ol>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>pengzhenglong.github.io/<br>https:<span class="hljs-regexp">//</span>pengzhenglong.github.io/<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>HTTP 是未经安全加密的协议，它的传输过程容易被攻击者监听、数据容易被窃取、发送方和接收方容易被伪造；而 HTTPS 是安全的协议，它通过<strong> 密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法 </strong>能够解决上面这些问题。</li>
<li>HTTP 的默认端口是 80，而 HTTPS 的默认端口是 443。</li>
</ol>
<h3 id="为什么有了HTTP为什么还要HTTPS？"><a href="#为什么有了HTTP为什么还要HTTPS？" class="headerlink" title="为什么有了HTTP为什么还要HTTPS？"></a>为什么有了HTTP为什么还要HTTPS？</h3><p>https是安全版的http，因为http协议的数据都是明文进行传输的，所以对于一些敏感信息的传输就很不安全，HTTPS就是为了解决HTTP的不安全而生的。</p>
<h3 id="HTTPS是如何保证安全的？"><a href="#HTTPS是如何保证安全的？" class="headerlink" title="HTTPS是如何保证安全的？"></a>HTTPS是如何保证安全的？</h3><p>过程比较复杂，我们得先理解两个概念</p>
<p>对称加密：即通信的双方都使用同一个秘钥进行加解密，比如特务接头的暗号，就属于对称加密</p>
<p>对称加密虽然很简单性能也好，但是无法解决首次把秘钥发给对方的问题，很容易被hacker拦截秘钥。<br>非对称加密：</p>
<ol>
<li>私钥 + 公钥= 密钥对</li>
<li>即用私钥加密的数据,只有对应的公钥才能解密,用公钥加密的数据,只有对应的私钥才能解密</li>
<li>因为通信双方的手里都有一套自己的密钥对,通信之前双方会先把自己的公钥都先发给对方</li>
<li>然后对方再拿着这个公钥来加密数据响应给对方,等到到了对方那里,对方再用自己的私钥进行解密</li>
</ol>
<p>非对称加密虽然安全性更高，但是带来的问题就是速度很慢，影响性能。<br>解决方案：</p>
<p>那么结合两种加密方式，将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。</p>
<p>此时又带来一个问题，中间人问题：</p>
<p>如果此时在客户端和服务器之间存在一个中间人,这个中间人只需要把原本双方通信互发的公钥,换成自己的公钥,这样中间人就可以轻松解密通信双方所发送的所有数据。</p>
<p>所以这个时候需要一个安全的第三方颁发证书（CA），证明身份的身份，防止被中间人攻击。</p>
<p>证书中包括：签发者、证书用途、使用者公钥、使用者私钥、使用者的HASH算法、证书到期时间等</p>
<p>但是问题来了，如果中间人篡改了证书，那么身份证明是不是就无效了？这个证明就白买了，这个时候需要一个新的技术，数字签名。</p>
<p>数字签名就是用CA自带的HASH算法对证书的内容进行HASH得到一个摘要，再用CA的私钥加密，最终组成数字签名。</p>
<p>当别人把他的证书发过来的时候,我再用同样的Hash算法,再次生成消息摘要，然后用CA的公钥对数字签名解密,得到CA创建的消息摘要,两者一比,就知道中间有没有被人篡改了。</p>
<p>这个时候就能最大程度保证通信的安全了。</p>
<h3 id="HTTP2相对于HTTP1-x有什么优势和特点？"><a href="#HTTP2相对于HTTP1-x有什么优势和特点？" class="headerlink" title="HTTP2相对于HTTP1.x有什么优势和特点？"></a>HTTP2相对于HTTP1.x有什么优势和特点？</h3><h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4><p>帧：HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。<br>流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID<br>HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。</p>
<h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。</p>
<p>服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。</p>
<h4 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h4><p>HTTP/1.x会在请求和响应中中重复地携带不常改变的、冗长的头部数据，给网络带来额外的负担。</p>
<ol>
<li>HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送</li>
<li>首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</li>
<li>每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。</li>
</ol>
<blockquote>
<p>你可以理解为只发送差异数据，而不是全部发送，从而减少头部的信息量</p>
</blockquote>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。<br>HTTP2中：</p>
<p>同域名下所有通信都在单个连接上完成。<br>单个连接可以承载任意数量的双向数据流。<br>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装</p>
<h3 id="2-http-和-https-的区别及优缺点？"><a href="#2-http-和-https-的区别及优缺点？" class="headerlink" title="2.http 和 https 的区别及优缺点？"></a>2.http 和 https 的区别及优缺点？</h3><ol>
<li>http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议安全，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。</li>
<li>http 协议的默认端口为 80，https 的默认端口为 443。</li>
<li>http 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li>
<li>https 缓存不如 http 高效，会增加数据开销。</li>
<li>Https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。</li>
<li>SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。</li>
</ol>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>应用层协议定义了应用进程间的交互和通信规则，不同主机的应用进程间如何相互传递报文，比如传递的报文的类型、格式、  有哪些字段等等。</p>
<h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。<br>HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</p>
<p>HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP连接三次握手时所花费的时间。</p>
<p>在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-alive 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。</p>
<h3 id="HTTP的keep-alive是干什么的？"><a href="#HTTP的keep-alive是干什么的？" class="headerlink" title="HTTP的keep-alive是干什么的？"></a>HTTP的keep-alive是干什么的？</h3><p>在早期的HTTP/1.0中，每次http请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的HTTP/1.0中以及HTTP/1.1中，引入了重用连接的机制，就是在http请求头中加入Connection: keep-alive来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive。</p>
<h4 id="keep-alive的优点"><a href="#keep-alive的优点" class="headerlink" title="keep-alive的优点"></a>keep-alive的优点</h4><p>较少的CPU和内存的使用（由于同时打开的连接的减少了）<br>允许请求和应答的HTTP管线化<br>降低拥塞控制 （TCP连接减少了）<br>减少了后续请求的延迟（无需再进行握手）<br>报告错误无需关闭TCP连</p>
<h3 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h3><h4 id="HTTP-报文有两种，一种是请求报文，一种是响应报文"><a href="#HTTP-报文有两种，一种是请求报文，一种是响应报文" class="headerlink" title="HTTP 报文有两种，一种是请求报文，一种是响应报文"></a>HTTP 报文有两种，一种是请求报文，一种是响应报文</h4><p>HTTP 请求报文的格式如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GET</span> / HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span>User-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Macintosh; Intel Mac OS X <span class="hljs-number">10</span>_<span class="hljs-number">10</span>_<span class="hljs-number">5</span>)Accept: */*<br></code></pre></td></tr></table></figure>

<p>HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这<br>个空行不能省略，它用来划分首部与实体。</p>
<p>请求行包含三个字段：方法字段、URL 字段和 HTTP 版本字段。</p>
<p>方法字段可以取几种不同的值，一般有 GET、POST、HEAD、PUT 和 DELETE。<br>一般 GET 方法只被用于向服务器获取数据。<br>POST 方法用于将实体提交到指定的资源，通常会造成服务器资源的修改。<br>HEAD 方法与 GET 方法类似，但是在返回的响应中，不包含请求对象。<br>PUT 方法用于上传文件到服务器，<br>DELETE 方法用于删除服务器上的对象。<br>虽然请求的方法很多，但更多表达的是一种语义上的区别，并不是说 POST 能做的事情，GET 就不能做了，主要看我们如何选择。更多的方法可以参<br>看  <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">文档</a>。</p>
<h3 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a>HTTP 响应报文</h3><p>HTTP 响应报文的格式如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">0</span> <span class="hljs-number">200</span> OKContent-Type: text/plainContent-Length: <span class="hljs-number">137582</span>Expires: Thu, <span class="hljs-number">05</span> Dec <span class="hljs-number">1997</span> <span class="hljs-number">16</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> GMTLast-Modified: Wed, <span class="hljs-number">5</span> August <span class="hljs-number">1996</span> <span class="hljs-number">15</span>:<span class="hljs-number">55</span>:<span class="hljs-number">28</span> GMTServer: Apache <span class="hljs-number">0</span>.<span class="hljs-number">84</span>&lt;html&gt; &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;<br></code></pre></td></tr></table></figure>

<p>HTTP 响应报文的第一行叫做状态行，后面的行是首部行，最后是实体主体。<br>状态行包含了三个字段：协议版本字段、状态码和相应的状态信息。<br>实体部分是报文的主要部分，它包含了所请求的对象。<br>常见的状态有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">200-请求成功、202-服务器端已经收到请求消息，但是尚未进行处理<br>301-永久移动、302-临时移动、304-所请求的资源未修改、<br>400-客户端请求的语法错误、404-请求的资源不存在<br>500-服务器内部错误。<br>一般 1XX 代表服务器接收到请求、2XX 代表成功、3XX 代表重定向、4XX 代表客户端错误、5XX 代表服务器端错误。<br></code></pre></td></tr></table></figure>

<p>更多关于状态码的可以查看：</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/http/http-status-codes.html">《HTTP 状态码》</a></p>
<h4 id="首部行"><a href="#首部行" class="headerlink" title="首部行"></a>首部行</h4><p>首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设<br>置，区别在于请求首部和响应首部。<br>常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。<br>常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。<br>常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。<br>常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修改时间。<br>更多关于首部的资料可以查看：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jycboy/p/http_head.html">《HTTP 首部字段详细介绍》</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34289537/article/details/52971516">《图解 HTTP》</a></p>
<h3 id="3-https-协议的工作原理"><a href="#3-https-协议的工作原理" class="headerlink" title="3.https 协议的工作原理"></a>3.https 协议的工作原理</h3><p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p>
<ol>
<li>客户端使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。</li>
<li>web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），传输给客户端。</li>
<li>客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。</li>
<li>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</li>
<li>web 服务器通过自己的私钥解密出会话密钥。</li>
<li>web 服务器通过会话密钥加密与客户端之间的通信。<br>传送门 ☞ #<a target="_blank" rel="noopener" href="https://juejin.cn/post/6995109407545622542">解读 HTTP1/HTTP2/HTTP3</a></li>
</ol>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><ol>
<li>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li>
<li>第二次握手：服务器收到syn包并确认客户的SYN（ack=j+1），同时也发送一个自己的SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>
<li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li>
</ol>
<blockquote>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p>
</blockquote>
<h4 id="目的：-建立可靠的通信通道-，数据的发送和接收（双方正常）"><a href="#目的：-建立可靠的通信通道-，数据的发送和接收（双方正常）" class="headerlink" title="目的： 建立可靠的通信通道 ，数据的发送和接收（双方正常）"></a>目的： 建立可靠的通信通道 ，数据的发送和接收（双方正常）</h4><p>翻译成大白话就是： 客户端：你能接收到我的消息吗？ 服务端：可以的，那你能接收到我的回复吗？ 客户端：可以，那我们开始聊正事吧。</p>
<h4 id="为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人-为什么不是4次？：3次够了第四次浪费"><a href="#为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人-为什么不是4次？：3次够了第四次浪费" class="headerlink" title="为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人 为什么不是4次？：3次够了第四次浪费"></a>为什么是3次？：避免历史连接，确认客户端发来的请求是这次通信的人 为什么不是4次？：3次够了第四次浪费</h4><h3 id="TCP-协议四次挥手"><a href="#TCP-协议四次挥手" class="headerlink" title="TCP 协议四次挥手"></a>TCP 协议四次挥手</h3><p>客户端-发送一个FIN,用来关闭客户端到服务器的数据传输<br>服务器-收到这个FIN,它发回一个ACK，确认序号为收到的序号加1.和SYN一样，一个FIN将占用一个序号<br>服务器-关闭与客户端的连接，发送一个FIN给客户端<br>客户端-发回ACK报文确认，并将确认序号设置为收到序号加1</p>
<h4 id="为什么不是两次？"><a href="#为什么不是两次？" class="headerlink" title="为什么不是两次？"></a>为什么不是两次？</h4><p>两次情况客户端说完结束就立马断开不再接收，无法确认服务端是否接收到断开消息，但且服务端可能还有消息未发送完。</p>
<h4 id="为什么不是三次？"><a href="#为什么不是三次？" class="headerlink" title="为什么不是三次？"></a>为什么不是三次？</h4><p>3次情况服务端接收到断开消息，向客户端发送确认接受消息，客户端未给最后确认断开的回复。</p>
<h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<h4 id="TCP作为一种可靠的传输控制协议，其核心思想就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求"><a href="#TCP作为一种可靠的传输控制协议，其核心思想就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求" class="headerlink" title="TCP作为一种可靠的传输控制协议，其核心思想就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求"></a>TCP作为一种可靠的传输控制协议，其核心思想就是：既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上俩方面的需求</h4><p><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2021/05/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">博客</a></p>
<h3 id="TCP-IP-如何保证数据包传输的有序可靠？"><a href="#TCP-IP-如何保证数据包传输的有序可靠？" class="headerlink" title="TCP/IP / 如何保证数据包传输的有序可靠？"></a>TCP/IP / 如何保证数据包传输的有序可靠？</h3><p>对字节流分段并进行编号然后通过 ACK 回复和超时重发这两个机制来保证。<br>（1）为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；<br>（2）并为每个已发送的数据包启动一个超时定时器；<br>（3）如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;<br>（4）否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。<br>（5）接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</p>
<h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><ol>
<li>TCP是面向链接的，而UDP是面向无连接的。</li>
<li>TCP仅支持单播传输，UDP 提供了单播，多播，广播的功能。</li>
<li>TCP的三次握手保证了连接的可靠性; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</li>
<li>UDP的头部开销比TCP的更小，数据传输速率更高，实时性更好。</li>
</ol>
<p>传送门 ☞<a target="_blank" rel="noopener" href="https://juejin.cn/post/6992743999756845087"># 深度剖析TCP与UDP的区别</a><br><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2021/07/09/TCP%E5%8D%8F%E8%AE%AE/">博客</a></p>
<h3 id="Ajax-是什么-如何创建一个-Ajax？"><a href="#Ajax-是什么-如何创建一个-Ajax？" class="headerlink" title="Ajax 是什么? 如何创建一个 Ajax？"></a>Ajax 是什么? 如何创建一个 Ajax？</h3><p>Gmail开发人员发现IE里面有个XMLHTTPRequest对象来请求数据时，可以实现无刷新数据请求，所以使用这个特性，进行网络数据请求，这就是AJAX的由来。<br>AJAX不是一个单词，他的全称是Asynchronous JavaScript and XML，就是<strong>异步的JavaScript和XML</strong>，它是一套用于创建快速动态网页的技术标准，使用步骤如下：</p>
<ol>
<li>创建异步XMLHttpRequest对象</li>
<li>设置请求参数，包括请求的方法和URL等</li>
<li>发送请求</li>
<li>注册事件，事件状态变更会及时响应监听</li>
<li>在监听里面获取并处理返回数据</li>
</ol>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-comment">//创建 XMLHttpRequest 对象</span><br><span class="hljs-keyword">var</span> ajax = <span class="hljs-keyword">new</span> XMLHttpRequest();<br><span class="hljs-comment">//规定请求的类型、URL 以及是否异步处理请求。</span><br>ajax.open(<span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-built_in">url</span>,<span class="hljs-literal">true</span>);<br><span class="hljs-comment">//发送信息至服务器时内容编码类型</span><br>ajax.setRequestHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>); <br><span class="hljs-comment">//发送请求</span><br>ajax.send(<span class="hljs-literal">null</span>);  <br><span class="hljs-comment">//接受服务器响应数据</span><br>ajax.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (obj.readyState == <span class="hljs-number">4</span> &amp;&amp; (obj.status == <span class="hljs-number">200</span> || obj.status == <span class="hljs-number">304</span>)) &#123; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>所以AJAX的核心就是XMLHttpRequest对象，这是一个非常早的实现方法，也是兼容性最好的，已经成为了浏览器标准，虽然我们现在都使用其它的API规范，但对象名字暂时还是用XML命名</p>
<p><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2021/05/28/ajax%E9%9D%A2%E8%AF%95/#http%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">博客</a></p>
<h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>axios是一个基于Promise的HTTP库，可以用在浏览器和node.js中，它底层还是基于XMLHttpRequest对象的，你可以认为它是一个方便的封装库，除了基础请求数据，它还增加了如下功能：</p>
<ol>
<li>对PromiseAPI的支持</li>
<li>支持请求拦截和响应、转换请求数据和响应数据、取消请求</li>
<li>可以自动转换JSON数据</li>
<li>支持防御XSRF</li>
</ol>
<h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>fetch就<strong>不是XMLHttpRequest对象了，fetch是原生的js对象，也就是说，它不依赖浏览器</strong>，fetch提供了一个理解的请求替换方案，可以提供给其它技术使用。我们主要需要了解下fetch和ajax的本质区别：</p>
<ol>
<li>fetch返回的是Promise，所以如果HTTP状态码是404之类的，fetch也是成功返回的，只有在网络连接错误的情况下，才会reject</li>
<li>fetch不发送cookies</li>
</ol>
<p>fetch的请求写法会比AJAX简单许多，但我想，最主要的问题是，<strong>无法区分HTTP状态码了</strong>，这个在编程时还是比较常用的，所以我们目前还是使用axios比较多，而很少使用fetch<br><img src="/imageO/Ajax.jpg" srcset="/img/loading.gif" lazyload alt="Ajax"></p>
<h3 id="Cookie、sessionStorage、localStorage-的区别"><a href="#Cookie、sessionStorage、localStorage-的区别" class="headerlink" title="Cookie、sessionStorage、localStorage 的区别"></a>Cookie、sessionStorage、localStorage 的区别</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>存储在客户端</p>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul>
<li>cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+</li>
<li>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</li>
<li>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</li>
</ul>
<p>localStorage和SessionStorage</p>
<ul>
<li>只能存储字符串对象</li>
<li>不同浏览器无法共享localStorage与SessionStroage中的信息。相同浏览器的不同页面间（同源页面）可以共享相同的localStorage，但不能共享sessionStorage。</li>
</ul>
<h4 id="2-Session"><a href="#2-Session" class="headerlink" title="2. Session"></a>2. Session</h4><p>Session是一种服务端解决方案，通过服务器来保持状态。<br>Session是服务器为了保存用户状态而创建的一个特殊对象。客户端请求服务端，服务端会为这次请示开辟一块内存空间。<br>Session弥补了HTTP的无状态特性。</p>
<h5 id="Session的创建过程"><a href="#Session的创建过程" class="headerlink" title="Session的创建过程"></a>Session的创建过程</h5><p>当浏览器第一次访问服务器时，服务器会创建一个Session对象(该对象有唯一的ID，即SessionID)。服务器会将SessionID以cookie的方式返回浏览器。<br>当浏览器再次访问服务器时，会将SessionID发送过来，服务器依据sessionID就可以找到对应的session对象。</p>
<h6 id="Session的缺点"><a href="#Session的缺点" class="headerlink" title="Session的缺点"></a>Session的缺点</h6><p>A 服务器存储了 Session，就是做了负载均衡后，假如一段时间内 A 的访问量激增，会转发到 B 进行访问，但是 B 服务器并没有存储 A 的 Session，会导致 Session 的失效。</p>
<p><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2021/06/16/cookie%E3%80%81localStorage%E3%80%81sessionStorage&token/">博客</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7012506796489359368">JavaScript的存储–Cookie、Session、localStorage、sessionStorage</a></p>
<h4 id="什么是-Token（令牌）"><a href="#什么是-Token（令牌）" class="headerlink" title="什么是 Token（令牌）"></a>什么是 Token（令牌）</h4><p>Acesss Token</p>
<ol>
<li>访问资源接口（API）时所需要的资源凭证</li>
<li>简单 token 的组成：<strong> uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</strong></li>
</ol>
<p>特点：</p>
<ol>
<li>服务端无状态化、可扩展性好</li>
<li>支持移动端设备</li>
<li>安全</li>
<li>支持跨程序调用<br>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里<br>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库<br>token 完全由应用管理，所以它可以避开同源策略</li>
</ol>
<h5 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h5><p>另外一种 token——refresh token<br>refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904034181070861#heading-6">Acesss Token</a></p>
<h3 id="什么是浏览器的同源政策？"><a href="#什么是浏览器的同源政策？" class="headerlink" title="什么是浏览器的同源政策？"></a>什么是浏览器的同源政策？</h3><p>我对浏览器的同源政策的理解是，一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个域的  <strong>协议、域名、端口号</strong>必须相同，否则不属于同一个域。<br>同源政策主要限制了三个方面</p>
<ol>
<li>第一个是当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</li>
<li>第二个是当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</li>
<li>第三个是当前域下 ajax 无法发送跨域请求。</li>
</ol>
<p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。<br>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是80（默认端口可以省略）。</p>
<h3 id="跨域怎么实现？jsonp的原理是什么？"><a href="#跨域怎么实现？jsonp的原理是什么？" class="headerlink" title="跨域怎么实现？jsonp的原理是什么？"></a>跨域怎么实现？jsonp的原理是什么？</h3><h4 id="跨域，指的是浏览器不能执行其他网站的脚本。浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行"><a href="#跨域，指的是浏览器不能执行其他网站的脚本。浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行" class="headerlink" title="跨域，指的是浏览器不能执行其他网站的脚本。浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行"></a>跨域，指的是浏览器不能执行其他网站的脚本。浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行</h4><p>解决办法：</p>
<ol>
<li>JSONP：注意JSONP只支持GET请求，不支持POST请求。<br>原理：ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。 —   callback</li>
<li>代理：写后端接口，在后端调用页面拿到返回值返回给html文件。相当于绕过了浏览器，就不会存在跨域问题。例；(nigx反向代理)</li>
<li>CORS CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对CORS的支持原理：<strong>服务器设置Access-Control-Allow-Origin HTTP响应头</strong>之后，浏览器将会允许跨域请求</li>
</ol>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin:*&#x27;</span>);<span class="hljs-comment">//允许所有来源访问</span><br><span class="hljs-selector-tag">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Method:POST,GET&#x27;</span>);<span class="hljs-comment">//允许访问的方式</span><br></code></pre></td></tr></table></figure>

<ol start="4">
<li>proxy代理 目前常用方式,通过服务器设置代理</li>
<li>window.postMessage() 利用h5新特性window.postMessage()</li>
</ol>
<h5 id="Options-CORS跨域，非简单请求"><a href="#Options-CORS跨域，非简单请求" class="headerlink" title="Options(CORS跨域，非简单请求)"></a>Options(CORS跨域，非简单请求)</h5><p>1.HTTP的options方法作用</p>
<blockquote>
<p>检测服务器所支持的请求方法。（比如：‘／user’路由支持哪些方法：get、post、delete…）<br>CORS中的预检请求（检测某个接口是否支持跨域）</p>
</blockquote>
<p>2.allowedMethods方法<br>响应options方法，告诉它所支持的请求方法<br>相应的返回405（不允许）和501（没实现）（比如我使用delete，会返回405，因为我没有写这个接口。但我使用link接口请求，会返回501，因为koa里不支持link请求）<br>options 请求就是预检请求，可用于检测服务器允许的 http 方法。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起 OPTIONS 请求，即 CORS 预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求。<br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS">MDN</a></p>
<h3 id="浏览器会拦截跨域请求，但是只是拦截返回结果，请求还是会被发送到服务器，这样有意义么"><a href="#浏览器会拦截跨域请求，但是只是拦截返回结果，请求还是会被发送到服务器，这样有意义么" class="headerlink" title="浏览器会拦截跨域请求，但是只是拦截返回结果，请求还是会被发送到服务器，这样有意义么"></a>浏览器会拦截跨域请求，但是只是拦截返回结果，请求还是会被发送到服务器，这样有意义么</h3><p>有意义。<br>首先，请求因为跨域被拦截后，会改成OPTIONS请求送达服务器，这样服务器就可以知道有人在请求。<br>至于你说跨域POST也能修改，那因为服务器没对method进行校验，来者不拒，这是你服务器的问题。<br>正常的API数据操作method不包括OPTIONS，OPTIONS只用来确认允许的操作。</p>
<h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><p>仅记录在 RFC2616 上的 HTTP 状态码就达 40 种，若再加上 WebDAV（RFC4918、5842）和附加 HTTP 状态码 （RFC6585）等扩展，数量就达 60 余种。接下来，我们就介绍一下这些具有代表性的一些状态码。</p>
<p>1xx: 指示信息——表示请求已接收，继续处理</p>
<p>2xx: 成功——表示请求已被成功接收</p>
<p>3xx: 重定向——表示要完成请求必须进行进一步操作</p>
<p>4xx: 客户端错误——表示请求有语法错误或请求无法实现</p>
<p>5xx: 服务端错误——表示服务器未能实现合法的请求</p>
<h4 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h4><p>状态码 描述<br>200 请求成功<br>202-服务器端已经收到请求消息，但是尚未进行处理<br>204 （无内容） 服务器成功处理了请求，但没有返回任何内容。默认情况下 204 响应是可缓存的<br>206 已完成指定范围的请求(带Range头的GET请求),场景如video,audio播放文件较大,文件分片时<br>301 永久重定向<br>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替<br>302 临时重定向<br> 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI<br>304 请求资源未修改，可以使用缓存的资源，不用在服务器取<br>400 请求有语法错误<br>401 没有权限访问<br>403 服务器拒绝执行请求，场景如不允许直接访问，只能通过服务器访问时<br>404 请求资源不存在<br>500 服务器内部错误，无法完成请求<br>503 请求未完成，因服务器过载、宕机或维护等</p>
<h3 id="长轮询和短轮询"><a href="#长轮询和短轮询" class="headerlink" title="长轮询和短轮询"></a>长轮询和短轮询</h3><h4 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h4><p>客户端发送请求后服务器端不会立即返回数据，服务器端会阻塞请求<strong>连接不会立即断开，直到服务器端有数据更新或者是连接超时才返回，客户端才再次发出请求新建连接、如此反复从而获取最新数据</strong>。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LongAjax</span>(<span class="hljs-params"></span>) </span>&#123;<br>    fetch(url).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>     <span class="hljs-comment">// 数据正确拿到后，</span><br>        LongPolling();<br>    &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>     <span class="hljs-comment">// 出错或者就是超时间</span><br>        LongPolling();<br><br>    &#125;);<br>&#125;<br>LongAjax()<br></code></pre></td></tr></table></figure>

<p>优点：长轮询与短轮询相比，明显减少了很多不必要的http请求，节约资源。<br>节点：连接挂起也会导致资源的浪费，停留在服务器端。</p>
<h4 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h4><p>短轮询(Polling)的实现思路就是浏览器端每隔几秒钟向服务器端<strong>发送http请求，服务端在收到请求后，不论是否有数据更新，都直接进行响应。</strong>在服务端响应完成，就会关闭这个Tcp连接。</p>
<p>优点：就是兼容性比较好，只要支持http协议就可以实现该方式。<br>缺点：很明显消耗资源，因为下一次的建立Tcp是非常消耗资源的，服务器端响应后就会关闭这个Tcp连接。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LongAjax</span>(<span class="hljs-params"></span>) </span>&#123;<br>    fetch(url).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 数据正确拿到后，dosometing</span><br><br>    &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 发现错误，比如返回的数据为空等。</span><br>        console.log(err);<br>    &#125;);<br>&#125;<br>setInterval(LongAjax, <span class="hljs-number">5000</span>);<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6864398060702760968#heading-105">长轮询和短轮询</a></p>
<h3 id="说下进程、线程和协程"><a href="#说下进程、线程和协程" class="headerlink" title="说下进程、线程和协程"></a>说下进程、线程和协程</h3><p> 进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，<strong>是操作系统进行资源分配和调度的一个独立单位</strong>，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义</p>
<p> 线程是程序执行中一个单一的顺序控制流程，是<strong>程序执行流的最小单元</strong>，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成</p>
<p> 协程，英文Coroutines，<strong>是一种基于线程之上</strong>，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性</p>
<p>进程和线程的区别与联系<br>【区别】：</p>
<h4 id="调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位"><a href="#调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位" class="headerlink" title="调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位"></a>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位</h4><h4 id="并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行"><a href="#并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行" class="headerlink" title="并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行"></a>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行</h4><p>拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。</p>
<p>系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。<br>【联系】：</p>
<blockquote>
<p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；</p>
</blockquote>
<blockquote>
<p>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</p>
</blockquote>
<blockquote>
<p>处理机分给线程，即真正在处理机上运行的是线程；</p>
</blockquote>
<p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p>
<p>传送门 ☞ # <a target="_blank" rel="noopener" href="https://juejin.cn/post/7005465381791875109">一文搞懂进程、线程、协程及JS协程的发展 ☞了解更多</a><br>关于浏览器传送门 ☞#<a target="_blank" rel="noopener" href="https://juejin.cn/post/6993095345576083486">深入了解现代 Web 浏览器</a><br><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2021/04/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%A7%A3(%E4%B8%80)/">博客</a></p>
<h3 id="浏览器的缓存机制-强制缓存-amp-amp-协商缓存"><a href="#浏览器的缓存机制-强制缓存-amp-amp-协商缓存" class="headerlink" title="浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存"></a>浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存</h3><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：<br><img src="/imageO/HC.jpg" srcset="/img/loading.gif" lazyload alt="如图"><br>由上图我们可以知道：</p>
<ol>
<li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li>
<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中<br>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。</li>
</ol>
<h4 id="强制缓存强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程"><a href="#强制缓存强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程" class="headerlink" title="强制缓存强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程"></a>强制缓存强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程</h4><p>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 Expires 和 Cache-Control，其中Cache-Control优先级比Expires高。强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p>
<ol>
<li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。</li>
<li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。</li>
<li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li>
</ol>
<h4 id="协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程"><a href="#协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程" class="headerlink" title="协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程"></a>协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</h4><p>同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since 和 Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。协商缓存主要有以下两种情况：</p>
<ol>
<li>协商缓存生效，返回304</li>
<li>协商缓存失效，返回200和请求结果结果<br>传送门 ☞ #<a target="_blank" rel="noopener" href="https://juejin.cn/post/6992843117963509791">彻底理解浏览器的缓存机制</a></li>
</ol>
<h3 id="介绍下304过程"><a href="#介绍下304过程" class="headerlink" title="介绍下304过程"></a>介绍下304过程</h3><p>a. 浏览器请求资源时首先命中资源的Expires 和 Cache-Control，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过Cache-control: max-age指定最大生命周期，状态仍然返回200，但不会请求数据，在浏览器中能明显看到from cache字样。<br>b. 强缓存失效，进入协商缓存阶段，首先验证ETagETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据客户端上送的If-None-Match值来判断是否命中缓存。<br>c. 协商缓存Last-Modify/If-Modify-Since阶段，客户端第一次请求资源时，服务服返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间。再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。</p>
<h3 id="粘包问题分析与对策"><a href="#粘包问题分析与对策" class="headerlink" title="粘包问题分析与对策"></a>粘包问题分析与对策</h3><p>TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。<br>粘包出现原因<br>简单得说，在流传输中出现，UDP不会出现粘包，因为它有消息边界</p>
<h4 id="粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包"><a href="#粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包" class="headerlink" title="粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包"></a>粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包</h4><h4 id="为了避免粘包现象，可采取以下几种措施"><a href="#为了避免粘包现象，可采取以下几种措施" class="headerlink" title="为了避免粘包现象，可采取以下几种措施"></a>为了避免粘包现象，可采取以下几种措施</h4><p>（1）对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；<br>（2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；<br>（3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。分包多发。</p>
<h4 id="以上提到的三种措施，都有其不足之处"><a href="#以上提到的三种措施，都有其不足之处" class="headerlink" title="以上提到的三种措施，都有其不足之处"></a>以上提到的三种措施，都有其不足之处</h4><p>（1）第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。<br>（2）第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。<br>（3）第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</p>
<blockquote>
<p>一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。实验证明这种方法是高效可行的。</p>
</blockquote>
<h2 id="网路安全"><a href="#网路安全" class="headerlink" title="网路安全"></a>网路安全</h2><h3 id="什么是-XSS？如何预防？"><a href="#什么是-XSS？如何预防？" class="headerlink" title="什么是 XSS？如何预防？"></a>什么是 XSS？如何预防？</h3><p>XSS 全称是 Cross Site Scripting ,为了与CSS区分开来，故简称 XSS，翻译过来就是“跨站脚本”。<br>XSS是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。<br>最开始的时候，这种攻击是通过跨域来实现的，所以叫“跨域脚本”。发展到现在，往HTML文件中中插入恶意代码方式越来越多，所以是否跨域注入脚本已经不是唯一的注入手段了，但是 XSS 这个名字却一直保留至今。<br>注入恶意脚本可以完成这些事情：</p>
<ol>
<li>窃取Cookie</li>
<li>监听用户行为，比如输入账号密码后之间发给黑客服务器</li>
<li>在网页中生成浮窗广告</li>
<li>修改DOM伪造登入表单</li>
</ol>
<p>一般的情况下，XSS攻击有三种实现方式</p>
<p>存储型 XSS 攻击<br>反射型 XSS 攻击<br>基于 DOM 的 XSS 攻击</p>
<h4 id="存储型-XSS-攻击"><a href="#存储型-XSS-攻击" class="headerlink" title="存储型 XSS 攻击"></a>存储型 XSS 攻击</h4><p>存储型 XSS 攻击大致步骤如下：</p>
<ol>
<li>首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；</li>
<li>然后用户向网站请求包含了恶意 JavaScript 脚本的页面；</li>
<li>当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。</li>
</ol>
<p>比如常见的场景：</p>
<p>在评论区提交一份脚本代码，假设前后端没有做好转义工作，那内容上传到服务器，在页面渲染的时候就会直接执行，相当于执行一段未知的JS代码。这就是存储型 XSS 攻击。</p>
<h4 id="反射型-XSS-攻击"><a href="#反射型-XSS-攻击" class="headerlink" title="反射型 XSS 攻击"></a>反射型 XSS 攻击</h4><p>反射型 XSS 攻击指的就是恶意脚本作为<strong>「网络请求的一部分」</strong>，随后网站又把恶意的JavaScript脚本返回给用户，当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。<br>举个例子:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">http://dragon.com?query=<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">alert(<span class="hljs-string">&quot;你受到了XSS攻击&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>如上，服务器拿到后解析参数query，最后将内容返回给浏览器，浏览器将这些内容作为HTML的一部分解析，发现是Javascript脚本，直接执行，这样子被XSS攻击了。<br>这也就是反射型名字的由来，将恶意脚本作为参数，通过网络请求，最后经过服务器，在反射到HTML文档中，执行解析。<br>主要注意的就是，<strong>「服务器不会存储这些恶意的脚本，这也算是和存储型XSS攻击的区别吧」。</strong></p>
<h4 id="基于-DOM-的-XSS-攻击"><a href="#基于-DOM-的-XSS-攻击" class="headerlink" title="基于 DOM 的 XSS 攻击"></a>基于 DOM 的 XSS 攻击</h4><p>基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，在数据传输的时候劫持网络数据包<br>常见的劫持手段有：</p>
<p>WIFI路由器劫持<br>本地恶意软件</p>
<h4 id="阻止-XSS-攻击的策略"><a href="#阻止-XSS-攻击的策略" class="headerlink" title="阻止 XSS 攻击的策略"></a>阻止 XSS 攻击的策略</h4><p>以上讲述的XSS攻击原理，都有一个共同点：让恶意脚本直接在浏览器执行。<br>针对三种不同形式的XSS攻击，有以下三种解决办法</p>
<h5 id="对输入脚本进行过滤或转码"><a href="#对输入脚本进行过滤或转码" class="headerlink" title="对输入脚本进行过滤或转码"></a>对输入脚本进行过滤或转码</h5><p>对用户输入的信息过滤或者是转码<br>举个例子👇<br>转码后👇</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-symbol">&amp;lt;</span>script<span class="hljs-symbol">&amp;gt;</span>alert(<span class="hljs-symbol">&amp;#39;</span>你受到XSS攻击了<span class="hljs-symbol">&amp;#39;</span>)<span class="hljs-symbol">&amp;lt;</span>/script<span class="hljs-symbol">&amp;gt;</span><br></code></pre></td></tr></table></figure>

<p>这样的代码在 html 解析的过程中是无法执行的。<br>当然了对于<code>&lt;script&gt;、&lt;img&gt;、&lt;a&gt;</code>等关键字标签也是可以过来的，效果如下👇</p>
<p>最后什么都没有剩下了</p>
<h5 id="利用-CSP"><a href="#利用-CSP" class="headerlink" title="利用 CSP"></a>利用 CSP</h5><p>该安全策略的实现基于一个称作 Content-Security-Policy的 HTTP 首部。<br>可以移步MDN，有更加规范的解释。我在这里就是梳理一下吧。<br>CSP，即浏览器中的内容安全策略，它的核心思想大概就是服务器决定浏览器加载哪些资源，具体来说有几个功能👇</p>
<p>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；<br>禁止向第三方域提交数据，这样用户数据也不会外泄；<br>提供上报机制，能帮助我们及时发现 XSS 攻击。<br>禁止执行内联脚本和未授权的脚本；</p>
<h5 id="利用-HttpOnly"><a href="#利用-HttpOnly" class="headerlink" title="利用 HttpOnly"></a>利用 HttpOnly</h5><p>由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。这样子的话，JavaScript 便无法读取 Cookie 的值。这样也能很好的防范 XSS 攻击。<br>通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的，下面是打开 Google 时，HTTP 响应头中的一段：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set</span>-cookie: NID=<span class="hljs-number">189</span>=M<span class="hljs-number">8</span>l<span class="hljs-number">6</span>-z<span class="hljs-number">41</span>asXtm<span class="hljs-number">2</span>uEwcOC<span class="hljs-number">5</span>oh<span class="hljs-number">9</span>djkffOMhWqQrlnCtOI; expires=Sat, <span class="hljs-number">18</span>-Apr-<span class="hljs-number">2020</span> <span class="hljs-number">06</span>:<span class="hljs-number">52</span>:<span class="hljs-number">22</span> GMT; path=/; domain=.google.com; HttpOnly<br></code></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>XSS 攻击是指浏览器中执行恶意脚本, 然后拿到用户的信息进行操作。主要分为存储型、反射型和文档型。防范的措施包括:</p>
<p>对输入内容过滤或者转码，尤其是类似于<code>&lt;script&gt;、&lt;img&gt;、&lt;a&gt;</code>标签<br>利用CSP<br>利用Cookie的HttpOnly属性</p>
<p>除了以上策略之外，我们还可以通过添加验证码防止脚本冒充用户提交危险操作。而对于一些不受信任的输入，还可以限制其输入长度，这样可以增大 XSS 攻击的难度。<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6864398060702760968#heading-93">掘金</a></p>
<h3 id="什么是-CSP？"><a href="#什么是-CSP？" class="headerlink" title="什么是 CSP？"></a>什么是 CSP？</h3><p>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</p>
<p>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式<code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></p>
<h3 id="什么是-CSRF-攻击？如何防范-CSRF-攻击？"><a href="#什么是-CSRF-攻击？如何防范-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？如何防范 CSRF 攻击？"></a>什么是 CSRF 攻击？如何防范 CSRF 攻击？</h3><p>CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被<br>攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</p>
<p>CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</p>
<p>一般的 CSRF 攻击类型有三种：</p>
<p>第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提<br>交。</p>
<p>第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</p>
<p>第三种是链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</p>
<p>CSRF 可以用下面几种方法来防护：</p>
<p>第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。</p>
<p>第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。</p>
<p>第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</p>
<p>第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</p>
<h3 id="什么是-Samesite-Cookie-属性？"><a href="#什么是-Samesite-Cookie-属性？" class="headerlink" title="什么是 Samesite Cookie 属性？"></a>什么是 Samesite Cookie 属性？</h3><p>Samesite Cookie 表示同站 cookie，避免 cookie 被第三方所利用。</p>
<p>将 Samesite 设为 strict ，这种称为严格模式，表示这个 cookie 在任何情况下都不可能作为第三方 cookie。</p>
<p>将 Samesite 设为 Lax ，这种模式称为宽松模式，如果这个请求是个 GET 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie。</p>
<p>使用这种方法的缺点是，因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都回重新登录。还有一个问题就是它的兼容性不够好。</p>
<h3 id="什么是点击劫持？如何防范点击劫持？"><a href="#什么是点击劫持？如何防范点击劫持？" class="headerlink" title="什么是点击劫持？如何防范点击劫持？"></a>什么是点击劫持？如何防范点击劫持？</h3><p>点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。</p>
<p>我们可以在 http 相应头中设置 X-FRAME-OPTIONS 来防御用 iframe 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特定的一些情况才能作为 iframe 来使用。</p>
<h3 id="SQL-注入攻击？"><a href="#SQL-注入攻击？" class="headerlink" title="SQL 注入攻击？"></a>SQL 注入攻击？</h3><p>SQL 注入攻击指的是攻击者在 HTTP 请求中注入恶意的 SQL 代码，服务器使用参数构建数据库 SQL 命令时，恶意 SQL 被一起构造，破坏原有 SQL 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/">前端基础</a>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/01/10/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Vue面试题总结</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/05/JS+ES6%E9%9D%A2%E8%AF%95%E9%A2%98/">
                        <span class="hidden-mobile">JS+ES6面试题总结</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
